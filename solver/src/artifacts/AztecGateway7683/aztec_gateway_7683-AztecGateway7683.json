{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "AztecGateway7683",
  "functions": [
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "log_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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+1uufX/Lte9vufb9Lde+v+Xa97dc+/6Wa9/fcu2HW679cMu1H2659sMt13645doPt1z74ZZrP9xy7Ydbrv1bnuuztzzXZ295rs/e8lyfveW5PnvLc332luf67C3P9dlbnuuztzzXZ295rs/e8lyfveW5PnvLc332luf67C3P9dlbnuuztzzXZ295rs/e8lyfveW5PnfLc33uluf63C3P9blbnutzk73lW9wt31Lk2rcqLHs5PFamM69uKPebLFfmecFqo4+iR58kj77Mc5PVRq9Ej16LHr0RPXorevRO9OhFz7VK9FyrRM+1SvRcqxufa/26x+g06Y3hNz7Z5obf+GybG37j021u+I3Pt7nhNz7h5oZfaL+kw90dXKHnynPfku74lkLPlee+Rd3yLfqWbzG3fIu95VvcLd/ib/mWW659c8u1b2659u0t17695dq3t1z79pZr395y7dtbrn17y7Vvb7n27S3Xvr3l2ne3XPvulmvf3XLtu1uufXfLte9uufbdLde+u+Xad7dc++6Wa9/fcu37W659f8u172+59v0t176/5dr3t1z7/pZr399y7ftbrv1wy7Ufbrn2wy3Xfrjl2g+3XPvhlmv/lj1WXbjl2g+3XPvhlms/3nLtx1uu/XjLtR9vufbjLdd+vOXaj7dc+/GWaz/ecu3HW679dMu1n2659tMt13665dpPt1z76ZZrP91y7adbrv10y7Wf7rj2/TTd8i3qlm/p6P0Tx4vZfuroJV25Uu04pXb0mq5cqR29pytXakcv6sqV+ulfXG0M/0cvi9HrC2CMUc93Ivvv4SfRw//4/s8fHr66f/gmLQdHq3XmovrZC+inpVav/cux31fKx/e3bqpYM1KxdqRi3UjF+pGKDSMVG0cqNg1UrJ5GKnYkB6VHclB6JAf18XcmNFXsSA5Kj+Sg9EgOSo/koPRIDsqM5KDMSA7KjOSgzEgO6uNvnmmq2JEclBnJQZmRHJQZyUHZvuZZuxzsndootq+7sV8+2fu4UWzrd2On3Fqssb8VOxfQ+h02W0Drd81sAa3fCbMFNN8fWvUswGUueOWDX7Zsefwdp/X474V713yHWLbc5ueusuU23yWWLbf5PrFsubalcuchNeUg5iE15QnmIVWY5a1b5r3oYuZgFfyq0+CfDxZ6szmjrp/86yHC44PjWmG0z89V1nwDEwFmG5gE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",
      "brillig_names": ["process_log"]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "10852400770788842366": {
            "error_kind": "string",
            "string": "Invalid order domain"
          },
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "11094545764365153162": {
            "error_kind": "string",
            "string": "Function _assert_nonce_and_set_order_details can only be called internally"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "12018683598614887596": {
            "error_kind": "string",
            "string": "Function _check_order_status can only be called internally"
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13459246948365409099": {
            "error_kind": "string",
            "string": "Function _emit_open can only be called internally"
          },
          "13594925270014003382": {
            "error_kind": "string",
            "string": "Function _trigger_settlement can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14563046062317426044": {
            "error_kind": "string",
            "string": "Function _check_order_commitment can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "5048864367174250545": {
            "error_kind": "string",
            "string": "Function get_filled_order_block_number can only be called statically"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6017907102598075401": {
            "error_kind": "string",
            "string": "Function get_order_status can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8412360910299423372": {
            "error_kind": "string",
            "string": "Invalid order destination domain"
          },
          "9169818942746597700": {
            "error_kind": "string",
            "string": "Function _update_order_status can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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GwEZAB0MARkBGgIoAgEbBACcATgAFAEbAR0uDQEdARwdDAEcAR0CHQwBHQEbAB0MARsBHAIoAgEdBACdATgAFAEdAR8uDQEfAR4dDAEeAR8CHQwBHwEdAB0MAR0BHgIoAgEfBACeATgAFAEfASEuDQEhASAdDAEgASECHQwBIQEfAB0MAR8BIAIoAgEhBACfATgAFAEhASMuDQEjASIdDAEiASMCHQwBIwEhAB0MASEBIgIBKAAUgLABJC4NASQBIx0MASMBJQIdDAElASQAHQwBJAEjAigCASUEAKEBOAAUASUBJy4NAScBJh0MASYBJwIdDAEnASUAHQwBJQEmAigCAScEAKIBOAAUAScBKS4NASkBKB0MASgBKQIdDAEpAScAHQwBJwEoAigCASkEAKMBOAAUASkBKy4NASsBKh0MASoBKwIdDAErASkAHQwBKQEqAigCASsEAKQBOAAUASsBLS4NAS0BLB0MASwBLQIdDAEtASsAHQwBKwEsAigCAS0EAKUBOAAUAS0BLy4NAS8BLh0MAS4BLwIdDAEvAS0AHQwBLQEuAigCAS8EAKYBOAAUAS8BMS4NATEBMB0MATABMQIdDAExAS8AHQwBLwEwAigCATEEAKcBOAAUATEBMy4NATMBMh0MATIBMwIdDAEzATEAHQwBMQEyAigCATMEAKgBOAAUATMBNS4NATUBNB0MATQBNQIdDAE1ATMAHQwBMwE0AigCATUEAKkBOAAUATUBNy4NATcBNh0MATYBNwIdDAE3ATUAHQwBNQE2AigCATcEAKoBOAAUATcBOS4NATkBOB0MATgBOQIdDAE5ATcAHQwBNwE4AigCATkEAKsBOAAUATkBOy4NATsBOh0MAToBOwIdDAE7ATkAHQwBOQE6AigCATsEAKwBOAAUATsBPS4NAT0BPB0MATwBPQIdDAE9ATsAHQwBOwE8AigCAT0EAK0BOAAUAT0BPy4NAT8BPh0MAT4BPwIdDAE/AT0AHQwBPQE+AigCAT8EAK4BOAAUAT8BQS4NAUEBQB0MAUABQQIdDAFBAT8AHQwBPwFAAigCAUEEAK8BOAAUAUEBQy4NAUMBQh0MAUIBQwIdDAFDAUEAHQwBQQFCAigCAUMEALABOAAUAUMBRS4NAUUBRB0MAUQBRQIdDAFFAUMAHQwBQwFEAigCAUUEALEBOAAUAUUBRy4NAUcBRh0MAUYBRwIdDAFHAUUAHQwBRQFGAigCAUcEALIBOAAUAUcBSS4NAUkBSB0MAUgBSQIdDAFJAUcAHQwBRwFIAigCAUkEALMBOAAUAUkBSy4NAUsBSh0MAUoBSwIdDAFLAUkAHQwBSQFKAigCAUsEALQBOAAUAUsBTS4NAU0BTB0MAUwBTQIdDAFNAUsAHQwBSwFMAigCAU0EALUBOAAUAU0BTy4NAU8BTh0MAU4BTwIdDAFPAU0AHQwBTQFOAigCAU8EALYBOAAUAU8BUS4NAVEBUB0MAVABUQIdDAFRAU8AHQwBTwFQAigCAVEEALcBOAAUAVEBUy4NAVMBUh0MAVIBUwIdDAFTAVEAHQwBUQFSAigCAVMEALgBOAAUAVMBVS4NAVUBVB0MAVQBVQIdDAFVAVMAHQwBUwFUAigCAVUEALkBOAAUAVUBVy4NAVcBVh0MAVYBVwIdDAFXAVUAHQwBVQFWAigCAVcEALoBOAAUAVcBWS4NAVkBWB0MAVgBWQIdDAFZAVcAHQwBVwFYAigCAVkEALsBOAAUAVkBWy4NAVsBWh0MAVoBWwIdDAFbAVkAHQwBWQFaAigCAVsEALwBOAAUAVsBXS4NAV0BXB0MAVwBXQIdDAFdAVsAHQwBWwFcAigCAV0EAL0BOAAUAV0BXy4NAV8BXh0MAV4BXwIdDAFfAV0AHQwBXQFeAigCAV8EAL4BOAAUAV8BYS4NAWEBYB0MAWABYQIdDAFhAV8AHQwBXwFgAigCAWEEAL8BOAAUAWEBYy4NAWMBYh0MAWIBYwIdDAFjAWEAHQwBYQFiAgEoABSAsQFkLg0BZAFjHQwBYwFlAh0MAWUBZAAdDAFkAWMCKAIBZQQAwQE4ABQBZQFnLg0BZwFmHQwBZgFnAh0MAWcBZQAdDAFlAWYCKAIBZwQAwgE4ABQBZwFpLg0BaQFoHQwBaAFpAh0MAWkBZwAdDAFnAWgCKAIBaQQAwwE4ABQBaQFrLg0BawFqHQwBagFrAh0MAWsBaQAdDAFpAWoCKAIBawQAxAE4ABQBawFtLg0BbQFsHQwBbAFtAh0MAW0BawAdDAFrAWwCKAIBbQQAxQE4ABQBbQFvLg0BbwFuHQwBbgFvAh0MAW8BbQAdDAFtAW4CKAIBbwQAxgE4ABQBbwFxLg0BcQFwHQwBcAFxAh0MAXEBbwAdDAFvAXACKAIBcQQAxwE4ABQBcQFzLg0BcwFyHQwBcgFzAh0MAXMBcQAdDAFxAXICKAIBcwQAyAE4ABQBcwF1Lg0BdQF0HQwBdAF1Ah0MAXUBcwAdDAFzAXQCKAIBdQQAyQE4ABQBdQF3Lg0BdwF2HQwBdgF3Ah0MAXcBdQAdDAF1AXYCKAIBdwQAygE4ABQBdwF5Lg0BeQF4HQwBeAF5Ah0MAXkBdwAdDAF3AXgCKAIBeQQAywE4ABQBeQF7Lg0BewF6HQwBegF7Ah0MAXsBeQAdDAF5AXoCKAIBewQAzAE4ABQBewF9Lg0BfQF8HQwBfAF9Ah0MAX0BewAdDAF7AXwCKAIBfQQAzQE4ABQBfQF/Lg0BfwF+HQwBfgF/Ah0MAX8BfQAdDAF9AX4CKAIBfwQAzgE4ABQBfwGBLg0BgQGAHQwBgAGBAh0MAYEBfwAdDAF/AYACKAIBgQQAzwE4ABQBgQGDLg0BgwGCHQwBggGDAh0MAYMBgQAdDAGBAYICKAIBgwQA0AE4ABQBgwGFLg0BhQGEHQwBhAGFAh0MAYUBgwAdDAGDAYQCKAIBhQQA0QE4ABQBhQGHLg0BhwGGHQwBhgGHAh0MAYcBhQAdDAGFAYYCKAIBhwQA0gE4ABQBhwGJLg0BiQGIHQwBiAGJAh0MAYkBhwAdDAGHAYgCKAIBiQQA0wE4ABQBiQGLLg0BiwGKHQwBigGLAh0MAYsBiQAdDAGJAYoCKAIBiwQA1AE4ABQBiwGNLg0BjQGMHQwBjAGNAh0MAY0BiwAdDAGLAYwCKAIBjQQA1QE4ABQBjQGPLg0BjwGOHQwBjgGPAh0MAY8BjQAdDAGNAY4CKAIBjwQA1gE4ABQBjwGRLg0BkQGQHQwBkAGRAh0MAZEBjwAdDAGPAZACKAIBkQQA1wE4ABQBkQGTLg0BkwGSHQwBkgGTAh0MAZMBkQAdDAGRAZICKAIBkwQA2AE4ABQBkwGVLg0BlQGUHQwBlAGVAh0MAZUBkwAdDAGTAZQCKAIBlQQA2QE4ABQBlQGXLg0BlwGWHQwBlgGXAh0MAZcBlQAdDAGVAZYCKAIBlwQA2gE4ABQBlwGZLg0BmQGYHQwBmAGZAh0MAZkBlwAdDAGXAZgCKAIBmQQA2wE4ABQBmQGbLg0BmwGaHQwBmgGbAh0MAZsBmQAdDAGZAZoCKAIBmwQA3AE4ABQBmwGd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AB0MAh0CHgIoAgIfBAEeATgAFAIfAiEuDQIhAiAdDAIgAiECHQwCIQIfAB0MAh8CIAIoAgIhBAEfATgAFAIhAiMuDQIjAiIdDAIiAiMCHQwCIwIhAB0MAiECIgIoAgIjBAEgATgAFAIjAiUuDQIlAiQdDAIkAiUCHQwCJQIjAB0MAiMCJAIoAgIlBAEhATgAFAIlAicuDQInAiYdDAImAicCHQwCJwIlAB0MAiUCJgIoAgInBAEiATgAFAInAikuDQIpAigdDAIoAikCHQwCKQInAB0MAicCKAIoAgIpBAEjATgAFAIpAisuDQIrAiodDAIqAisCHQwCKwIpAB0MAikCKgIoAgIrBAEkATgAFAIrAi0uDQItAiwdDAIsAi0CHQwCLQIrAB0MAisCLAIoAgItBAElATgAFAItAi8uDQIvAi4dDAIuAi8CHQwCLwItAB0MAi0CLgIoAgIvBAEmATgAFAIvAjEuDQIxAjAdDAIwAjECHQwCMQIvAB0MAi8CMAIoAgIxBAEnATgAFAIxAjMuDQIzAjIdDAIyAjMCHQwCMwIxAB0MAjECMgIoAgIzBAEoATgAFAIzAjUuDQI1AjQdDAI0AjUCHQwCNQIzAB0MAjMCNAIoAgI1BAEpATgAFAI1AjcuDQI3AjYdDAI2AjcCHQwCNwI1AB0MAjUCNgIoAgI3BAEqATgAFAI3AjkuDQI5AjgdDAI4AjkCHQwCOQI3AB0MAjcCOAIoAgI5BAErATgAFAI5AjsuDQI7AjodDAI6AjsCHQwCOwI5AB0MAjkCOgIoAgI7BAEsATgAFAI7Aj0uDQI9AjwdDAI8Aj0CHQwCPQI7AB0MAjsCPAIBKAAUgIMCPi4NAj4CPR0MAj0CPwIdDAI/Aj4AHQwCPgI9AigCAj8EAS4BOAAUAj8CQS4NAkECQB0MAkACQQIdDAJBAj8AHQwCPwJAAgE4ABQADQJCLg0CQgJBHQwCQQJDAh0MAkMCQgAdDAJCAkECKAICQwQBMAE4ABQCQwJFLg0CRQJEHQwCRAJFAh0MAkUCQwAdDAJDAkQCKAICRQQBMQE4ABQCRQJHLg0CRwJGHQwCRgJHAh0MAkcCRQAdDAJFAkYCKAICRwQBMgE4ABQCRwJJLg0CSQJIHQwCSAJJAh0MAkkCRwAdDAJHAkgCKAICSQQBMwE4ABQCSQJLLg0CSwJKHQwCSgJLAh0MAksCSQAdDAJJAkoCKAICSwQBNAE4ABQCSwJNLg0CTQJMHQwCTAJNAh0MAk0CSwAdDAJLAkwCKAICTQQBNQE4ABQCTQJPLg0CTwJOHQwCTgJPAh0MAk8CTQAdDAJNAk4CKAICTwQBNgE4ABQCTwJRLg0CUQJQHQwCUAJRAh0MAlECTwAdDAJPAlACKAICUQQBNwE4ABQCUQJTLg0CUwJSHQwCUgJTAh0MAlMCUQAdDAJRAlICKAICUwQBOAE4ABQCUwJVLg0CVQJUHQwCVAJVAh0MAlUCUwAdDAJTAlQCKAICVQQBOQE4ABQCVQJXLg0CVwJWHQwCVgJXAh0MAlcCVQAdDAJVAlYCKAICVwQBOgE4ABQCVwJZLg0CWQJYHQwCWAJZAh0MAlkCVwAdDAJXAlgCKAICWQQBOwE4ABQCWQJbLg0CWwJaHQwCWgJbAh0MAlsCWQAdDAJZAloCKAICWwQBPAE4ABQCWwJdLg0CXQJcHQwCXAJdAh0MAl0CWwAdDAJbAlwCKAICXQQBPQE4ABQCXQJfLg0CXwJeHQwCXgJfAh0MAl8CXQAdDAJdAl4CKAICXwQBPgE4ABQCXwJhLg0CYQJgHQwCYAJhAh0MAmECXwAdDAJfAmACKAICYQQBPwE4ABQCYQJjLg0CYwJiHQwCYgJjAh0MAmMCYQAdDAJhAmICKAICYwQBQAE4ABQCYwJlLg0CZQJkHQwCZAJlAh0MAmUCYwAdDAJjAmQCKAICZQQBQQE4ABQCZQJnLg0CZwJmHQwCZgJnAh0MAmcCZQAdDAJlAmYCKAICZwQBQgE4ABQCZwJpLg0CaQJoHQwCaAJpAh0MAmkCZwAdDAJnAmgCKAICaQQBQwE4ABQCaQJrLg0CawJqHQwCagJrAh0MAmsCaQAdDAJpAmoCKAICawQBRAE4ABQCawJtLg0CbQJsHQwCbAJtAh0MAm0CawAdDAJrAmwCKAICbQQBRQE4ABQCbQJvLg0CbwJuHQwCbgJvAh0MAm8CbQAdDAJtAm4CKAICbwQBRgE4ABQCbwJxLg0CcQJwHQwCcAJxAh0MAnECbwAdDAJvAnACKAICcQQBRwE4ABQCcQJzLg0CcwJyHQwCcgJzAh0MAnMCcQAdDAJxAnICKAICcwQBSAE4ABQCcwJ1Lg0CdQJ0HQwCdAJ1Ah0MAnUCcwAdDAJzAnQCKAICdQQBSQE4ABQCdQJ3Lg0CdwJ2HQwCdgJ3Ah0MAncCdQAdDAJ1AnYCKAICdwQBSgE4ABQCdwJ5Lg0CeQJ4HQwCeAJ5Ah0MAnkCdwAdDAJ3AngCKAICeQQBSwE4ABQCeQJ7Lg0CewJ6HQwCegJ7Ah0MAnsCeQAdDAJ5AnoCKAICewQBTAE4ABQCewJ9Lg0CfQJ8HQwCfAJ9Ah0MAn0CewAdDAJ7AnwCASgAFIC7An4uDQJ+An0dDAJ9An8CHQwCfwJ+AB0MAn4CfQIBOAAUABICgC4NAoACfx0MAn8CgAIdDAKAABQAHQwAFAJ/Ai4IAAECgCgCAoEEAS4BEAABAoEAASgDAoAEAAEBKAKAAAICgS4MAoECgi4OABcCggEoAoIAAgKCLg4AGgKCASgCggACAoIuDgAeAoIBKAKCAAICgi4OACACggEoAoIAAgKCLg4AIgKCASgCggACAoIuDgAkAoIBKAKCAAICgi4OACYCggEoAoIAAgKCLg4AKQKCASgCggACAoIuDgAtAoIBKAKCAAICgi4OADECggEoAoIAAgKCLg4AMwKCASgCggACAoIuDgA5AoIBKAKCAAICgi4OAD0CggEoAoIAAgKCLg4AQQKCASgCggACAoIuDgBDAoIBKAKCAAICgi4OAEYCggEoAoIAAgKCLg4ASAKCASgCggACAoIuDgBKAoIBKAKCAAICgi4OAEwCggEoAoIAAgKCLg4ATgKCASgCggACAoIuDgBQAoIBKAKCAAICgi4OAFICggEoAoIAAgKCLg4AUwKCASgCggACAoIuDgBWAoIBKAKCAAICgi4OAFgCggEoAoIAAgKCLg4AWgKCASgCggACAoIuDgBcAoIBKAKCAAICgi4OAF4CggEoAoIAAgKCLg4AYAKCASgCggACAoIuDgBiAoIBKAKCAAICgi4OAGMCggEoAoIAAgKCLg4AZQKCASgCggACAoIuDgBoAoIBKAKCAAICgi4OAGoCggEoAoIAAgKCLg4AbAKCASgCggACAoIuDgBuAoIBKAKCAAICgi4OAHACggEoAoIAAgKCLg4AcgKCASgCggACAoIuDgB0AoIBKAKCAAICgi4OAHYCggEoAoIAAgKCLg4AeAKCASgCggACAoIuDgB6AoIBKAKCAAICgi4OAHwCggEoAoIAAgKCLg4AfgKCASgCggACAoIuDgCAAoIBKAKCAAICgi4OAIICggEoAoIAAgKCLg4AhAKCASgCggACAoIuDgCGAoIBKAKCAAICgi4OAIgCggEoAoIAAgKCLg4AigKCASgCggACAoIuDgCMAoIBKAKCAAICgi4OAI4CggEoAoIAAgKCLg4AkAKCASgCggACAoIuDgCSAoIBKAKCAAICgi4OAJQCggEoAoIAAgKCLg4AlgKCASgCggACAoIuDgCYAoIBKAKCAAICgi4OAJoCggEoAoIAAgKCLg4AnAKCASgCggACAoIuDgCeAoIBKAKCAAICgi4OAKACggEoAoIAAgKCLg4AogKCASgCggACAoIuDgCjAoIBKAKCAAICgi4OAKYCggEoAoIAAgKCLg4AqAKCASgCggACAoIuDgCqAoIBKAKCAAICgi4OAKwCggEoAoIAAgKCLg4ArgKCASgCggACAoIuDgCwAoIBKAKCAAICgi4OALICggEoAoIAAgKCLg4AtAKCASgCggACAoIuDgC2AoIBKAKCAAICgi4OALgCggEoAoIAAgKCLg4AugKCASgCggACAoIuDgC8AoIBKAKCAAICgi4OAL4CggEoAoIAAgKCLg4AwAKCASgCggACAoIuDgDCAoIBKAKCAAICgi4OAMQCggEoAoIAAgKCLg4AxgKCASgCggACAoIuDgDIAoIBKAKCAAICgi4OAMoCggEoAoIAAgKCLg4AzAKCASgCggACAoIuDgDOAoIBKAKCAAICgi4OANACggEoAoIAAgKCLg4A0gKCASgCggACAoIuDgDUAoIBKAKCAAICgi4OANYCggEoAoIAAgKCLg4A2AKCASgCggACAoIuDgDaAoIBKAKCAAICgi4OANwCggEoAoIAAgKCLg4A3gKCASgCggACAoIuDgDgAoIBKAKCAAICgi4OAOICggEoAoIAAgKCLg4A4wKCASgCggACAoIuDgDmAoIBKAKCAAICgi4OAOgCggEoAoIAAgKCLg4A6gKCASgCggACAoIuDgDsAoIBKAKCAAICgi4OAO4CggEoAoIAAgKCLg4A8AKCASgCggACAoIuDgDyAoIBKAKCAAICgi4OAPQCggEoAoIAAgKCLg4A9gKCASgCggACAoIuDgD4AoIBKAKCAAICgi4OAPoCggEoAoIAAgKCLg4A/AKCASgCggACAoIuDgD+AoIBKAKCAAICgi4OAQACggEoAoIAAgKCLg4BAgKCASgCggACAoIuDgEEAoIBKAKCAAICgi4OAQYCggEoAoIAAgKCLg4BCAKCASgCggACAoIuDgEKAoIBKAKCAAICgi4OAQwCggEoAoIAAgKCLg4BDgKCASgCggACAoIuDgEQAoIBKAKCAAICgi4OARICggEoAoIAAgKCLg4BFAKCASgCggACAoIuDgEWAoIBKAKCAAICgi4OARgCggEoAoIAAgKCLg4BGgKCASgCggACAoIuDgEcAoIBKAKCAAICgi4OAR4CggEoAoIAAgKCLg4BIAKCASgCggACAoIuDgEiAoIBKAKCAAICgi4OASMCggEoAoIAAgKCLg4BJgKCASgCggACAoIuDgEoAoIBKAKCAAICgi4OASoCggEoAoIAAgKCLg4BLAKCASgCggACAoIuDgEuAoIBKAKCAAICgi4OATACggEoAoIAAgKCLg4BMgKCASgCggACAoIuDgE0AoIBKAKCAAICgi4OATYCggEoAoIAAgKCLg4BOAKCASgCggACAoIuDgE6AoIBKAKCAAICgi4OATwCggEoAoIAAgKCLg4BPgKCASgCggACAoIuDgFAAoIBKAKCAAICgi4OAUICggEoAoIAAgKCLg4BRAKCASgCggACAoIuDgFGAoIBKAKCAAICgi4OAUgCggEoAoIAAgKCLg4BSgKCASgCggACAoIuDgFMAoIBKAKCAAICgi4OAU4CggEoAoIAAgKCLg4BUAKCASgCggACAoIuDgFSAoIBKAKCAAICgi4OAVQCggEoAoIAAgKCLg4BVgKCASgCggACAoIuDgFYAoIBKAKCAAICgi4OAVoCggEoAoIAAgKCLg4BXAKCASgCggACAoIuDgFeAoIBKAKCAAICgi4OAWACggEoAoIAAgKCLg4BYgKCASgCggACAoIuDgFjAoIBKAKCAAICgi4OAWYCggEoAoIAAgKCLg4BaAKCASgCggACAoIuDgFqAoIBKAKCAAICgi4OAWwCggEoAoIAAgKCLg4BbgKCASgCggACAoIuDgFwAoIBKAKCAAICgi4OAXICggEoAoIAAgKCLg4BdAKCASgCggACAoIuDgF2AoIBKAKCAAICgi4OAXgCggEoAoIAAgKCLg4BegKCASgCggACAoIuDgF8AoIBKAKCAAICgi4OAX4CggEoAoIAAgKCLg4BgAKCASgCggACAoIuDgGCAoIBKAKCAAICgi4OAYQCggEoAoIAAgKCLg4BhgKCASgCggACAoIuDgGIAoIBKAKCAAICgi4OAYoCggEoAoIAAgKCLg4BjAKCASgCggACAoIuDgGOAoIBKAKCAAICgi4OAZACggEoAoIAAgKCLg4BkgKCASgCggACAoIuDgGUAoIBKAKCAAICgi4OAZYCggEoAoIAAgKCLg4BmAKCASgCggACAoIuDgGaAoIBKAKCAAICgi4OAZwCggEoAoIAAgKCLg4BngKCASgCggACAoIuDgGgAoIBKAKCAAICgi4OAaICggEoAoIAAgKCLg4BowKCASgCggACAoIuDgGmAoIBKAKCAAICgi4OAagCggEoAoIAAgKCLg4BqgKCASgCggACAoIuDgGrAoIBKAKCAAICgi4OAa4CggEoAoIAAgKCLg4BsAKCASgCggACAoIuDgGyAoIBKAKCAAICgi4OAbMCggEoAoIAAgKCLg4BtgKCASgCggACAoIuDgG4AoIBKAKCAAICgi4OAboCggEoAoIAAgKCLg4BvAKCASgCggACAoIuDgG+AoIBKAKCAAICgi4OAcACggEoAoIAAgKCLg4BwgKCASgCggACAoIuDgHEAoIBKAKCAAICgi4OAcYCggEoAoIAAgKCLg4ByAKCASgCggACAoIuDgHKAoIBKAKCAAICgi4OAcwCggEoAoIAAgKCLg4BzgKCASgCggACAoIuDgHQAoIBKAKCAAICgi4OAdICggEoAoIAAgKCLg4B1AKCASgCggACAoIuDgHWAoIBKAKCAAICgi4OAdgCggEoAoIAAgKCLg4B2gKCASgCggACAoIuDgHcAoIBKAKCAAICgi4OAd4CggEoAoIAAgKCLg4B4AKCASgCggACAoIuDgHiAoIBKAKCAAICgi4OAeMCggEoAoIAAgKCLg4B5gKCASgCggACAoIuDgHoAoIBKAKCAAICgi4OAeoCggEoAoIAAgKCLg4B7AKCASgCggACAoIuDgHuAoIBKAKCAAICgi4OAfACggEoAoIAAgKCLg4B8gKCASgCggACAoIuDgHzAoIBKAKCAAICgi4OAfYCggEoAoIAAgKCLg4B+AKCASgCggACAoIuDgH6AoIBKAKCAAICgi4OAfwCggEoAoIAAgKCLg4B/QKCASgCggACAoIuDgIAAoIBKAKCAAICgi4OAgICggEoAoIAAgKCLg4CBAKCASgCggACAoIuDgIFAoIBKAKCAAICgi4OAggCggEoAoIAAgKCLg4CCgKCASgCggACAoIuDgIMAoIBKAKCAAICgi4OAg4CggEoAoIAAgKCLg4CEAKCASgCggACAoIuDgISAoIBKAKCAAICgi4OAhQCggEoAoIAAgKCLg4CFgKCASgCggACAoIuDgIYAoIBKAKCAAICgi4OAhoCggEoAoIAAgKCLg4CHAKCASgCggACAoIuDgIeAoIBKAKCAAICgi4OAiACggEoAoIAAgKCLg4CIgKCASgCggACAoIuDgIkAoIBKAKCAAICgi4OAiYCggEoAoIAAgKCLg4CKAKCASgCggACAoIuDgIqAoIBKAKCAAICgi4OAiwCggEoAoIAAgKCLg4CLgKCASgCggACAoIuDgIwAoIBKAKCAAICgi4OAjICggEoAoIAAgKCLg4CNAKCASgCggACAoIuDgI2AoIBKAKCAAICgi4OAjgCggEoAoIAAgKCLg4COgKCASgCggACAoIuDgI8AoIBKAKCAAICgi4OAj0CggEoAoIAAgKCLg4CQAKCASgCggACAoIuDgJBAoIBKAKCAAICgi4OAkQCggEoAoIAAgKCLg4CRgKCASgCggACAoIuDgJIAoIBKAKCAAICgi4OAkoCggEoAoIAAgKCLg4CTAKCASgCggACAoIuDgJOAoIBKAKCAAICgi4OAlACggEoAoIAAgKCLg4CUgKCASgCggACAoIuDgJUAoIBKAKCAAICgi4OAlYCggEoAoIAAgKCLg4CWAKCASgCggACAoIuDgJaAoIBKAKCAAICgi4OAlwCggEoAoIAAgKCLg4CXgKCASgCggACAoIuDgJgAoIBKAKCAAICgi4OAmICggEoAoIAAgKCLg4CZAKCASgCggACAoIuDgJmAoIBKAKCAAICgi4OAmgCggEoAoIAAgKCLg4CagKCASgCggACAoIuDgJsAoIBKAKCAAICgi4OAm4CggEoAoIAAgKCLg4CcAKCASgCggACAoIuDgJyAoIBKAKCAAICgi4OAnQCggEoAoIAAgKCLg4CdgKCASgCggACAoIuDgJ4AoIBKAKCAAICgi4OAnoCggEoAoIAAgKCLg4CfAKCASgCggACAoIuDgJ9AoIBKAKCAAICgi4OAn8Cgi0NRRcAKBcCFy0OF0Uu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AUQALQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEBOAAxADQBRi4NAUYABB0MAAQBRgAtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMQE4ADEANgFILg0BSAAEHQwABAFIAC0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxATgAMQA4AUouDQFKAAQdDAAEAUoALQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEBOAAxADoBTC4NAUwABB0MAAQBTAAtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMQE4ADEAPAFOLg0BTgAEHQwABAFOAC0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxATgAMQA+AVAuDQFQAAQdDAAEAVAALQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEBOAAxAEABUi4NAVIABB0MAAQBUgAtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMQEoADGAowFULg0BVAAEHQwABAFUAC0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxASgAMYClAVYuDQFWAAQdDAAEAVYALQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEBKAAxgKcBWC4NAVgABB0MAAQBWAAtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMS0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxLQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEBKABBgGMBWi4NAVoABB0MAAQBWgAtDSkEACgEAgQtDgQpLQ0xBAAoBAIELQ4EMQEoAEGAZQFcLg0BXAAEHQwABAFcAC0NKQQAKAQCBC0OBCktDTEEACgEAgQtDgQxASgAQYBnAV4uDQFeAAQdDAAEAV4ALQ0pBAAoBAIELQ4EKS0NMQQAKAQCBC0OBDEBKABBgI8AKS0NKQQcDAQpAC0NLQQAKAQCBC0OBC0tDTMEACgEAgQtDgQzLQ0mBAAoBAIELQ4EJgEoAC2AYwAxLQ0xBBwMBDEALQ0tBAAoBAIELQ4ELS0NMwQAKAQCBC0OBDMtDSYEACgEAgQtDgQmASgALYBlAEEtDUEEHAwEQQAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgGcBYC4NAWAABB0MAAQBYAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgI8BYi4NAWIABB0MAAQBYgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtABkBYy4NAWMABB0MAAQBYwAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtABsBZi4NAWYABB0MAAQBZgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtAB0BaC4NAWgABB0MAAQBaAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgJwBai4NAWoABB0MAAQBagAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgJ0BbC4NAWwABB0MAAQBbAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgJ4Bbi4NAW4ABB0MAAQBbgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgJ8BcC4NAXAABB0MAAQBcAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgKABci4NAXIABB0MAAQBcgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgIQBdC4NAXQABB0MAAQBdAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgJMBdi4NAXYABB0MAAQBdgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgKEBeC4NAXgABB0MAAQBeAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgJIBei4NAXoABB0MAAQBegAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtACgBfC4NAXwABB0MAAQBfAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtACoBfi4NAX4ABB0MAAQBfgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtACwBgC4NAYAABB0MAAQBgAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtAC4Bgi4NAYIABB0MAAQBggAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtADABhC4NAYQABB0MAAQBhAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtADIBhi4NAYYABB0MAAQBhgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtADQBiC4NAYgABB0MAAQBiAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtADYBii4NAYoABB0MAAQBigAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtADgBjC4NAYwABB0MAAQBjAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtADoBji4NAY4ABB0MAAQBjgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtADwBkC4NAZAABB0MAAQBkAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtAD4Bki4NAZIABB0MAAQBkgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAtAEABlC4NAZQABB0MAAQBlAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgKMBli4NAZYABB0MAAQBlgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgKUBmC4NAZgABB0MAAQBmAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAtgKcBmi4NAZoABB0MAAQBmgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgGMBnC4NAZwABB0MAAQBnAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgGUBni4NAZ4ABB0MAAQBngAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgGcBoC4NAaAABB0MAAQBoAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgI8Boi4NAaIABB0MAAQBogAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzABkBoy4NAaMABB0MAAQBowAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzABsBpi4NAaYABB0MAAQBpgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzAB0BqC4NAagABB0MAAQBqAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgJwBqi4NAaoABB0MAAQBqgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgJ0Bqy4NAasABB0MAAQBqwAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgJ4Bri4NAa4ABB0MAAQBrgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgJ8BsC4NAbAABB0MAAQBsAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgKABsi4NAbIABB0MAAQBsgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgIQBsy4NAbMABB0MAAQBswAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgJMBti4NAbYABB0MAAQBtgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgKEBuC4NAbgABB0MAAQBuAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgJIBui4NAboABB0MAAQBugAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzACgBvC4NAbwABB0MAAQBvAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzACoBvi4NAb4ABB0MAAQBvgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzACwBwC4NAcAABB0MAAQBwAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzAC4Bwi4NAcIABB0MAAQBwgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzADABxC4NAcQABB0MAAQBxAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzADIBxi4NAcYABB0MAAQBxgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzADQByC4NAcgABB0MAAQByAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzADYByi4NAcoABB0MAAQBygAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzADgBzC4NAcwABB0MAAQBzAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzADoBzi4NAc4ABB0MAAQBzgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzADwB0C4NAdAABB0MAAQB0AAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzAD4B0i4NAdIABB0MAAQB0gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAzAEAB1C4NAdQABB0MAAQB1AAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgKMB1i4NAdYABB0MAAQB1gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgKUB2C4NAdgABB0MAAQB2AAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAzgKcB2i4NAdoABB0MAAQB2gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgGMB3C4NAdwABB0MAAQB3AAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgGUB3i4NAd4ABB0MAAQB3gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgGcB4C4NAeAABB0MAAQB4AAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgI8B4i4NAeIABB0MAAQB4gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmABkB4y4NAeMABB0MAAQB4wAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmABsB5i4NAeYABB0MAAQB5gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmAB0B6C4NAegABB0MAAQB6AAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgJwB6i4NAeoABB0MAAQB6gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgJ0B7C4NAewABB0MAAQB7AAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgJ4B7i4NAe4ABB0MAAQB7gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgJ8B8C4NAfAABB0MAAQB8AAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgKAB8i4NAfIABB0MAAQB8gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgIQB8y4NAfMABB0MAAQB8wAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgJMB9i4NAfYABB0MAAQB9gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgKEB+C4NAfgABB0MAAQB+AAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgJIB+i4NAfoABB0MAAQB+gAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmACgB/C4NAfwABB0MAAQB/AAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmACoB/S4NAf0ABB0MAAQB/QAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmACwCAC4NAgAABB0MAAQCAAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmAC4CAi4NAgIABB0MAAQCAgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmADACBC4NAgQABB0MAAQCBAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmADICBS4NAgUABB0MAAQCBQAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmADQCCC4NAggABB0MAAQCCAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmADYCCi4NAgoABB0MAAQCCgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmADgCDC4NAgwABB0MAAQCDAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmADoCDi4NAg4ABB0MAAQCDgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmADwCEC4NAhAABB0MAAQCEAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmAD4CEi4NAhIABB0MAAQCEgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBOAAmAEACFC4NAhQABB0MAAQCFAAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgKMCFi4NAhYABB0MAAQCFgAtDS0EACgEAgQtDgQtLQ0zBAAoBAIELQ4EMy0NJgQAKAQCBC0OBCYBKAAmgKUCGC4NAhgABB0MAAQCGAAtDS0EACgEAgQtDgQtLQ0zBAAo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Lg4AJAI8ASgCPAACAjwuDgCIAjwBKAI8AAICPC4OAIoCPAEoAjwAAgI8Lg4AjAI8ASgCPAACAjwuDgBMAjwBKAI8AAICPC4OAI4CPAEoAjwAAgI8Lg4AkAI8ASgCPAACAjwuDgCSAjwBKAI8AAICPC4OAE4CPAEoAjwAAgI8Lg4AlAI8ASgCPAACAjwuDgCWAjwBKAI8AAICPC4OAJgCPAEoAjwAAgI8Lg4AIgI8ASgCPAACAjwuDgCaAjwBKAI8AAICPC4OAJwCPAEoAjwAAgI8Lg4AngI8ASgCPAACAjwuDgCgAjwBKAI8AAICPC4OAKICPAEoAjwAAgI8Lg4AowI8ASgCPAACAjwuDgCmAjwBKAI8AAICPC4OAKgCPAEoAjwAAgI8Lg4AqgI8ASgCPAACAjwuDgCsAjwBKAI8AAICPC4OAK4CPAEoAjwAAgI8Lg4AsAI8ASgCPAACAjwuDgCyAjwBKAI8AAICPC4OALQCPAEoAjwAAgI8Lg4AtgI8ASgCPAACAjwuDgC4AjwBKAI8AAICPC4OALoCPAEoAjwAAgI8Lg4AvAI8ASgCPAACAjwuDgC+AjwBKAI8AAICPC4OAMACPAEoAjwAAgI8Lg4AwgI8ASgCPAACAjwuDgDEAjwBKAI8AAICPC4OAMYCPAEoAjwAAgI8Lg4AyAI8ASgCPAACAjwuDgDKAjwBKAI8AAICPC4OAMwCPAEoAjwAAgI8Lg4AzgI8ASgCPAACAjwuDgDQAjwBKAI8AAICPC4OANICPAEoAjwAAgI8Lg4A1AI8ASgCPAACAjwuDgDWAjwBKAI8AAICPC4OANgCPAEoAjwAAgI8Lg4A2gI8ASgCPAACAjwuDgDcAjwBKAI8AAICPC4OAN4CPAEoAjwAAgI8Lg4A4AI8ASgCPAACAjwuDgDiAjwBKAI8AAICPC4OAOMCPAEoAjwAAgI8Lg4A5gI8ASgCPAACAjwuDgDoAjwBKAI8AAICPC4OAOoCPAEoAjwAAgI8Lg4A7AI8ASgCPAACAjwuDgDuAjwBKAI8AAICPC4OAPACPAEoAjwAAgI8Lg4A8gI8ASgCPAACAjwuDgD0AjwBKAI8AAICPC4OAPYCPAEoAjwAAgI8Lg4A+AI8ASgCPAACAjwuDgD6AjwBKAI8AAICPC4OAPwCPAEoAjwAAgI8Lg4A/gI8ASgCPAACAjwuDgEAAjwBKAI8AAICPC4OAQICPAEoAjwAAgI8Lg4BBAI8ASgCPAACAjwuDgEGAjwBKAI8AAICPC4OAQgCPAEoAjwAAgI8Lg4BCgI8ASgCPAACAjwuDgEMAjwBKAI8AAICPC4OAQ4CPAEoAjwAAgI8Lg4BEAI8ASgCPAACAjwuDgESAjwBKAI8AAICPC4OARQCPAEoAjwAAgI8Lg4BFgI8ASgCPAACAjwuDgEYAjwBKAI8AAICPC4OARoCPAEoAjwAAgI8Lg4BHAI8ASgCPAACAjwuDgEeAjwBKAI8AAICPC4OASACPAEoAjwAAgI8Lg4BIgI8ASgCPAACAjwuDgEjAjwBKAI8AAICPC4OASYCPAEoAjwAAgI8Lg4BKAI8ASgCPAACAjwuDgEqAjwBKAI8AAICPC4OASwCPAEoAjwAAgI8Lg4BLgI8ASgCPAACAjwuDgEwAjwBKAI8AAICPC4OATICPAEoAjwAAgI8Lg4BNAI8ASgCPAACAjwuDgE2AjwBKAI8AAICPC4OATgCPAEoAjwAAgI8Lg4BOgI8ASgCPAACAjwuDgE8AjwBKAI8AAICPC4OAT4CPAEoAjwAAgI8Lg4BQAI8ASgCPAACAjwuDgFCAjwBKAI8AAICPC4OAUQCPAEoAjwAAgI8Lg4BRgI8ASgCPAACAjwuDgFIAjwBKAI8AAICPC4OAUoCPAEoAjwAAgI8Lg4BTAI8ASgCPAACAjwuDgFOAjwBKAI8AAICPC4OAVACPAEoAjwAAgI8Lg4BUgI8ASgCPAACAjwuDgFUAjwBKAI8AAICPC4OAVYCPAEoAjwAAgI8Lg4BWAI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8LgqAlgI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8LgqAlgI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8LgqAlgI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8LgqAlgI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8LgqAlgI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8LgqAlgI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8LgqAlgI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8LgqAlgI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8LgqAlgI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8LgqAlgI8ASgCPAACAjwuCoCWAjwBKAI8AAICPC4KgJYCPAEoAjwAAgI8Lg4BWgI8ASgCPAACAjwuDgFcAjwBKAI8AAICPC4OAV4CPAEoAjwAAgI8Lg4AKQI8ASgCPAACAjwuDgAxAjwBKAI8AAICPC4OAEECPAEoAjwAAgI8Lg4BYAI8ASgCPAACAjwuDgFiAjwBKAI8AAICPC4OAWMCPAEoAjwAAgI8Lg4BZgI8ASgCPAACAjwuDgFoAjwBKAI8AAICPC4OAWoCPAEoAjwAAgI8Lg4BbAI8ASgCPAACAjwuDgFuAjwBKAI8AAICPC4OAXACPAEoAjwAAgI8Lg4BcgI8ASgCPAACAjwuDgF0AjwBKAI8AAICPC4OAXYCPAEoAjwAAgI8Lg4BeAI8ASgCPAACAjwuDgF6AjwBKAI8AAICPC4OAXwCPAEoAjwAAgI8Lg4BfgI8ASgCPAACAjwuDgGAAjwBKAI8AAICPC4OAYICPAEoAjwAAgI8Lg4BhAI8ASgCPAACAjwuDgGGAjwBKAI8AAICPC4OAYgCPAEoAjwAAgI8Lg4BigI8ASgCPAACAjwuDgGMAjwBKAI8AAICPC4OAY4CPAEoAjwAAgI8Lg4BkAI8ASgCPAACAjwuDgGSAjwBKAI8AAICPC4OAZQCPAEoAjwAAgI8Lg4BlgI8ASgCPAACAjwuDgGYAjwBKAI8AAICPC4OAZoCPAEoAjwAAgI8Lg4BnAI8ASgCPAACAjwuDgGeAjwBKAI8AAICPC4OAaACPAEoAjwAAgI8Lg4BogI8ASgCPAACAjwuDgGjAjwBKAI8AAICPC4OAaYCPAEoAjwAAgI8Lg4BqAI8ASgCPAACAjwuDgGqAjwBKAI8AAICPC4OAasCPAEoAjwAAgI8Lg4BrgI8ASgCPAACAjwuDgGwAjwBKAI8AAICPC4OAbICPAEoAjwAAgI8Lg4BswI8ASgCPAACAjwuDgG2AjwBKAI8AAICPC4OAbgCPAEoAjwAAgI8Lg4BugI8ASgCPAACAjwuDgG8AjwBKAI8AAICPC4OAb4CPAEoAjwAAgI8Lg4BwAI8ASgCPAACAjwuDgHCAjwBKAI8AAICPC4OAcQCPAEoAjwAAgI8Lg4BxgI8ASgCPAACAjwuDgHIAjwBKAI8AAICPC4OAcoCPAEoAjwAAgI8Lg4BzAI8ASgCPAACAjwuDgHOAjwBKAI8AAICPC4OAdACPAEoAjwAAgI8Lg4B0gI8ASgCPAACAjwuDgHUAjwBKAI8AAICPC4OAdYCPAEoAjwAAgI8Lg4B2AI8ASgCPAACAjwuDgHaAjwBKAI8AAICPC4OAdwCPAEoAjwAAgI8Lg4B3gI8ASgCPAACAjwuDgHgAjwBKAI8AAICPC4OAeICPAEoAjwAAgI8Lg4B4wI8ASgCPAACAjwuDgHmAjwBKAI8AAICPC4OAegCPAEoAjwAAgI8Lg4B6gI8ASgCPAACAjwuDgHsAjwBKAI8AAICPC4OAe4CPAEoAjwAAgI8Lg4B8AI8ASgCPAACAjwuDgHyAjwBKAI8AAICPC4OAfMCPAEoAjwAAgI8Lg4B9gI8ASgCPAACAjwuDgH4AjwBKAI8AAICPC4OAfoCPAEoAjwAAgI8Lg4B/AI8ASgCPAACAjwuDgH9AjwBKAI8AAICPC4OAgACPAEoAjwAAgI8Lg4CAgI8ASgCPAACAjwuDgIEAjwBKAI8AAICPC4OAgUCPAEoAjwAAgI8Lg4CCAI8ASgCPAACAjwuDgIKAjwBKAI8AAICPC4OAgwCPAEoAjwAAgI8Lg4CDgI8ASgCPAACAjwuDgIQAjwBKAI8AAICPC4OAhICPAEoAjwAAgI8Lg4CFAI8ASgCPAACAjwuDgIWAjwBKAI8AAICPC4OAhgCPAEoAjwAAgI8Lg4CGgI8ASgCPAACAjwuDgIcAjwBKAI8AAICPC4OAh4CPAEoAjwAAgI8Lg4CIAI8ASgCPAACAjwuDgAmAjwBKAI8AAICPC4OAhwCPAEoAjwAAgI8Lg4CHgI8ASgCPAACAjwuDgIgAjwBKAI8AAICPC4OACYCPAEoAjwAAgI8Lg4ALQI8ASgCPAACAjwuDgAzAjwBKAI8AAICPC4OAEoCPAEoAjwAAgI8Lg4CIgI8ASgCPAACAjwuDgAZAjwBKAI8AAICPC4OABsCPAEoAjwAAgI8Lg4AHQI8ASgCPAACAjwuDgIkAjwBKAI8AAICPC4OAiYCPAEoAjwAAgI8Lg4CKAI8ASgCPAACAjwuDgIqAjwBKAI8AAICPC4OAiwCPAEoAjwAAgI8Lg4CLgI8ASgCPAACAjwuDgIwAjwBKAI8AAICPC4OAjICPAEoAjwAAgI8Lg4CNAI8ASgCPAACAjwuDgAoAjwBKAI8AAICPC4OACoCPAEoAjwAAgI8Lg4ALAI8ASgCPAACAjwuDgAuAjwBKAI8AAICPC4OADACPAEoAjwAAgI8Lg4AMgI8ASgCPAACAjwuDgA0AjwBKAI8AAICPC4OADYCPAEoAjwAAgI8Lg4AOAI8ASgCPAACAjwuDgA6AjwBKAI8AAICPC4OADwCPAEoAjwAAgI8Lg4APgI8ASgCPAACAjwuDgBAAjwBKAI8AAICPC4OAjYCPAEoAjwAAgI8Lg4COAI8ASgCPAACAjwuDgI6AjwBKAI8AAICPC4OABYCPAEoAjwAAgI8Lg4AGAI8ASgCPAACAjwuDgAcAjwBKAI8AAICPC4OAB8CPAEoAjwAAgI8Lg4AIQI8ASgCPAACAjwuDgAjAjwBKAI8AAICPC4OACUCPAEoAjwAAgI8Lg4AJwI8ASgCPAACAjwuDgArAjwBKAI8AAICPC4OAC8CPAEoAjwAAgI8Lg4ANQI8ASgCPAACAjwuDgA3AjwBKAI8AAICPC4OADsCPAEoAjwAAgI8Lg4APwI8ASgCPAACAjwuDgBCAjwBKAI8AAICPC4OAEQCPAEoAjwAAgI8Lg4ARwI8ASgCPAACAjwuDgBJAjwBKAI8AAICPC4OAEsCPAEoAjwAAgI8Lg4ATQI8ASgCPAACAjwuDgBPAjwBKAI8AAICPC4OAFECPAEoAjwAAgI8Lg4AVAI8ASgCPAACAjwuDgBVAjwBKAI8AAICPC4OAFcCPAEoAjwAAgI8Lg4AWQI8ASgCPAACAjwuDgBbAjwBKAI8AAICPC4OAF0CPAEoAjwAAgI8Lg4AXwI8ASgCPAACAjwuDgBhAjwBKAI8AAICPC4OAGQCPAEoAjwAAgI8Lg4AZgI8ASgCPAACAjwuDgBnAjwBKAI8AAICPC4OAGkCPAEoAjwAAgI8Lg4AawI8ASgCPAACAjwuDgBtAjwBKAI8AAICPC4OAG8CPAEoAjwAAgI8Lg4AcQI8ASgCPAACAjwuDgBzAjwBKAI8AAICPC4OAHUCPAEoAjwAAgI8Lg4AdwI8ASgCPAACAjwuDgB5AjwBKAI8AAICPC4OAHsCPAEoAjwAAgI8Lg4AfQI8ASgCPAACAjwuDgB/AjwBKAI8AAICPC4OAIECPAEoAjwAAgI8Lg4AgwI8ASgCPAACAjwuDgCFAjwBKAI8AAICPC4OAIcCPAEoAjwAAgI8Lg4AiQI8ASgCPAACAjwuDgCLAjwBKAI8AAICPC4OAI0CPAEoAjwAAgI8Lg4AjwI8ASgCPAACAjwuDgCRAjwBKAI8AAICPC4OAJMCPAEoAjwAAgI8Lg4AlQI8ASgCPAACAjwuDgCXAjwBKAI8AAICPC4OAJkCPAEoAjwAAgI8Lg4AmwI8ASgCPAACAjwuDgCdAjwBKAI8AAICPC4OAJ8CPAEoAjwAAgI8Lg4AoQI8ASgCPAACAjwuDgCkAjwBKAI8AAICPC4OAKUCPAEoAjwAAgI8Lg4ApwI8ASgCPAACAjwuDgCpAjwBKAI8AAICPC4OAKsCPAEoAjwAAgI8Lg4ArQI8ASgCPAACAjwuDgCvAjwBKAI8AAICPC4OALECPAEoAjwAAgI8Lg4AswI8ASgCPAACAjwuDgC1AjwBKAI8AAICPC4OALcCPAEoAjwAAgI8Lg4AuQI8ASgCPAACAjwuDgC7AjwBKAI8AAICPC4OAL0CPAEoAjwAAgI8Lg4AvwI8ASgCPAACAjwuDgDBAjwBKAI8AAICPC4OAMMCPAEoAjwAAgI8Lg4AxQI8ASgCPAACAjwuDgDHAjwBKAI8AAICPC4OAMkCPAEoAjwAAgI8Lg4AywI8ASgCPAACAjwuDgDNAjwBKAI8AAICPC4OAM8CPAEoAjwAAgI8Lg4A0QI8ASgCPAACAjwuDgDTAjwBKAI8AAICPC4OANUCPAEoAjwAAgI8Lg4A1wI8ASgCPAACAjwuDgDZAjwBKAI8AAICPC4OANsCPAEoAjwAAgI8Lg4A3QI8ASgCPAACAjwuDgDfAjwBKAI8AAICPC4OAOECPAEoAjwAAgI8Lg4A5AI8ASgCPAACAjwuDgDlAjwBKAI8AAICPC4OAOcCPAEoAjwAAgI8Lg4A6QI8ASgCPAACAjwuDgDrAjwBKAI8AAICPC4OAO0CPAEoAjwAAgI8Lg4A7wI8ASgCPAACAjwuDgDxAjwBKAI8AAICPC4OAPMCPAEoAjwAAgI8Lg4A9QI8ASgCPAACAjwuDgD3AjwBKAI8AAICPC4OAPkCPAEoAjwAAgI8Lg4A+wI8ASgCPAACAjwuDgD9AjwBKAI8AAICPC4OAP8CPAEoAjwAAgI8Lg4BAQI8ASgCPAACAjwuDgEDAjwBKAI8AAICPC4OAQUCPAEoAjwAAgI8Lg4BBwI8ASgCPAACAjwuDgEJAjwBKAI8AAICPC4OAQsCPAEoAjwAAgI8Lg4BDQI8ASgCPAACAjwuDgEPAjwBKAI8AAICPC4OARECPAEoAjwAAgI8Lg4BEwI8ASgCPAACAjwuDgEVAjwBKAI8AAICPC4OARcCPAEoAjwAAgI8Lg4BGQI8ASgCPAACAjwuDgEbAjwBKAI8AAICPC4OAR0CPAEoAjwAAgI8Lg4BHwI8ASgCPAACAjwuDgEhAjwBKAI8AAICPC4OASQCPAEoAjwAAgI8Lg4BJQI8ASgCPAACAjwuDgEnAjwBKAI8AAICPC4OASkCPAEoAjwAAgI8Lg4BKwI8ASgCPAACAjwuDgEtAjwBKAI8AAICPC4OAS8CPAEoAjwAAgI8Lg4BMQI8ASgCPAACAjwuDgEzAjwBKAI8AAICPC4OATUCPAEoAjwAAgI8Lg4BNwI8ASgCPAACAjwuDgE5AjwBKAI8AAICPC4OATsCPAEoAjwAAgI8Lg4BPQI8ASgCPAACAjwuDgE/AjwBKAI8AAICPC4OAUECPAEoAjwAAgI8Lg4BQwI8ASgCPAACAjwuDgFFAjwBKAI8AAICPC4OAUcCPAEoAjwAAgI8Lg4BSQI8ASgCPAACAjwuDgFLAjwBKAI8AAICPC4OAU0CPAEoAjwAAgI8Lg4BTwI8ASgCPAACAjwuDgFRAjwBKAI8AAICPC4OAVMCPAEoAjwAAgI8Lg4BVQI8ASgCPAACAjwuDgFXAjwBKAI8AAICPC4OAVkCPAEoAjwAAgI8Lg4BWwI8ASgCPAACAjwuDgFdAjwBKAI8AAICPC4OAV8CPAEoAjwAAgI8Lg4BYQI8ASgCPAACAjwuDgFkAjwBKAI8AAICPC4OAWUCPAEoAjwAAgI8Lg4BZwI8ASgCPAACAjwuDgFpAjwBKAI8AAICPC4OAWsCPAEoAjwAAgI8Lg4BbQI8ASgCPAACAjwuDgFvAjwBKAI8AAICPC4OAXECPAEoAjwAAgI8Lg4BcwI8ASgCPAACAjwuDgF1AjwBKAI8AAICPC4OAXcCPAEoAjwAAgI8Lg4BeQI8ASgCPAACAjwuDgF7AjwBKAI8AAICPC4OAX0CPAEoAjwAAgI8Lg4BfwI8ASgCPAACAjwuDgGBAjwBKAI8AAICPC4OAYMCPAEoAjwAAgI8Lg4BhQI8ASgCPAACAjwuDgGHAjwBKAI8AAICPC4OAYkCPAEoAjwAAgI8Lg4BiwI8ASgCPAACAjwuDgGNAjwBKAI8AAICPC4OAY8CPAEoAjwAAgI8Lg4BkQI8ASgCPAACAjwuDgGTAjwBKAI8AAICPC4OAZUCPAEoAjwAAgI8Lg4BlwI8ASgCPAACAjwuDgGZAjwBKAI8AAICPC4OAZsCPAEoAjwAAgI8Lg4BnQI8ASgCPAACAjwuDgGfAjwBKAI8AAICPC4OAaECPAEoAjwAAgI8Lg4BpAI8ASgCPAACAjwuDgGlAjwBKAI8AAICPC4OAacCPAEoAjwAAgI8Lg4BqQI8ASgCPAACAjwuDgGsAjwBKAI8AAICPC4OAa0CPAEoAjwAAgI8Lg4BrwI8ASgCPAACAjwuDgGxAjwBKAI8AAICPC4OAbQCPAEoAjwAAgI8Lg4BtQI8ASgCPAACAjwuDgG3AjwBKAI8AAICPC4OAbkCPAEoAjwAAgI8Lg4BuwI8ASgCPAACAjwuDgG9AjwBKAI8AAICPC4OAb8CPAEoAjwAAgI8Lg4BwQI8ASgCPAACAjwuDgHDAjwBKAI8AAICPC4OAcUCPAEoAjwAAgI8Lg4BxwI8ASgCPAACAjwuDgHJAjwBKAI8AAICPC4OAcsCPAEoAjwAAgI8Lg4BzQI8ASgCPAACAjwuDgHPAjwBKAI8AAICPC4OAdECPAEoAjwAAgI8Lg4B0wI8ASgCPAACAjwuDgHVAjwBKAI8AAICPC4OAdcCPAEoAjwAAgI8Lg4B2QI8ASgCPAACAjwuDgHbAjwBKAI8AAICPC4OAd0CPAEoAjwAAgI8Lg4B3wI8ASgCPAACAjwuDgHhAjwBKAI8AAICPC4OAeQCPAEoAjwAAgI8Lg4B5QI8ASgCPAACAjwuDgHnAjwBKAI8AAICPC4OAekCPAEoAjwAAgI8Lg4B6wI8ASgCPAACAjwuDgHtAjwBKAI8AAICPC4OAe8CPAEoAjwAAgI8Lg4B8QI8ASgCPAACAjwuDgH0AjwBKAI8AAICPC4OAfUCPAEoAjwAAgI8Lg4B9wI8ASgCPAACAjwuDgH5AjwBKAI8AAICPC4OAfsCPAEoAjwAAgI8Lg4B/gI8ASgCPAACAjwuDgH/AjwBKAI8AAICPC4OAgECPAEoAjwAAgI8Lg4CAwI8ASgCPAACAjwuDgIGAjwBKAI8AAICPC4OAgcCPAEoAjwAAgI8Lg4CCQI8ASgCPAACAjwuDgILAjwBKAI8AAICPC4OAg0CPAEoAjwAAgI8Lg4CDwI8ASgCPAACAjwuDgIRAjwBKAI8AAICPC4OAhMCPAEoAjwAAgI8Lg4CFQI8ASgCPAACAjwuDgIXAjwBKAI8AAICPC4OAhkCPAEoAjwAAgI8Lg4CGwI8ASgCPAACAjwuDgIdAjwBKAI8AAICPC4OAh8CPAEoAjwAAgI8Lg4CIQI8ASgCPAACAjwuDgIjAjwBKAI8AAICPC4OAiUCPAEoAjwAAgI8Lg4CJwI8ASgCPAACAjwuDgIpAjwBKAI8AAICPC4OAisCPAEoAjwAAgI8Lg4CLQI8ASgCPAACAjwuDgIvAjwBKAI8AAICPC4OAjECPAEoAjwAAgI8Lg4CMwI8ASgCPAACAjwuDgI1AjwBKAI8AAICPC4OAjcCPAEoAjwAAgI8Lg4COQI8ASgCPAACAjwuDgI7AjwBKAI8AAICPC4OAj4CPAEoAjwAAgI8Lg4CPwI8ASgCPAACAjwuDgJCAjwBKAI8AAICPC4OAkMCPAEoAjwAAgI8Lg4CRQI8ASgCPAACAjwuDgJHAjwBKAI8AAICPC4OAkkCPAEoAjwAAgI8Lg4CSwI8ASgCPAACAjwuDgJNAjwBKAI8AAICPC4OAk8CPAEoAjwAAgI8Lg4CUQI8ASgCPAACAjwuDgJTAjwBKAI8AAICPC4OAlUCPAEoAjwAAgI8Lg4CVwI8ASgCPAACAjwuDgJZAjwBKAI8AAICPC4OAlsCPAEoAjwAAgI8Lg4CXQI8ASgCPAACAjwuDgJfAjwBKAI8AAICPC4OAmECPAEoAjwAAgI8Lg4CYwI8ASgCPAACAjwuDgJlAjwBKAI8AAICPC4OAmcCPAEoAjwAAgI8Lg4CaQI8ASgCPAACAjwuDgJrAjwBKAI8AAICPC4OAm0CPAEoAjwAAgI8Lg4CbwI8ASgCPAACAjwuDgJxAjwBKAI8AAICPC4OAnMCPAEoAjwAAgI8Lg4CdQI8ASgCPAACAjwuDgJ3AjwBKAI8AAICPC4OAnkCPAEo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DiUAATOJLgQAFoADKACABAQBTyUAATUgLgiABQAYACgYAhoAOBoEGy0OGRstDhgXASgABIBjABYtDBYEIwAAD6skAgAMAADoViMAAOirJwINBAMMOAMNDiQCAA4AAOhtJQABM4kAKAcCDQA4DQMOLQ0ODCcCDQQOLQgADi0MBA8tDAYQLQwKES0MCxItDAwTABAADQAlAADrCS0EAAAjAADoqwEoAAOAYwAMLQwMAyMAAAvgJAIADAAA6MkjAADpHicCDgQCDDgDDg8kAgAPAADo4CUAATOJACgKAg4AOA4DDy0NDwwnAg4EDy0IAA8tDA0QLQwGES0MBxItDAsTLQwMFAAQAA4AJQAA6wktBAAAIwAA6R4BKAADgGMADC0MDAMjAAAKvigAgAQEeAANAAAAgASAAyQAgAMAAOlXKgEAAQX3ofOvpa3UyjwBAQImJQAA6S8BKAABgGMAAy0NAwIcDAIBACwCAAMAAAAAAAAAAAAAAAAA//////////////////////////8OOAEDBCQCAAQAAOmlJQABPZotDAIBJiUAAOkvHAwBAwQcDAMCABwMAgEEJiUAAOkvLQgBAicCAwQEABABAwEnAwIEAQAoAgIDLQwDBC4KgJYABAAoBAIELgqAlgAEACgEAgQuCoCWAAQtDQIDACgDAgMtDgMCLQgBAycCBAQFABABBAEnAwMEAQAoAwIELQwEBS4KgJYABQAoBQIFLgqAlgAFACgFAgUuCoCWAAUAKAUCBS0OAQUuCICVAAQtDAIBLQwDAi4IgGQAAyYlAADpLy0NBAULKAAFgJUABiQCAAYAAOqBJwIHBAA8CQEHJwIFBAYtCAAGLQwBBy0MAggtDAMJLQwECgAQAAUAJQABPawtBAAALQ0BBS0NAgYtDQMHLQ4FAS0OBgItDgcDLgqAlwAEASgABoBjAAItDQIBJioBAAEF9IABplnTJ0I8AQECJioBAAEFHwBQEkAkIu48AQECJioBAAEFHwotJ9yCh6I8AQECJiUAAOkvLQ0DBi0NBAcLKAAHgJUACCQCAAgAAOsvJwIJBAA8CQEJCygABoBnAAckAgAHAADrwCMAAOtELQ0BBi0NAgctDQMILQ0ECScCCwQDDDgICwwkAgAMAADrayUAATOJLgQABoADKACABAQABCUAATUgLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgGMABQ44CAUGJAIABgAA66slAADsNC0OCgEtDgcCLQ4FAy0OCQQjAADsMycCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAT2sLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAE1IC4IgAUACQAoCQIKASgACoBkAAstDgULLQ4JAS0OBwIuCoBjAAMtDggEIwAA7DMmKgEAAQVFp8pxGUHkFTwBAQImJQAA6S8eAgAEAB4CAAUAMzgABAAFAAYkAgAGAADsaiUAAT7/JiUAAOkvLQgBBAAAAQIBLgqAlwAELgiAZAADIwAA7IoNKAADgKcABSQCAAUAAOykIwAA7J8tDQQBJi0NBAUnAgcEIAw4AwcIJAIACAAA7L8lAAEziQAoAQIHADgHAwgtDQgGJwIIBCAMOAMICSQCAAkAAOzkJQABM4kAKAICCAA4CAMJLQ0JBwo4BgcIBDgFCAYtDgYEASgAA4BjAAUtDAUDIwAA7IoqAQABBbfkiV0xdorfPAEBAiYlAADpLycCAwQELQgABC0MAQUuCIBkAAYAEAADACUAAT8RLQQAAC0MBQItDQIDACgDAgMtDgMCJwIEBAUtCAAFLQwBBi4IgKcABwAQAAQAJQABPxEtBAAALQwGAy0NAwQAKAQCBC0OBAMnAgUEBi0IAAYtDAEHLgiAjgAIABAABQAlAAE/ES0EAAAtDAcELQ0EBQAoBQIFLQ4FBCcCBgQHLQgABy0MAQguCICtAAkAEAAGACUAAT8RLQQAAC0MCAUtDQUGACgGAgYtDgYFJwIHBAgtCAAILQwBCS4IgK8ACgAQAAcAJQABPxEtBAAALQwJBi0NBgcAKAcCBy0OBwYnAggECS0IAAktDAEKLgiAsAALABAACAAlAAE/ES0EAAAtDAoHLQ0HCAAoCAIILQ4IBycCCQQKLQgACi0MAQsuCICxAAwAEAAJACUAAT8RLQQAAC0MCwgtDQgJACgJAgktDgkIJwIKBAstCAALLQwBDC4IgLIADQAQAAoAJQABQCMtBAAALQwMCScCCwQMLQgADC0MCQ0AEAALACUAAUExLQQAAC0MDQonAgsEDC0IAAwtDAENLgiAswAOABAACwAlAAFAIy0EAAAtDA0JJwIMBA0tCAANLQwJDgAQAAwAJQABQTEtBAAALQwOCycCDAQNLQgADS0MAQ4uCIC0AA8AEAAMACUAAT8RLQQAAC0MDgktDQkMACgMAgwtDgwJJwINBA4tCAAOLQwBDy4IgLYAEAAQAA0AJQABQCMtBAAALQwPDCcCDgQPLQgADy0MDBAAEAAOACUAAUExLQQAAC0MEA0BKAABgLcADi0NDgwnAg8EEC0IABAtDAERLgiAtwASABAADwAlAAE/ES0EAAAtDBEOLQ0OAQAoAQIBLQ4BDi0NAgEAKAECAS0OAQItDQMBACgBAgEtDgEDLQ0EAQAoAQIBLQ4BBC0NBQEAKAECAS0OAQUtDQYBACgBAgEtDgEGLQ0HAQAoAQIBLQ4BBy0NCAEAKAECAS0OAQgtDQkBACgBAgEtDgEJLQ0OAQAoAQIBLQ4BDi0MAgEtDAMCLQwEAy0MBQQtDAYFLQwHBi0MCActDAoILQwJCi0MCwktDA0LLQwODSYqAQABBSrhixTU6kFaPAEBAiYlAADpLy0IAQMAAAECAS4KgJgAAy0IAQQAAAECAS4KgJYABC4IgGQAAiMAAPCoDSgAAoCnAAUkAgAFAADwwiMAAPC9LQ0EASYtDQQFAzCApQACAAYPKAACgKUAByQCAAcAAPDjJQABQiInAggEIAw4BggJJAIACQAA8PolAAEziQAoAQIIADgIBgktDQkHHAwHBgAtDQMHBDgGBwgAOAUIBi0OBgQFKAAHgLUABS0OBQMBKAACgGMABS0MBQIjAADwqCoBAAEFkH5HBrl0Rj88AQECJiUAAOkvHAwCBQQcDAUEBRwMBAIEDTCAgwACAAQLKAAEgJUABSQCAAUAAPGDJwIGBAA8CQEGBygAAoCOAAQuCYCNAAUAKAUCBS4GAAWAjS0IAQUAAAECAS4KgI0ABS4IgGQAAyMAAPG2DDgDBAYkAgAGAAD0RiMAAPHIJwIIBEAGOAIICQQ4CQgKAjgCCgcLKAAHgGQACCQCAAgAAPJqIwAA8fEFMICOAAQABycCCQQACjgJBAgkAgAIAADyJQY4BwQLCygAC4COAAokAgAKAADyJSUAAUI0JwIJBAotCAAKLQwBCy0MAgwtDAcNABAACQAlAAFCRi0EAAAtDAsELQwMCC0NBAEAKAECAS0OAQQtDAQDLQwIBiMAAPLALQgBAScCBAQRABABBAEnAwEEAQAoAQIEJwIHBBAAOAcEBy0MBAgMOAgHCRYMCQkkAgAJAADysS4KgGQACAAoCAIIIwAA8pAtDAEDLgiAZAAGIwAA8sAtDQMHACgHAgctDgcDBygABoCPAAcnAgkEEAw4BwkKJAIACgAA8uwlAAEziQAoAwIJADgJBwotDQoIJwIKBAstCAALLQwIDC0MBg0uCICuAA4AEAAKACUAATObLQQAAC0MDAknAgoEEAw4BwoLJAIACwAA8zolAAEziS4EAAOAAygAgAQEABElAAE1IC4IgAUACAAoCAIKADgKBwstDgkLDSgABoCQAAMkAgADAADzsiMAAPN1LQ0FAy0IAQUnAgYECQAQAQYBJwMFBAEAKAgCBgAoAwIHACgFAglAPwAJAAcABi0MBQEuCIBkAAQjAADz3S0NBQMBKAAGgGMABQ44BgUHJAIABwAA89AlAADsNC0MAwEtDAUEIwAA890tDQEDACgDAgMtDgMBJwIFBAktCAAJLQwICi0MBAstDAIMABAABQAlAAE1ri0EAAAtDAoDLQ0DAgAoAgICLQ4CAycCBAQFLQgABS0MAwYtDAEHABAABAAlAAE6AS0EAAAtDAYCLQwCASYFMICOAAMABicCCAQACjgIAwckAgAHAAD0egY4BgMKCygACoCOAAkkAgAJAAD0eiUAAUI0JwIJBAotCAAKLQwBCy0MAgwtDAYNABAACQAlAAFCRi0EAAAtDAsHLQwMCC0NBwYAKAYCBi0OBgctDQUGLQgBCScCCgQJABABCgEnAwkEAQAoBwIKACgGAgsAKAkCDEA/AAwACwAKLQ0JBgAoBgIGLQ4GCS0OCQUBKAADgGMABi0MBgMjAADxtiUAAOkvJwICAhgaOAECAxwMAwQCHAwEAgQcDAIDAhsoAAGAogACHAwCBQIcDAUEBBwMBAICGygAAYCbAAQcDAQGAhwMBgUEHAwFBAIcDAEGAhwMBgUEHAwFAQItCAEFJwIGBAUAEAEGAScDBQQBACgFAgYtDAYHLQ4DBwAoBwIHLQ4CBwAoBwIHLQ4EBwAoBwIHLQ4BBy0MBQEmKgEAAQVQJfx3MGTjlTwBAQImKgEAAQVbTbUKj4cAEzwBAQImKgEAAQUC3G4ngHYSnTwBAQImJQAA6S8tCAEIJwIJBAMAEAEJAScDCAQBACgIAgktDAkKLQ4ECgAoCgIKLQ4GCicCCwQMLQgADC4IgL4ADQAQAAsAJQAA6b8tBAAALQwNBC0MDgYtDA8JLQwQCi0NBAsAKAsCCy0OCwQtCAELAAABAgEtDgQLLQ0GBAAoBAIELQ4EBi0IAQQAAAECAS0OBgQtCAEGAAABAgEtDgkGLQgBCQAAAQIBLQ4KCS4IgGQAByMAAPaHDSgAB4BlAAokAgAKAAD4HyMAAPacJwIOBA8tCAAPLQwLEC0MBBEtDAYSLQwJEwAQAA4AJQAA6l8tBAAALQwQDQsoAAWAqAAECygADYCWAAYkAgAEAAD35CMAAPbkCygABYCpAAQkAgAEAAD3uiMAAPb5CygABYCqAAQkAgAEAAD3kCMAAPcOCygABYCrAAQkAgAEAAD3ZiMAAPcjCygABYCsAAQkAgAEAAD3PCcCCQQAPAkBCQsoAAaAlQAEJAIABAAA91ElAAD1wS0MAQctDAIILQwDCi0MDQwjAAD4DgsoAAaAlQAEJAIABAAA93slAAD1wS0MAQctDAIILQwDCi0MDQwjAAD4DgsoAAaAlQAEJAIABAAA96UlAAD1wS0MAQctDAIILQwDCi0MDQwjAAD4DgsoAAaAlQAEJAIABAAA988lAAD1wS0MAQctDAIILQwDCi0MDQwjAAD4DgsoAAaAlQAEJAIABAAA9/klAAD1wS0MAQctDAIILQwDCi0MDQwjAAD4Di0MCgMtDAcBLQwIAi0MDAQmJAIACgAA+CwjAAD4gScCDAQCDDgHDA0kAgANAAD4QyUAATOJACgIAgwAOAwHDS0NDQonAgwEDS0IAA0tDAsOLQwEDy0MBhAtDAkRLQwKEgAQAAwAJQAA6wktBAAAIwAA+IEBKAAHgGMACi0MCgcjAAD2hyUAAOkvLwwABAAFHAwFBgEcDAYEABwMBAUBLQwFASYqAQABBQ/0kvy25IIAPAEBAiYlAADpLy0IAQgnAgkEAwAQAQkBJwMIBAEAKAgCCS0MCQotDgQKACgKAgotDgYKJwILBAwtCAAMLgiAvgANABAACwAlAADpvy0EAAAtDA0ELQwOBi0MDwktDBAKLQ0ECwAoCwILLQ4LBC0IAQsAAAECAS0OBAstDQYEACgEAgQtDgQGLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS0OCQYtCAEJAAABAgEtDgoJLgiAZAAHIwAA+XcNKAAHgGUACiQCAAoAAPsPIwAA+YwnAg4EDy0IAA8tDAsQLQwEES0MBhItDAkTABAADgAlAADqXy0EAAAtDBANCygABYCoAAQLKAANgJYABiQCAAQAAPrUIwAA+dQLKAAFgKkABCQCAAQAAPqqIwAA+ekLKAAFgKoABCQCAAQAAPqAIwAA+f4LKAAFgKsABCQCAAQAAPpWIwAA+hMLKAAFgKwABCQCAAQAAPosJwIJBAA8CQEJCygABoCVAAQkAgAEAAD6QSUAAPXBLQwBBy0MAggtDAMKLQwNDCMAAPr+CygABoCVAAQkAgAEAAD6ayUAAPXBLQwBBy0MAggtDAMKLQwNDCMAAPr+CygABoCVAAQkAgAEAAD6lSUAAPXBLQwBBy0MAggtDAMKLQwNDCMAAPr+CygABoCVAAQkAgAEAAD6vyUAAPXBLQwBBy0MAggtDAMKLQwNDCMAAPr+CygABoCVAAQkAgAEAAD66SUAAPXBLQwBBy0MAggtDAMKLQwNDCMAAPr+LQwKAy0MBwEtDAgCLQwMBCYkAgAKAAD7HCMAAPtxJwIMBAIMOAcMDSQCAA0AAPszJQABM4kAKAgCDAA4DAcNLQ0NCicCDAQNLQgADS0MCw4tDAQPLQwGEC0MCREtDAoSABAADAAlAADrCS0EAAAjAAD7cQEoAAeAYwAKLQwKByMAAPl3JQAA6S8tCAEDKAIABAQBTgAQAQQBJwMDBAEAKAMCBCgCAAUEAU0AOAUEBS0MBAYMOAYFBxYMBwckAgAHAAD70i4KgGEABgAoBgIGIwAA+7EtCAEEAAABAgEtDgMELgiAZAACIwAA++oNKAACgKcAAyQCAAMAAPzUIwAA+/8uCIBkAAIjAAD8Cg0oAAKAgwADJAIAAwAA/E0jAAD8Hy0NBAEnAgMEBC0IAAQtDAEFLgiAvAAGABAAAwAlAAFFHy0EAAAtDAUCLQwCASYtDQQDASgAAoCnAAUoAgAHBAEtDDgCBwgkAgAIAAD8ciUAATOJACgBAgcAOAcCCC0NCAYoAgAIBAFNDDgFCAkkAgAJAAD8mSUAATOJLgQAA4ADKACABAQBTiUAATUgLgiABQAHACgHAggAOAgFCS0OBgktDgcEASgAAoBjAAMtDAMCIwAA/AotDQQDJwIGBCAMOAIGByQCAAcAAPzvJQABM4kBIIBgAAIABgA4BgIHLQ0HBSgCAAcEAU0MOAIHCCQCAAgAAP0ZJQABM4kuBAADgAMoAIAEBAFOJQABNSAuCIAFAAYAKAYCBwA4BwIILQ4FCAEoAAKAYwADLQ4GBC0MAwIjAAD76iUAAOkvLQgBBycCCAQhABABCAEnAwcEAQAoBwIIJwIJBCAAOAkICS0MCAoMOAoJCxYMCwskAgALAAD9oC4KgJYACgAoCgIKIwAA/X8tCAEIAAABAgEtDgcILgiAZAAGIwAA/bgNKAAGgKcAASQCAAEAAP44IwAA/c0tDQgCLgiAZAABIwAA/dwNKAABgKcAAyQCAAMAAP3yIwAA/fEmHAwBAwAAOAQDBScCBgQgDDgBBgckAgAHAAD+EyUAATOJACgCAgYAOAYBBy0NBwMwDAADAAUBKAABgGMAAy0MAwEjAAD93CcCAgQgDDgGAgMkAgADAAD+TyUAATOJACgFAgIAOAIGAy0NAwEcDAECAC0NCAEnAgcEIAw4BgcJJAIACQAA/n0lAAEziS4EAAGAAygAgAQEACElAAE1IC4IgAUAAwAoAwIHADgHBgktDgIJLQ4DCAEoAAaAYwABLQwBBiMAAP24JQAA6S8tCAEIJwIJBAMAEAEJAScDCAQBACgIAgktDAkKLQ4ECgAoCgIKLQ4GCicCCwQMLQgADC4IgL4ADQAQAAsAJQAA6b8tBAAALQwNBC0MDgYtDA8JLQwQCi0NBAsAKAsCCy0OCwQtCAELAAABAgEtDgQLLQ0GBAAoBAIELQ4EBi0IAQQAAAECAS0OBgQtCAEGAAABAgEtDgkGLQgBCQAAAQIBLQ4KCS4IgGQAByMAAP9sDSgAB4BlAAokAgAKAAEBBCMAAP+BJwIOBA8tCAAPLQwLEC0MBBEtDAYSLQwJEwAQAA4AJQAA6l8tBAAALQwQDQsoAAWAqAAECygADYCWAAYkAgAEAAEAySMAAP/JCygABYCpAAQkAgAEAAEAnyMAAP/eCygABYCqAAQkAgAEAAEAdSMAAP/zCygABYCrAAQkAgAEAAEASyMAAQAICygABYCsAAQkAgAEAAEAIScCCQQAPAkBCQsoAAaAlQAEJAIABAABADYlAAD1wS0MAQctDAIILQwDCi0MDQwjAAEA8wsoAAaAlQAEJAIABAABAGAlAAD1wS0MAQctDAIILQwDCi0MDQwjAAEA8wsoAAaAlQAEJAIABAABAIolAAD1wS0MAQctDAIILQwDCi0MDQwjAAEA8wsoAAaAlQAEJAIABAABALQlAAD1wS0MAQctDAIILQwDCi0MDQwjAAEA8wsoAAaAlQAEJAIABAABAN4lAAD1wS0MAQctDAIILQwDCi0MDQwjAAEA8y0MCgMtDAcBLQwIAi0MDAQmJAIACgABAREjAAEBZicCDAQCDDgHDA0kAgANAAEBKCUAATOJACgIAgwAOAwHDS0NDQonAgwEDS0IAA0tDAsOLQwEDy0MBhAtDAkRLQwKEgAQAAwAJQAA6wktBAAAIwABAWYBKAAHgGMACi0MCgcjAAD/bCUAAOkvHAwFBgAwDAAGAAQmJQAA6S8tCAEDAAABAgEnAgQGAC0OBAMnAgQGAScCBQIfLgiAYQACIwABAbQNKAACgKIABiQCAAYAAQHOIwABAcktDQMBJi0NAwYCOAUCBxwMBwgEJwIJBCAMOAgJCiQCAAoAAQHzJQABM4kAKAECCQA4CQgKLQ0KBxwMBwgGBSgAAoCbAAcYOAQHCQ0oAAeArgAKJAIACgABAiglAAFI0wQ4CAkHJwILBgAKOAsJCiQCAAoAAQJWBjgHCQ0KOA0IDCQCAAwAAQJWJQABQjQAOAYHCA44BggJJAIACQABAm0lAADsNC0OCAMBKAACgGYABi0MBgIjAAEBtCUAAOkvLQgBBgAAAQIBLQ4BBi0NAgEAKAECAS0OAQItCAEBAAABAgEtDgIBLQ0EAgAoAgICLQ4CBC4IgGQABSMAAQLGDDgFAwIkAgACAAEC6SMAAQLYLQ0GAi0NAQMtDAIBLQwDAiYkAgACAAEC9iUAAUjlJwIIBAMAOAQIBwA4BwUILQ0IAi0NBgctDQEIACgHAgkuBAAIgAMoAIAEBAABJQABA14uCIAFAAouCIAGAAstDgILLQ0KAgAoAgICLQ4CCi0OCQYtDgoBASgABYBjAAItDAIFIwABAsYuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAAEDrSMAAQQdJACADQABA7ojAAED0y4AgAOABQEAgAUAAoAOLgKAC4AOIwABBBgoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwABBBgjAAEEcSgAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAAEEcSgAgA0EAAMBAIAFgA2ADAsAgAOABYANJACADQABBNUBAIAKgAiADy4AgAqAEC4AgAyAEQsAgBCAD4ASJACAEgABBNUuAYAQgA4uAoAOgBEBAIAQAAKAEAEAgBEAAoARIwABBKQBAIAMgAiABiYlAADpLxwMAg4AACgEAgIuBAAFgAMoAIAEBAABJQABSPcuCIAFAA8uCIAGABAtDg4QLQ0PBAAoBAIELQ4EDxYMBwQcDAcFABwMBAcABDgFCAQFKAAHgJEABQA4BAUHFgwJBBwMCQUAHAwECAAEOAUKBAUoAAiAkQAFADgEBQgtCAEEJwIFBAMAEAEFAScDBAQBACgEAgUtDAUJLQ4HCQAoCQIJLQ4ICQAoBAIFACgPAgktDQkIJwIKBAIAOAkKBzn1AAUAAQAHAAggAgABIQIAAi0IAQUAKAUCCS0NCQgnAgoEAgA4CQoHIjSAZAACAActDAIIJwIKBAMAOAgKCQAQAQkBJwMFBAEAKAUCCi0OCAoAKAoCCi0OCAotDAgEBigEAgQtDQUCACgCAgItDgIFJAIAAQABBjcjAAEGGwAoBQIDLQ0DAicCBgQCADgDBgE8DQECIwABBjctDQUBACgBAgEtDgEFCygABIBkAAEkAgABAAEGXScCAgQAPAkBAiYlAADpLy0IAQQoAgAFBAFVABABBQEnAwQEAQAoBAIFKAIABgQBVAA4BgUGLQwFBww4BwYIFgwICCQCAAgAAQauLgqAYQAHACgHAgcjAAEGjS0IAQUAAAECAS0OBAUuCIBkAAMjAAEGxg0oAAOAvQAEJAIABAABCGIjAAEG2y0IAQQoAgAGBAESABABBgEnAwQEAQAoBAIGKAIABwQBEQA4BwYHLQwGCAw4CAcJFgwJCSQCAAkAAQcmLgqAYQAIACgIAggjAAEHBS0IAQYAAAECAS0OBAYuCIBkAAMjAAEHPg0oAAOAuAAEJAIABAABB8wjAAEHUy0NAQIAKAICAi0OAgEtDQUCLQ0CAwAoAwIDLQ4DAi0NAQMAKAMCAy0OAwEtDQIDACgDAgMtDgMCLQ0BAwAoAwIDLQ4DAS0NBgMtDQMEACgEAgQtDgQDLQ0BBAAoBAIELQ4EAS0NAwQAKAQCBC0OBAMtDAMELQwBAyYtDQYEASgAA4C9AAcoAgAJBAJlDDgHCQokAgAKAAEH8SUAATOJACgCAgkAOAkHCi0NCggcDAgJAhwMCQcAHAwHCAIoAgAJBAERDDgDCQokAgAKAAEIJyUAATOJLgQABIADKACABAQBEiUAATUgLgiABQAHACgHAgkAOAkDCi0OCAoBKAADgGMABC0OBwYtDAQDIwABBz4tDQUEKAIABwQCZQw4AwcIJAIACAABCH8lAAEziQAoAgIHADgHAwgtDQgGHAwGCAIcDAgHABwMBwYCKAIACAQBVAw4AwgJJAIACQABCLUlAAEziS4EAASAAygAgAQEAVUlAAE1IC4IgAUABwAoBwIIADgIAwktDgYJASgAA4BjAAQtDgcFLQwEAyMAAQbGJQAA6S8tCAEEJwIFBA4AEAEFAScDBAQBACgEAgUnAgYEDQA4BgUGLQwFBww4BwYIFgwICCQCAAgAAQk8LgqAlgAHACgHAgcjAAEJGy0IAQUAAAECAS0OBAUtCAEEJwIGBCAAEAEGAScDBAQBACgEAgYnAgcEHwA4BwYHLQwGCAw4CAcJFgwJCSQCAAkAAQmQLgqAYQAIACgIAggjAAEJby0IAQYAAAECAS0OBAYtCAEEJwIHBCAAEAEHAScDBAQBACgEAgcnAggEHwA4CAcILQwHCQw4CQgKFgwKCiQCAAoAAQnkLgqAYQAJACgJAgkjAAEJwy0IAQcAAAECAS0OBAcuCIBkAAMjAAEJ/A0oAAOApQAEJAIABAABDV8jAAEKES0NBgQBKAABgKcACS0NCQguBAAEgAMoAIAEBAAgJQABNSAuCIAFAAEAKAECCQEoAAmAZAAKLQ4ICi0OAQYtCAEBJwIEBCAAEAEEAScDAQQBACgBAgQnAggEHwA4CAQILQwECQw4CQgKFgwKCiQCAAoAAQqVLgqAYQAJACgJAgkjAAEKdC4IgGQAAyMAAQqgDSgAA4CgAAQkAgAEAAELViMAAQq1LQ0FAS0NBwInAgQEBy0IAActDAIIABAABAAlAAFKcS0EAAAtDAgDLgQAAYADKACABAQADiUAATUgLgiABQACACgCAgQBKAAEgGQABy0OAwctDQYBJwIEBAYtCAAGLQwBBwAQAAQAJQABSnEtBAAALQwHAy4EAAKAAygAgAQEAA4lAAE1IC4IgAUAAQAoAQIEASgABICgAAYtDgMGLQ4BBSYtDQEIACgIAggtDggBLQgBCAAAAQIBLQ4BCAUwgKcAAwAJLgiAZAAEIwABC4MNKAAEgKUACiQCAAoAAQyxIwABC5gtDQUEASgAA4BjAAotDQgLJwIMBA0tCAANLQwLDgAQAAwAJQABSzMtBAAALQwOCCcCDAQNDDgKDA0kAgANAAEL3iUAATOJLgQABIADKACABAQADiUAATUgLgiABQALACgLAgwAOAwKDS0OCA0tDgsFASgACYClAAQOOAkECCQCAAgAAQwiJQAA7DQNKAAEgL0ACCQCAAgAAQw3IwABDKgtDQYIKAIACwQBVAw4BAsMJAIADAABDFQlAAEziQAoAgILADgLBAwtDQwJJwILBB8MOAoLDCQCAAwAAQx5JQABM4kuBAAIgAMoAIAEBAAgJQABNSAuCIAFAAQAKAQCCwA4CwoMLQ4JDC0OBAYjAAEMqC0MCgMjAAEKoAA4CQQKDjgJCgskAgALAAEMyCUAAOw0DSgACoC9AAsBKAAEgGMADCQCAAsAAQzlIwABDVYtDQgLKAIADgQBVAw4Cg4PJAIADwABDQIlAAEziQAoAgIOADgOCg8tDQ8NJwIOBB8MOAQODyQCAA8AAQ0nJQABM4kuBAALgAMoAIAEBAAgJQABNSAuCIAFAAoAKAoCDgA4DgQPLQ4NDy0OCggjAAENVi0MDAQjAAELgy0NBwQnAgkEIAw4AwkKJAIACgABDXolAAEziQAoAQIJADgJAwotDQoIJwIKBB8MOAMKCyQCAAsAAQ2fJQABM4kuBAAEgAMoAIAEBAAgJQABNSAuCIAFAAkAKAkCCgA4CgMLLQ4ICwEoAAOAYwAELQ4JBy0MBAMjAAEJ/CUAAOkvLQgBBicCBwQOABABBwEnAwYEAQAoBgIHJwIIBA0AOAgHCC0MBwkMOAkIChYMCgokAgAKAAEOJi4KgJYACQAoCQIJIwABDgUtCAEHAAABAgEtDgYHLgiAZAAFIwABDj4NKAAFgIQAASQCAAEAAQ7LIwABDlMtDQcBJwIEBA0GKAQCAicCBgQDADgEBgUtCAEDABABBQEnAwMEAQAoAwIFLQ4EBQAoBQIFLQ4EBScCBgQDADgDBgUAKAECBi4EAAaAAy4EAAWABC4EAASABSUAAT1UACgDAgUtDQUEJwIGBAIAOAUGATcNAAEABCYnAgIEDQw4BQIDJAIAAwABDuIlAAEziQAoBAICADgCBQMtDQMBLQ0HAicCBgQNDDgFBggkAgAIAAEPCyUAATOJLgQAAoADKACABAQADiUAATUgLgiABQADACgDAgYAOAYFCC0OAQgtDgMHASgABYBjAAEtDAEFIwABDj4lAADpLy0IAQQnAgUEDAAQAQUBJwMEBAEAKAQCBScCBgQLADgGBQYtDAUHDDgHBggWDAgIJAIACAABD5IuCoCWAAcAKAcCByMAAQ9xLQgBBQAAAQIBLQ4EBS0IAQQnAgYEIAAQAQYBJwMEBAEAKAQCBicCBwQfADgHBgctDAYIDDgIBwkWDAkJJAIACQABD+YuCoBhAAgAKAgCCCMAAQ/FLQgBBgAAAQIBLQ4EBi0IAQQnAgcEIAAQAQcBJwMEBAEAKAQCBycCCAQfADgIBwgtDAcJDDgJCAoWDAoKJAIACgABEDouCoBhAAkAKAkCCSMAARAZLQgBBwAAAQIBLQ4EBy4IgGQAAyMAARBSDSgAA4ClAAQkAgAEAAETtSMAARBnLQ0GBAEoAAGApwAJLQ0JCC4EAASAAygAgAQEACAlAAE1IC4IgAUAAQAoAQIJASgACYBkAAotDggKLQ4BBi0IAQEnAgQEIAAQAQQBJwMBBAEAKAECBCcCCAQfADgIBAgtDAQJDDgJCAoWDAoKJAIACgABEOsuCoBhAAkAKAkCCSMAARDKLgiAZAADIwABEPYNKAADgJ4ABCQCAAQAARGsIwABEQstDQUBLQ0HAicCBAQHLQgABy0MAggAEAAEACUAAUpxLQQAAC0MCAMuBAABgAMoAIAEBAAMJQABNSAuCIAFAAIAKAICBAEoAASAZAAHLQ4DBy0NBgEnAgQEBi0IAAYtDAEHABAABAAlAAFKcS0EAAAtDAcDLgQAAoADKACABAQADCUAATUgLgiABQABACgBAgQBKAAEgJ4ABi0OAwYtDgEFJi0NAQgAKAgCCC0OCAEtCAEIAAABAgEtDgEIBTCApwADAAkuCIBkAAQjAAER2Q0oAASApQAKJAIACgABEwcjAAER7i0NBQQBKAADgGMACi0NCAsnAgwEDS0IAA0tDAsOABAADAAlAAFLMy0EAAAtDA4IJwIMBAsMOAoMDSQCAA0AARI0JQABM4kuBAAEgAMoAIAEBAAMJQABNSAuCIAFAAsAKAsCDAA4DAoNLQ4IDS0OCwUBKAAJgKUABA44CQQIJAIACAABEnglAADsNA0oAASAuAAIJAIACAABEo0jAAES/i0NBggoAgALBAERDDgECwwkAgAMAAESqiUAATOJACgCAgsAOAsEDC0NDAknAgsEHww4CgsMJAIADAABEs8lAAEziS4EAAiAAygAgAQEACAlAAE1IC4IgAUABAAoBAILADgLCgwtDgkMLQ4EBiMAARL+LQwKAyMAARD2ADgJBAoOOAkKCyQCAAsAARMeJQAA7DQNKAAKgLgACwEoAASAYwAMJAIACwABEzsjAAETrC0NCAsoAgAOBAERDDgKDg8kAgAPAAETWCUAATOJACgCAg4AOA4KDy0NDw0nAg4EHww4BA4PJAIADwABE30lAAEziS4EAAuAAygAgAQEACAlAAE1IC4IgAUACgAoCgIOADgOBA8tDg0PLQ4KCCMAAROsLQwMBCMAARHZLQ0HBCcCCQQgDDgDCQokAgAKAAET0CUAATOJACgBAgkAOAkDCi0NCggnAgoEHww4AwoLJAIACwABE/UlAAEziS4EAASAAygAgAQEACAlAAE1IC4IgAUACQAoCQIKADgKAwstDggLASgAA4BjAAQtDgkHLQwEAyMAARBSJQAA6S8tCAEGJwIHBAwAEAEHAScDBgQBACgGAgcnAggECwA4CAcILQwHCQw4CQgKFgwKCiQCAAoAARR8LgqAlgAJACgJAgkjAAEUWy0IAQcAAAECAS0OBgcuCIBkAAUjAAEUlA0oAAWAnwABJAIAAQABFSEjAAEUqS0NBwEnAgQECwYoBAICJwIGBAMAOAQGBS0IAQMAEAEFAScDAwQBACgDAgUtDgQFACgFAgUtDgQFJwIGBAMAOAMGBQAoAQIGLgQABoADLgQABYAELgQABIAFJQABPVQAKAMCBS0NBQQnAgYEAgA4BQYBNw0AAQAEJicCAgQLDDgFAgMkAgADAAEVOCUAATOJACgEAgIAOAIFAy0NAwEtDQcCJwIGBAsMOAUGCCQCAAgAARVhJQABM4kuBAACgAMoAIAEBAAMJQABNSAuCIAFAAMAKAMCBgA4BgUILQ4BCC0OAwcBKAAFgGMAAS0MAQUjAAEUlCUAAOkvLQgBBScCBgQhABABBgEnAwUEAQAoBQIGJwIHBCAAOAcGBy0MBggMOAgHCRYMCQkkAgAJAAEV6C4KgJYACAAoCAIIIwABFcctCAEGAAABAgEtDgUGLgiAZAAEIwABFgANKAAEgKcAAyQCAAMAARZ0IwABFhUtDQEDLQ0CBAEoAASApwAFDjgEBQckAgAHAAEWNyUAAOw0LQ4DAS0OBQItDQYBJwIDBAQtCAAELQwBBQAQAAMAJQABLWAtBAAALQwFAi0NAgEAKAECAS0OAQItDAIBJi0NBgMtDQEFLQ0CBwA4BwQIDjgHCAkkAgAJAAEWlyUAAOw0KAIACQQBbQw4CAkKJAIACgABFrAlAAEziQAoBQIJADgJCAotDQoHJwIIBCAMOAQICSQCAAkAARbVJQABM4kuBAADgAMoAIAEBAAhJQABNSAuCIAFAAUAKAUCCAA4CAQJLQ4HCS0OBQYBKAAEgGMAAy0MAwQjAAEWACUAAOkvLQgBBSgCAAYEAS4AEAEGAScDBQQBACgFAgYoAgAHBAEtADgHBgctDAYIDDgIBwkWDAkJJAIACQABF2AuCoCWAAgAKAgCCCMAARc/LQgBBgAAAQIBLQ4FBi4IgGQABCMAARd4DSgABICDAAMkAgADAAEX7CMAAReNLQ0BAy0NAgQBKAAEgIMABQ44BAUHJAIABwABF68lAADsNC0OAwEtDgUCLQ0GAScCAwQELQgABC0MAQUAEAADACUAASp5LQQAAC0MBQItDQIBACgBAgEtDgECLQwCASYtDQYDLQ0BBS0NAgcAOAcECA44BwgJJAIACQABGA8lAADsNCgCAAkEAW0MOAgJCiQCAAoAARgoJQABM4kAKAUCCQA4CQgKLQ0KBygCAAgEAS0MOAQICSQCAAkAARhPJQABM4kuBAADgAMoAIAEBAEuJQABNSAuCIAFAAUAKAUCCAA4CAQJLQ4HCS0OBQYBKAAEgGMAAy0MAwQjAAEXeCUAAOkvHAwCDgAAKAQCAi4EAAWAAygAgAQEAAElAAFI9y4IgAUADy4IgAYAEC0ODhAtDQ8EACgEAgQtDgQPFgwHBBwMBwUAHAwEBwAEOAUIBAUoAAeAkQAFADgEBQcWDAkEHAwJBQAcDAQIAAQ4BQoEBSgACICRAAUAOAQFCC0IAQQnAgUEAwAQAQUBJwMEBAEAKAQCBS0MBQktDgcJACgJAgktDggJACgEAgUAKA8CCS0NCQgnAgoEAgA4CQoHOfUABQABAAcACCACAAEhAgACLQgBBQAoBQIJLQ0JCCcCCgQCADgJCgciNIBkAAIABy0MAggnAgoEAwA4CAoJABABCQEnAwUEAQAoBQIKLQ4ICgAoCgIKLQ4ICi0MCAQGKAQCBC0NBQIAKAICAi0OAgUkAgABAAEZ4yMAARnHACgFAgMtDQMCJwIGBAIAOAMGATwNAQIjAAEZ4y0NBQEAKAECAS0OAQULKAAEgGQAASQCAAEAARoJJwICBAA8CQECJioBAAEFCZ3dU4eDB048AQECJioBAAEFuWR1XlTX4iM8AQECJioBAAEFdL61rWTHYow8AQECJiUAAOkvLQgBBCcCBQQCABABBQEnAwQEAQAoBAIFLQwFBi4KgJYABi0NBAUAKAUCBS0OBQQtCAEFJwIGBCEAEAEGAScDBQQBACgFAgYtDAYHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBwAoBwIHLQ4EBy0IAQQAAAECAS0OBQQLKAACgLkABS4IgGQAAyMAARvLDSgAA4CnAAYkAgAGAAEb5SMAARvgLQ0EASYtDQQHJwIJBCAMOAMJCiQCAAoAARwAJQABM4kAKAECCQA4CQMKLQ0KCBwMCAkALQgBCCcCCgQCABABCgEnAwgEAQAoCAIKLQwKCy0OCQskAgAFAAEcYiMAARxACygAAoC6AAkkAgAJAAEcWScCCgQAPAkBCi0MCAYjAAEciy0IAQgnAgoEAgAQAQoBJwMIBAEAKAgCCi0MCgstDgkLLQwIBiMAARyLJwIJBCAMOAMJCiQCAAoAARyiJQABM4kuBAAHgAMoAIAEBAAhJQABNSAuCIAFAAgAKAgCCQA4CQMKLQ4GCgEoAAOAYwAGLQ4IBC0MBgMjAAEbyyUAAOkvLQgBBScCBgQOABABBgEnAwUEAQAoBQIGJwIHBA0AOAcGBy0MBggMOAgHCRYMCQkkAgAJAAEdKS4KgJYACAAoCAIIIwABHQgtCAEGAAABAgEtDgUGLQgBBScCBwQgABABBwEnAwUEAQAoBQIHJwIIBB8AOAgHCC0MBwkMOAkIChYMCgokAgAKAAEdfS4KgGEACQAoCQIJIwABHVwtCAEHAAABAgEtDgUHLQgBBScCCAQgABABCAEnAwUEAQAoBQIIJwIJBB8AOAkICS0MCAoMOAoJCxYMCwskAgALAAEd0S4KgGEACgAoCgIKIwABHbAtCAEIAAABAgEtDgUILQgBBScCCQQgABABCQEnAwUEAQAoBQIJJwIKBB8AOAoJCi0MCQsMOAsKDBYMDAwkAgAMAAEeJS4KgGEACwAoCwILIwABHgQtCAEJAAABAgEtDgUJLgiAZAAEIwABHj0NKAAEgKUABSQCAAUAASIlIwABHlItDQcFASgAAYCnAAstDQsKLgQABYADKACABAQAICUAATUgLgiABQABACgBAgsBKAALgGQADC0OCgwBKAADgKcACi0NCgUuBAABgAMoAIAEBAAgJQABNSAuCIAFAAMAKAMCCgEoAAqAngALLQ4FCy0OAwctCAEBJwIDBCAAEAEDAScDAQQBACgBAgMnAgUEHwA4BQMFLQwDCgw4CgULFgwLCyQCAAsAAR8LLgqAYQAKACgKAgojAAEe6i4IgGQABCMAAR8WDSgABICeAAMkAgADAAEgHCMAAR8rLQ0GAS0NCAInAgQECi0IAAotDAILABAABAAlAAFKcS0EAAAtDAsDLgQAAYADKACABAQADiUAATUgLgiABQACACgCAgQBKAAEgGQABS0OAwUtDQkBJwIEBAgtCAAILQwBCQAQAAQAJQABSnEtBAAALQwJAy4EAAKAAygAgAQEAA4lAAE1IC4IgAUAAQAoAQIEASgABICfAAUtDgMFLQ0HAicCBAQHLQgABy0MAggAEAAEACUAAUpxLQQAAC0MCAMuBAABgAMoAIAEBAAOJQABNSAuCIAFAAIAKAICBAEoAASAoAAFLQ4DBS0OAgYtDAIBJi0NAQUAKAUCBS0OBQEtCAEFAAABAgEtDgEFBTCApwAEAAouCIBkAAMjAAEgSQ0oAAOApQALJAIACwABIXcjAAEgXi0NBgMBKAAEgGMACy0NBQwnAg0EDi0IAA4tDAwPABAADQAlAAFLMy0EAAAtDA8FJwINBA0MOAsNDiQCAA4AASCkJQABM4kuBAADgAMoAIAEBAAOJQABNSAuCIAFAAwAKAwCDQA4DQsOLQ4FDi0ODAYNKAAEgJ0AAyQCAAMAASDjIwABIW4tDQcDASgACoClAAUOOAoFDCQCAAwAASEBJQAA7DQoAgAMBAEtDDgFDA0kAgANAAEhGiUAATOJACgCAgwAOAwFDS0NDQonAgwEHww4CwwNJAIADQABIT8lAAEziS4EAAOAAygAgAQEACAlAAE1IC4IgAUABQAoBQIMADgMCw0tDgoNLQ4FByMAASFuLQwLBCMAAR8WADgKAwsOOAoLDCQCAAwAASGOJQAA7DQNKAALgIMADAEoAAOAYwANJAIADAABIasjAAEiHC0NBQwoAgAPBAEtDDgLDxAkAgAQAAEhyCUAATOJACgCAg8AOA8LEC0NEA4nAg8EHww4Aw8QJAIAEAABIe0lAAEziS4EAAyAAygAgAQEACAlAAE1IC4IgAUACwAoCwIPADgPAxAtDg4QLQ4LBSMAASIcLQwNAyMAASBJLQ0IBScCCwQgDDgECwwkAgAMAAEiQCUAATOJACgBAgsAOAsEDC0NDAonAgwEHww4BAwNJAIADQABImUlAAEziS4EAAWAAygAgAQEACAlAAE1IC4IgAUACwAoCwIMADgMBA0tDgoNASgABIBjAAUtDgsILQ0JCicCDAQgDDgEDA0kAgANAAEisiUAATOJACgDAgwAOAwEDS0NDQsnAg0EHww4BA0OJAIADgABItclAAEziS4EAAqAAygAgAQEACAlAAE1IC4IgAUADAAoDAINADgNBA4tDgsOLQ4MCS0MBQQjAAEePSoBAAEFRbw5K215C9w8AQECJioBAAEFlpt5AKcLW348AQECJiUAAOkvLQgBCCcCCQQDABABCQEnAwgEAQAoCAIJLQwJCi0OBAoAKAoCCi0OBgonAgsEDC0IAAwuCIC+AA0AEAALACUAAOm/LQQAAC0MDQQtDA4GLQwPCS0MEAotDQQLACgLAgstDgsELQgBCwAAAQIBLQ4ECy0NBgQAKAQCBC0OBAYtCAEEAAABAgEtDgYELQgBBgAAAQIBLQ4JBi0IAQkAAAECAS0OCgkuCIBkAAcjAAEj4g0oAAeAZQAKJAIACgABJXojAAEj9ycCDgQPLQgADy0MCxAtDAQRLQwGEi0MCRMAEAAOACUAAOpfLQQAAC0MEA0LKAAFgKgABAsoAA2AlgAGJAIABAABJT8jAAEkPwsoAAWAqQAEJAIABAABJRUjAAEkVAsoAAWAqgAEJAIABAABJOsjAAEkaQsoAAWAqwAEJAIABAABJMEjAAEkfgsoAAWArAAEJAIABAABJJcnAgkEADwJAQkLKAAGgJUABCQCAAQAASSsJQAA9cEtDAEHLQwCCC0MAwotDA0MIwABJWkLKAAGgJUABCQCAAQAASTWJQAA9cEtDAEHLQwCCC0MAwotDA0MIwABJWkLKAAGgJUABCQCAAQAASUAJQAA9cEtDAEHLQwCCC0MAwotDA0MIwABJWkLKAAGgJUABCQCAAQAASUqJQAA9cEtDAEHLQwCCC0MAwotDA0MIwABJWkLKAAGgJUABCQCAAQAASVUJQAA9cEtDAEHLQwCCC0MAwotDA0MIwABJWktDAoDLQwHAS0MCAItDAwEJiQCAAoAASWHIwABJdwnAgwEAgw4BwwNJAIADQABJZ4lAAEziQAoCAIMADgMBw0tDQ0KJwIMBA0tCAANLQwLDi0MBA8tDAYQLQwJES0MChIAEAAMACUAAOsJLQQAACMAASXcASgAB4BjAAotDAoHIwABI+IlAADpLy0IAQQoAgAFBAFOABABBQEnAwQEAQAoBAIFKAIABgQBTQA4BgUGLQwFBww4BwYIFgwICCQCAAgAASY9LgqAYQAHACgHAgcjAAEmHC0IAQUAAAECAS0OBAUuCIBkAAMjAAEmVQ0oAAOAgwAEJAIABAABJxQjAAEmai4IgGQAASMAASZ1DSgAAYCnAAMkAgADAAEmjyMAASaKLQ0FASYtDQUDASgAAYCDAAQnAgcEIAw4AQcIJAIACAABJrIlAAEziQAoAgIHADgHAQgtDQgGKAIACAQBTQw4BAgJJAIACQABJtklAAEziS4EAAOAAygAgAQEAU4lAAE1IC4IgAUABwAoBwIIADgIBAktDgYJLQ4HBQEoAAGAYwADLQwDASMAASZ1LQ0FBCgCAAcEAS0MOAMHCCQCAAgAAScxJQABM4kAKAECBwA4BwMILQ0IBigCAAgEAU0MOAMICSQCAAkAASdYJQABM4kuBAAEgAMoAIAEBAFOJQABNSAuCIAFAAcAKAcCCAA4CAMJLQ4GCQEoAAOAYwAELQ4HBS0MBAMjAAEmVSUAAOkvJwIDBAQtCAAELQwBBS4IgLwABgAQAAMAJQABRR8tBAAALQwFAi0NAgEAKAECAS0OAQInAgMEBC0IAAQtDAIFABAAAwAlAAE7+C0EAAAtDAUBJiUAAOkvLQgBBScCBgQhABABBgEnAwUEAQAoBQIGJwIHBCAAOAcGBy0MBggMOAgHCRYMCQkkAgAJAAEoNi4KgJYACAAoCAIIIwABKBUtCAEGAAABAgEtDgUGLgiAZAAEIwABKE4NKAAEgKcAAyQCAAMAASjCIwABKGMtDQEDLQ0CBAEoAASApwAFDjgEBQckAgAHAAEohSUAAOw0LQ4DAS0OBQItDQYBJwIDBAQtCAAELQwBBQAQAAMAJQABLWAtBAAALQwFAi0NAgEAKAECAS0OAQItDAIBJi0NBgMtDQEFLQ0CBwA4BwQIDjgHCAkkAgAJAAEo5SUAAOw0JwIJBCAMOAgJCiQCAAoAASj8JQABM4kAKAUCCQA4CQgKLQ0KBycCCAQgDDgECAkkAgAJAAEpISUAATOJLgQAA4ADKACABAQAISUAATUgLgiABQAFACgFAggAOAgECS0OBwktDgUGASgABIBjAAMtDAMEIwABKE4qAQABBVOD5qAlqJQJPAEBAiYlAADpLy8MAAQABRwMBQYEHAwGBAAcDAQFBC0MBQEmKgEAAQVGEStkVIxwMTwBAQImJQAA6S8tDQEFLQ0CBigCAAgEAS8MOAYICSQCAAkAASnFJQABM4kAKAUCCAA4CAYJLQ0JBy0IAQgnAgkEAgAQAQkBJwMIBAEAKAgCCS0MCQotDgcKASgABoBjAAkOOAYJCiQCAAoAASoNJQAA7DQtDgUBLQ4JAgsoAAOAmgABJAIAAQABKkwjAAEqKgsoAAOApAABJAIAAQABKkMnAgIEADwJAQItDAcEIwABKnQnAgIECS0IAAktDAgKABAAAgAlAADpWC0EAAAtDAoBLQwBBCMAASp0LQwEASYlAADpLy0NAQMAKAMCAy0OAwEtCAEDAAABAgEtDgEDLQgBAQAAAQIBLgqAZAABLQgBBCgCAAUEAS4AEAEFAScDBAQBACgEAgUoAgAGBAEtADgGBQYtDAUHDDgHBggWDAgIJAIACAABKvIuCoBhAAcAKAcCByMAASrRLQ0EBQAoBQIFLQ4FBC0IAQUAAAECAS0OBAUuCIBkAAIjAAErFw0oAAKAgwAEJAIABAABKzEjAAErLC0NBQEmLQ0FBC0NAwYtDQEHKAIACQQBLQw4BwkKJAIACgABK1YlAAEziQAoBgIJADgJBwotDQoILQgBCScCCgQCABABCgEnAwkEAQAoCQIKLQwKCy0OCAsBKAAHgGMACA44BwgKJAIACgABK54lAADsNC0OBgMtDggBJwIHBAotCAAKLQwJCwAQAAcAJQABS/UtBAAALQwLBigCAAgEAS0MOAIICSQCAAkAASveJQABM4kuBAAEgAMoAIAEBAEuJQABNSAuCIAFAAcAKAcCCAA4CAIJLQ4GCS0OBwUBKAACgGMABC0MBAIjAAErFyoBAAEFmfe+l11Ms4o8AQECJiUAAOkvJwIGBActCAAHLQwBCC0MAgkAEAAGACUAASzDLQQAAC0MCAULKAADgJoAASQCAAEAASyWIwABLGgLKAADgKQAASQCAAEAASyBJwICBAA8CQECASgABYBjAAItDQIBLQwBBCMAASy+JwICBAYtCAAGLQwFBwAQAAIAJQAA6VgtBAAALQwHAS0MAQQjAAEsvi0MBAEmJQAA6S8tDQEDLQ0CBCcCBgQCDDgEBgckAgAHAAEs5yUAATOJACgDAgYAOAYEBy0NBwUtCAEGJwIHBAIAEAEHAScDBgQBACgGAgctDAcILQ4FCAEoAASAYwAFDjgEBQckAgAHAAEtLyUAAOw0LQ4DAS0OBQItDAYBJioBAAEFpsrxDiNA/Kw8AQECJioBAAEFlwqFBOycP3U8AQECJiUAAOkvLQ0BAwAoAwIDLQ4DAS0IAQMAAAECAS0OAQMtCAEBAAABAgEuCoBkAAEtCAEEJwIFBCEAEAEFAScDBAQBACgEAgUnAgYEIAA4BgUGLQwFBww4BwYIFgwICCQCAAgAAS3VLgqAYQAHACgHAgcjAAEttC0NBAUAKAUCBS0OBQQtCAEFAAABAgEtDgQFLgiAZAACIwABLfoNKAACgKcABCQCAAQAAS4UIwABLg8tDQUBJi0NBQQtDQMGLQ0BBycCCQQgDDgHCQokAgAKAAEuNyUAATOJACgGAgkAOAkHCi0NCggtCAEJJwIKBAIAEAEKAScDCQQBACgJAgotDAoLLQ4ICwEoAAeAYwAIDjgHCAokAgAKAAEufyUAAOw0LQ4GAy0OCAEnAgcECi0IAAotDAkLABAABwAlAAFL9S0EAAAtDAsGJwIIBCAMOAIICSQCAAkAAS69JQABM4kuBAAEgAMoAIAEBAAhJQABNSAuCIAFAAcAKAcCCAA4CAIJLQ4GCS0OBwUBKAACgGMABC0MBAIjAAEt+ioBAAEFyhpVPEAU1Xw8AQECJioBAAEFA4ujEK5zO0o8AQECJioBAAEFusjZyhWUm0s8AQECJiUAAOkvLQgBBScCBgQhABABBgEnAwUEAQAoBQIGJwIHBCAAOAcGBy0MBggMOAgHCRYMCQkkAgAJAAEvei4KgJYACAAoCAIIIwABL1ktCAEGAAABAgEtDgUGLgiAZAAEIwABL5INKAAEgKcAAyQCAAMAATAGIwABL6ctDQEDLQ0CBAEoAASApwAFDjgEBQckAgAHAAEvySUAAOw0LQ4DAS0OBQItDQYBJwIDBAQtCAAELQwBBQAQAAMAJQABLWAtBAAALQwFAi0NAgEAKAECAS0OAQItDAIBJi0NBgMtDQEFLQ0CBwA4BwQIDjgHCAkkAgAJAAEwKSUAAOw0JwIJBEEMOAgJCiQCAAoAATBAJQABM4kAKAUCCQA4CQgKLQ0KBycCCAQgDDgECAkkAgAJAAEwZSUAATOJLgQAA4ADKACABAQAISUAATUgLgiABQAFACgFAggAOAgECS0OBwktDgUGASgABIBjAAMtDAMEIwABL5IqAQABBbyq4IELKoi2PAEBAiYlAADpLy0IAQUnAgYEEQAQAQYBJwMFBAEAKAUCBicCBwQQADgHBgctDAYIDDgIBwkWDAkJJAIACQABMP4uCoBkAAgAKAgCCCMAATDdLQgBBgAAAQIBLQ4FBgw4AgMFJAIABQABMX0jAAExHQEoAAOAjgAHDjgDBwgkAgAIAAExNyUAAOw0DDgCBwgkAgAIAAExVCMAATFJLgiAjgAFIwABMXQCOAIDBw44AwIIJAIACAABMWslAAFCIi0MBwUjAAExdC0MBQQjAAExiC4IgGQABCMAATGIBygABICPAAItCAEFAAABAgEtDgIFJwIIBAQGOAQICQQ4CQgKAjgECgcLKAAHgGQACCQCAAgAATHpIwABMcYBKAACgGMABw44AgcIJAIACAABMeAlAADsNC0OBwUjAAEx6S0NBQcuCIBkAAIjAAEx+Aw4AgcFJAIABQABMhMjAAEyCi0NBgEtDAQCJi0IAQgAAAECAS4KgGQACC4IgGQABSMAATItDSgABYCPAAkkAgAJAAEynCMAATJCLQ0GBS0NCAknAgoEEAw4AgoLJAIACwABMmElAAEziS4EAAWAAygAgAQEABElAAE1IC4IgAUACAAoCAIKADgKAgstDgkLASgAAoBjAAUtDggGLQwFAiMAATH4BSgAAoCPAAonAgwEAAsoAAyAjwALJAIACwABMtMHKAAKgI8ADgo4DgINJAIADQABMtMlAAFCNAA4CgULDjgKCwwkAgAMAAEy6iUAAOw0DDgLBAokAgAKAAEzByMAATL8LgiAYQAJIwABM0wAOAMLCg44AwoMJAIADAABMx4lAADsNCcCDARgDDgKDA0kAgANAAEzNSUAATOJACgBAgwAOAwKDS0NDQstDAsJIwABM0wtDQgKGSgACoCbAAscDAkKBAA4CwoJDjgLCQwkAgAMAAEzdCUAAOw0LQ4JCAEoAAWAYwAJLQwJBSMAATItKgEAAQXonQn+oREtDjwBAQImJQAA6S8nAgYEBAY4AgYHBDgHBggCOAIIBQMwgI8ABQACDygABYCPAAYkAgAGAAEz0SUAAUIiHAwCBwIcDAcGBBwMBgICBTCAmwACAAYnAggCAAo4CAIHJAIABwABNBQGOAYCCgsoAAqAmwAJJAIACQABNBQlAAFCNBo4AQYHDSgAAoCZAAEkAgABAAE0OSMAATQuLgiAZAAEIwABNFwYOAcGAQ0oAAaApgACJAIAAgABNFMlAAFI0y0MAQQjAAE0XBwMAwIEAzCAZwAFAAMPKAAFgGcABiQCAAYAATR+JQABQiIcDAMGAhwMBgUEHAwFAwINKAADgJkABSQCAAUAATStIwABNKIuCIBkAAEjAAE1BAUwgJsAAwAFJwIHAgAKOAcDBiQCAAYAATThBjgFAwkLKAAJgJsACCQCAAgAATThJQABQjQYOAIFAw0oAAWApgACJAIAAgABNPslAAFI0y0MAwEjAAE1BAA4BAECDjgEAgMkAgADAAE1GyUAAOw0LQwCASYuAYADgAYLAIAGAAKAByQAgAcAATU7IwABNUYuAIADgAUjAAE1rS4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAATWZLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAATVoKAGABQQAAQMAgAYAAoAGIwABNa0mJQAA6S8tDQEEACgEAgQtDgQBLQgBBAAAAQIBLQ4BBC0IAQUAAAECAS0OAgUnAgcEBAY4AgcIBDgIBwkCOAIJBgsoAAaAZAAHJAIABwABNzkjAAE2AwcoAAKAjwAIAzCAjwAGAAkPKAAGgI8ACiQCAAoAATYoJQABQiInAgoEEAw4CAoLJAIACwABNj8lAAEziQAoAQIKADgKCAstDQsGHAwJCwIcDAsKBBwMCgsCBTCAmwALAAonAg0CAAo4DQsMJAIADAABNpAGOAoLDwsoAA+AmwAOJAIADgABNpAlAAFCNBo4BgoMDSgAC4CZAAYkAgAGAAE2tSMAATaqLgiAZAAHIwABNtgYOAwKBg0oAAqApgALJAIACwABNs8lAAFI0y0MBgcjAAE22CcCCgQQDDgICgskAgALAAE27yUAATOJLgQAAYADKACABAQAESUAATUgLgiABQAGACgGAgoAOAoICy0OBwstDgYEADgCCQEOOAIBBiQCAAYAATcwJQAA7DQtDgEFIwABNzktDQUCBygAAoCPAAUtDAUBIwABN04NKAABgJMAAiQCAAIAATmpIwABN2MFMICcAAMAAicCBgQACjgGAwUkAgAFAAE3lwY4AgMICygACICcAAckAgAHAAE3lyUAAUI0HAwCAwAnAgUBAC0IAQInAgYECQAQAQYBJwMCBAEAKAICBicCBwQIQwOwAAOAlAAHAAUABi4IgGQAASMAATfWDSgAAYBlAAMkAgADAAE38CMAATfrLQ0EASYFKAABgI8AAy0NBAUBMICTAAEABicCCAQIDDgDCAkkAgAJAAE4GyUAATOJACgCAggAOAgDCS0NCQcBKAADgGMACA44AwgJJAIACQABOEMlAADsNCcCCgQIDDgICgskAgALAAE4WiUAATOJACgCAgoAOAoICy0NCwkBKAADgGUACA44AwgKJAIACgABOIIlAADsNCcCCwQIDDgICwwkAgAMAAE4mSUAATOJACgCAgsAOAsIDC0NDAoBKAADgGcACA44AwgLJAIACwABOMElAADsNCcCCwQIDDgICwwkAgAMAAE42CUAATOJACgCAgsAOAsIDC0N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",
      "debug_symbols": "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",
      "brillig_names": ["public_dispatch"]
    },
    {
      "name": "claim_private",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15663063161611103517": {
            "error_kind": "string",
            "string": "Invalid secret"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_notes",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAAES36m5K+\nPhy60YelKz9dgwmWA2TD4mRpu8jznugjpYgS7raFvCn7fZaLjVWL0vSDQ7KxKwgB/qqYjZCZsNYQ\nERxPC4fmTYnnby7eHFyXcth408F6+BtMHlgaAgiP+JYKEBVyMUz1ShM1Pk+D1H31230BZPX4CjJK\nagDXBEZoXvIbq02SrAxh4/LoarYVbzrxsDQBrxEa3eplI2fVav4DpSRhYf01azpMu9MF+LkxYoSE\naIiQzW7+QPKCSqNv5iv1Jc4Y88o+hQH85S8c1eTtnUd4VWYpqJPY3DcV9PYh6IIXS6X2K8ukjus6\nXbwuaUwmvtcvOl49yictDwBSjvCIkA3902HVvsbx3rpfNYQr/PJmApKG2vBOcq4D+EjEUZcZGX5s\nmA6T4zWmpyIIB9+NliqeYshHyjk8cnaotzcBI98Vbhd+af9n63FqQuLeN5ozgIiReV53blWpzYX8\nAWhdwykxDPVlWIKZyr+HWTJPV0tzKJO+S85iAFWM3Wtd/HpIBFa7cBtbC0Y7vPDE/nGQVSOT0JUz\n4bIAS9hOn4pTqI8DgPTmuzBHdr/U+yLiCYd0FWSB6aP48JHTDbEAOm2qtBeLX7pkty84W07XnANO\nffS98tL2pzWC4p73hAiC46JREAhmzOvN0rd8TPt/+R2+rZKv2lChktlaXccxjKozEaso4On2noWS\n555QFYY1H/wH2ThPP2xOQpWmZGVLQtHyvSDPWXb8/e0cC6lg7T+SmzD8vjdJ45UbjtJlg5b+DC/U\nFVDY7FUJeTw+GunLkan5I7iyT/czRqmxN9ekGmWzfsAc3m7s5Zf3DyktkY/GITdtg2nKuKa4XZ5J\nTiS8n8nRIwCmHerHazcMpPQvc6Zly3Wp69xYzUvfivfn/P+jbVtxLll4nw2duz8VreU4S3hJDbHY\nM3nHO+QRI96/yIyfyNYrcq3BN0OMoNM3FEWlepaQ5kT1hLr6RUEkzwGtW+CxOQEZ4kHuu+v/XH1/\nINxsWtG2r3jcIG1/d4U/Bf3n69NyIgWbBOk3VT2AJgYIwVfvFo3lCtDx8baLcvbynCJ7pEsVvfAX\nIZDZRmU6h64y8P9JhBmCUyRtjF9vpdo2C4GbrCKtyu4S565qbJItZupNEaupVBPGe0DfG5877Vz0\n8xYlLdGyTGFfzDj/+X1bhiLPk6y6xhiwt1bRiYDlXEfRFToEWJtfQDxCeADJqRwDqc0zSeCE1pf3\nQdEtCjI32pPCPxMJPAH0rU8cyvHQDNAVta+Iv9Fz2E1KJf1fCsFOjnYxHuDlbEX8w9zyDUfnjkO/\n1m7KQ13eVFsiATmtgr9vzZsVbq+RJyyRqjPRqShMQq35ResBALnlfIxVlHLdxhH8MAlofJLeGztw\njzWRsVDyMEpFGw7q1Daw8SSZZYMQvBDGJ/KLII04jt+f8S/zh4N6UYZo0RwjKReep261PlUZrCov\n3GfJvMIG8IdUo9l+cwaPQvXIFahbjV9QumeWSvbqwCN3ilHIuw9Aiq+TX13XMQ20QVbJo/D/Qct4\nfVzaJTG5DLww3GUpNsN0u7Jjqq3JKEuQhqUkslIZJaJYv3Rt6WcNJ0U4l5jYes7MId5Dm3nM4RYk\nsJDV+PmV+Ndu2nq2TQ3BjRpIHLxZ4JepnfaQPdk4qSQbsczdHkPokWChiLhMLlwV5rhArMQwiUC/\nQRtCODB5d17NwFovQoOeCgQbHuwvXEVWzHSLcxgVH6DCLe+IzcwKJR/ys2uwIr/Q/Lt6ZhAzecR0\n2nhzbvCgS+Ybh8EqxhFGvUJDFZ8n8NejEWEzB5ZI2fRsZYnzVvsrN6JgZOSRLIi+t3pkFnBN4dk8\nlmIqk/942vP7Ckb6/0cKSEXbZ3P8LCfOKbDXiO5VioStfhAoqtx1Nsj14OtC+xqxo1GsW0GdqFah\nvIm0lDIYUvfLAHYXaAmc4dFUb8HF2T8KO2o9Ml9fz2XeBm/nwG55ldcBazN1btkZIJ9Nb1xpPOIS\nQctqyc8U7pzyCvnJ83Em6gMIU1PxSp2rBzzBk7mLR7GQkPwwLqaUFvfU+HMKjogaLESUKWtigfab\nefMtYKTgpFbKL/hvYxhz/mw3BiBl7EAtm+c5KAbUenket2ewpJYNTV7J9tYNWNz+Y4AqqMsQoA6e\nfOievCZP3GlpR5CVadLo3HzKsWxO4cFJtAqHGXu8IO1CrgTw2toWiVQkdyQBK/11f+E0D/PzBUjh\nc8VPLg0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAACI3MvVfsLGPShpqpwQs1tLapUsGXRc2mQkzlgzOuHtsUjEM/lD/uh91RSbP2b\n/3gtKT3J8CRgvGGaxi5o+ljhsADENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04s\nAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJ\niS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "open",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order",
            "type": {
              "fields": [
                {
                  "name": "fill_deadline",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                },
                {
                  "name": "order_data_type",
                  "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                },
                {
                  "name": "order_data",
                  "type": {
                    "kind": "array",
                    "length": 301,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                }
              ],
              "kind": "struct",
              "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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LQ4LES0NCgsAKAsCCy0OCwoBKAAKgH8BAC4NAQAACx0MAAsBAAAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKAB4BAS4NAQEACx0MAAsBAQAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKACQBAi4NAQIACx0MAAsBAgAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKACYBAy4NAQMACx0MAAsBAwAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKACgBBC4NAQQACx0MAAsBBAAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKACoBBS4NAQUACx0MAAsBBQAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBKAAKgHQBBi4NAQYACx0MAAsBBgAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKACwBBy4NAQcACx0MAAsBBwAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBKAAKgHMBCC4NAQgACx0MAAsBCAAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKAC8BCS4NAQkACx0MAAsBCQAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKADIBCi4NAQoACx0MAAsBCgAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKADQBCy4NAQsACx0MAAsBCwAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKADYBDC4NAQwACx0MAAsBDAAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKADgBDS4NAQ0ACx0MAAsBDQAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKADoBDi4NAQ4ACx0MAAsBDgAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKADwBDy4NAQ8ACx0MAAsBDwAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKAD4BEC4NARAACx0MAAsBEAAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKAEABES4NAREACx0MAAsBEQAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKAEIBEi4NARIACx0MAAsBEgAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKAEQBEy4NARMACx0MAAsBEwAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKAEYBFC4NARQACx0MAAsBFAAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBOAAKAEgBFS4NARUACx0MAAsBFQAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBKAAKgIEBFi4NARYACx0MAAsBFgAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBKAAKgIIBFy4NARcACx0MAAsBFwAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBKAAKgIQBGC4NARgACx0MAAsBGAAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBKAAcgGMBGS4NARkACx0MAAsBGQAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBKAAcgHwBGi4NARoACx0MAAsBGgAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBKAAcgHYBGy4NARsACx0MAAsBGwAtDQ0LACgLAgstDgsNLQ0RCwAoCwILLQ4LES0NCgsAKAsCCy0OCwoBKAAcgHAACy0NCwocDAoLAC0NGQoAKAoCCi0OChkBKAAZgGMADS0NDQocDAoNAC0NGQoAKAoCCi0OChkBKAAZgHwAES0NEQocDAoRAC0NGQoAKAoCCi0OChkBKAAZgHYAHC0NHAoc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ngQAegE4AAMBngGgLg0BoAGfHQwBnwGeAC4NABkBnwEoAZ8AAgGfLg4BnwAZKAIBnwQAewE4AAMBnwGhLg0BoQGgHQwBoAGfAC4NABkBoAEoAaAAAgGgLg4BoAAZKAIBoAQAfAE4AAMBoAGiLg0BogGhHQwBoQGgAC4NABkBoQEoAaEAAgGhLg4BoQAZKAIBoQQAfQE4AAMBoQGjLg0BowGiHQwBogGhAC4NABkBogEoAaIAAgGiLg4BogAZKAIBogQAfgE4AAMBogGkLg0BpAGjHQwBowGiAC4NABkBowEoAaMAAgGjLg4BowAZKAIBowQAfwE4AAMBowGlLg0BpQGkHQwBpAGjAC4NABkBpAEoAaQAAgGkLg4BpAAZATgAAwAOAaUuDQGlAaQdDAGkAA4ALg0AGQGkASgBpAACAaQuDgGkABkoAgGkBACBATgAAwGkAaYuDQGmAaUdDAGlAaQALg0AGQGlASgBpQACAaUuDgGlABkoAgGlBACCATgAAwGlAacuDQGnAaYdDAGmAaUALg0AGQGmASgBpgACAaYuDgGmABkoAgGmBACDATgAAwGmAaguDQGoAacdDAGnAaYALg0AGQGnASgBpwACAacuDgGnABkoAgGnBACEATgAAwGnAakuDQGpAagdDAGoAacALg0AGQGoASgBqAACAaguDgGoABkoAgGoBACFATgAAwGoAaouDQGqAakdDAGpAagALg0AGQGpASgBqQACAakuDgGpABkoAgGpBACGATgAAwGpAasuDQGrAaodDAGqAakALg0AGQGqASgBqgACAaouDgGqABkoAgGqBACHATgAAwGqAawuDQGsAasdDAGrAaoALg0AGQGrASgBqwACAasuDgGrABkoAgGrBACIATgAAwGrAa0uDQGtAawdDAGsAasALg0AGQGsASgBrAACAawuDgGsABkoAgGsBACJATgAAwGsAa4uDQGuAa0dDAGtAawALg0AGQGtASgBrQACAa0uDgGtABkoAgGtBACKATgAAwGtAa8uDQGvAa4dDAGuAa0ALg0AGQGuASgBrgACAa4uDgGuABkoAgGuBACLATgAAwGuAbAuDQGwAa8dDAGvAa4ALg0AGQGvASgBrwACAa8uDgGvABkoAgGvBACMATgAAwGvAbEuDQGxAbAdDAGwAa8ALg0AGQGwASgBsAACAbAuDgGw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AAICSy4OAE8CSwEoAksAAgJLLg4AUAJLASgCSwACAksuDgAfAksBKAJLAAICSy4OAFECSwEoAksAAgJLLg4AUgJLASgCSwACAksuDgBTAksBKAJLAAICSy4OACACSwEoAksAAgJLLg4AVAJLASgCSwACAksuDgBVAksBKAJLAAICSy4OAFYCSwEoAksAAgJLLg4ACAJLASgCSwACAksuDgBXAksBKAJLAAICSy4OAFgCSwEoAksAAgJLLg4AWQJLASgCSwACAksuDgBaAksBKAJLAAICSy4OAFsCSwEoAksAAgJLLg4AXAJLASgCSwACAksuDgBdAksBKAJLAAICSy4OAF4CSwEoAksAAgJLLg4AXwJLASgCSwACAksuDgBgAksBKAJLAAICSy4OAGECSwEoAksAAgJLLg4AYgJLASgCSwACAksuDgBjAksBKAJLAAICSy4OAGQCSwEoAksAAgJLLg4AZQJLASgCSwACAksuDgBmAksBKAJLAAICSy4OAGcCSwEoAksAAgJLLg4AaAJLASgCSwACAksuDgBpAksBKAJLAAICSy4OAGoCSwEoAksAAgJLLg4AawJLASgCSwACAksuDgBsAksBKAJLAAICSy4OAG0CSwEoAksAAgJLLg4AbgJLASgCSwACAksuDgBvAksBKAJLAAICSy4OAHACSwEoAksAAgJLLg4AcQJLASgCSwACAksuDgByAksBKAJLAAICSy4OAHMCSwEoAksAAgJLLg4AdAJLASgCSwACAksuDgB1AksBKAJLAAICSy4OAHYCSwEoAksAAgJLLg4AeAJLASgCSwACAksuDgB5AksBKAJLAAICSy4OAHoCSwEoAksAAgJLLg4AewJLASgCSwACAksuDgB8AksBKAJLAAICSy4OAH0CSwEoAksAAgJLLg4AfgJLASgCSwACAksuDgB/AksBKAJLAAICSy4OAIACSwEoAksAAgJLLg4AgQJLASgCSwACAksuDgCCAksBKAJLAAICSy4OAIMCSwEoAksAAgJLLg4AhAJLASgCSwACAksuDgCFAksBKAJLAAICSy4OAIYCSwEoAksAAgJLLg4AhwJLASgCSwACAksuDgCIAksBKAJLAAICSy4OAIkCSwEoAksAAgJLLg4AigJLASgCSwACAksuDgCLAksBKAJLAAICSy4OAIwCSwEoAksAAgJLLg4AjQJLASgCSwACAksuDgCOAksBKAJLAAICSy4OAI8CSwEoAksAAgJLLg4AkAJLASgCSwACAksuDgCRAksBKAJLAAICSy4OAJICSwEoAksAAgJLLg4AkwJLASgCSwACAksuDgCUAksBKAJLAAICSy4OAJUCSwEoAksAAgJLLg4AlgJLASgCSwACAksuDgCXAksBKAJLAAICSy4OAJgCSwEoAksAAgJLLg4AmQJLASgCSwACAksuDgCaAksBKAJLAAICSy4OAJsCSwEoAksAAgJLLg4AnAJLASgCSwACAksuDgCdAksBKAJLAAICSy4OAJ4CSwEoAksAAgJLLg4AnwJLASgCSwACAksuDgCgAksBKAJLAAICSy4OAKECSwEoAksAAgJLLg4AogJLASgCSwACAksuDgCjAksBKAJLAAICSy4OAKQCSwEoAksAAgJLLg4ApQJLASgCSwACAksuDgCmAksBKAJLAAICSy4OAKcCSwEoAksAAgJLLg4AqAJLASgCSwACAksuDgCpAksBKAJLAAICSy4OAKoCSwEoAksAAgJLLg4AqwJLASgCSwACAksuDgCsAksBKAJLAAICSy4OAK0CSwEoAksAAgJLLg4ArgJLASgCSwACAksuDgCvAksBKAJLAAICSy4OALACSwEoAksAAgJLLg4AsQJLASgCSwACAksuDgCyAksBKAJLAAICSy4OALMCSwEoAksAAgJLLg4AtAJLASgCSwACAksuDgC1AksBKAJLAAICSy4OALYCSwEoAksAAgJLLg4AtwJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLg4AuAJLASgCSwACAksuDgC5AksBKAJLAAICSy4OALoCSwEoAksAAgJLLg4ADwJLASgCSwACAksuDgAYAksBKAJLAAICSy4OAHcCSwEoAksAAgJLLg4AuwJLASgCSwACAksuDgC8AksBKAJLAAICSy4OAL0CSwEoAksAAgJLLg4AvgJLASgCSwACAksuDgC/AksBKAJLAAICSy4OAMACSwEoAksAAgJLLg4AwQJLASgCSwACAksuDgDCAksBKAJLAAICSy4OAMMCSwEoAksAAgJLLg4AxAJLASgCSwACAksuDgDFAksBKAJLAAICSy4OAMYCSwEoAksAAgJLLg4AxwJLASgCSwACAksuDgDIAksBKAJLAAICSy4OAMkCSwEoAksAAgJLLg4AygJLASgCSwACAksuDgDLAksBKAJLAAICSy4OAMwCSwEoAksAAgJLLg4AzQJLASgCSwACAksuDgDOAksBKAJLAAICSy4OAM8CSwEoAksAAgJLLg4A0AJLASgCSwACAksuDgDRAksBKAJLAAICSy4OANICSwEoAksAAgJLLg4A0wJLASgCSwACAksuDgDUAksBKAJLAAICSy4OANUCSwEoAksAAgJLLg4A1gJLASgCSwACAksuDgDXAksBKAJLAAICSy4OANgCSwEoAksAAgJLLg4A2QJLASgCSwACAksuDgDaAksBKAJLAAICSy4OANsCSwEoAksAAgJLLg4A3AJLASgCSwACAksuDgDdAksBKAJLAAICSy4OAN4CSwEoAksAAgJLLg4A3wJLASgCSwACAksuDgDgAksBKAJLAAICSy4OAOECSwEoAksAAgJLLg4A4gJLASgCSwACAksuDgDjAksBKAJLAAICSy4OAOQCSwEoAksAAgJLLg4A5QJLASgCSwACAksuDgDmAksBKAJLAAICSy4OAOcCSwEoAksAAgJLLg4A6AJLASgCSwACAksuDgDpAksBKAJLAAICSy4OAOoCSwEoAksAAgJLLg4A6wJLASgCSwACAksuDgDsAksBKAJLAAICSy4OAO0CSwEoAksAAgJLLg4A7gJLASgCSwACAksuDgDvAksBKAJLAAICSy4OAPACSwEoAksAAgJLLg4A8QJLASgCSwACAksuDgDyAksBKAJLAAICSy4OAPMCSwEoAksAAgJLLg4A9AJLASgCSwACAksuDgD1AksBKAJLAAICSy4OAPYCSwEoAksAAgJLLg4A9wJLASgCSwACAksuDgD4AksBKAJLAAICSy4OAPkCSwEoAksAAgJLLg4A+gJLASgCSwACAksuDgD7AksBKAJLAAICSy4OAPwCSwEoAksAAgJLLg4A/QJLASgCSwACAksuDgD+AksBKAJLAAICSy4OAP8CSwEoAksAAgJLLg4BAAJLASgCSwACAksuDgEBAksBKAJLAAICSy4OAQICSwEoAksAAgJLLg4BAwJLASgCSwACAksuDgEEAksBKAJLAAICSy4OAQUCSwEoAksAAgJLLg4BBgJLASgCSwACAksuDgEHAksBKAJLAAICSy4OAQgCSwEoAksAAgJLLg4BCQJLASgCSwACAksuDgEKAksBKAJLAAICSy4OAQsCSwEoAksAAgJLLg4BDAJLASgCSwACAksuDgENAksBKAJLAAICSy4OAQ4CSwEoAksAAgJLLg4BDwJLASgCSwACAksuDgEQAksBKAJLAAICSy4OARECSwEoAksAAgJLLg4BEgJLASgCSwACAksuDgETAksBKAJLAAICSy4OARQCSwEoAksAAgJLLg4BFQJLASgCSwACAksuDgEWAksBKAJLAAICSy4OARcCSwEoAksAAgJLLg4BGAJLASgCSwACAksuDgEZAksBKAJLAAICSy4OARoCSwEoAksAAgJLLg4BGwJLASgCSwACAksuDgALAksBKAJLAAICSy4OARkCSwEoAksAAgJLLg4BGgJLASgCSwACAksuDgEbAksBKAJLAAICSy4OAAsCSwEoAksAAgJLLg4ADQJLASgCSwACAksuDgARAksBKAJLAAICSy4OABwCSwEoAksAAgJLLg4BHAJLASgCSwACAksuDgEdAksBKAJLAAICSy4OAR4CSwEoAksAAgJLLg4BHwJLASgCSwACAksuDgEgAksBKAJLAAICSy4OASECSwEoAksAAgJLLg4BIgJLASgCSwACAksuDgEjAksBKAJLAAICSy4OASQCSwEoAksAAgJLLg4BJQJLASgCSwACAksuDgEmAksBKAJLAAICSy4OAScCSwEoAksAAgJLLg4BKAJLASgCSwACAksuDgEpAksBKAJLAAICSy4OASoCSwEoAksAAgJLLg4BKwJLASgCSwACAksuDgEsAksBKAJLAAICSy4OAS0CSwEoAksAAgJLLg4BLgJLASgCSwACAksuDgEvAksBKAJLAAICSy4OATACSwEoAksAAgJLLg4BMQJLASgCSwACAksuDgEyAksBKAJLAAICSy4OATMCSwEoAksAAgJLLg4BNAJLASgCSwACAksuDgE1AksBKAJLAAICSy4OATYCSwEoAksAAgJLLg4BNwJLASgCSwACAksuDgE4AksBKAJLAAICSy4OATkCSwEoAksAAgJLLg4BOgJLASgCSwACAksuDgE7AksBKAJLAAICSy4OATwCSwEoAksAAgJLLg4AIQJLASgCSwACAksuDgACAksBKAJLAAICSy4OABYCSwEoAksAAgJLLg4BPQJLASgCSwACAksuDgAeAksBKAJLAAICSy4OAT4CSwEoAksAAgJLLg4BPwJLASgCSwACAksuDgFAAksBKAJLAAICSy4OAUECSwEoAksAAgJLLg4BQgJLASgCSwACAksuDgAsAksBKAJLAAICSy4OAUMCSwEoAksAAgJLLg4ALwJLASgCSwACAksuDgAyAksBKAJLAAICSy4OADQCSwEoAksAAgJLLg4ANgJLASgCSwACAksuDgA4AksBKAJLAAICSy4OADoCSwEoAksAAgJLLg4APAJLASgCSwACAksuDgA+AksBKAJLAAICSy4OAEACSwEoAksAAgJLLg4AQgJLASgCSwACAksuDgBEAksBKAJLAAICSy4OAEYCSwEoAksAAgJLLg4ASAJLASgCSwACAksuDgFEAksBKAJLAAICSy4OAUUCSwEoAksAAgJLLg4BRgJLASgCSwACAksuDgAKAksBKAJLAAICSy4OAUcCSwEoAksAAgJLLg4BSAJLASgCSwACAksuDgFJAksBKAJLAAICSy4OAUoCSwEoAksAAgJLLg4BSwJLASgCSwACAksuDgFMAksBKAJLAAICSy4OAU0CSwEoAksAAgJLLg4BTgJLASgCSwACAksuDgFPAksBKAJLAAICSy4OAVACSwEoAksAAgJLLg4BUgJLASgCSwACAksuDgFRAksBKAJLAAICSy4OAVMCSwEoAksAAgJLLg4BVAJLASgCSwACAksuDgFVAksBKAJLAAICSy4OAVYCSwEoAksAAgJLLg4BVwJLASgCSwACAksuDgFYAksBKAJLAAICSy4OAVkCSwEoAksAAgJLLg4BWgJLASgCSwACAksuDgFbAksBKAJLAAICSy4OAVwCSwEoAksAAgJLLg4BXgJLASgCSwACAksuDgFdAksBKAJLAAICSy4OAV8CSwEoAksAAgJLLg4BYAJLASgCSwACAksuDgFhAksBKAJLAAICSy4OAWICSwEoAksAAgJLLg4BYwJLASgCSwACAksuDgFkAksBKAJLAAICSy4OAWYCSwEoAksAAgJLLg4BZQJLASgCSwACAksuDgFnAksBKAJLAAICSy4OAWgCSwEoAksAAgJLLg4BaQJLASgCSwACAksuDgFqAksBKAJLAAICSy4OAWsCSwEoAksAAgJLLg4BbAJLASgCSwACAksuDgFtAksBKAJLAAICSy4OAW4CSwEoAksAAgJLLg4BbwJLASgCSwACAksuDgFwAksBKAJLAAICSy4OAXECSwEoAksAAgJLLg4BcgJLASgCSwACAksuDgFzAksBKAJLAAICSy4OAXQCSwEoAksAAgJLLg4BdQJLASgCSwACAksuDgF2AksBKAJLAAICSy4OAXcCSwEoAksAAgJLLg4BeAJLASgCSwACAksuDgF5AksBKAJLAAICSy4OAXoCSwEoAksAAgJLLg4BewJLASgCSwACAksuDgF8AksBKAJLAAICSy4OAX0CSwEoAksAAgJLLg4BfgJLASgCSwACAksuDgF/AksBKAJLAAICSy4OAYACSwEoAksAAgJLLg4BgQJLASgCSwACAksuDgGCAksBKAJLAAICSy4OAYMCSwEoAksAAgJLLg4BhAJLASgCSwACAksuDgAMAksBKAJLAAICSy4OAYUCSwEoAksAAgJLLg4BhgJLASgCSwACAksuDgGHAksBKAJLAAICSy4OAYgCSwEoAksAAgJLLg4BiQJLASgCSwACAksuDgGKAksBKAJLAAICSy4OAYsCSwEoAksAAgJLLg4BjAJLASgCSwACAksuDgGNAksBKAJLAAICSy4OAY4CSwEoAksAAgJLLg4BjwJLASgCSwACAksuDgGQAksBKAJLAAICSy4OAZECSwEoAksAAgJLLg4BkgJLASgCSwACAksuDgGTAksBKAJLAAICSy4OAZQCSwEoAksAAgJLLg4BlQJLASgCSwACAksuDgGWAksBKAJLAAICSy4OAZcCSwEoAksAAgJLLg4BmAJLASgCSwACAksuDgGZAksBKAJLAAICSy4OAZoCSwEoAksAAgJLLg4BmwJLASgCSwACAksuDgGcAksBKAJLAAICSy4OAZ0CSwEoAksAAgJLLg4BngJLASgCSwACAksuDgGfAksBKAJLAAICSy4OAaACSwEoAksAAgJLLg4BoQJLASgCSwACAksuDgGiAksBKAJLAAICSy4OAaMCSwEoAksAAgJLLg4ADgJLASgCSwACAksuDgGkAksBKAJLAAICSy4OAaUCSwEoAksAAgJLLg4BpgJLASgCSwACAksuDgGnAksBKAJLAAICSy4OAagCSwEoAksAAgJLLg4BqQJLASgCSwACAksuDgGqAksBKAJLAAICSy4OAasCSwEoAksAAgJLLg4BrAJLASgCSwACAksuDgGtAksBKAJLAAICSy4OAa4CSwEoAksAAgJLLg4BrwJLASgCSwACAksuDgGwAksBKAJLAAICSy4OAbECSwEoAksAAgJLLg4BsgJLASgCSwACAksuDgGzAksBKAJLAAICSy4OAbQCSwEoAksAAgJLLg4BtQJLASgCSwACAksuDgG2AksBKAJLAAICSy4OAbcCSwEoAksAAgJLLg4BuAJLASgCSwACAksuDgG5AksBKAJLAAICSy4OAboCSwEoAksAAgJLLg4BuwJLASgCSwACAksuDgG8AksBKAJLAAICSy4OAb0CSwEoAksAAgJLLg4BvgJLASgCSwACAksuDgG/AksBKAJLAAICSy4OAcACSwEoAksAAgJLLg4BwQJLASgCSwACAksuDgHCAksBKAJLAAICSy4OABACSwEoAksAAgJLLg4BwwJLASgCSwACAksuDgHEAksBKAJLAAICSy4OAcUCSwEoAksAAgJLLg4BxgJLASgCSwACAksuDgHHAksBKAJLAAICSy4OAcgCSwEoAksAAgJLLg4ByQJLASgCSwACAksuDgHKAksBKAJLAAICSy4OAcsCSwEoAksAAgJLLg4BzAJLASgCSwACAksuDgHNAksBKAJLAAICSy4OAc4CSwEoAksAAgJLLg4BzwJLASgCSwACAksuDgHQAksBKAJLAAICSy4OAdECSwEoAksAAgJLLg4B0gJLASgCSwACAksuDgHTAksBKAJLAAICSy4OAdQCSwEoAksAAgJLLg4B1QJLASgCSwACAksuDgHWAksBKAJLAAICSy4OAdcCSwEoAksAAgJLLg4B2AJLASgCSwACAksuDgHZAksBKAJLAAICSy4OAdoCSwEoAksAAgJLLg4B2wJLASgCSwACAksuDgHcAksBKAJLAAICSy4OAd0CSwEoAksAAgJLLg4B3gJLASgCSwACAksuDgHfAksBKAJLAAICSy4OAeACSwEoAksAAgJLLg4B4QJLASgCSwACAksuDgASAksBKAJLAAICSy4OAeICSwEoAksAAgJLLg4B4wJLASgCSwACAksuDgHkAksBKAJLAAICSy4OAeUCSwEoAksAAgJLLg4B5gJLASgCSwACAksuDgHnAksBKAJLAAICSy4OAegCSwEoAksAAgJLLg4B6QJLASgCSwACAksuDgHqAksBKAJLAAICSy4OAesCSwEoAksAAgJLLg4B7AJLASgCSwACAksuDgHtAksBKAJLAAICSy4OAe4CSwEoAksAAgJLLg4B7wJLASgCSwACAksuDgHwAksBKAJLAAICSy4OAfECSwEoAksAAgJLLg4B8gJLASgCSwACAksuDgHzAksBKAJLAAICSy4OAfQCSwEoAksAAgJLLg4B9QJLASgCSwACAksuDgH2AksBKAJLAAICSy4OAfcCSwEoAksAAgJLLg4B+AJLASgCSwACAksuDgH5AksBKAJLAAICSy4OAfoCSwEoAksAAgJLLg4B+wJLASgCSwACAksuDgH8AksBKAJLAAICSy4OAf0CSwEoAksAAgJLLg4B/gJLASgCSwACAksuDgH/AksBKAJLAAICSy4OAgACSwEoAksAAgJLLg4AFAJLASgCSwACAksuDgIBAksBKAJLAAICSy4OAgICSwEoAksAAgJLLg4CAwJLASgCSwACAksuDgAVAksBKAJLAAICSy4OAgQCSwEoAksAAgJLLg4CBQJLASgCSwACAksuDgIGAksBKAJLAAICSy4OABcCSwEoAksAAgJLLg4CBwJLASgCSwACAksuDgIIAksBKAJLAAICSy4OAgkCSwEoAksAAgJLLg4CCgJLASgCSwACAksuDgILAksBKAJLAAICSy4OAgwCSwEoAksAAgJLLg4CDQJLASgCSwACAksuDgIOAksBKAJLAAICSy4OAg8CSwEoAksAAgJLLg4CEAJLASgCSwACAksuDgIRAksBKAJLAAICSy4OAhICSwEoAksAAgJLLg4CEwJLASgCSwACAksuDgIUAksBKAJLAAICSy4OAhUCSwEoAksAAgJLLg4CFgJLASgCSwACAksuDgIXAksBKAJLAAICSy4OAhgCSwEoAksAAgJLLg4CGQJLASgCSwACAksuDgIaAksBKAJLAAICSy4OAhsCSwEoAksAAgJLLg4CHAJLASgCSwACAksuDgIdAksBKAJLAAICSy4OAh8CSwEoAksAAgJLLg4CHgJLASgCSwACAksuDgIgAksBKAJLAAICSy4OAiECSwEoAksAAgJLLg4CIgJLASgCSwACAksuDgIjAksBKAJLAAICSy4OAiQCSwEoAksAAgJLLg4CJQJLASgCSwACAksuDgAaAksBKAJLAAICSy4OAiYCSwEoAksAAgJLLg4CJwJLASgCSwACAksuDgIoAksBKAJLAAICSy4OAikCSwEoAksAAgJLLgqAeQJLASgCSwACAksuDgIqAksBKAJLAAICSy4OAisCSwEoAksAAgJLLg4CLAJLASgCSwACAksuDgIvAksBKAJLAAICSy4OAi4CSwEoAksAAgJLLg4CMAJLASgCSwACAksuDgIxAksBKAJLAAICSy4OAjICSwEoAksAAgJLLg4CMwJLASgCSwACAksuDgI0AksBKAJLAAICSy4OAjUCSwEoAksAAgJLLg4CNgJLASgCSwACAksuDgI3AksBKAJLAAICSy4OAjgCSwEoAksAAgJLLg4COQJLASgCSwACAksuDgI6AksBKAJLAAICSy4OAjsCSwEoAksAAgJLLg4CPAJLASgCSwACAksuDgI9AksBKAJLAAICSy4OAj4CSwEoAksAAgJLLg4CPwJLASgCSwACAksuDgJAAksBKAJLAAICSy4OAkECSwEoAksAAgJLLg4CQgJLASgCSwACAksuDgJDAksBKAJLAAICSy4OAkQCSwEoAksAAgJLLg4CRQJLASgCSwACAksuDgJGAksBKAJLAAICSy4OAkcCSwEoAksAAgJLLg4CSAJLASgCSwACAksuDgJJ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6ScCCgQQDDgICgskAgALAADMACUAAMiILgQAAYADKACABAQAESUAAMofLgiABQAGACgGAgoAOAoICy0OBwstDgYEADgCCQEOOAIBBiQCAAYAAMxBJQAAyq0tDgEFIwAAzEotDQUCBygAAoBwAAUtDAUBIwAAzF8NKAABgHQAAiQCAAIAAM66IwAAzHQFMIB/AAMAAicCBgQACjgGAwUkAgAFAADMqAY4AgMICygACIB/AAckAgAHAADMqCUAAN7tHAwCAwAnAgUBAC0IAQInAgYECQAQAQYBJwMCBAEAKAICBicCBwQIQwOwAAOAdQAHAAUABi4IgHgAASMAAMznDSgAAYB8AAMkAgADAADNASMAAMz8LQ0EASYFKAABgHAAAy0NBAUBMIB0AAEABicCCAQIDDgDCAkkAgAJAADNLCUAAMiIACgCAggAOAgDCS0NCQcBKAADgGMACA44AwgJJAIACQAAzVQlAADKrScCCgQIDDgICgskAgALAADNayUAAMiIACgCAgoAOAoICy0NCwkBKAADgHwACA44AwgKJAIACgAAzZMlAADKrScCCwQIDDgICwwkAgAMAADNqiUAAMiIACgCAgsAOAsIDC0NDAoBKAADgHYACA44AwgLJAIACwAAzdIlAADKrScCCwQIDDgICwwkAgAMAADN6SUAAMiIACgCAgsAOAsIDC0NDAMcDAcIBBkoAAiAfgAHHAwJCAQAOAcICQ44BwkLJAIACwAAziAlAADKrRkoAAmAfgAHHAwKCAQAOAcICQ44BwkKJAIACgAAzkQlAADKrRkoAAmAfgAHHAwDCAQAOAcIAw44BwMJJAIACQAAzmglAADKrScCCAQQDDgGCAkkAgAJAADOfyUAAMiILgQABYADKACABAQAESUAAMofLgiABQAHACgHAggAOAgGCS0OAwktDgcEASgAAYBjAAMtDAMBIwAAzOctDQQCJwIGBBAMOAEGByQCAAcAAM7VJQAAyIguBAACgAMoAIAEBAARJQAAyh8uCIAFAAUAKAUCBgA4BgEHLgqAeAAHASgAAYBjAAItDgUELQwCASMAAMxfJQAAwWstDQIEACgEAgQtDgQCLQgBBAAAAQIBLQgBBScCBgQhABABBgEnAwUEAQAoBQIGJwIHBCAAOAcGBy0MBggMOAgHCRYMCQkkAgAJAADPdC4KgGEACAAoCAIIIwAAz1MtCAEGAAABAgEtDgUGLQgBBScCBwQJABABBwEnAwUEAQAoAQIHACgCAggAKAUCCUA/AAkACAAHLQ0FAQAoAQIBLQ4BBS0OBQQuCIB4AAMjAADPxw0oAAOAfwABJAIAAQAAz+EjAADP3C0NBgEmLQ0EAicCBwQIDDgDBwgkAgAIAADP/CUAAMiIACgCAgcAOAcDCC0NCAUcDAUCACcCBwEALQgBBScCCAQFABABCAEnAwUEAQAoBQIIJwIJBARDA7AAAoB1AAkABwAIBTCAcAADAAIuCIB4AAEjAADQUQ0oAAGAcAAHJAIABwAA0HcjAADQZgEoAAOAYwABLQwBAyMAAM/HLQ0GBwA4AgEIDjgCCAkkAgAJAADQkiUAAMqtJwIKBAQMOAEKCyQCAAsAANCpJQAAyIgAKAUCCgA4CgELLQ0LCScCCwQgDDgICwwkAgAMAADQziUAAMiILgQAB4ADKACABAQAISUAAMofLgiABQAKACgKAgsAOAsIDC0OCQwtDgoGASgAAYBjAActDAcBIwAA0FElAADBaycCAgIYGjgBAgMcDAMEAhwMBAIEHAwCAwIbKAABgIAAAhwMAgUCHAwFBAQcDAQCAhsoAAGAfgAEHAwEBgIcDAYFBBwMBQQCHAwBBgIcDAYFBBwMBQECLQgBBScCBgQFABABBgEnAwUEAQAoBQIGLQwGBy0OAwcAKAcCBy0OAgcAKAcCBy0OBAcAKAcCBy0OAQctDAUBJioBAAEFUCX8dzBk45U8AQECJioBAAEFW021Co+HABM8AQECJiUAAMFrLgiAeAAFIwAA0dgNKAAFgHYABiQCAAYAANJDIwAA0e0tDQEFLQ0CBi0NAwctDQQILQgBCScCCgQFABABCgEnAwkEAQAoBgIKJwILBAQAKAkCDD8PAAoADC0NCQYAKAYCBi0OBgktDgUBLQ4JAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWAYwAGJAIABwAA0mEjAADTEi0NAQctDQIILQ0DCS0NBAonAgwEBAw4BQwNJAIADQAA0oglAADIiAAoCAIMADgMBQ0tDQ0LJwINBAMMOAUNDiQCAA4AANKtJQAAyIgAKAcCDQA4DQUOLQ0ODAA4CwwNJwIMBAQMOAUMDiQCAA4AANLXJQAAyIguBAAIgAMoAIAEBAAFJQAAyh8uCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAADTEi0MBgUjAADR2CoBAAEFAtxuJ4B2Ep08AQECJiUAAMFrLQgBCCcCCQQDABABCQEnAwgEAQAoCAIJLQwJCi0OBAoAKAoCCi0OBgotCAEEJwIGBAQAEAEGAScDBAQBACgEAgYtDAYJLgqAeQAJACgJAgkuCoB5AAkAKAkCCS4KgHkACS0NBAYAKAYCBi0OBgQtCAEGJwIJBAUAEAEJAScDBgQBACgGAgktDAkKLgqAeQAKACgKAgouCoB5AAoAKAoCCi4KgHkACgAoCgIKLgqAhwAKLQ0ECQAoCQIJLQ4JBC0IAQkAAAECAS0OBAktDQYEACgEAgQtDgQGLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS4KgHgABi0IAQoAAAECAS4KgHcACi4IgHgAByMAANRADSgAB4B8AAskAgALAADWIyMAANRVLQ0KDQsoAA2AdwAOJAIADgAA1HInAg8EADwJAQ8nAg0EDi0IAA4tDAkPLQwEEC0MBhEtDAoSABAADQAlAADRyC0EAAAtDQkNLQ0EDi0NBg8tDg0JLQ4OBC0ODwYuCoB6AAoBKAAOgGMABi0NBgQnAgYAcQo4BQYJCygABIB5AAYkAgAJAADV6CMAANTiJwIJAHMKOAUJCiQCAAoAANW+IwAA1PknAgkAdQo4BQkKJAIACgAA1ZQjAADVECcCCQB4CjgFCQokAgAKAADVaiMAANUnCygABYCFAAkkAgAJAADVQCcCCgQAPAkBCgsoAAaAdwAFJAIABQAA1VUlAADTGy0MAQctDAIILQwDCy0MBAwjAADWEgsoAAaAdwAFJAIABQAA1X8lAADTGy0MAQctDAIILQwDCy0MBAwjAADWEgsoAAaAdwAFJAIABQAA1aklAADTGy0MAQctDAIILQwDCy0MBAwjAADWEgsoAAaAdwAFJAIABQAA1dMlAADTGy0MAQctDAIILQwDCy0MBAwjAADWEgsoAAaAdwAFJAIABQAA1f0lAADTGy0MAQctDAIILQwDCy0MBAwjAADWEi0MBwEtDAgCLQwLAy0MDAQmJAIACwAA1jAjAADWhScCDAQCDDgHDA0kAgANAADWRyUAAMiIACgIAgwAOAwHDS0NDQsnAgwEDS0IAA0tDAkOLQwEDy0MBhAtDAoRLQwLEgAQAAwAJQAA3v8tBAAAIwAA1oUBKAAHgGMACy0MCwcjAADUQCoBAAEFD/SS/LbkggA8AQECJiUAAMFrLQgBBScCBgQRABABBgEnAwUEAQAoBQIGJwIHBBAAOAcGBy0MBggMOAgHCRYMCQkkAgAJAADW9C4KgHgACAAoCAIIIwAA1tMtCAEGAAABAgEtDgUGDDgCAwUkAgAFAADXcyMAANcTASgAA4BvAAcOOAMHCCQCAAgAANctJQAAyq0MOAIHCCQCAAgAANdKIwAA1z8uCIBvAAUjAADXagI4AgMHDjgDAggkAgAIAADXYSUAAOA8LQwHBSMAANdqLQwFBCMAANd+LgiAeAAEIwAA134HKAAEgHAAAi0IAQUAAAECAS0OAgUnAggEBAY4BAgJBDgJCAoCOAQKBwsoAAeAeAAIJAIACAAA198jAADXvAEoAAKAYwAHDjgCBwgkAgAIAADX1iUAAMqtLQ4HBSMAANffLQ0FBy4IgHgAAiMAANfuDDgCBwUkAgAFAADYCSMAANgALQ0GAS0MBAImLQgBCAAAAQIBLgqAeAAILgiAeAAFIwAA2CMNKAAFgHAACSQCAAkAANiSIwAA2DgtDQYFLQ0ICScCCgQQDDgCCgskAgALAADYVyUAAMiILgQABYADKACABAQAESUAAMofLgiABQAIACgIAgoAOAoCCy0OCQsBKAACgGMABS0OCAYtDAUCIwAA1+4FKAACgHAACicCDAQACygADIBwAAskAgALAADYyQcoAAqAcAAOCjgOAg0kAgANAADYySUAAN7tADgKBQsOOAoLDCQCAAwAANjgJQAAyq0MOAsECiQCAAoAANj9IwAA2PIuCIBhAAkjAADZRAA4AwsKDjgDCgwkAgAMAADZFCUAAMqtKAIADAQBTQw4CgwNJAIADQAA2S0lAADIiAAoAQIMADgMCg0tDQ0LLQwLCSMAANlELQ0IChkoAAqAfgALHAwJCgQAOAsKCQ44CwkMJAIADAAA2WwlAADKrS0OCQgBKAAFgGMACS0MCQUjAADYIyUAAMFrLQgBBgAAAQIBLQ4BBi0NAgEAKAECAS0OAQItCAEBAAABAgEtDgIBLQ0EAgAoAgICLQ4CBC4IgHgABSMAANnFDDgFAwIkAgACAADZ6CMAANnXLQ0GAi0NAQMtDAIBLQwDAiYkAgACAADZ9SUAAOBOJwIIBAMAOAQIBwA4BwUILQ0IAi0NBgctDQEIACgHAgkuBAAIgAMoAIAEBAABJQAA2l0uCIAFAAouCIAGAAstDgILLQ0KAgAoAgICLQ4CCi0OCQYtDgoBASgABYBjAAItDAIFIwAA2cUuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAADarCMAANscJACADQAA2rkjAADa0i4AgAOABQEAgAUAAoAOLgKAC4AOIwAA2xcoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAA2xcjAADbcCgAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAADbcCgAgA0EAAMBAIAFgA2ADAsAgAOABYANJACADQAA29QBAIAKgAiADy4AgAqAEC4AgAyAEQsAgBCAD4ASJACAEgAA29QuAYAQgA4uAoAOgBEBAIAQAAKAEAEAgBEAAoARIwAA26MBAIAMgAiABiYuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAADcLCMAANycJACADQAA3DkjAADcUi4AgAOABQEAgAUAAoAOLgKAC4AOIwAA3JcoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAA3JcjAADc8CgAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAADc8CgAgA0EAAMBAIAFgA2ADAEAgAyABIANAwCACAACgA4BAIANgA6ADwEAgAqADoAQDQCAEIAKgA4kAIAOAADdUC4BgBCAES4CgBGADwMAgBAAAoAQAwCADwACgA8jAADdHy4AgAyABiYlAADBay0IAQMAAAECAS4KgHsAAy0IAQQAAAECAS4KgHkABC4IgHgAAiMAAN2FDSgAAoCCAAUkAgAFAADdnyMAAN2aLQ0EASYtDQQFAzCAgQACAAYPKAACgIEAByQCAAcAAN3AJQAA4DwnAggEHww4BggJJAIACQAA3dclAADIiAAoAQIIADgIBgktDQkHHAwHBgAtDQMHBDgGBwgAOAUIBi0OBgQFKAAHgIYABS0OBQMBKAACgGMABS0MBQIjAADdhSUAAMFrLQgBAwAAAQIBLgqAewADLQgBBAAAAQIBLgqAeQAELgiAeAACIwAA3kcNKAACgIIABSQCAAUAAN5hIwAA3lwtDQQBJi0NBAUDMICBAAIABg8oAAKAgQAHJAIABwAA3oIlAADgPCcCCAQfDDgGCAkkAgAJAADemSUAAMiIACgBAggAOAgGCS0NCQccDAcGAC0NAwcEOAYHCAA4BQgGLQ4GBAUoAAeAhgAFLQ4FAwEoAAKAYwAFLQwFAiMAAN5HKgEAAQXJb5M7E53pFjwBAQImKgEAAQVkYYioxs+UyzwBAQImJQAAwWstDQMGLQ0EBwsoAAeAdwAIJAIACAAA3yUnAgkEADwJAQkLKAAGgHYAByQCAAcAAN+2IwAA3zotDQEGLQ0CBy0NAwgtDQQJJwILBAMMOAgLDCQCAAwAAN9hJQAAyIguBAAGgAMoAIAEBAAEJQAAyh8uCIAFAAoAKAoCCwA4CwgMLQ4FDAEoAAiAYwAFDjgIBQYkAgAGAADfoSUAAMqtLQ4KAS0OBwItDgUDLQ4JBCMAAOApJwIGBActCAAHLQwBCC0MAgktDAMKLQwECwAQAAYAJQAA0cgtBAAALQ0BBi0NAgctDQQILgQABoADKACABAQABCUAAMofLgiABQAJACgJAgoBKAAKgHgACy0OBQstDgkBLQ4HAi4KgGMAAy0OCAQjAADgKSYqAQABBVoC5Bu1HqmfPAEBAiYqAQABBSiGkrBH3P1DPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuABjKGMo=",
      "debug_symbols": "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",
      "brillig_names": ["open"]
    },
    {
      "name": "_check_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "12018683598614887596": {
            "error_kind": "string",
            "string": "Function _check_order_status can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "status",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_check_order_status"]
    },
    {
      "name": "_assert_nonce_and_set_order_details",
      "is_unconstrained": true,
      "custom_attributes": ["internal", "public"],
      "abi": {
        "error_types": {
          "11094545764365153162": {
            "error_kind": "string",
            "string": "Function _assert_nonce_and_set_order_details can only be called internally"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "order_data",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_assert_nonce_and_set_order_details"]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": ["public", "initializer"],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "portal",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["constructor"]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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PYLeMrPWI2x8FvTOlrUeYeOzoDegrPUIG58FvU9krUfY+Czo7RxrPcLGZ0HvuljrETY+C3pzxFqPsPFZ0HsY1nqEjc+C3mqw1iNsfBb0joC1HmHjs6An7td6hI3Pgp5fX+sRNj4Lehp8rUfY+Czo2eq1HmHjs6Anldd6hI3Pgp77XesRNj4Leop2rUfY+CzomdS1HmHjs6AnPNd6hI3Pgp6XXOsRNj4/++lDn5Pd6imLu6/HPLue5VqPMbf13B+cF/9+bHZlP9RWjy05vh9bys/Hru20StrplLTTK2lnUNLOqKSdSUk7s5J2Fh3tjIuSdirxQ1GJH4pK/NCznwt8WTun8UNxO9Ysi600dBpD1GroNI6o1dBpLFGrodN4okZD0zSmqNXQoa5ovYQdfwk3/hJ+/CXC+EvE8ZdI4y+Rx1+iDL/E2Aey10uM7915fO/O43t3Ht+78/jencf37jy+d+fxvTuP791lfO8u43t3Gd+7y/jeXcb37jK+d5fxvbuM791lfO8uw3t3WpbxlzDjL2HHX8KNv4Qff4kw/hJx/CXS+Evk8ZcY37vN+N5txvduM753m/G924zv3WZ87zbje7cZ37vN+N5txvduO7532/G9247v3XZ877bje7cd37vt+N5tx/duO7532/G9243v3W5873bje7cb37vd+N7txvduN753u/G9243v3W587/bje7cf37v9+N7tx/duP753+/G924/v3X587/bje7cf37vD+N4dxvfuML53h/G9O4zv3WF87w7je3cY37vD+N4dxvfuOL53x/G9O47v3XF8747je3cc37vj+N4dx/fuOL53x/G9O43v3eP3qqXxe9XS+L1qafxetTR+r1oav1ctjd+rlsbvVUsd9qoFF7aHm0OI5fOD+236Tx32wL2sdHPe0u15S3fnLd2ft/Rw3tLjeUtP5y09n7f0886m5byzaTnvbFrOO5uW886mHfb0vqx0ybPp58+LpSJ5Om3VLnk+bdUueUJt1S55Rv289rxInlJbtQ+dU9dL2PGXcOMv4cdfIoy/RBx/iTT+Enn8JcrwS5hl/CXG924zvneb8b27w97rEPL2beUYnfn84M+/w5w77HD+pJy3S3TY4dy8hBl/CTv+Eo+rLy3ObAcvoTG722TS+8E22es7RKN7r8cLqycIqycKqycJqycLq6fIqqfD5vC+9Zhn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",
      "brillig_names": ["sync_notes"]
    },
    {
      "name": "_check_order_commitment",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14563046062317426044": {
            "error_kind": "string",
            "string": "Function _check_order_commitment can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_check_order_commitment"]
    },
    {
      "name": "fill_private",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "10852400770788842366": {
            "error_kind": "string",
            "string": "Invalid order domain"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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AgQuCIBDAAUjAAA4TQw4BQMCJAIAAgAAOHAjAAA4Xy0NBgItDQEDLQwCAS0MAwImJAIAAgAAOH0lAABC5icCCAQDADgECAcAOAcFCC0NCAItDQYHLQ0BCAAoBwIJLgQACIADKACABAQAASUAADjlLgiABQAKLgiABgALLQ4CCy0NCgIAKAICAi0OAgotDgkGLQ4KAQEoAAWAXAACLQwCBSMAADhNLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAOTQjAAA5pCQAgA0AADlBIwAAOVouAIADgAUBAIAFAAKADi4CgAuADiMAADmfKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAADmfIwAAOfgoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAOfgoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AADpcAQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAADpcLgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAADorAQCADIAIgAYmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAOrQjAAA7JCQAgA0AADrBIwAAOtouAIADgAUBAIAFAAKADi4CgAuADiMAADsfKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAADsfIwAAO3goAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAO3goAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAAO9guAYAQgBEuAoARgA8D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",
      "debug_symbols": "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",
      "brillig_names": ["fill_private"]
    },
    {
      "name": "_update_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9169818942746597700": {
            "error_kind": "string",
            "string": "Function _update_order_status can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "status",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_update_order_status"]
    },
    {
      "name": "_emit_open",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13459246948365409099": {
            "error_kind": "string",
            "string": "Function _emit_open can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "resolved_order_bytes",
            "type": {
              "kind": "array",
              "length": 613,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_emit_open"]
    },
    {
      "name": "fill",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8412360910299423372": {
            "error_kind": "string",
            "string": "Invalid order destination domain"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["fill"]
    },
    {
      "name": "open_private",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "error_types": {
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "order",
            "type": {
              "fields": [
                {
                  "name": "fill_deadline",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                },
                {
                  "name": "order_data_type",
                  "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                },
                {
                  "name": "order_data",
                  "type": {
                    "kind": "array",
                    "length": 301,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                }
              ],
              "kind": "struct",
              "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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oUShRWFEYUXhROFFEUQRRZFEkUVRRFFF0UTRRTFEMUWxRLFFcURxRfFE8UUJRL+JfhclFCUSJRYlESUVJRMlF/0h+lOUQpRSlEqUWpRGlFaUTpRelEHkfOJziNxE7iIPkacooyiTyEvkLcosyiLKKsomyi7K4XzPOFEuUW5RHlFeUT5RflEBUUFRIVFhURFRUVExUXFRCVFJUSlRaVEZUVlROVF5UQVRRVElUWVRFVFVUTVRdVENUU1RLZGPqLaojshX5CeqK6onqi9qIGooaiRqLGoiaipqJmouaiFqKWolai1qI2oraidqL+og6ijqJOos6iLqKuom6i7qIeop6iXqLeoj6ivqJ+ovGiAaKBokGiwaIhoqGiYaLhohGikaJRotGiMaKxonGi+aIJoomiSaLJoimiqaJpoumiGaKZolmi2aI5ormieaL1ogWihaJFosWiJaKlomWi5aIVopWiVaLVojWity3q/eeS94533Wnfcwd94f3Hnvbed9rZ33jHbej9l5r2PnfYSd9+h13v/WeW9Z531bnfdEdd5v1HkvT+d9Mp33oHTe39F570TnfQmd9/xz3k/Pea86533gnPdYc96/zHlvMOd9t5z3tHLeL8p5LybnfY6c9xBy3p/Hee8b531lnPdscd4PxXmvEed9PJz3yHDef8J5bwfnfROc9yRwvt+/8730ne9T73wPeOf7qzvfu9z5vuDO99x2vp+1872ine/D7HyPY+f7Bzvfm9f5vrfO95R1vl+r871Qne8z6nwPT+f7Yzrfe9L5vo7O90x0vh+h873+nO+j53yPOuf7vznfW835vmXO9wRzvt+W872snO8T5XwPJuf7GznfO8j5vjzO97xxvp+M871anO+D4nyPEef7dzjfG8P5vhPO93Rwvl+C870InH/n7/wbeuffpzv/9tv5d9XOv1l2/j2w829tnX/H6vwbUeffXzr/ttH5d4POv8lz/r2b82/JnH+n5fwbKOffFzn/dsf5dzHOvzlx/uKv828lnH+H4Pwdf+fvzzt/N935u9rO34N2/i6v83dbnb/r6fzdR+fvAjp/N875u2L/87tTIufv1jh/18T5uxfO30Vw/mze+bNq589unT/LdP5sz/mzLufPfpw/C3H+bMD5b+XOfzt2/luq898Wnf/W5vy3J+e/xTj/bcL5vbrze1fn93LO722cr/WdcRvsL8v/9zX63x/+L8Vc/I/Exfm7vc7fdXX+7qfzdyGdvxvo/F055++OOX+Xyvm7Rc7ftXH+7onzdzGcv5vg/Fm982fXzp/lOn+26fxZn/NnX86fBTl/NuL8WYHz386d/5bs/LdV5781Ov/tLbEoiSipKJkoucj5vZ3zex3n78+nFKUSpRalEaUVpROlF2Vwfu8icojcnN9fiTxEnqKMokwiL5G3KLMoiyirKJsouyiH//dTuUS5RXlEeUX5RPlFBUQFRYVEhUVFREVFxUTFRSVEJUWlRKVFZURlReVE5UUVRBVFlUSVRVVEVUXVRNVFNUQ1RbVEPqLaojoiX5GfqK6onqi+qIGooaiRqLGoiaipqJmouaiFqKWolai1qI2oraidqL2og6ijqJOos6iLqKuom6i7qIeop6iXqLeoj6ivqJ+ov2iAaKBokGiwaIhoqGiYaLhohGikaJRotGiMaKxonGi8aIJoomiSaLJoimiqaJpoumiGaKZolmi2aI5ormieaL5ogWihaJFosWiJaKlomWi5aIVopWiVaLVojWitaJ1ovWiDaKNok2izaItoq2ibaLtoh2inaJdot2iPaK9on2i/6IDooOiQ6LDoiOio6JjouOiE6KTolOi06IzorOic6Lzoguii6JLosuiK6Kromui66IbopuiW6Lbojuiu6J7ovuiB6KHokeix6InoqeiZ6Lnoheil6JXoteiN6K3onei96IPoo+iT6LPoi+iryHnxBxMFF4UQhRSFEoUWhRGFFYUThRdFEEUURRJFFkURRRVFE0UXxRDFFMUSxRbFEcUVxRPFFyUQ/Sb6XZRQlEiUWJRElFSUTJRc9IfoT1EKUUpRKlFqURpRWlE6UXpRBpGryCFyE7mLPESeooyiTCIvkbcosyiLKKsomyi7KIcopyiXKLcojyivKJ8ov6iAqKCokKiwqIioqKiYqLiohKikqJSotKiMqKyonKi8qIKooqiSqLKoiqiqqJqouqiGqKaolshHVFtUR+Qr8hPVFdUT1Rc1EDUUNRI1FjURNRU1EzUXtRC1FLUStQ7m8l8fu5Q952ty50esW7niNT8wN5/6//cxgM999v/c1QFtHNX631qrfu5LAJ/7GsDn/udJ5x8+FyyAzwUP4HMhAvhcyAA+FyqAz4UO4HNhAvhc2AA+Fy6Az4UP4HMRAvhcxAA+FymAz0UO4HNRAvhc1AA+Fy2Az0UP4HMxAvhczAA+FyuAz8UO4HNxAvhc3AA+Fy+Az8UP4HMJAvjcbwF8LqH/56bOT7g6wa3gldXPpQzgc+4BfC6b/+cq53pwKubA66nVz2X3/1yO/K3Why7QZZj6udL+n7PLibL+nzs46uieef1q1VE/Vz6Ar6sYwNdVDuDrqgXwuRoB9KwVwNfVDuDrfAP4unoBfK5BAD0bBfB1TQL4umYBfF3LAD7XOoCebQP4uvYBfF3HAL6uSwCf6xZAzx4BfF2vAL6uTwBf1z+Azw0MoOfgAL5uaABfNzyArxsVwOfGBNBzXABfNyGAr5sUwNdNDeBz0wPoOTOAr5sdwNfNDeDrFgTwuUUB9FwSwNctC+DrVgTwdasD+NzaAHquD+DrNgbwdZsD+LptAXxuRwA9dwXwdXsC+Lp9AXzdwQA+dziAnkcD+LrjAXzdyQC+7kwAnzsXQM8LAXzdpQC+7koAX3c9gM/dDKDn7QC+7m4AX3c/gK97FMDnngTQ81kAX/cigK97FcDXvQ3gc+8D6PkxgK/7f+19CXxcV3X+G0ljWZs1ieMkzk72PTPSaAtZlFh24t1xHO9OMtKMnIQQJ7ENhK2CltL+KaVtWlqgLWVfylb2tSxlL9AWytJCKVCWtkDZCqVl++c574w+fXPumRnNvaNxrPv76aeZd7/znXPPPXd99735hSH3K0Pu9A533pkdbs5HGXLnGHLnGXIXGnkXG5yXGnKXG3JZQ27QyBsyOEcMuTFD7tGG3DVG3rjBeb0hN2HIrTHk1hp56w3OjYbcZkPuJkNum5G33eDcacjtNuT2GnK3GXkFg3PKkCsZcvsNubuMvLsNznsMuXsNufsNucNG3uMNzgcMuScZck8x5GaMvKcbnL9hyP2mIfdbhtyzjLxnG5zPMeR+35B70JB7rpH3Jwbn8w25PzXk/tyQe5GR9xKD82WG3CsMuVcZcq8x8l5ncL7BkHujIfdmQ+5tRt47DM53GXLvMeTea8h9wMj7oMH5YUPuo4bcxw25rxh5XzM4v27IfdOQ+3dD7ttG3ncNzu8Zcj8w5H5kyP3EyPupwfl/htzPDblfGnKptDuvPe3mTBtynYZclyHXa+QtMzgzhtzxhtwJhtxJRt5Kg/NUQ+50Q+5MQ+5sI+9cg/N8Q+5CQ+5iQ+4yI+8KgzNnyA0ackOG3KiRd6XBeZUhd40hN27IrTLyVhucNxhyaw259YbcJiNvi8G51ZDbZshtN+R2GXl7DM59htxthlzBkCsaedMG5x2G3F2G3N2G3AEj7z6D86Ahd9iQe7wh90Qj78kG51MNuRlD7umG3DOMvGcanL9tyD3LkHu2IfcSI+9lBucrDLlXGXJ/aci9zsh7g8H5RkPuzYbcWw25dxh57zI432PIvdeQe78h90Ej78MG50cNuY8bcp8w5P7OyPsHg/MzhtxnDbnPG3L/bOR9yeD8siH3FUPua4bcN4y8bxmc/2HIfduQ+64h930j74cG538bcj8x5H5qyP3MyPuFwfkrQy61xC3XvsQtt8TIW2pwdhtyvYbcMkPuOCNvucG5wpA7yZBbacidZuSdYXCeZcidbcida8hdYORdZHBeYshdZshdYcgNGHl5g3PYkBs15K405K428q41OK8z5FYZcqsNuRuNvHUG5wZDbpMht8WQmzTyigbntCF3hyF3lyH3WCPvgMF5nyF30JA7bMg9wch7osH5ZEPuqYbcjCH360beMwzOZxpyv23IPcuQ+10j7/cMzj8w5P7QkHuuIfc8I+8FBuefGXIvNOReZMi91Mh7ucH5SkPu1Ybcawy51xt5f2VwvsmQe4sh9zZD7p1G3rsNzr825N5nyH3AkPuQkfcRg/NjhtzfGnKfNOT+3sj7tMH5j4bc5wy5LxhyXzTk/sXI+46R91+Gvr5Ot9zyTrfcCkPuJCPvPCPvRUnel3oeeOwlY++eo+/FSd7y6JnP6X7Lxj2Yd1WX285rjbzrjLxVRt5qI+8GI2+tkbfeyNuc5Kn39A25Wwy5HYbcHkNunyFXMOSmDLn9htydhtxjDbkDhtxBQ+6wIfd4Q+5JRt5TDM5nGnkf6NXzepL/b1/28P+EovxukPixjPiY0njyPdtYynUBr2/+0ezwZFc0N3m2f7ALOAPwDwh/Rxj+bNL1RXfOzOWPSG9f8h0f1REZyWuDvLuSvKVJvnzOJ5+7iC9EvaNNvv22XLG/DcoWp1Uzs3kpb7pHBoV/Igx/UfhXh+GXrjxaE4R/eET4b0j4I2/c+bJvbpwJElcDwr+2cdtzfEG414WxvdyXr2/c9qzL9g1BbM+X+TeG8U1e+DeF4S/3CZuBPxWAf0sY/nLc3xTGP9PCvzUMf0n4bwb+KPIf/9vC2F/mvyWM/eW+YXvCH4J7B9juLzYHyr7ZGYR/uGz/rjD85ba7Owx/uW/bE4Z/SPj3huEfFv59YfjHhP/WMPyy/I1uC8NfnvPcHoa/3HcWwvCX+/7JIPwj5f5hKgx/eWwshuEvt99SGP5y+5oOw19uX/vD8Jf3EO5I+KP5cw/yhXi/JV4Xfyvh0/YT/JVlKCtr9Y7ZopTHetGdhuv+5hi5Qor0RVTOiPR3R0H3PnIp0if2sH9kXS++W6LYmlHyuA6XKHqWKHoySh6PrY1wTXnk2uuRq+CRy2cZb/PItc8j1+0eudZ45NrhkctnGX3GV9Ejl8+27dP3uz1y+Yz7VR65dnnk8hlfJY9crTp2yHww7Lzj4b2NmLMzDP+g5Qssk+jvAxsiyNf+R5E+RxJd3VHlXCPEHEkrG9rvqmf2QSMxg1xdSl6IOk0b5Wb9Lrw2lxT8UoMf8f1RZQwvJV90hfHFgFVvS0Gn6O+F68XS5OH9Gw7sjyjx3Fj8tpJwst/ZFlX6u9PBFdH3lXStHfgw9UIZDj5wz9SmA4dKB6MqyWrMYW/e5sZq7SxEf7M6iw6yxxXU4ru0YmsmqmxQvMDXGlta0aNxTXjk2uGRa9Ij1x6PXLd75NrtkWufRy6fZVzjkatV42unR64pj1xFj1w+48unv271yOUzvny2oYJHrqJHLp/9qixmAy+ChnnzEpPk4eQyRXk4Ub0Bys+pnb5jmWKO7wIv49genDfhZM81Z4hT4IVBrov84Zm/vPDojOb6lMu01OErydf+Cxfnia5mbbhrZdMWSZmoMi55waVxddbJtZAbBFqM9xm2auXgBba1aEWfCH6pYRfij5VF6MmEkwNzjSxCT6ZrrkVoo5tDYmecMgqXLKh5bRqn8eR/tqFUzPFY5pE7G7h/H+G2h4nHQvSt5GH88xjaDVwyhkpeD8ilSa7X4OwzOJcZdvYbnBnI47X6cZCHfRcnbR4gdRb77xfAyzhJsU/Enx0z0ZyyjCfXsw2kkdFsVvS1J/zpqNJ21J8m/HeS791kv/hnfJ52To8UctODhenCUKFYzE8Vjif+OLWBn/AQwcLd5H+4n2Y7j6ab/L3RbFu8+0ChuKpw78HDd5fayJWuoSNFdFxsbirl8KNrPIS0kZwMSVqosp0phUNzgXD2R3NtQNl2+s7DC19rU/CpGrjkc7thi4sjRRx9Bgc3HSl7j8InTaeP+MeT79nGUom7bUxat81dc4bsiqLau2Z8RqeeJRoOTTykiLx0qezXXshHfHeiKB4uip1z9R2v2FNLlxMnnhZhl8pD7nKPepYDZgnpOcGjnhMAw0uJFR71rAAML0NP9KjnRMDINEDa50mQJ2WV9rkS8jzebilIGU+JKpPknQq6OaZOgzycvnLS2qeUqd72eTLkoW3Iie0T/Xoy5CP+vNSsLSf2zdXPyxxcrsnZ//aosp5OiirLclKkc6NsH32X/DhJPJwC1z3GQ7aWuEb93VHI+Jyd6pxC9rB/6pzqoNuRvp/oBINYTP1gEuLT9J1DQR4JqmWq0xVVhrFHFxfDhlS2/NjqqWH4R4X/tDD8Q8J/ehj+KeE/Iwz/mPCfGYZ/WPjPCsNfEP5HheEfkaFA+oR9MFWT4wg89IgdcQo7RGcna+2SRX93VNnHheiSV5I97B+eyp+t2JqhvDjJo7YpJa9duda2yLXItcBcMoXHPoDnGFp7WWnosaaGPSAnj+fy8hXt03ZWOW+ZkdevlIuX6HHaRnLHKZxxv/qy1Cyfqw7QN7yNg77BfiX+O6cK143EhfLnENe5Vbg2ERfKn0tc51Xh2khcKH8ecZ1vcOFcqF+RP5+4LqjCdSZxofwFxHVhFa5HERfKX0hcF1XhOpW4UP4i4rq4CtcZxIXyFxPXJVW4ziIulL+EuC6twnUKcaH8pcR1WRWu04kL5S8jrsurcJ1EXCgvsn0KV9Lsy3OmK+D6QsyZRH832erZnvKc6Yqo0q/oH54zZRVbM0oe9zVZRU9W0aNxneeR63yPXBd45LrQI9dFHrku9sh1iUeuSz1ycV9TbVyU15tY46LIYbwhDm+7aGMhcrjG3fZIH08vr6E8eI19c7lDn8s+9I3sI1njvDY3ZZvrnZuivDU3lVevaLdWeB6Jt6DOpjy8638O5fUr5dJuH51LeXjXX/yGc9M0leeVyfUust/zWJHlu+KarxZgH6KUIn1RtLD7EOKLcwxfnBtEdz5Xqy/OJV+cE8gXVn+h7ckIXpv7n6PgcVt9f+nQhgP7r39gW2E/HijCpsLm9BGO72yc7TBrnHDn0ndptmwHcmFiO3jbnvHjVfD4uVe5Hidt2cRbA1q14TVra0BwEvIXkL3jyfdsY6l8AO6iMPzlA6XaEhLLJPr7FD+lHP+Fi/NEV3dUWUchmqdWNquecZpay1L7wjq5upS8EHV6gVFu1N9n2KqVo5fKwT4a91KOkRHNT/7488Na2/LHP1y+RXZxGP8M8VRpTRJ88XTq46m5dYvTwxTVH/ah/uJwcLjW/kD0d0eV41mI/qCX7GH/8HZAn2JrRsnjOO1T9PQpejJKHj+wNF8uLf4aset2T3bFabdHrh0euXyW0Vc9Rp7LuMsjl88y3uaRa9Ij160eufZ45Cp65NrnkctnTPhsjz7bkM+Y8OmvNR65Vnnk8un7vR65fPp+yiOXT3/57At3euTy6a+iRy6ffaFPf/nsc46FOVPRI5fPcduX7+PPvP5ulbgveuKKP/MavVXi3lcZ4+Szn/A5B/Dpr/0euSaIq9Z1veD7Fby2Lyh7yXg7TGRlDwVveXncsxiw/IS34ET/fB5WF78NEY4fVsf2uMzBFdH3IbrWHukPq2tPy3U67BS9XL/4azRo7xIFj3z81NhEUvGxH1cmF7WXJfQC/7YkQ+KBb92PJ9+zDaX8YF/Cd1k0m8SXojvMcZrBmh/IFf3dZKvntlHez9OOTaF/eD/vCsXWjJLHdagdI7pC0ZNR8nhO0wjXbR65Jj1y3eqRa49HrqJHrn0euXzGxO0euXZ45PIZEz79tcYjl09/7fXI5ctf8We+h9AqsbrbI9cjvR7jNOWRy6e/fI5DOz1y+fRX0SOXz3HIp7989vc+48tnn+OzPRY9cvmcM/nyffyZ96daJe6Lnrjiz7w/1Spx76uMcfLZT7Tq/Gu/R66JhKs/ycP1JD+ioT2SdKmhB+UvrYFLWw8LPqvgrX0wjHuRlb2HHOSF2AfT1vr4mIPon88+mPgtRzjeB8P9lSscXBF9z9E11z4Yn+l6Z+J88W+gs5Lq8Xd+lAH3zvgsLe7DWXuv2lnaHgcXvkBv28wsBt82g/j3wb7daX1zOasd0eZHXdEmPut6vkN/KpqNuTRhPwS2nZnY1hdV+kn8H7i+p1KkT/yC11B/s87mafWkxZG2z+rRnsla+mW0l/dltT5e+g18SxLiL4Uycj+D/V6arn0mcUomquzr18/MteEypTza2BDvaX+ybW7Z5nvmG3m18UvqV/Tgo77S7mN7vtA2tyzcT6Bs/PkUyEf8L3tnOb+YcPYr8lx/3BaxL4qTPOLOsSP3HxjD/ZjgvwJ9xdnUj2lv2jrFsFk48aWYaLO8xoBt+AaNO4H28NVxR3T1k71cP1wWrU447i5R/NCnyHE/HKifqbkfFv3NevOX9Yg8+jVwfEzW0m+hvVKXlyt5wiVzNmxDiL8Myoh4/CzyeO0n1A9jn839sDaP1R5Jj/uO71MfheVZSWWrdx2B8uxDlGu0v9dsttrdfPUgF84ZsV5dfSfew8f6wL4T45D7TsG3J4bG/fd5xlwPx7Z0e3VbexRb04T/KoxtSxNOiZt+kJf60Oqnn/JWKnpThD1SbgXD45HYucSB73eUqx98upLGRPSFVq/9Dhs6lHLFietV8MvnUa8r2qvbqq010oT/INTryVSv6D+rXjOUh/UqPtLGXK7zesdclF9p6FlBeRg78gbXPvou+XGSsQjHeH9j0VTNjx+L/m6yNdRYrb0aB/3TnDXTVLaWMQjtDTx3GNTOe7hez4HtEfG8JsO9Jtw3S9O1fBIY2nxE+H3OE5rNZe2Lcj9/EfkC4zXl+C+8fM2az3MfEWL+Eifp36Wfukyxgcca0cPXWA/KC05rJ/HfePI921AazGnnxjzyD2ivnfLHny/bnw1jf1biifdwsW4G4Lq/Pmyo5mdoRX832RpqzBkge9g/fOZuULE1o+RxjAwqegYVPRklrzjTmlx7PHLd5pFr0iNX0SPXPo9ct3vkWuORa4dHLp9lLHjkKnrk8tmGfPp+t0cun3G/yiPXLo9cPuOr5JHLZ3xNeeSa9sjlM+591qPP/stnGfd74oo/81y1EbsmZvxx+fSXz/nEsTAO+Yz7okcun+PQTo9ct3rkWpx/LVzc+5ybLI5p9XG16lyuVftCn3M5n32hz3oseuRq1fkX76U+Eudfez1y+WzbPtuQT3/5HIeKHrla1fc++y+fe2mtujfkM758zn1bdY7ZqmMH3yfzMXa0K9z43u2w95myg8KfD8Rv+QrLJPr53r3ka/+Fi/NEVzdxeS5bziqb9awQxhT6oNH4FK4uJS9EnQ4Y5Ub99d4L9NXO4s8rPXL1EZd2rkK7Fyr4vILX4qRf0S2yUrdDkOexbgesusU+QvTP53kr8dsthJOfd2uLKtvGoIMrou+30LX2SH/eqj+qjLWMw07Ry9es826XG3pObFDPiTXqOZrLw9xyzmoZ5MvZpLDnWIZDn2MZ0p6h9Mc/MqrNITz6Z1Ibb/zxD03L+JGn2MC6D9MfDg/WOucQ/d1RZV8ZYs4xRPawf/gczrBia0bJ4xgfVvQMK3o0rpwnrjjxPaVGuPZ45NrlkavokctnGXd75NrhkctnTOz0yOUrJrQ+ezEmbK7bPXIVPHIVPXL5rEefvvfpr70euXyW8VaPXD7r0Wfcr/HIVfTEFX/md+20Skzs98jlKybiz4vzr4WJ1Ti14lgbf+Y12mJfaHNNeOTy1efEn3mvoxGuiz1xxak444/LZx/tc0xr1Xlhq45prbi2ilPRE5fvNuTTX7766MWx45ExdsTJ59rKZ1845ZFrcU9h4dqQT98XPXJNe+Rq1fWQT9/v88jVqvuFPuc5i/3Ews0nfJbxkd5P+PZ9q/YTE8SlnWnJwDV+FyzeC+X7MENVuG4kLpQfiqqXEbk2ERfKD5PciEMPvucG42BE0a3xC0eXcj3+G0++ZxtK+VKXUg5//ANFuR8+CuVOJf9F9xhc93fvPl/zOx9FfzfZ6tee2bMEY2QP+4fPElyp2JpR8jhGrlT0XKnoySh5PB42wlX0yLXHI9cOT1zxZ75X0ohdOz3ZFadVHrl8+SvyXEafdq32yOUzVqc8cvls2z59f7tHrsX+a7H/CllGn3G/yyOXr7iPP/Mee6u07aJHrlbto1t1rPVZj7s9ch0L49CxUEafdvnsV1t13OZ1e6vEly9/xZ/5XFUjdu3zZFecfK6tih65fMbqYntcuDK26rh9LKzTfPbRfHbskRj3kx65WnWvo+SRK0Qfzc9lxmk8+Z9tKA3ma3k3N+4/e9w3L6VIn/gIr6H+Zr2bW7uPpD2Prt1j8WhPMUX8aM+I4h+pyzElj+MR72MhfgTKyP0dxmaarj0v/fD/jMLJ/aR2nwSviX/j3z54MOGtow0MTE3nBodKI0PZ4UJ+qDg8OFAcGMkW80PTudxobmAsPzo4OD2VHy2ODgxOD4wMTPGznWIr6g1Ux/la24Do746CtsmcFXPa/WIt5kSWYyFO22dmcfXEgs+40uyS3yzi3xsR/jiFjYXByfnGwuVB7LFjQXsPQT2xEH++ED43Wn88p26Ea59Hrls9cu3xyLXbI9cOj1xFj1wFj1w+y7jLI5fPMt7mkWvSE1f8me9XtEp8+WyPPuPLZ1/o067bPXL5jPuiR65WjIn4M98jbZX4WuWJy3cZfcb9Xo9cPuN+yiPXYj/xyBg7ih65pj1y+ZpPxKlVfb/fI9diG6pv7OBz/Itt6Oj0/b4Zf1w+18gTCZfsIV0IeePJ/2xDabD8/sOLvXNnp8O+mzCb5b01j7YPdCn1MU/uYtZh95X+7S6/U/rR/rnz1X53/YIlc+v5qgTj+t31cyEf8b/XOct5ccIp5VoWzdUx7qVs+Xwtv3F+Elz3t2c6kE2RvijS93BFf7N+4/wksof9w3u4KxVbM0oe1+FKRc9KRU9GyeO+uxGuVR65dnnkKnjkKnnk2uORa6pF7drtkWuHR66dLWpX0SOXz7j3aZdP39/qkctnPfr0/V6PXD7LuN8TV/w5G/nhitPEjD8un/663SNXq7Ztn2OHzCfk2XGcP14Szc3DWLqU9J0Cecgv89LTIN/nPFD4zwjDX/4tk9OjSh9jmUS/zDNPBXzK8V+4OE90dROXb99ZZUP7OX5OB3vQBy6u0+vk6lLyQtTpaUa5UX+fYatWjlPIJ5oebY0i+DMNuxAv7RJjX2TFh2dBnkcfDlj1fSboFP3z+R0Y8duZhJP3cLRFlb4/w8EV0fcz6Vo78GESH+M69iTiOpHK4KrfjCIvuFrW9mH6gcGaf8NC9DdrbX9qjX4V352m2JpR8nhtr7XP0xQ9GSWP1/aNcK3yyLXLI1fBI1fJI9cej1xTLWrXbo9cOzxy7ffEFX/mdUkjdk3M+OPy6a/bPXL5bI9Fj1w+495nX+izHvd65PJZjz77L5/+mvTItdMjl09/FT1y+ZxP+PTXrR65FvvVhetXffk+/nxB5IcrTj7jvuiJK/7MZy9bJe59lTFOPvuJNR65WnW+elnkhytOEzMP/w+7xp89K9Jqe2r4e60px3/h4jzR1U1cnsuWs8qG9lsxgz5oNP6EK/DeerlOTzXKjfrr3YepZZ+0Vp/0ElevwmXtudZat/1RZX2KbOA2Vt5zPSVy+wn1z2fPVfw2QDh5X3FbVFl3pzq4Ivo+QNeq7blina6gPIy/DOlZRuWr1k5Rfpmh5+QG9Zxco56juTzVzt+d2KnrdJ2/Wwn5iC/B+buVnXPLiPLHR3PzMKaWU14f5J1Aeeg3wUl774c8f+09lxVfSn1ikrzjQHcP5R0PeVhuTu30HcsU9x/fBV7GsT3oQ7QNObGuNb+mCX9h56wtF/bpnCngRDvlXpHgxZdLotlyI4ZtEPylYMPZfTpnh6Nc/Q7OVRDDV3TqnFGkt0Uu13FULlefkib8IJRrJTgOMfIdx1R534HoOl7RFTmucWwc78irVy/6R64tr0FvSsnjWGJ/orzL5xxLgr/aiKU+xQb0B9f7MrKBMceRDYK/TrEh9rP0IVMH7n1gVeHeg4fvLkWUOuAzd/VaVXMV9Ck8riRuiIsnzYV55LsVJlpzjBzXXNXeC9eLpbtLh0oOB7URWY9DWVukJ+5LRS5OYcech+eYqC+K9LWX6O+O9Lgd92NPjvt5sYf9w/eCM4qt9c6PsEzcv9QyP7L6jmU1lqc3mg3sg4cO3O+KORzDtZjrdehPKfIRyaaUa3GKG+W2pFF2kV7PcVB+l1GvYqM290hRHpaXY4XbEuZhrHRQHo4XacrDsWUJ5S2HvE7KOwHyllLeCsjrojw8i9ENnzlpcz2ps1jfL4CXcZLi8hQTw2PZR9oahrnaosq1SZzkd3ck9sOch5nKij2y5nbNn0+EfMTfC2P9JTTf0M4unaT4i21APJab6wpjlvd7NN3aHDfs3uisf08D/2llOxXyEf8Ew7/a3pnl32r7p2KP+Bd9ehpxVfOv7Om0un9nFtC/2j6ndiaQ+7t6zwRmDBtQz8kN6jlZ0WNxZRQuXCc8NBG+83Gl+zcdOFR+7aVQolsj+txF13rpO099VzhMdU2t5fsp9J1vN5xN349T7NOS2IGJbWmPqicJdfHVsyHUL6dQ14Y21CndJW/BoSxuwUl4XQ04DuOrFZ14zQpjwWl6+NGCaxS5FOWhDdcYNqC84KSLuxby/HVx+XIXJ3yu7cxrIR/xLzC6OJHB8p+jlJ9tQDyWW+zRfC+yfYrulOO/6OFrXC9ow3lN0nN+8rlfyeNY1/x8raEH5a9tUnkyTdLT3yQ9fU3Sw7cnxj3qGQeM3K6QeLsO8rhfu4708DWrX7uOynO1x/Jo/XSfYl+jetA3/DjZ9ZCHY5zYsUqxQ/r4CbjucQui5lcai/5ustWzPeWtsQmyh/3D2x2rFVszSh7/VMtqRc9qRY/GdZ5HLomN/qgyVlaRnusVPdcbelYpeiSuboA8j3OHUamXG6PKJHlr4dodM7N2cNK2d8TueG6R65vlZRzrRL+upTxsY+soD+tqPeWtgbwNyef+qNK/qBvzpIx8jesR5W8gG1Cu0T5Ms1mLywkqT71xOaHo6VPkGi2PZjPXuQ89WJ7VpGe1Rz0Yi2tIz1Ugh0cUvkO3YkUO5/QoK9uAacK/tneW83u0Tb4W7PLYlxSkbOuiyiR560E3t40NkMdxthHyODY2QR76nJPWP4kv4v5pax39042QJ2WSOpD9gV/BLfafdc6Vxzrk1+Tj+Lme8tYoeUfquHvWHvQDHgvA/QmOG8GvTPb9w447wyPa2MJzqXWBdNfSnrWxBe0Ru7uVvI4GbJ2eGs0OZoeHi6Xh/ORQfjoVVbapduUar8PXK/i8ghdfbwjj6wFpS+0zs/w4LsepA/LWUV4a8sTGOEQf0zfX/vWB7K/F/6g/o+A3QRnqqcuQXNgf+OBaNk+u46PKMUn6nMBz3zGtD5KktfkrKA9jboDysD0NUR6OZXjbmFO1+fTj6hivcFxc5+CUsQDXAjLGpAl7UTJOxGPP+Uvn6sI54eaZuXk49xI9Mcf40tnrqAfP6cg4GadbHHZdTeNXoLlOUZvr8Pi1PpDuWscvXv+gPWJ3t5LXyPg1mZseLGUnJ/MDk8Wh4eFhazzCazx+bVDwowpefL0xjK8ntfFrA/g1Th2Qx2Mbjl9iozZ+hRl/85O1+B/1ZxT8NihDPXUpfbs2b9LW+YOUh2s+nOuOUxsPM098uO65bBHZiPXG4wPGJI8PuGbh8WEz5NU7Pogv6h0fsJ/EMiFnB1zT+vg04TfDGLGRxggc00V3jPsI4dYrdodtM7XvtYp+rQ8Nsdeq9Ylau9Pij9s35j0aPmMe6tmo6NG4VnrkkrjojypjdD3pWavoWWvoWa/okbjC9uevHofKj1RsiSqT5N0E1+rdaxW7691rRb/eRHnYxrZSHtbVzZSH/du25HN/VOlf1I15Uka+xvWI8pvJBpRLOf6LHr7GejSbtbjkvrPeuNyg6LH2SuZbHs1mrnMferA8G0nPRo96MBY3kR6co+Ne65NozSFyuNeqrb3ThH8u7LU+leYm2A4Wqi/R2sZWyOM4uxnyODa2QR76nJPWP4kv6t1rxb4ay4S21zo3EfzvUD0Fmktkj6dyaT619kBbbY4TZj1tz3G0/rLeOQ7+5DL3PfXOSyY8ckls90eRc16SojzUs97Qo82XjtU5jtaHNGuOw3PVeuc4KN+sOY4VlzzHqTcuNyh6rPXefMuj2XyszXHe7mmO82swx3lXU/Zf/M5xOM5CzXFw/6WeOY61Bqu2V5Ii3a650JaZh//zPs0nYJ/m40vddt0Auie65uIW92mO3X0aiQvtLBWPffWepdLOixyrcxj0a7PnMKgb86SM1eYwKN+sOYwVlzyHqTcuNyh6+hS5Rsuj2XyszWF+6mkOcwfMYX52FO7TcJwdTfs0eD+/lrlJua9P5hmtsE9zvVL+sGdUap/jiP5usjXUHEfrL7UzxNr4JLJa38P7NNpcaoOiR+Oa8MjF62HtTHSK8lDPhKFHO/cc+FxDicd/TNq4XO8cR+yud46DfuW+ENvYFsqrd3+nP6r0b6P7eijfrDF0gsqDNvCcrd64vEHR06fINVoezebQc6mF2ndyzXGGumZlUK7WOY7gb4I5ziiNnYHOydTVl2htYwvkcZzhPIJjQ9vfqbV/mu8+DfbV3D/hXongtL0Sre0EnkeUaollbR4R6HlGcx6h9UlxWMvPa+0vHdpyePLuO6fWlx44eN09xS2F+w/dWbj7umLx/tLBg1gajhouLUcLY+TzFcp15FhXpRTydgRtJbqOuNZX4bqRuLRT6NyLuLg2EZfWc/HIp7U2nk0hHu3ZWMWejTNuezYS1yaDK/7ML0zRVp7CtbkK15nEhfKbSW6LQw9isDfcoujW+Dlub6pi86PIZrSLV2dbq3CdSlwov5W4bq7CdQZxofzNJLfNoQcxuAreBrpTyjXNnrMMe7YR1y1VuE4hLpS/hbi2V+E6nbhQfjvJ7XDoQcx2uL4DdKeUa5o9Jxn2iGwtIxza6nFEqflUvOhv1ghn+TVOvFLeqdiaUfJ4dr9T0bNT0aNxrfPItcEj13qPXBs9cm32yLXFI9dNHrlu9si11SPXNo9c0idqdzxypKfeOx4o36w7HjnSgztyuNr8A1ptSgziahNXOqdDPuKvhNXmHyWc2k6E2Kj5mXdd6vWzpkfGGoxhj7v6w+JfHMMlSR6Oc2PwmZO2OhW76909Q7/ymIz9zE7Kw35jF+Vh292dfO6PKv3LfaI2D8RrVhzzXUqUa7S9aDZrccn9cr1xuUXRE7r9867oFo96tPUDx48PPdraolp/9jbqz0TO1Z+dBPmIPwf6s3fS7hm2g4XsS7htaPMSydsFeRwbuyEPfc5J65/EF/XunmFfzf2T1ia6osrYW4i7a6K/O6pscyHWDNqegNbXaP23yGrt6WL4zO22Xblmtc0Jj1yylrTmDinKQz3WXQxtrhF4fpDnu/CY+qjMcar37tp85wfo11soD9vYdsrDuuJ2i/2i9EXa/IDjpd75Aco3a35g3V3j+UG9cWnd9Qh1d+1YnR98v475QZz47prge2F+8COaHwQ6jVhXX6K1Ddz34zjDeQXHhmtfgVO1E47zvbt2C/CzfxHXEen7lZsjt10phYfb3PUO/XFaOzM3b0sNtrn2/KNI70+0O40u27YotjFvm1EOlx6tj9L6wmGyvd6+cFjRU8tecqB54WAtfRPqb9Ze8pYa/VrvvJDbRSNzuevJBuxXuf4CzaNrnteL/madmtP2EIYVvzYjvl31PGHYE2YNPPvjstqcUDtVeFz08Bjs6ldd8wTUgfHgqhvUzffwrTXKlipcfA/f2ne6qQoX38PXfMBtmHEat0u3a6yLlOsyf0Jf8UmrmwirnRQSX0g9tjlsuAnysa65LCkFr/Hx/eibFRxy8v3netcs0s5wPrcQ/aLo71bKHaJf1O6ra2vBuN13RnN9zTGD9ec6P7JJKSv3B9Vs4v6g3nv9yMX9gXav3+daV9tzbJRrhwcubQ2+jfJwPXML5eF6huchOxX7pL3hPulCtDfR3022hmpvu8ge9o/W3lzjnbZGsDC7QK9ci/92V7GJ2xvW2W7i2lOFi9sbyotsW1RZF9o5qT1V8rX9sQiu7SV9yLeLsLsIq51Vcn3fWwcv2rCbsLsNG24h7FaHHq3ObgFeuY6+l/Zcbx+xlfK0s1J8X3tX98P/4znmvm633vWG3o2GXhl/kJ+fVrsNbJgybJgwbNhs2LAlquRviyrbMc5l26jcaK98x7K3KXayPOYhHueqwqedC72Z8nCc3056Nit6XOc18ftSRznYvz5jg/VJfFyh6OB59n3ds3afnryauZb9lEBPxtc8Dor+Zu2nVDtrzXMc7Qy09UQ8twfUYz1JhFzrPHLJ2bxj9eky6yl09HOIp8sajQmUb9bTZdYT9ByX9T5Bv07R06fINVoezWaucx96tOcwOH586LGeLnPd/3o+/TqI9nSZdf9L8D/umeX8s4Qz8BusvT5dxnGGcwyOjUaeLsNfqpjv+RjX068oG/bJvuxQreM2v00+0FNs5XFbe95K62vi27Vy1mt/6dD60gPbC3ffWSwcuvPAPVtL9x0uHTyExUDqDriO+Zg6SJ3gJgi3fqYSh6lZD+/W6j5+DMv6wbUFCMv80R6W2rRCZLVu/kL4zMNJu3LNGjIafakkcjX74fPAQ01Rm05J0oaheqetOCzM99gWvzTHegF2vVPa/qjSv42+RAPlm/UCIysuOf7rjcu1ih5raT3f8mg2c5370IPlWajpsWva+mWatuJ2Ry3TVsF/GaatX6Vpa6Afl6qrL9HahnZsVZvScmxoU9pa+yf8can5Htvi/gl/6FB+tEnyVoEc/xAn/lir8OMPHWptW350u5++x5/Hk89psmtJEhtdhPMbD4PleNB+YDRsLA7W/GisaxmOdmtzqY4GbB0oTU4NFwrTg1PT2anCdClF/GIrX8MtXO4TBX+5gg87Nx0sSHvBH4zCNhqnDsjj11OkIQ9fUsI/GBXmReyDhVr8j/ozCn4dlKGeuqxl7VIrl/z4FP7w3XjyWeubuC2Ow/WFWLuIvm6y1bM95bXLeFTp16sUv2pzUpHV5i780tp651ta/+6DS8Yebay4ivRcq+i51tBzlWJzK/2YZZya9UPu6FeeX45DHs8JrXUDtmmZX2lb1Bwv9fZDKN+sLepa5jDzjctxRU+fItdoeTSbuc596BkHTLPWYjxPda1dBnpmZVCu1rWL4D8Ca5chmqtiO1iovkRrG7i3wHGG6/RxysNbT+hzTlr/JL5oZO3C/ZPWJlp1fnBtGHvM+YHW19Q7P+AXvjYypt/okUvioj9y952Wb8YNPVr/eKzOD8Yhj9ufdpTX5/xgHD5jnpSx2vwA5Zs1Pxin8qAN6K/5xOX1ip7Q4/b1pOd6j3qwPAs1P8A1FM4PHlPD/ABlXfODN8D84B6aH4QZE/zOD8YpD+cHHBuNzA/EF/XOD3Att87BmVaw11CeYJ8E9fXa5HO/In91NDfvasi7jvKugbyrKO9ahZP7B4w5HNM3zMwtg+Cfntgd+/KsZTpnm4NT4lhiFNuovxidyvIcAMs4Djqvj+aWUfDPhDJeQvGCe3vi++Rp8KhjJkh5crEd59BRTomDI/aDXu5H2xU8759qcyVtPKhl3nWNwjUO12R/cCFjANuMKwYerDEGxK8LEQPCfcR+0OuKAcTXGwPiM2s/LRVVxhr7PE7NjgGxD2PgOtDJMSD4F9YYA+PRbHni1DETpDxqDKBfa4kBxHMMrFLwWDfis0xUWe9riGtc4cKxgO8TCPcSBc/jFeJfDXW0sm+ufdqYLHlXK9w4LqeIA8vRo5Sjj/JQNua9YMlc+2UO90aYE3yQ5nBh7vPMPgIucxpt3on6+UcD36q0ixTJoL+0vQK2AfFrFR/2k99QNqy/8gVtjSxJm9fynLfWfS+e8+IZAV7D4BkB9AknbT4sforrbwz6E8ZJwthMkU7RwW2F28VVir24FuJ28TFoF19sgXaB/aCrXXyyznah3WOrtV3wHtXR3i54rxjbxTjltVK7+GIN7QLHYW4X1yv24j0EPs/0FWgXP6R2gT4L0S60H99D+zdGc20W/NeNdrFR8Zd11kP76QetD9UeFxTZVnoECtuBdsaL4xvPePH5L3xsgfdTtccTa20X4qd62sUPqV1oZ41rbRfrgffL9Mis+O5/oF10Ja9qC/sDj7PtQurS1S6w3SD+Z0a7sH7iJE7cLrRX2GC5uV1g38uvzg7jr/x0n2KrJC32N1JerT8IVUvsSx6+ugN9wklrF/iIcK3tQmIzRTpFRz3tYgPwPp/ahfhjGby28CxqF1j2EO0CH7HX2sW2aK7Ngj8+sVNrF9pPumivx2UbEI/l5nahvdIgrL+GhvoUWyVJHj5Czq8TwkfIebzQfm5C8vCVDPxoK76igX9+B5PWLsRP9bSLs6hdaK/TqLVdbAVeef0nt4vzoF2MNKddFKVsUpe1tgvBX1Rnu7DGC+21RLW2C5EN3C5a6vXokqe98iVkuxgJ1C7eRj/ZgeNuLa+E1HSGfbV2dopj3dV+boZ8xI8b7cf66bI4cfvR2pv2ijjrp8UWsr+5SbGH+5sbFH9p+99boDxx6pgJUp6Stv+N9ZYGvdXqKE719onis1peNWT9pMn1Cif+NA+vbW6GsarUAmsbvL/vWtvsMNqatrbB/qTetY3Y80hZ2/AcDvsOXve00tqmVMPaBvcKeaxap9iLP5DM+0p3Qbt4MrWLZr0+19UutkRzbRb8PUa70F4dqz2PbY3LWG5uFxj7IhvWX0O5PsVWSVp88zwN45tjX4tvXktpbQ37bf6ZVkxauxA/1dMunkztQuv/am0X+Pq4nybvJuN28TRoFw8eJe3iGXW2C7yfcqy3i1r6/VZsFw8Gahdvd7SLP4F28eqjpF386eJ4UU71tgu+P3K0tItXB2oXT6J2IWd2Xg/t4v3ULvB8X4h2gffStTMoN0ZzbRb8m4x2ITLor1VwjduFdm8ey81nUPCsk8iG9Zffc9d8zkR7f4p2H57Pt2NbQJ9w0tqF+KmedvF+ahdrSAfWVZysMyhrgPc7nQ9/lvrNAO7SaG7eZZC3Mpprz+WKPYjvIfwVYIOGFz5+/evHIfblzJvEXxbkPbbXSbE5Bza1K+XKks2C/5TRXkUG/XYJXOP2mlPwWG6xp5/8hrJd9D2UvwYUf12u2JMm/Gdr3HvLQHni1DETpDxT2t4b1lsa9FarozhxnQ4oeKwb8VmG8Fi/kncp5GUpD9vsZWRDRrGh1rOeIhu35RVJh6f1GdyfYCxwf3KFYg/iuT/Jgg0aXvjShP+W0Z8Eah8Fq31guVzt49tGf6LFXj9cqzf2uD/BvkZku6LKuAzRnwwq/rpCsSdN+B/W2J9cBuWJU8dMkPKo/QnWG/cnVh3Fiet0UMFbfcYg5HGfgf1JjvKwzV5ONlym2FBrfyKycVtOU3+CuPNJ56WKThxL5ecvuhSbQ9x7wj6nPar0p2uO05EEp9a+tXnWyXCNY6FaP2rN8UQ2sL8mLX9dUoO/ehR/ae27B8oTp46ZIOVR2zfGJrdvrU4RX2+dis8yUWUfeRnlYRu6lPT0KHqwPXEbxroS2bgNfyEpQDfky/+OaP5+n5ocnszH71HL5YcH89ni8cQfJ/FdTwD9+aHCyFRhJJcby+dK+dxQs/WXJvNjI5NjU0PZYnYsNzbYbP0jhdGHtI/lC/nh7FR2ZLjZ+gdGR4fHBiaz+ZHi1HQx3/TyTxaHp7Jjg7lioTDyUPFHm17+YrGUy+dGxkZL+XxxrPnxNzr2UOBNlwq5XG6gmC01W/9QcXI0OzJQGCtODRcHh6aq6Y/75W8l36XPagOsyMl41w7XPY4PNb/rRq51k62e7Sm/66ad7GH/tJHvOhRbM5QXJ3kPfErJa1eutTWZqz+qrG8eczXftBt6uK7i1KfIccyxT8eT79nGUs0/aSD6u6OgbSBn1Z/mV/FdWrE1Q3lx4jhJK3rSip6jhUvk49RH3zH+uJ+rFo/yrhZu43G6OcnjvrQ/cteN2JU8AjznelrhThN+J+3JdFI5xpPv2QYTjx2oq0spn0fd5bO+S6LK1KeUm+t9KeRxvXeRzZiH4zH/7gemdvqOvoh1H6rhHoYWIynKW6KUQ/K43uOUiSrjPk15GPdLKA/7tk7Kw7iX93eniDOKZtss1h3/ZKfWLnvgeufMXL4j/+FaOvks/l2KeMrrgryOmVm9cepOvneAHuQSO9KEP5yQyz7iEpAR+Yyifwnpn2O3cg3rirnalWuCP/IOqMRG1zwP64fH3EB9Ss1jrujvjirbQYgxt5PsYf9wH7JUsTVDeXHaPjOL47x25Vqbg4vbTKNcbR65pF/Q2vYS0pNS9KQMPSwfpy5Fbjz5n60v5fmCcPMYMU9+TgUeZzBp+75ae0H/YUK76333IsZDD+XhONhLedhP9FEexkgyHJr9/3xjhOXRBpRLOf6LnqiKHs3mfsUGnudpY2OboadD0WOtzedbHs1mbY7bqB4sTyfp6fSoB2NxKenBeTW+e/HldC9B5HC/HWXl99DShF+ybJbzVTQ/x3bgsS8Z4/ksJm0+y20D+xmOs17I49jogzz0OSetfxJf1PvuRRwHuoGf22W7Iru4nxV+P4vnOfPdg+K6bpRLfN2scSfw/HmUx1ZMWn9Q77ubxe565w/o1y7Kw7jvpjysK553YBxIf6StfVP0WZvL4zVrXG/W+GTFZTvh6o3LdkVP6PlQLfu589WDmGbNU5aQHtf84Ss0fxA51/yB390s+O/1zXL+G80fAu2x1dWXaG2j1rkFx4Y2t0gpNlTbY6tn/oB9NfdP2pjQE1XW0Q+gjtqT+V7gOV75XLzYrMUV6k8T/sfGuRltza/NBdgGxGO5xR5t71JkW21OzDGtrb21uOWYxjkx91HLIA99wqnafLnWc/Ht9B7uJaSD+yQ+s5JW7MW+jtc+S2Htcwq1i0D7KHkpm9Slq11gu0F8b2Kn1i60ONf2AtkGxGO5uV1g7Itsq+47abHPa4RaY5/bWj/koU84VdvnqrVdnELtQuv/am0XS4FX9hC8nyUamBoqDA6NZadKQyOF4ZGmn+Wafkjr9Eh2aKCYLw0UC9X0a/dC8KxhnOR+Ct5vQbzwpQl/AfQxF1F9pxV9MW7UwKUc/49wKNc6ZuZe0+7D4P0pwYvu7plKGyWvB/LSpKc3+Y7+Qi6xI034oaTsUid4T0nkM4r+paR/jt3KNb4/1aPgexR8XD+XJzaW+3DQ7Xvv44hO4sdrbJvEjuu+Pt+Pwjxc5/FehPQb2p5onPiev+DHmzOuqvf8u6gMnVAGbXzkNY7g90AbXrVsrs+0+zyaP3nfneeRmId2i7/Ffz1h/Feer8t4ifMStLUnmusjwa9X5iXaue0lUJ44dcwEKU9eO7eNcwhss1iuKJotN+J57tSr4LFuxGeZqHIewucmtHNDOMavI1txbmutZ3gduB3qiH9jANtNN9mOZed7xu2KXm1fogtsPkh9QqB75CPaXpgk7V4fzx2xHfLcsZtsxjyMg3r3CcQX9Z7F8dEP4Rz4iH0zlXYtRLvFdQ23W2sNE0WV7bZaO5c9skxUWZcc39pYU0+bidM60ofxgnP1g45xvdo+3+Mda+p69/l+F8bAJ9IY6PMcWLW45PoVfdKXcLscT75nG0s1n/8R/d1RFHK+k7PiX1vzB54/5K1xUWuPx0UPr7G5ztA+4cK9crmPbe3VcaxX801GkefzhVjH1rlE7gdqOZeI8d4T2XP1FHG59o94PKh1L43nvg9Cu38rtXvrvpB2Zkub33K7186xSuzyPuZ48j3bWCrHbnm9Hek+xbkx4l9g7Mlp7UE7n8Y2IF6bO2rP0JbPjdJ3z/4qrxWWVfFXH/lL8C82/KWVv9Pw1zIF32f4C32Jsqzb1Rc1Kxar+ZZjUfCvrnEdthTKE6eOmSDlGdLmczgHS4NeV3tBfC31r7WXDOGxvq376Vof30N52Ddz/499vPRt2JdWu3ch87dliQFdih98ziuwb/bNP5obHeb7W777pqDPXuUGpgPf285K3K2ZmeXXnrNpJxzLYFzeAJgbHJgbAXOjA7MWMGsdmHWAWefArAfMegdmA2A2ODAbAbPRgdkEmE0OzGbAbHZgtgBmiwNzE2BucmC2AmarA3MzYG52YLYBZpsDcwtgbnFgtgNmuwOzAzA7HJidgNnpwOwCzC4HZjdgdjswewCzx4HZC5i9Dsw+wOxzYG4FzK0OzG2Auc2BuR0wtzswBcAUHJhJwEw6MFOAmXJgioApOjAlwJQcmGnATDsw+wGz34G5AzB3ODB3AuZOB+YuwNzlwDwGMI9xYO4GzN0OzGMB81gH5h7A3OPAHADMAQfmXsDc68DcB5j7HJj7AXO/A3MQMAcdmEOAOeTAHAbMYQfmcYB5nAPzeMA83oF5AmCe4MA8AJgHHJgnAuaJDsyTAPMkB+bJgHmyA/MUwDzFgXkqYJ7qwPwaYH7NgZkBzIwD8zTAPM2BeTpgnu7A/Dpgft2B+Q3A/IYD8wzAPMOB+U3A/KYD80zAPNOB+S3A/JYD89uA+W0H5v8B5v85MM8CzLMcmN8BzO84MM8GzLMdmN8FzO86MM8BzHMcmN8DzO85ML8PmN93YP4AMH/gwDwImAcdmD8EzB86MH8EmD9yYJ4LmOc6MH8MmD92YP4EMH/iwDwPMM9zYJ4PmOc7MC8AzAscmD8FzJ86MH8GmD9zYP4cMH/uwLwQMC90YP4CMH/hwLwIMC9yYF4MmBc7MC8BzEscmJcC5qUOzMsA8zIH5uWAebkD8wrAvMKBeSVgXunAvAowr3JgXg2YVzswfwmYv3RgXgOY1zgwrwXMax2Y1wHmdQ7M6wHzegfmDYB5gwPzV4D5KwfmjYB5owPzJsC8yYF5M2De7MC8BTBvcWDeCpi3OjBvA8zbHJi3A+btDsw7APMOB+adgHmnA/MuwLzLgXk3YN7twLwHMO9xYP4aMH/twLwXMO91YN4HmPc5MO8HzPsdmA8A5gMOzN8A5m8cmA8C5oMOzIcA8yEH5sOA+bAD8xHAfMSB+ShgPurAfAwwH3NgPg6YjzswfwuYv3VgPgGYTzgwnwTMJx2YTwHmUw7M3wHm7xyYvwfM3zsw/wCYf3BgPg2YTzswnwHMZxyYfwTMPzownwXMZx2YzwHmcw7M5wHzeQfmC4D5ggPzT4D5JwfmnwHzzw7MFwHzRQfmS4D5kgPzL4D5Fwfmy4D5sgPzr4D5VwfmK4D5igPzVcB81YH5GmC+5sD8G2D+zYH5OmC+7sB8AzDfcGC+CZhvOjDfAsy3HJh/B8y/OzD/AZj/cGD+EzD/6cB8GzDfdmC+A5jvODDfBcx3HZj/Asx/OTDfA8z3HJjvA+b7DswPAPMDB+aHgPmhA/MjwPzIgflvwPy3A/NjwPzYgfkJYH7iwPwPYP7HgfkpYH7qwPwvYP7Xgfk/wPyfA/MzwPzMgfk5YH7uwPwCML9wYH4JmF86ML8CzK8cmOhpsxj5zJgUYFIOTBtg2hyYdsC0OzAdgOlwYNKASTswSwCzxIHpBEynA7MUMEsdmC7AdDkw3YDpdmB6ANPjwPQCpteB6QNMnwOzDDDLHJh+wPQ7MBnAZByY4wBznANzPGCOd2CWA2a5A3MCYE5wYFYAZoUDcyJgTnRgTgLMSQ7MyYA52YFZCZiVDswpgDnFgTkVMKc6MKcB5jQH5nTAnO7AnAGYMxyYMwFzpgNzFmDOcmAeBZhHOTBnA+ZsB+YcwJzjwJwLmHMdmPMAc54Dcz5gzndgLgDMBQ7MhYC50IG5CDAXOTAXA+ZiB+YSwFziwFwKmEsdmMsAc5kDczlgLndgrgDMFQ5MFjBZByYHmJwDMwCYAQdmEDCDDkweMHkHZggwQw7MMGCGHZgRwIw4MKOAGXVgxgAz5sBcCZgrHZhHA+bRDsxVgLnKgbkaMFc7MNcA5hoH5lrAXOvAjANm3IG5DjDXOTDXA+Z6B2YVYFY5MBOAmXBgVgNmtQOzBjBrHJgbAHODA3MjYG50YNYCZq0Dsw4w6xyY9YBZ78BsAMwGB2YjYDY6MJsAs8mB2QyYzQ7MFsBscWBuAsxNDsxWwGx1YG4GzM0OzDbAbHNgbgHMLQ7MdsBsd2B2AGaHA7MTMDsdmF2A2eXA7AbMbgdmD2D2ODB7AbPXgdkHmH0OzK2AudWBuQ0wtzkwtwPmdgemAJiCAzMJmEkHZgowUw5METBFB6YEmJIDMw2YaQdmP2D2OzB3AOYOB+ZOwNzpwNwFmLscmMcA5jEOzN2AuduBeSxgHuvA3AOYexyYA4A54MDcC5h7HZj7AHOfA3M/YO53YA4C5iBg2gFzCDCHCMPvuZXr48n3bANpNJsfDnoGNzdQtN7RFfSZ1dxAKUX6ogj2Z+C/6O8mW73aA8+Zac8Pae8y1J41SFFex0xlOfhdF1i/8TMEW1KzOI4tfj4Q3wUl8au9303iNubfk5r9fFtqru0o0076o6jyGbsQdTGaGxkKe/Y8l9XqrrzXlPzvgDx+XriWuovTM6C/YN+1B/ZdmHaSyy1X7OdnvztnonJqJ1+j/8RPzf5tgN0JQSv/NsDNiVD8DI48S7JqZpbPZ98n/BNB+PNZ4V8dxv68PCv+zcRnoZ9d4fefig7UHeb9srlcreNmq/4+Q9j3C+ayKeJHe7TfhLDeoylc2jvsEL8Uyoh4/BxFle+4O5BUmPZcNr9rQHvnnfa8eezzO2kOEeodua5nr9FP/Pye5CP+N1Ozth+mOYlWjzhPmZiZi8f3rzAe+fg9nA/AvOg7KZ3TVS4X51OhXE+mOlmilCG+9huO8qci26e1lr/NYevTofzfc9iK9qCtvI5Amfj/bxm4tIJLka3tkT4Xl/HE6o/nG+fa+zya/c5MrdysP/7rgTK0R5V9EOO1mNLe880xhe8Ts97DJPjnQfw/WEO7xvUMznVccV1LG/xjpV1rdYxxLXZr73jA9wNpfeB48j3bWBrVYs0jf7ZP8SG2xT+n+tLGQMv/gn8pxMCLyK8pkOfxGLklNnsi/dn6Rtu69u4j7f1X6J9XkX+098nh2C99Fb9P7j3gn9eQf7T3IGvvd8DfCE9Fod6HMTu30t7ZgPXleh/GG6Et/hDGhDjhWhzfuRunjpkg5cnFdvyYxibrnQ3aOzvqfWcD1g3HIb6zoZe4tPcfaf2lNk/j321AO/FdDdzm+6Bcmk6JaYk7fF+wz/UW+xPHoX7FHo67D1G5jotm/cj1gjyCzyh6j4Oy8pwqQ3rjOOtpm8tZLTb43f3lvQoHfhnZIPiPKeMf1y+2Y4zBDuIU/Kegz/oEtR+MWxyzv+jQjeVvV8pjlR/xfY7yf1opf9B4fWhfneMG/Yt11k82C/5zSj/JfkC/peAa90EZBd+v+E3GFfS7yGp1Kzis236ljDyXFLnuSPfJErIV8/hdRDz2opz2/hsrlrS+l2Ppa0osaXMI7rs1+7A/l75bm3P0gq2vgviNU8fMLM5X/I6MPtzfHrF1ZtYPuOaOSH+a8N9OCHy/73x6pJCbHixMF4YKxWJ+qtD0960PFUamCiO53Fg+V8rnhpqtf2B0dHhsYDKbHylOTRfzg83WXxodK2bHpkuFXO6hXi5bWsj3zf8vjEE/gzHoCFbRF+O629y4lOP/EQ7lWsfM3Gut/r75zqTsrfy+efnSiu+bl9gJ0a6G88O50dHC6NTw1PRYfmqyWrsaoXHgqHxHWnZ48qh+R9pDE71mvSMN30FmvSPN9d6ydsC43luGGNd7yxDjem8ZYlzvLUOM671liHG9twwxrveWIcb13jLEuN5bhhjXe8sQ43pvGWJc7y1DjOu9ZYhxvbcMMa73liHG9d4yxLjeWxbnBz4PNdaMcyHYxiIoS9DzUHXc1z3WzkMNAI5jyzoPJfGrnYeSuI35rwZdE9Fc25HPWmsHPdOTHZoMPI6p56G4Xjtm5urGPKy7DvDnAPknxDwF/RPC/7F/ljvsl89xknVJFOnzf/HRQp15uir53spnnoaSz0048zQQ9szT7Nx5dRj+vPCvCcM/KPw3hOEvCf+NIfhz2aycCetNAlH2JrXfHk9FleOaNdZp79Fu1u8ep0hP2qMenFfx2Bbo99LLZx6Wgp3aPUU+k4VrX+1MAuN53sb8Xc0pb8X5NO032lB/4HMAo/w7ds9J/se27CCd2rkU7X6g4LXfmEYMn53AvW72CcryPfS9yf+4DMen5votzO8XzN4L1+6hafv3fA/tdrB5RUr3QxTZ8062AfFYbrFH+72VPpKz7t1o3HzWoNp9m5RSzraosl0jh3a/zmMbUO8vpxSdrnMN95BdeH85Fdk+i/8yil68v9xFejOkN46hkymGxLaeSO9f+Hc+Ap1jyrMf01Fl3KJ+vud2OPl/5LfBks8y9mn9fYx7CpUF18zW/T7t/Iw/Xwyo52es+ND6sCjyN0flOH5S8j/266kpt6+XKL5u9f72aVC2FVC2OGl7Fs04e3QG+RjHujTZpI0J2vn6eseETFQZ8/ybntq5XuzHWQ/awmOI9puebPuR8hP+2cn/2LZ8aq592u/yxXIyl+lX9Lh+m7Ta3Ebbh8JzgQ8SL96/1MZyWV+lCf9z4Hxu8jnkPspDaZR9oZ37Ep1oT5hnOWbHZYkB1/nj9miuDwX/wmhuXUgsYh2nFR7Bdyt6MZ753Fc36cVxWfMjrt20ve3Ioy+1fdAU6Q70jNBYivRFUW1722H28+y9bfQPr4EDxfloPNfj39+KE+6NaGfVMV60fgnnRK+G67X0S7Lvxv3S64Hztcln7Tw3ntlmnW0OndLHar+3ynsgXHdxwr0qju1Qdcd9Rb3n49+a/NfWgdWefeJxUzsjbP0+Je5x8HnTas9nTMzoumt9PkPw70n+47ge+Ddcy3U239+Afz/YzHWm/e6yVWe1/r669kwAr6vrfaZG9NRaZ4L/aDRbfq6zQL8XWa4zbf6/VPEJz/8/ATbXst9i1Vm1uTXXmfbbpbXWGe7vo55a60zwn4lmy3+01NnnweZm1xnK8x6Za58ZxzR8/lqT6zI4ux2cWv/eqZTBihWtz+dY+WryH2PFKld3jeXq8VSunjrLJfhvBSpXm6NcbXWWq7tKuVzrje8q5WrWc/bavEebq7LNPwCbrf0YmQMuxH4MPjefBr1YriiqrKs41Ts3499hx9iz7gfyfa5qZ1YmZqI5ZUwpenC9oPWH/Hvlgc5EVdwr09YqqJ/vZaUSULUYw3VenDpmgpRHjTHcA+AYq/Zb9hxjWkzyfl2cMpE9jtUTR1pMWmtSjDHZK2v151mOSwgeac+zHG3Pkyz0uXvf+qfGhqfHBgcnc4NjxdJYbnghn6c5OyGI2+W51FemFX0xbtDApRz/j3Ao1zpm5l5r9edppFNp5edpLqJ+C8vuez/1iE7ix2tsm8ROKzynN5p8Pqqfp8mN5Jv1PE2QffncYDbsOefZ52kmZubyR6S3nXCaDM9tEBP2vHM+7DsecwPTge8HDYrfcC7brpQJnxHAupJ87X8UReq9pfJ56ChgDMO9Ja1s2v6Udg+b73VoXOk6uRayTtHX/NxHrc8cpCkPxzJ85uBMwGltUHAXw+dLyEch++dQ/UKclkfu9RbPD6NIn1eJXxfqOYWLku+t/JzC2cnnnuQPn3Wx2gGuqflenLZ+DtxmB1JRZb/E/Qvqj/eHVySfDx46cH9p7T2rn1CaOnzozgP3rCpM3VHCTphJIqXwkpeC665BmWXaAY8JHx7pmJmLH0+uZxtIPjYURpLvC72hIJ3l0f0geb7QrIlvoIY4FPqhA23iqz1sIDG8embWl6tn5trEhy3wM2NuBAweZomTNYHWHuhcTXnY3tZQHj58cwPlYccsNsUd+AnR7OcVYGOc8GH68oARBZ3kj4V9qDGbsx5qlEFtZfK9Fz6X7rnvcOlwacvhybvvnFpz+J6ph3v/u+/mzh8DDBM/scRyWkeP3/nJqrTC65Lna65gRPuPhgHljOT7Qg8oj4idlKTxYQo1oARq3EOLOynVU/CdlOQp3YATh8WdlGhxJ+WY20mBydHiTsriTsriTgrkpeC6a1Be3Empnuqd+Moj6Ef5xHdycSfFTos7KdV3UqRjiz+fBDbGSdtJkTx8HaHYG/bVWrMTiUALgAHr5/ICv+IoJwPqNeBnjFfRiX4O1G4GU6QvivTFRav+bFk8YC9PPk89tNm15f47H1c4VJL9LywC0rYpRXQN4a24L6Y92VfLE+DaMJlxyMdJ68JSjv+iJ6qiR7NZ6w7nqyfwHk6WnwhFXYG7rSGti4/Ih1Y9ak8tpBQuLQZxDToBvIxje7S1sTYH5/rS9kuqrb3Z72HfTJod1rpuLj+f4MY819MqnLT6wLdx1lMf2lMK2j57O+WhffgUcasvRVYl3xd6KYJDfn9UGbvct2M9cd8Wer0scYFPdmj7lmnCr0/+x2XdTmWr9al+tgHxWO4O8he28c4adOO4zE/g4hP69ZR/a/I/Lv+u5LM27rVTXpvCbb3R5JF46v+YPB08MFU4qu9pDYwOL97Tqp6C39MaGB1avKc177R4T8soN9fpEczMbN4j+p5W0j+H6hfitHhPa1b/4j2tqmnxntZ80iPpnpZsGnQp9vgMtC7QGYA/iwu8iMqCetkHHYpcyvG9jf5bWL6O1/qUPOGU/We0l38qWf6vAN4Qi5QTwvCrdbUCPp9A5UR/j3uyQfjak//aJihv2uPkAe1L+bcvF1HSNqklScycANfEn8eRrYE2L7PCH+pejvCHunelxeScV8Mk/7V64Mkit1PPthbKEzmwoZ10so2I0fq8NvrOY257DVgtNiWvPGEz5LoUW/EaLxwiBV+e/CX/0w4u3JREfCdhQ9XhcsUmsf3/AxC8CPBIiBUA",
      "debug_symbols": "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dPDKEh28skCHfftEOnhliQ5eWaKDV5boeOgIdPDKEh28skQHryzRwStLdPDKAh327RPp4JUlOnhliQ5eWaLjoSPQwStLdPDKEh28skQHryzRwSvX6UT27RPp4JUlOnhliQ5eWaLjoSPQwStLdPDKEh28skQHryzRwSsLdNi3T6SDV5bo4JUlOnhliY6HjkAHryzRwStLdPDKEh28skQHryzQYd8+kQ5eWaKDV5bo4JUlOh46Ah28skQHryzRwStLdPDKEh28skCHfftEOnhliQ5eWaKDV5boeOgIdPDKEh28skQHryzRwStLdPDKAh327RPp4JUlOnhliQ5eWaLjoSPQwStLdPDKEh28skQHryzRwSsLdNi3T6SDV5bo4JUlOnhliY6HjkAHryzRwStLdPDKEh28skQHryzQYd8+kQ5eWaKDV5bo4JUlOh46Ah28skQHryzRwStLdPDKEh28skCHfftEOnhliQ5eWaKDV5boeOgIdPDKEh28skQHryzRwStLdPDKAh327RPp4JUlOnhliQ5eWaLjoSPQwStLdPDKEh28skQHryzRwSsLdNi3T6SDV5bo4JUlOnhliY6HjkAHryzRwStLdPDKEh28skQHr1ynk9i3T6SDV5bo4JUlOnhliY6HjkAHryzRwStLdPDKEh28skQHryzQYd8+kQ5eWaKDV5bo4JUlOh46Ah28skQHryzRwStLdPDKEh28skCHfftEOnhliQ5eWaKDV5boeOgIdPDKEh28skQHryzRwStLdPDKAh327RPp4JUlOnhliQ5eWaLjoSPQwStLdPDKEh28skQHryzRwSsLdNi3T6SDV5bo4JUlOnhliY6HjkAHryzRwStLdPDKEh28skQHryzQYd8+kQ5eWaKDV5bo4JUlOh46Ah28skQHryzRwStLdPDKEh28skCHfftEOnhliQ5eWaKDV5boeOgIdPDKEh28skQHryzRwStLdPDKAh327RPp4JUlOnhliQ5eWaLjoSPQwStLdPDKEh28skQHryzRwSsLdNi3T6SDV5bo4JUlOnhliY6HjkAHryzRwStLdPDKEh28skQHryzQYd8+kQ5eWaKDV5bo4JUlOh46Ah28skQHryzRwStLdPDKEh28cp3Ozr59Ih28skQHryzRwStLdDx0BDp4ZYkOXlmig1eW6OCVJTp4ZYEO+/aJdPDKEh28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55/++tDvyd7iyZt7jif/dDzbIx5jPsbzfPC++fdjd5fvh9risXmP78fm/Puxb9f5098Ivuw6zSLXaRe5TrfIdfpFrjMscp1xketMi1znvsh1LuKH4iJ+KC7ih+IifihO44fi7VizbbZwoX6VC53GEbUudBpL1LrQaTxR60KnMUWtCx3qit5OkbbxpzDjT2HHn8KNP4Uff4ow/hRx/CnS+FPs408xvnfv43v3Pr537+N79z6+d+/je/c+vnfv43v3Pr537+N79z6+d+fxvTuP7915fO/O43t3Ht+78/jencf37jy+d+fxvTsP791p28afwow/hR1/Cjf+FH78KcL4U8Txp0jjT7GPP8X43m3G924zvneb8b3bjO/dZnzvNuN7txnfu8343m3G924zvnfb8b3bju/ddnzvtuN7tx3fu+343m3H9247vnfb8b3bju/dbnzvduN7txvfu9343u3G9243vne78b3bje/dbnzvduN7tx/fu/343u3H924/vnf78b3bj+/dfnzv9uN7tx/fu/343h3G9+4wvneH8b07jO/dYXzvDuN7dxjfu8P43h3G9+4wvnfH8b07ju/dcXzvjuN7dxzfu+P43h3H9+44vnfH8b17/Ltqafy7amn8u2pp/Ltqafy7amn8u2pp/Ltqafy7aqnDu2rBhdvHzSHELB/c76X/1OEduJeFnk8beod39l4Wujlv6Pa8obvzhu7PG3o4b+jxvKGf9266n/duup/3bprPezfN572b5vPeTbPmu6n8vVjq8BLy62LXfD9txa75htqKXfMdtRW75ltqK/ah99Rfp9i3bfwpzPhT2PGncONP4cefIow/RRx/ijT+FPv4U4zv3WZ87zbje3eHd69D2G97K8fojHywvA/z3uENZyGc6yn28afIw0/R4Q3n5im+r760OXM7eAuNu7tNJr0fbJN9rCEa3Xs8Vlk8Tlk8Xlk8QVk8UVk8SVk8u7J48k/H4/09nhif4unw2nnfeIyyeH54fHYm3g52l/ncczxOWTxeWTxBWTzxp+MJVoznh8cf56K7xeOSfYrHb8riMcriscri+enxx4XtHk/8LZ7CPGy7d0a/FcTvverg9/uCcFt+vhP5cBbypeB/ehh0+Xaw8x+2Sjgmm6Q6+IZs9rOQLwX/03crb/d78GF7iidsyuIxyuKxyuJxr4zHP8fjlcUTlMUT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",
      "brillig_names": [
        "discover_new_notes",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "_trigger_settlement",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13594925270014003382": {
            "error_kind": "string",
            "string": "Function _trigger_settlement can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_trigger_settlement"]
    },
    {
      "name": "get_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6017907102598075401": {
            "error_kind": "string",
            "string": "Function get_order_status can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBnJwAABAMnAgIEICcCAwQAHxgAAwACgEYdAIBGgEYCHQCAR4BHAh0AgEiASAIdAIBJgEkCHQCASoBKAh0AgEuASwIdAIBMgEwCHQCATYBNAh0AgE6ATgIdAIBPgE8CHQCAUIBQAh0AgFGAUQIdAIBSgFICHQCAU4BTAh0AgFSAVAIdAIBVgFUCHQCAVoBWAh0AgFeAVwIdAIBYgFgCHQCAWYBZAh0AgFqAWgIdAIBbgFsCHQCAXIBcAh0AgF2AXQIdAIBegF4CHQCAX4BfAh0AgGCAYAIdAIBhgGECHQCAYoBiAh0AgGOAYwIdAIBkgGQCHQCAZYBlAigCAAEEgEYnAgMEIC0IAQInAgQEIQAQAQQBJwMCBAEAKAICBC4EAAGAAy4EAASABC4EAAOABSUAAAFkLQwCASUAAAGqJQAAAcAuBAABgGYoAgACBIBmJwIDBAE7DQACAAMBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAAAakuAYAIgAYuAoAGgAkBAIAIAAKACAEAgAkAAoAJIwAAAXgmKACAQwQAAygAgEQEAAAoAIBFBAABJiUAAAX6HgIAAwAeAgAEADM4AAMABAAFJwIDAQEkAgAFAAAB6SUAAAYjHgIABAknAgUAAQo4BAUGJAIABgAAAgUlAAAGNS0IAQQAAAECAS0OBQQtCAEFAAABAgEnAgYAAC0OBgUnAgcEHycCCAQgKAIACQABAC4IgEQAAiMAAAJADDgCCAokAgAKAAAFiSMAAAJSLQ0FAicCBAAFLQgBBScCBwQDABABBwEnAwUEAQAoBQIHLQwHCC0OBAgAKAgCCC0OAggtCAECJwIEBAQAEAEEAScDAgQBACgCAgQtDAQHLQ4GBwAoBwIHLQ4GBwAoBwIHLQ4GBy0NAgQAKAQCBC0OBAIrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEHJwIIBAUAEAEIAScDBwQBACgHAggtDAgJLQ4GCQAoCQIJLQ4GCQAoCQIJLQ4GCQAoCQIJLQ4ECS0NAgQAKAQCBC0OBAItCAEEAAABAgEtDgIELQ0HAgAoAgICLQ4CBy0IAQIAAAECAS0OBwItCAEHAAABAgEuCoBEAActCAEIAAABAgEnAgkBAC0OCQgnAgoEAi4IgEQAASMAAAN4DDgBCgskAgALAAAEJCMAAAOKLQ0IAQo4AQkFJAIABQAAA6QnAgoEADwJAQonAgEECi0IAAotDAQLLQwCDC0MBw0tDAgOABAAAQAlAAAGRy0EAAAtDQQBLQ0CBS0NBwotDgEELQ4FAi0OCgctDgMIASgABYBFAAItDQIBCjgBBgIKOAIJAyQCAAMAAAQKJQAAB58vDAABAAIcDAIDBBwMAwEAHAwBAgQtDAIBJiQCAAsAAAQxIwAABXgnAgwEAgw4AQwNJAIADQAABEglAAAHsQAoBQIMADgMAQ0tDQ0LLQ0HDC0NCA0KOA0JDiQCAA4AAAR0JwIPBAA8CQEPCygADIBDAA0kAgANAAAFBSMAAASJLQ0EDC0NAg0tDQcOLQ0IDycCEQQDDDgOERIkAgASAAAEsCUAAAexLgQADIADKACABAQABCUAAAfDLgiABQAQACgQAhEAOBEOEi0OCxIBKAAOgEUACw44DgsMJAIADAAABPAlAAAIUS0OEAQtDg0CLQ4LBy0ODwgjAAAFeCcCDAQNLQgADS0MBA4tDAIPLQwHEC0MCBEAEAAMACUAAAZHLQQAAC0NBAwtDQINLQ0IDi4EAAyAAygAgAQEAAQlAAAHwy4IgAUADwAoDwIQASgAEIBEABEtDgsRLQ4PBC0ODQIuCoBFAActDg4IIwAABXgBKAABgEUACy0MCwEjAAADeC0NBQoCOAcCCw44AgcMJAIADAAABaQlAAAIYycCDQQgDDgLDQ4kAgAOAAAFuyUAAAexACgBAg0AOA0LDi0NDgwcDAwLAC0NBAwEOAsMDQA4Cg0LLQ4LBQQ4DAkKLQ4KBAEoAAKARQAKLQwKAiMAAAJAKACABAR4AA0AAACABIADJACAAwAABiIqAQABBfeh86+lrdTKPAEBAiYqAQABBb4eP/8+pPb6PAEBAiYqAQABBVOD5qAlqJQJPAEBAiYlAAAF+i4IgEQABSMAAAZXDSgABYBDAAYkAgAGAAAGxyMAAAZsLQ0BBS0NAgYtDQMHLQ0ECCcCCQQELQgBCicCCwQFABABCwEnAwoEAQAoBgILJwIMBAQAKAoCDT8PAAsADS0NCgYAKAYCBi0OBgotDgUBLQ4KAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWARQAGJAIABwAABuUjAAAHli0NAQctDQIILQ0DCS0NBAonAgwEBAw4BQwNJAIADQAABwwlAAAHsQAoCAIMADgMBQ0tDQ0LJwINBAMMOAUNDiQCAA4AAAcxJQAAB7EAKAcCDQA4DQUOLQ0ODAA4CwwNJwIMBAQMOAUMDiQCAA4AAAdbJQAAB7EuBAAIgAMoAIAEBAAFJQAAB8MuCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAAHli0MBgUjAAAGVyoBAAEFAtxuJ4B2Ep08AQECJioBAAEF6J0J/qERLQ48AQECJi4BgAOABgsAgAYAAoAHJACABwAAB94jAAAH6S4AgAOABSMAAAhQLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAACDwuAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAACAsoAYAFBAABAwCABgACgAYjAAAIUCYqAQABBUWnynEZQeQVPAEBAiYqAQABBSiGkrBH3P1DPAEBAiYuABjKGMo=",
      "debug_symbols": "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",
      "brillig_names": ["get_order_status"]
    },
    {
      "name": "get_filled_order_block_number",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5048864367174250545": {
            "error_kind": "string",
            "string": "Function get_filled_order_block_number can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["get_filled_order_block_number"]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "AztecGateway7683"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claimable_orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "open_orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "order_status",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "used_nonces",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "filled_orders_block_numbers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "order_data",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_assert_nonce_and_set_order_details_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_assert_nonce_and_set_order_details_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "status",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_check_order_status_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_check_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::get_filled_order_block_number_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_filled_order_block_number_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_check_order_commitment_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_check_order_commitment_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::fill_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::fill_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::claim_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::claim_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_trigger_settlement_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_trigger_settlement_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::fill_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::fill_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "fill_deadline",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        },
                        {
                          "name": "order_data_type",
                          "type": {
                            "kind": "array",
                            "length": 32,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        },
                        {
                          "name": "order_data",
                          "type": {
                            "kind": "array",
                            "length": 301,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::open_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::open_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "fill_deadline",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        },
                        {
                          "name": "order_data_type",
                          "type": {
                            "kind": "array",
                            "length": 32,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        },
                        {
                          "name": "order_data",
                          "type": {
                            "kind": "array",
                            "length": 301,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::open_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::open_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "status",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_update_order_status_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_update_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "resolved_order_bytes",
                    "type": {
                      "kind": "array",
                      "length": 613,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_emit_open_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_emit_open_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::get_order_status_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_order_status_abi"
        }
      ]
    }
  },
  "file_map": {
    "110": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "114": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "117": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "118": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "121": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\n    // Top-level unconstrained fns are contract entrypoints, but they're not explicitly designated in any way. They're\n    // the fallback case for a function that matches no other rules.\n    // TODO(#12743): improve this\n\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\n    // public, but which *are* contract entrypoints (i.e. they're not opting out via the #[test] or\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\n        !is_fn_private(f)\n            & !is_fn_public(f)\n            & !f.has_named_attribute(\"contract_library_method\")\n            & !f.has_named_attribute(\"test\")\n    });\n\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\n    // https://github.com/noir-lang/noir/issues/7714). We can't simply print a message since that'd otherwise break the\n    // output of utils such as `nargo test --list-tests`.\n    // // We don't expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr's\n    // // #[private] macro, possibly resulting in a non-standard interface).\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n    //     !f.is_unconstrained()\n    // }) {\n    //     let name = f.name();\n    //     warn(\n    //         f\"found private contract function '{name}' which does not have the #[private] attribute - make sure you know what you're doing!\",\n    //     );\n    // }\n\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n        f.is_unconstrained()\n    }) {\n        transform_top_level_unconstrained(f);\n    }\n}\n\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n"
    },
    "122": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{\n    stub_registry,\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\n};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    find_and_transform_top_level_unconstrained_fns(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The note discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_ciphertext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let note_discovery_call = create_note_discovery_call();\n    quote {\n        unconstrained fn sync_notes() {\n            // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n            // unconstrained execution context since it will not be available otherwise.\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n            $note_discovery_call\n        }\n    }\n}\n"
    },
    "123": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/notes/mod.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "124": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr",
      "source": "use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "125": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ.get_trait_impl(trait_constraint).expect(f\"Type does not implement trait\").methods().filter(\n        |m| m.name() == target_method,\n    )[0]\n        .as_typed_expr()\n}\n"
    },
    "136": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "139": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "142": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "143": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "144": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "145": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "146": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "147": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n    traits::{Deserialize, FromField},\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "152": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::{\n    abis::validation_requests::{\n        key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n    },\n    traits::Deserialize,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "153": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "156": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "159": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress,\n    point::{Point, POINT_LENGTH},\n    traits::Deserialize,\n};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(\n    address: AztecAddress,\n    ephPk: Point,\n) -> [Field; POINT_LENGTH] {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    let fields = get_shared_secret_oracle(address, ephPk);\n    Point::deserialize(fields)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "162": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "169": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "184": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "186": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "187": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "188": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "191": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "193": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "195": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "199": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "217": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "253": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "260": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "261": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "277": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "278": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "292": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "294": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "295": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "304": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "315": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "329": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "333": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "334": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "350": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "351": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "353": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "365": {
      "path": "/Users/eidoo/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "394": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    encrypted_logs::log_assembly_strategies::default_aes128,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        // TODO: we're abusing the note encoding scheme by computing the log for a fake note type with such a note type\n        // id that the recipient will realize that these are the private fields of a partial note. Ideally we'd not rely\n        // on this crude mechanism and we'd instead compute it as a proper event log. However, given the current state\n        // of the log library it's far easier to do it this way.\n        let encrypted_log = default_aes128::note::compute_log(\n            *context,\n            private_log_content,\n            storage_slot,\n            recipient,\n            sender,\n        );\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        // We abuse the fact that note type ids are 7 bits long to use the 8th bit indicate the log corresponds to a\n        // partial note. Ideally we'd use proper events with selectors, but those are not handled well at the moment.\n        UintNote::get_id() + 128\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "55": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/main.nr",
      "source": "mod config;\nmod types;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract AztecGateway7683 {\n    // context.chain_id() returns 1, which corresponds to the mainnet, making it unsuitable for our use case.\n    // Instead, we designate 999999 as the destination domain.\n    global LOCAL_DESTINATION_DOMAIN: u32 = 999999;\n\n    global UNKNOWN: u32 = 0;\n    global OPENED: u32 = 1;\n    global FILLED: u32 = 2;\n    global INITIATED_PRIVATELY: u32 = 3;\n\n    global SETTLE_ORDER_TYPE: [u8; 32] = [\n        25, 30, 167, 118, 189, 110, 12, 213, 106, 109, 68, 186, 74, 234, 47, 236, 70, 139, 74, 11,\n        76, 29, 136, 13, 64, 37, 146, 158, 235, 97, 93, 13,\n    ]; // sha256(\"SETTLE_ORDER_TYPE\")\n\n    use crate::{\n        config::Config,\n        types::{\n            events::{Filled, Open},\n            helpers::InternalRCOParams,\n            onchain_cross_chain_order::OnchainCrossChainOrder,\n            order_data::{\n                ORDER_DATA_LENGTH, ORDER_DATA_TYPE, OrderData, PRIVATE_ORDER, PUBLIC_ORDER,\n            },\n            resolved_cross_chain_order::{\n                FILL_INSTRUCTIONS_MAX_INSTRUCTIONS, FillInstruction, MAX_SPENT_MAX_OUTPUTS,\n                MIN_RECEIVED_MAX_OUTPUTS, Output, RESOLVED_CROSS_CHAIN_LENGTH,\n                ResolvedCrossChainOrder,\n            },\n        },\n        utils::{u32_to_u8_4, u8_32_to_aztec_address, u8_32_to_u128},\n    };\n    use dep::aztec::{\n        macros::{functions::{initializer, internal, private, public, view}, storage::storage},\n        prelude::{AztecAddress, EthAddress, Map, PublicImmutable, PublicMutable},\n        protocol_types::{hash::sha256_to_field, traits::{Packable, Serialize}},\n    };\n    use token::Token;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n        claimable_orders: Map<Field, PublicMutable<Field, Context>, Context>,\n        open_orders: Map<Field, PublicMutable<[u8; 32], Context>, Context>,\n        order_status: Map<Field, PublicMutable<u32, Context>, Context>,\n        used_nonces: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n        filled_orders_block_numbers: Map<Field, PublicMutable<Field, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(portal: EthAddress) {\n        storage.config.initialize(Config { portal });\n    }\n\n    #[public]\n    fn open(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, \"Invalid order data type\");\n\n        let data = _resolve(order, context.msg_sender(), context.timestamp());\n        let order_data = data.order_data;\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(order_data.sender_nonce);\n\n        assert(order_data.order_type == PUBLIC_ORDER, \"Not a public order\");\n        assert(order_data.origin_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order origin domain\");\n        assert(!storage.used_nonces.at(context.msg_sender()).at(nonce).read(), \"Invalid nonce\");\n\n        // We cannot store the entire order_data + ORDER_DATA_TYPE as it raises the following error:\n        // Reached the limit (63) on number of 'public data (contract storage) write' per tx 'storage_write_opcode(storage_slot, value).\n        // For this reason we store a commitment of it.\n        storage.open_orders.at(order_id).write(_get_open_order_commitment(order.order_data));\n        storage.order_status.at(order_id).write(OPENED);\n        storage.used_nonces.at(context.msg_sender()).at(nonce).write(true);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n\n            Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_in_public(\n                    context.msg_sender(),\n                    context.this_address(),\n                    u8_32_to_u128(min_received.amount),\n                    nonce,\n                )\n                .call(&mut context);\n        }\n\n        let event = Open::new(data.order_id_bytes, resolved_order.serialize());\n        context.emit_public_log(event.open1.pack());\n        context.emit_public_log(event.open2.pack());\n    }\n\n    #[private]\n    fn open_private(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, \"Invalid order data type\");\n\n        // NOTE: Force the sender to be zero in order to avoid creating a connection between the sender and the recipient.\n        let data = _resolve(order, AztecAddress::zero(), 0 as u64);\n        let order_data = data.order_data;\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(order_data.sender_nonce);\n\n        assert(order_data.order_type == PRIVATE_ORDER, \"Not a private order\");\n        assert(order_data.origin_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order origin domain\");\n        AztecGateway7683::at(context.this_address())\n            ._assert_nonce_and_set_order_details(order_id, order.order_data, nonce)\n            .enqueue(&mut context);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n\n            Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_in_private(\n                    context.msg_sender(),\n                    context.this_address(),\n                    u8_32_to_u128(min_received.amount),\n                    nonce,\n                )\n                .call(&mut context);\n        }\n\n        AztecGateway7683::at(context.this_address())\n            ._emit_open(data.order_id_bytes, resolved_order.serialize())\n            .enqueue(&mut context);\n    }\n\n    #[private]\n    fn claim_private(\n        secret: [u8; 32],\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n\n        AztecGateway7683::at(context.this_address())\n            ._check_order_status(order_id, INITIATED_PRIVATELY)\n            .enqueue(&mut context);\n\n        // verify that a commitment exists for the given order.\n        AztecGateway7683::at(context.this_address())\n            ._check_order_commitment(order_id, origin_data_bytes, filler_data_bytes)\n            .enqueue(&mut context);\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        // if a commitment exists, the order is valid, allowing us to compare the recipient with hash(secret).\n        assert(sha256::digest(secret) == order_data.recipient, \"Invalid secret\");\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_to_private(context.msg_sender(), u8_32_to_u128(order_data.amount_out))\n            .call(&mut context);\n\n        AztecGateway7683::at(context.this_address())._update_order_status(order_id, FILLED).enqueue(\n            &mut context,\n        );\n\n        // TODO: store filled order\n\n        AztecGateway7683::at(context.this_address())\n            ._trigger_settlement(\n                order_id,\n                order_id_bytes,\n                filler_data_bytes, // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn fill(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        AztecGateway7683::at(context.this_address())._check_order_status(order_id, UNKNOWN).call(\n            &mut context,\n        );\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_data.order_type == PUBLIC_ORDER, \"Not a public order\");\n        assert(order_id_bytes == sha256::digest(origin_data_bytes), \"Invalid order id\");\n        assert(context.timestamp() as u32 <= order_data.fill_deadline, \"Order fill expired\");\n        assert(\n            order_data.destination_domain == LOCAL_DESTINATION_DOMAIN,\n            \"Invalid order destination domain\",\n        );\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_in_public(\n                context.msg_sender(),\n                u8_32_to_aztec_address(order_data.recipient),\n                u8_32_to_u128(order_data.amount_out),\n                Field::from_be_bytes(order_data.sender_nonce),\n            )\n            .call(&mut context);\n\n        storage.order_status.at(order_id).write(FILLED);\n        // TODO: store filled order\n\n        AztecGateway7683::at(context.this_address())\n            ._trigger_settlement(\n                order_id,\n                order_id_bytes,\n                filler_data_bytes, // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n            )\n            .call(&mut context);\n\n        context.emit_public_log(Filled {\n            order_id: order_id_bytes,\n            origin_data: origin_data_bytes,\n            filler_data: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[public]\n    fn fill_private(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        AztecGateway7683::at(context.this_address())._check_order_status(order_id, UNKNOWN).call(\n            &mut context,\n        );\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_data.order_type == PRIVATE_ORDER, \"Not a private order\");\n        assert(order_id_bytes == sha256::digest(origin_data_bytes), \"Invalid order id\");\n        assert(context.timestamp() as u32 <= order_data.fill_deadline, \"Order fill expired\");\n        assert(order_data.destination_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order domain\");\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_in_public(\n                context.msg_sender(),\n                context.this_address(),\n                u8_32_to_u128(order_data.amount_out),\n                0,\n            )\n            .call(&mut context);\n\n        storage.claimable_orders.at(order_id).write(sha256_to_field(_get_order_pre_image(\n            origin_data_bytes,\n            filler_data_bytes,\n        )));\n        storage.order_status.at(order_id).write(INITIATED_PRIVATELY);\n\n        context.emit_public_log(Filled {\n            order_id: order_id_bytes,\n            origin_data: origin_data_bytes,\n            filler_data: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[public]\n    #[view]\n    fn get_order_status(order_id_bytes: [u8; 32]) -> u32 {\n        storage.order_status.at(Field::from_be_bytes(order_id_bytes)).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_filled_order_block_number(order_id_bytes: [u8; 32]) -> Field {\n        storage.filled_orders_block_numbers.at(Field::from_be_bytes(order_id_bytes)).read()\n    }\n\n    #[internal]\n    #[public]\n    fn _assert_nonce_and_set_order_details(\n        order_id: Field,\n        order_data: [u8; ORDER_DATA_LENGTH],\n        nonce: Field,\n    ) {\n        assert(!storage.used_nonces.at(context.msg_sender()).at(nonce).read(), \"Invalid nonce\");\n        // We cannot store the entire order_data + ORDER_DATA_TYPE as it raises the following error:\n        // Reached the limit (63) on number of 'public data (contract storage) write' per tx 'storage_write_opcode(storage_slot, value).\n        // For this reason we store a commitment of it.\n        storage.open_orders.at(order_id).write(_get_open_order_commitment(order_data));\n        storage.order_status.at(order_id).write(OPENED);\n        storage.used_nonces.at(context.msg_sender()).at(nonce).write(true);\n    }\n\n    #[contract_library_method]\n    fn _get_open_order_commitment(order_data: [u8; ORDER_DATA_LENGTH]) -> [u8; 32] {\n        let mut data: [u8; ORDER_DATA_LENGTH + 32] = [0; ORDER_DATA_LENGTH + 32];\n        for i in 0..32 {\n            data[i] = ORDER_DATA_TYPE[i];\n        }\n        for i in 0..ORDER_DATA_LENGTH {\n            data[i + 32] = order_data[i];\n        }\n        sha256::digest(data)\n    }\n\n    #[public]\n    #[internal]\n    fn _check_order_status(order_id: Field, status: u32) {\n        assert(storage.order_status.at(order_id).read() == status, \"Invalid order status\");\n    }\n\n    #[public]\n    #[internal]\n    fn _check_order_commitment(\n        order_id: Field,\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_commitment = storage.claimable_orders.at(order_id).read();\n        assert(\n            order_commitment\n                == sha256_to_field(_get_order_pre_image(origin_data_bytes, filler_data_bytes)),\n            \"Invalid order\",\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _emit_open(\n        order_id_bytes: [u8; 32],\n        resolved_order_bytes: [Field; RESOLVED_CROSS_CHAIN_LENGTH],\n    ) {\n        let event = Open::new(order_id_bytes, resolved_order_bytes);\n        context.emit_public_log(event.open1.pack());\n        context.emit_public_log(event.open2.pack());\n    }\n\n    #[public]\n    #[internal]\n    fn _trigger_settlement(order_id: Field, order_id_bytes: [u8; 32], filler_data: [u8; 32]) {\n        storage.filled_orders_block_numbers.at(order_id).write(context.block_number());\n\n        let mut settlement_message_bytes: [u8; 96] = [0; 96];\n\n        for i in 0..32 {\n            settlement_message_bytes[i] = SETTLE_ORDER_TYPE[i]; // order_type\n            settlement_message_bytes[i + 32] = order_id_bytes[i]; // order_id_bytes\n            settlement_message_bytes[i + 64] = filler_data[i]; // recipient\n        }\n\n        let config = storage.config.read();\n        context.message_portal(config.portal, sha256_to_field(settlement_message_bytes));\n    }\n\n    #[contract_library_method]\n    fn _resolve(\n        order: OnchainCrossChainOrder,\n        sender: AztecAddress,\n        timestamp: u64,\n    ) -> InternalRCOParams {\n        let mut order_data = OrderData::decode(order.order_data);\n\n        assert(order_data.fill_deadline == order.fill_deadline, \"Invalid fill deadline\");\n        assert(u8_32_to_aztec_address(order_data.sender) == sender, \"Invalid order sender\");\n\n        let order_id_bytes = sha256::digest(order.order_data);\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        let destination_domain_bytes = u32_to_u8_4(order_data.destination_domain);\n\n        let min_received_output = Output {\n            token: order_data.input_token,\n            recipient: [0; 32],\n            amount: order_data.amount_in,\n            chain_id: u32_to_u8_4(order_data.origin_domain),\n        };\n        let min_received: [Output; MIN_RECEIVED_MAX_OUTPUTS] =\n            [min_received_output; MIN_RECEIVED_MAX_OUTPUTS];\n\n        let max_spent_output = Output {\n            token: order_data.output_token,\n            recipient: order_data.recipient,\n            amount: order_data.amount_out,\n            chain_id: destination_domain_bytes,\n        };\n        let max_spent: [Output; MAX_SPENT_MAX_OUTPUTS] = [max_spent_output; MAX_SPENT_MAX_OUTPUTS];\n\n        let fill_instruction = FillInstruction {\n            destination_chain_id: destination_domain_bytes,\n            destination_settler: order_data.destination_settler,\n            origin_data: order.order_data,\n        };\n        let fill_instructions: [FillInstruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS] =\n            [fill_instruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS];\n\n        let resolved_order = ResolvedCrossChainOrder {\n            user: order_data.sender,\n            origin_chain_id: u32_to_u8_4(LOCAL_DESTINATION_DOMAIN),\n            open_deadline: u32_to_u8_4(timestamp as u32),\n            fill_deadline: u32_to_u8_4(order.fill_deadline),\n            order_id: order_id_bytes,\n            min_received,\n            max_spent,\n            fill_instructions,\n        };\n\n        InternalRCOParams {\n            order_id_bytes,\n            order_id,\n            resolved_cross_chain_order: resolved_order,\n            order_data,\n        }\n    }\n\n    #[contract_library_method]\n    fn _get_order_pre_image(\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) -> [u8; ORDER_DATA_LENGTH + 32] {\n        let mut pre_image: [u8; ORDER_DATA_LENGTH + 32] = [0; ORDER_DATA_LENGTH + 32];\n        for i in 0..ORDER_DATA_LENGTH {\n            pre_image[i] = origin_data_bytes[i];\n        }\n        for i in 0..32 {\n            pre_image[i + ORDER_DATA_LENGTH] = filler_data_bytes[i];\n        }\n        pre_image\n    }\n\n    #[public]\n    #[internal]\n    fn _update_order_status(order_id: Field, status: u32) {\n        storage.order_status.at(order_id).write(status);\n    }\n}\n"
    },
    "56": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/types/events.nr",
      "source": "use crate::types::{\n    order_data::ORDER_DATA_LENGTH, resolved_cross_chain_order::RESOLVED_CROSS_CHAIN_LENGTH,\n};\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n// #[event]\n#[derive(Serialize)]\npub struct Filled {\n    pub order_id: [u8; 32],\n    pub origin_data: [u8; ORDER_DATA_LENGTH],\n    pub filler_data: [u8; 32],\n}\n\n// 301 + 32 + 32 = 365      365 / 31 = 11.74 = 12 + 1 (residual bytes) = 13\nimpl Packable<13> for Filled {\n    fn pack(self) -> [Field; 13] {\n        let mut result = [0; 13];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        let mut filler_data_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n            filler_data_31[i] = self.filler_data[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n        residual_bytes[10] = self.filler_data[31];\n\n        for i in 0..10 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < ORDER_DATA_LENGTH {\n                    partial[j] = self.origin_data[k];\n                }\n            }\n            result[i + 1] = Field::from_be_bytes(partial);\n\n            if i < 9 {\n                // no residual bytes for the last one\n                residual_bytes[i + 1] = self.origin_data[offset + 31];\n            }\n        }\n\n        result[0] = Field::from_be_bytes::<31>(order_id_31);\n        result[11] = Field::from_be_bytes::<31>(filler_data_31);\n        result[12] = Field::from_be_bytes::<31>(residual_bytes);\n        result\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], origin_data: [0; ORDER_DATA_LENGTH], filler_data: [0; 32] }\n    }\n}\n\n// #[event]\n#[derive(Serialize)]\npub struct Open1 {\n    pub order_id: [u8; 32],\n    pub resolved_order: [u8; 340],\n}\n\nimpl Packable<13> for Open1 {\n    fn pack(self) -> [Field; 13] {\n        let mut result = [0; 13];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n\n        for i in 0..12 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < 340 {\n                    partial[j] = self.resolved_order[k];\n                }\n            }\n            result[i + 1] = Field::from_be_bytes(partial);\n\n            let residual_bytes_offset = offset + 31;\n            if residual_bytes_offset < 340 {\n                residual_bytes[i + 1] = self.resolved_order[residual_bytes_offset];\n            }\n        }\n\n        result[0] = Field::from_be_bytes::<31>(order_id_31);\n        result[12] = Field::from_be_bytes::<31>(residual_bytes);\n        result\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], resolved_order: [0; 340] }\n    }\n}\n\n// #[event]\n#[derive(Serialize)]\npub struct Open2 {\n    pub order_id: [u8; 32],\n    pub resolved_order: [u8; 273],\n}\n\nimpl Packable<11> for Open2 {\n    fn pack(self) -> [Field; 11] {\n        let mut result = [0; 11];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n\n        for i in 0..10 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < 273 {\n                    partial[j] = self.resolved_order[k];\n                }\n            }\n            result[i + 1] = Field::from_be_bytes(partial);\n\n            let residual_bytes_offset = offset + 31;\n            if residual_bytes_offset < 273 {\n                residual_bytes[i + 1] = self.resolved_order[residual_bytes_offset];\n            }\n        }\n\n        result[0] = Field::from_be_bytes::<31>(order_id_31);\n        result[10] = Field::from_be_bytes::<31>(residual_bytes);\n        result\n    }\n\n    fn unpack(fields: [Field; 11]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], resolved_order: [0; 273] }\n    }\n}\n\npub struct Open {\n    pub open1: Open1,\n    pub open2: Open2,\n}\n\nimpl Open {\n    pub fn new(order_id: [u8; 32], resolved_order: [Field; RESOLVED_CROSS_CHAIN_LENGTH]) -> Self {\n        let mut resolved_order1 = [0; 340];\n        for i in 0..340 {\n            resolved_order1[i] = resolved_order[i] as u8;\n        }\n        let mut resolved_order2 = [0; 273];\n        for i in 0..273 {\n            resolved_order2[i] = resolved_order[i + 340] as u8;\n        }\n\n        Self {\n            open1: Open1 { order_id, resolved_order: resolved_order1 },\n            open2: Open2 { order_id, resolved_order: resolved_order2 },\n        }\n    }\n}\n"
    },
    "59": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/types/order_data.nr",
      "source": "use crate::utils::u8_4_to_u32;\nuse dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n\npub global ORDER_DATA_LENGTH: u32 = 301;\npub global ORDER_DATA_TYPE: [u8; 32] = [\n    240, 12, 59, 246, 12, 115, 235, 151, 9, 127, 28, 152, 53, 83, 125, 160, 20, 224, 183, 85, 254,\n    148, 178, 93, 122, 200, 64, 29, 246, 103, 22, 160,\n];\n\npub global PUBLIC_ORDER: u8 = 0;\npub global PRIVATE_ORDER: u8 = 1;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OrderData {\n    pub sender: [u8; 32],\n    pub recipient: [u8; 32],\n    pub input_token: [u8; 32],\n    pub output_token: [u8; 32],\n    pub amount_in: [u8; 32],\n    pub amount_out: [u8; 32],\n    pub sender_nonce: [u8; 32],\n    pub origin_domain: u32,\n    pub destination_domain: u32,\n    pub destination_settler: [u8; 32],\n    pub fill_deadline: u32,\n    pub order_type: u8,\n    pub data: [u8; 32],\n}\n\nimpl OrderData {\n    pub fn decode(bytes: [u8; ORDER_DATA_LENGTH]) -> OrderData {\n        let sender = u8_order_data_length_to_u8_32(bytes, 0);\n        let recipient = u8_order_data_length_to_u8_32(bytes, 32);\n        let input_token = u8_order_data_length_to_u8_32(bytes, 64);\n        let output_token = u8_order_data_length_to_u8_32(bytes, 96);\n        let amount_in = u8_order_data_length_to_u8_32(bytes, 128);\n        let amount_out = u8_order_data_length_to_u8_32(bytes, 160);\n        let sender_nonce = u8_order_data_length_to_u8_32(bytes, 192);\n        let origin_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 224));\n        let destination_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 228));\n        let destination_settler = u8_order_data_length_to_u8_32(bytes, 232);\n        let fill_deadline = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 264));\n        let order_type = u8_order_data_length_to_u8(bytes, 268);\n        let data = u8_order_data_length_to_u8_32(bytes, 269);\n\n        OrderData {\n            sender,\n            recipient,\n            input_token,\n            output_token,\n            amount_in,\n            amount_out,\n            sender_nonce,\n            origin_domain,\n            destination_domain,\n            destination_settler,\n            fill_deadline,\n            order_type,\n            data,\n        }\n    }\n}\n\nfn u8_order_data_length_to_u8_32(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 32] {\n    let mut result = [0; 32];\n    for i in 0..32 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8_4(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 4] {\n    let mut result = [0; 4];\n    for i in 0..4 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> u8 {\n    bytes[start]\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/utils.nr",
      "source": "use dep::aztec::{prelude::AztecAddress, protocol_types::traits::FromField};\n\npub(crate) fn u8_32_to_u128(input: [u8; 32]) -> u128 {\n    let mut result = 0;\n    for i in 0..16 {\n        result = result + (input[31 - i] as u128) * (1 << (i * 8));\n    }\n    result\n}\n\npub(crate) fn u8_4_to_u32(bytes: [u8; 4]) -> u32 {\n    let field = Field::from_be_bytes(bytes);\n    field.assert_max_bit_size::<32>();\n    field as u32\n}\n\npub(crate) fn u8_32_to_aztec_address(bytes: [u8; 32]) -> AztecAddress {\n    AztecAddress::from_field(Field::from_be_bytes(bytes))\n}\n\npub(crate) fn u32_to_u8_4(x: u32) -> [u8; 4] {\n    [((x >> 24) & 0xFF) as u8, ((x >> 16) & 0xFF) as u8, ((x >> 8) & 0xFF) as u8, (x & 0xFF) as u8]\n}\n"
    },
    "63": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "64": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.set_public_teardown_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "71": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "72": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "73": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "74": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "76": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod private_logs;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size, encryption\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\n///\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\n/// along with its `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_notes<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing note discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "77": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "78": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\n    },\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = &mut 0;\n    whyle(\n        || *i < pending_partial_notes.len(),\n        || {\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\n\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n            if maybe_log.is_none() {\n                debug_log_format(\n                    \"Found no completion logs for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                *i += 1 as u32;\n                // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\n                // is somehow removed from the PXE DB.\n            } else {\n                debug_log_format(\n                    \"Completion log found for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                let log = maybe_log.unwrap();\n\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\n                // that we're getting the logs from the expected contract.\n                // TODO(#10273): improve how contract log siloing is handled\n                assert_eq(\n                    log.log_content.get(0),\n                    contract_address.to_field(),\n                    \"Got a public log emitted by a different contract\",\n                );\n\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n                // complete packed content.\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n                let complete_packed_note_content = array::append(\n                    pending_partial_note.packed_private_note_content,\n                    packed_public_note_content,\n                );\n\n                let discovered_notes = attempt_note_nonce_discovery(\n                    log.unique_note_hashes_in_tx,\n                    log.first_nullifier_in_tx,\n                    compute_note_hash_and_nullifier,\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.note_type_id,\n                    complete_packed_note_content,\n                );\n\n                debug_log_format(\n                    \"Discovered {0} notes for partial note with tag {1}\",\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n                );\n\n                array::for_each_in_bounded_vec(\n                    discovered_notes,\n                    |discovered_note: DiscoveredNoteInfo, _| {\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                        // temporary node connectivity issue - is simply throwing good enough here?\n                        assert(\n                            deliver_note(\n                                contract_address,\n                                pending_partial_note.storage_slot,\n                                discovered_note.nonce,\n                                complete_packed_note_content,\n                                discovered_note.note_hash,\n                                discovered_note.inner_nullifier,\n                                log.tx_hash,\n                                pending_partial_note.recipient,\n                            ),\n                            \"Failed to deliver note\",\n                        );\n                    },\n                );\n\n                // Because there is only a single log for a given tag, once we've processed the tagged log then we\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n                // being completed.\n                pending_partial_notes.remove(*i);\n\n                // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n                // shifts the elements to the left if the removed element is not the last element.\n            }\n        },\n    );\n}\n\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\n/// supports looping in unconstrained code.\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\n    if condition() {\n        body();\n        whyle(condition, body);\n    }\n}\n"
    },
    "79": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    capsules::CapsuleArray,\n    oracle::note_discovery::{deliver_note, sync_notes},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier,\n    MAX_NOTE_PACKED_LEN,\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\n    partial_notes::{\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\n    },\n};\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\n// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\n/// the note completion log tag).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\n/// which the notes would've been created (typically the same transaction in which the log was emitted), along with the\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let log_plaintext = decrypt_log(log, recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\n    // improved upon in the future to also handle events, etc.\n\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\n        destructure_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        attempt_note_discovery(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            storage_slot,\n            note_type_id,\n            log_payload,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            log_payload,\n            recipient,\n        );\n    } else {\n        // TODO(#11569): handle events\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id],\n        );\n    }\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\n        \"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\n    // distinguish private note logs and partial note logs.\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we'd be able to\n    // leverage enums and tagged unions to achieve this goal.\n    let combined_type_id = log_plaintext.get(1);\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\n\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, log_type_id, log_payload)\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note_content,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nunconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    recipient: AztecAddress,\n) {\n    // We store the information of the partial note we found so that we can later search for the public log that will\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\n    static_assert(\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\n        \"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\",\n    );\n\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag: log_payload.get(0),\n        storage_slot,\n        note_type_id,\n        packed_private_note_content: array::subbvec(log_payload, 1),\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n"
    },
    "80": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "86": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note/encryption.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle,\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse protocol_types::{address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, traits::ToField};\nuse std::aes128::aes128_encrypt;\n\n// contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48;\n\nglobal TAG_AND_EPH_PK_X_SIZE_IN_FIELDS: u32 = 2;\nglobal EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 = (\n    PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS\n)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES / 32;\n\n/// Computes an encrypted log using AES-128 encryption in CBC mode.\n///\n/// The resulting log has the following format:\n/// ```text\n/// [\n///   tag: Field,                    // Tag for note discovery, derived from sender/recipient\n///   epk_x: Field,                  // X coordinate of ephemeral public key\n///   log_bytes: [Field],            // Encrypted data converted from bytes to fields, containing:\n///     [\n///       epk_sign: u8,              // Sign bit of ephemeral public key Y coordinate\n///       header_ciphertext: [u8],   // AES encrypted header containing:\n///         [\n///           contract_address: [u8; 32],  // Contract address that emitted the note\n///           ciphertext_length: [u8; 2],  // Length of main ciphertext in bytes\n///           padding: [u8; 14]            // PKCS#7 padding to AES block size\n///         ],\n///       ciphertext: [u8],          // AES encrypted note data containing:\n///         [\n///           plaintext_bytes: [u8],       // The plaintext\n///           padding: [u8]                // PKCS#7 padding to AES block size\n///         ],\n///       padding: [u8]              // Random padding to make log_bytes multiple of 31\n///     ],\n///   padding: [Field]               // Random padding to PRIVATE_LOG_SIZE_IN_FIELDS\n/// ]\n/// ```\n///\n/// The encryption process:\n/// 1. Generate ephemeral key-pair and ECDH shared secret with recipient\n/// 2. Derive AES key and IV from shared secret using SHA-256\n/// 3. Encrypt header and note data separately using AES-128-CBC\n/// 4. Format into final log structure with padding\npub fn encrypt_log<let PT: u32>(\n    contract_address: AztecAddress,\n    plaintext: [Field; PT],\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n    // (This process is then reversed when processing the log in `do_process_log`)\n    let plaintext_bytes = fields_to_bytes(plaintext);\n\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    // (not to be confused with the tagging shared secret)\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + (PT * 32) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 = get_arr_of_size__log_bytes_padding__from_PT::<PT * 32>();\n    // Safety: this randomness won't be constrained to be random. It's in the\n    // interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PT * 32>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n    // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n    // should cover a full field.\n    let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // Safety: We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n        // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n        // TODO(#12749): Long term, this is not a good solution.\n\n        // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n        // contents publicly. It is therefore fine to trust the sender to provide random padding.\n        let field_bytes = unsafe { get_random_bytes::<31>() };\n        final_log[i] = Field::from_be_bytes::<31>(field_bytes);\n    }\n\n    final_log\n}\n\npub unconstrained fn decrypt_log(\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    recipient: AztecAddress,\n) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n    // let tag = log.get(0);\n    let eph_pk_x = log.get(1);\n\n    let log_ciphertext_fields = array::subbvec::<Field, PRIVATE_LOG_SIZE_IN_FIELDS, PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS>(\n        log,\n        TAG_AND_EPH_PK_X_SIZE_IN_FIELDS,\n    );\n\n    // Convert the ciphertext represented as fields to a byte representation (its original format)\n    let log_ciphertext = bytes_from_fields(log_ciphertext_fields);\n\n    // First byte of the ciphertext represents the ephemeral public key sign\n    let eph_pk_sign_bool = log_ciphertext.get(0) as bool;\n    // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n    let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n    // Derive shared secret and symmetric key\n    let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Extract the header ciphertext\n    let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n    let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), header_start);\n    // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n    // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n    // is fixed. But we do it anyway to not have to have duplicate oracles.\n    let header_ciphertext_bvec =\n        BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n    // Decrypt header\n    let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n    // Extract ciphertext length from header (2 bytes, big-endian)\n    let ciphertext_length =\n        ((header_plaintext.get(32) as u32) << 8) | (header_plaintext.get(33) as u32);\n\n    // Extract and decrypt main ciphertext\n    let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n    let ciphertext_with_padding: [u8; (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), ciphertext_start);\n    let ciphertext: BoundedVec<u8, (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n        BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n    // Decrypt main ciphertext and return it\n    let log_plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n    // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n    fields_from_bytes(log_plaintext_bytes)\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{decrypt_log, encrypt_log, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS};\n    use protocol_types::{address::AztecAddress, traits::{FromField, Serialize}};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn test_encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log =\n            BoundedVec::from_array(encrypt_log(contract_address, plaintext, recipient, sender));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret.serialize());\n\n        // Decrypt the log\n        let decrypted = decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n    }\n}\n"
    },
    "93": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
