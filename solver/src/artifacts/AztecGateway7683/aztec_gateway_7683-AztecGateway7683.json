{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "AztecGateway7683",
  "functions": [
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "10852400770788842366": {
            "error_kind": "string",
            "string": "Invalid order domain"
          },
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "11094545764365153162": {
            "error_kind": "string",
            "string": "Function _assert_nonce_and_set_order_details can only be called internally"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "12018683598614887596": {
            "error_kind": "string",
            "string": "Function _check_order_status can only be called internally"
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13594925270014003382": {
            "error_kind": "string",
            "string": "Function _trigger_settlement can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14563046062317426044": {
            "error_kind": "string",
            "string": "Function _check_order_commitment can only be called internally"
          },
          "15520311074722577191": {
            "error_kind": "string",
            "string": "Function get_config_public can only be called statically"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8412360910299423372": {
            "error_kind": "string",
            "string": "Invalid order destination domain"
          },
          "9169818942746597700": {
            "error_kind": "string",
            "string": "Function _update_order_status can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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KAIBJgQBDQEQAAEBJgABJwMXBAEBKAAXAAIBJi4MASYBJy4OABoBJwEoAScAAgEnLg4AGwEnASgBJwACAScuDgAcAScBKAEnAAIBJy4OAB0BJwEoAScAAgEnLg4AHgEnASgBJwACAScuDgAfAScBKAEnAAIBJy4OACABJwEoAScAAgEnLg4AIQEnASgBJwACAScuDgAiAScBKAEnAAIBJy4OACMBJwEoAScAAgEnLg4AGQEnASgBJwACAScuDgAlAScBKAEnAAIBJy4OACYBJwEoAScAAgEnLg4AJwEnASgBJwACAScuDgAoAScBKAEnAAIBJy4OACkBJwEoAScAAgEnLg4AKgEnASgBJwACAScuDgArAScBKAEnAAIBJy4OACwBJwEoAScAAgEnLg4ALQEnASgBJwACAScuDgAkAScBKAEnAAIBJy4OAC8BJwEoAScAAgEnLg4ALgEnASgBJwACAScuDgAxAScBKAEnAAIBJy4OADIBJwEoAScAAgEnLg4AMwEnASgBJwACAScuDgA0AScBKAEnAAIBJy4OADUBJwEoAScAAgEnLg4ANgEnASgBJwACAScuDgA3AScBKAEnAAIBJy4OADABJwEoAScAAgEnLg4AOgEnASgBJwACAScuDgA7AScBKAEnAAIBJy4OADwBJwEoAScAAgEnLg4APQEnASgBJwACAScuDgA+AScBKAEnAAIBJy4OAD8BJwEoAScAAgEnLg4AQAEnASgBJwACAScuDgBBAScBKAEnAAIBJy4OAEIBJwEoAScAAgEnLg4AQwEnASgBJwACAScuDgBEAScBKAEnAAIBJy4OAEUBJwEoAScAAgEnLg4ARgEnASgBJwACAScuDgBHAScBKAEnAAIBJy4OAEgBJwEoAScAAgEnLg4ASQEnASgBJwACAScuDgBKAScBKAEnAAIBJy4OAEsBJwEoAScAAgEnLg4ATAEnASgBJwACAScuDgBNAScBKAEnAAIBJy4OAE4BJwEoAScAAgEnLg4ATwEnASgBJwACAScuDgBQAScBKAEnAAIBJy4OAFEBJwEoAScAAgEnLg4AUgEnASgBJwACAScuDgBTAScBKAEnAAIBJy4OAFQBJwEoAScAAgEnLg4AVQEnASgBJwACAScuDgBWAScBKAEnAAIBJy4OAFcBJwEoAScAAgEnLg4AWAEnASgBJwACAScuDgA5AScBKAEnAAIBJy4OAFoBJwEoAScAAgEnLg4AWwEnASgBJwACAScuDgBcAScBKAEnAAIBJy4OAF0BJwEoAScAAgEnLg4AXgEnASgBJwACAScuDgBfAScBKAEnAAIBJy4OAGABJwEoAScAAgEnLg4AYQEnASgBJwACAScuDgBiAScBKAEnAAIBJy4OAGMBJwEoAScAAgEnLg4AZAEnASgBJwACAScuDgBlAScBKAEnAAIBJy4OAGYBJwEoAScAAgEnLg4AZwEnASgBJwACAScuDgBoAScBKAEnAAIBJy4OAGkBJwEoAScAAgEnLg4AagEnASgBJwACAScuDgBrAScBKAEnAAIBJy4OAGwBJwEoAScAAgEnLg4AbQEnASgBJwACAScuDgBuAScBKAEnAAIBJy4OAG8BJwEoAScAAgEnLg4AcAEnASgBJwACAScuDgBxAScBKAEnAAIBJy4OAHIBJwEoAScAAgEnLg4AcwEnASgBJwACAScuDgB0AScBKAEnAAIBJy4OAHUBJwEoAScAAgEnLg4AdgEnASgBJwACAScuDgB3AScBKAEnAAIBJy4OAHgBJwEoAScAAgEnLg4AWQEnASgBJwACAScuDgB6AScBKAEnAAIBJy4OAHsBJwEoAScAAgEnLg4AfAEnASgBJwACAScuDgB9AScBKAEnAAIBJy4OAH4BJwEoAScAAgEnLg4AfwEnASgBJwACAScuDgCAAScBKAEnAAIBJy4OAIEBJwEoAScAAgEnLg4AggEnASgBJwACAScuDgCDAScBKAEnAAIBJy4OAIQBJwEoAScAAgEnLg4AhQEnASgBJwACAScuDgCGAScBKAEnAAIBJy4OAIcBJwEoAScAAgEnLg4AiAEnASgBJwACAScuDgCJAScBKAEnAAIBJy4OAIoBJwEoAScAAgEnLg4AiwEnASgBJwACAScuDgCMAScBKAEnAAIBJy4OAI0BJwEoAScAAgEnLg4AjgEnASgBJwACAScuDgCPAScBKAEnAAIBJy4OAJABJwEoAScAAgEnLg4AkQEnASgBJwACAScuDgCSAScBKAEnAAIBJy4OAJMBJwEoAScAAgEnLg4AlAEnASgBJwACAScuDgCVAScBKAEnAAIBJy4OAJYBJwEoAScAAgEnLg4AlwEnASgBJwACAScuDgCYAScBKAEnAAIBJy4OAHkBJwEoAScAAgEnLg4AmgEnASgBJwACAScuDgCbAScBKAEnAAIBJy4OAJwBJwEoAScAAgEnLg4AnQEnASgBJwACAScuDgCeAScBKAEnAAIBJy4OAJ8BJwEoAScAAgEnLg4AoAEnASgBJwACAScuDgChAScBKAEnAAIBJy4OAKIBJwEoAScAAgEnLg4AowEnASgBJwACAScuDgCkAScBKAEnAAIBJy4OAKUBJwEoAScAAgEnLg4ApgEnASgBJwACAScuDgCnAScBKAEnAAIBJy4OAKgBJwEoAScAAgEnLg4AqQEnASgBJwACAScuDgCqAScBKAEnAAIBJy4OAKsBJwEoAScAAgEnLg4ArAEnASgBJwACAScuDgCtAScBKAEnAAIBJy4OAK4BJwEoAScAAgEnLg4ArwEnASgBJwACAScuDgCwAScBKAEnAAIBJy4OALEBJwEoAScAAgEnLg4AsgEnASgBJwACAScuDgCzAScBKAEnAAIBJy4OALQBJwEoAScAAgEnLg4AtQEnASgBJwACAScuDgC2AScBKAEnAAIBJy4OALcBJwEoAScAAgEnLg4AuAEnASgBJwACAScuDgCZAScBKAEnAAIBJy4OALoBJwEoAScAAgEnLg4AuwEnASgBJwACAScuDgC8AScBKAEnAAIBJy4OAL0BJwEoAScAAgEnLg4AvgEnASgBJwACAScuDgC/AScBKAEnAAIBJy4OAMABJwEoAScAAgEnLg4AwQEnASgBJwACAScuDgDCAScBKAEnAAIBJy4OAMMBJwEoAScAAgEnLg4AxAEnASgBJwACAScuDgDFAScBKAEnAAIBJy4OAMYBJwEoAScAAgEnLg4AxwEnASgBJwACAScuDgDIAScBKAEnAAIBJy4OAMkBJwEoAScAAgEnLg4AygEnASgBJwACAScuDgDLAScBKAEnAAIBJy4OAMwBJwEoAScAAgEnLg4AzQEnASgBJwACAScuDgDOAScBKAEnAAIBJy4OAM8BJwEoAScAAgEnLg4A0AEnASgBJwACAScuDgDRAScBKAEnAAIBJy4OANIBJwEoAScAAgEnLg4A0wEnASgBJwACAScuDgDUAScBKAEnAAIBJy4OANUBJwEoAScAAgEnLg4A1gEnASgBJwACAScuDgDXAScBKAEnAAIBJy4OANgBJwEoAScAAgEnLg4AuQEnASgBJwACAScuDgDaAScBKAEnAAIBJy4OANsBJwEoAScAAgEnLg4A3AEnASgBJwACAScuDgDZAScBKAEnAAIBJy4OAN4BJwEoAScAAgEnLg4A3wEnASgBJwACAScuDgDgAScBKAEnAAIBJy4OAN0BJwEoAScAAgEnLg4A4gEnASgBJwACAScuDgDjAScBKAEnAAIBJy4OAOQBJwEoAScAAgEnLg4A5QEnASgBJwACAScuDgDmAScBKAEnAAIBJy4OAOcBJwEoAScAAgEnLg4A6AEnASgBJwACAScuDgDpAScBKAEnAAIBJy4OAOoBJwEoAScAAgEnLg4A6wEnASgBJwACAScuDgDsAScBKAEnAAIBJy4OAO0BJwEoAScAAgEnLg4A7gEnASgBJwACAScuDgDvAScBKAEnAAIBJy4OAPABJwEoAScAAgEnLg4A8QEnASgBJwACAScuDgDyAScBKAEnAAIBJy4OAPMBJwEoAScAAgEnLg4A9AEnASgBJwACAScuDgD1AScBKAEnAAIBJy4OAPYBJwEoAScAAgEnLg4A9wEnASgBJwACAScuDgD4AScBKAEnAAIBJy4OAOEBJwEoAScAAgEnLg4A+gEnASgBJwACAScuDgD7AScBKAEnAAIBJy4OAPwBJwEoAScAAgEnLg4A/QEnASgBJwACAScuDgD+AScBKAEnAAIBJy4OAP8BJwEoAScAAgEnLg4BAAEnASgBJwACAScuDgD5AScBKAEnAAIBJy4OAQIBJwEoAScAAgEnLg4BAwEnASgBJwACAScuDgEEAScBKAEnAAIBJy4OAQEBJwEoAScAAgEnLg4BBgEnASgBJwACAScuDgEFAScBKAEnAAIBJy4OAQgBJwEoAScAAgEnLg4BCQEnASgBJwACAScuDgEKAScBKAEnAAIBJy4OAQsBJwEoAScAAgEnLg4BDAEnASgBJwACAScuDgENAScBKAEnAAIBJy4OAQ4BJwEoAScAAgEnLg4BDwEnASgBJwACAScuDgEQAScBKAEnAAIBJy4OAREBJwEoAScAAgEnLg4BEgEnASgBJwACAScuDgETAScBKAEnAAIBJy4OARQBJwEoAScAAgEnLg4BFQEnASgBJwACAScuDgEWAScBKAEnAAIBJy4OARcBJwEoAScAAgEnLg4BGAEnASgBJwACAScuDgEZAScBKAEn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",
      "debug_symbols": "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",
      "brillig_names": ["public_dispatch"]
    },
    {
      "name": "claim_private",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15663063161611103517": {
            "error_kind": "string",
            "string": "Invalid secret"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 268,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_notes",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "open_private",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "error_types": {
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "order",
            "type": {
              "fields": [
                {
                  "name": "fill_deadline",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                },
                {
                  "name": "order_data_type",
                  "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                },
                {
                  "name": "order_data",
                  "type": {
                    "kind": "array",
                    "length": 268,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                }
              ],
              "kind": "struct",
              "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_notes",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "_check_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "12018683598614887596": {
            "error_kind": "string",
            "string": "Function _check_order_status can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "status",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "7Z3ZbuM6DIbfJde50EYt8yqDg6LbFAGCpEjbAxwUffdjt7WdxGwci0Inhf6bYjwhTfozbVKLpdfF3f3Ny8PVavNn+7T49ft1sd7eXj+vtpvm6PVtubjZrdbr1cPV/n8vVPtHq/Su8PR4vWmPn56vd8+LX9pFpZaL+81d++9kqTnJn9X6vjky6m05llfGdOLKmUFaB0baeUef0s6T66WDZoSji+lTOJKifeF/lgutXRn/U2dEa52+0/9C/Cn2/OMUf00hdNLe2tP+JwrdxSav47H/JpT2X5tD/1sr1nyHFae+xQqxViy5Xs2S9xNWXNSduIvGT8Qgke9jsJU4vIekvvAomMGjZKY8KvhU0DmMkjvwqNXzKlMv5ukFy+ppP+hpvweciA0Yb4eXz/A4as+R07G7lToNT6PV7sOheGEORXNpDoULcyhdGqF0YYSMujBCRvkLc0irS3OILs2h9P0O9Um3ieADh8ayIfXJM6Q0nNkEroCz/Zldm4o7We7EzYW7zgujzWlhMt15yYR90ZagcSAoJBhBUEbQWhAUEkQMCgk6xKCUIGJQSJAMCAoJehCUEfQaBIUECQRlBIMCQSFBB4LTBH03AEBejwiimhESjKiopQQDCE4T7GX9oWhD0Co8xUKCGm0SKUE8xUKCBjEoJYgYFBK0iEEpQfTNCAk6tIulBNE3IyWIEXchQXIgKCSIVp2QoEffjJQgKupjgi2WgOEjFgtqXw5LREHLYnHAwmFB6clhScjlLBYkaAaLU+jHYrEgQXNYNBI0iwXdSCwWJGgOi0GCZrGgF4fDYh2wcFgQLRwWfLbAY0G0cFh8rViMHbA4OsYSay3+g+6WazBhb8WQucItw1RrS2EOQ+2H6/NRjxjW2qwox5BUrQmxJMNa00RBhtXOm53FMIR+dYeQaMSw1i7cggxNrQOyJRkiL8sZ1to3WJBhtetklGSInCJm6FDbyBkiDsUMCbWNnCFqGzlD1DZihtXOSC7JEDlFzLDaCcwlGSKnyBkip5zBMOl+LfNkRgyrXT+jIMNU5H2oYy+9P/7KMyQKnXTTsT5Q1MZyFH2360GIbu/M6cN9/5Pd9+pH0/cq/Wj3v9iF5ND96Kfct8MmJP7QCOMQ+e7cgeKwZQm73UKwg/tOTewW0fjRrzXU+mT3xdurNeovXG2/qUbwyk1dQKI+DvQQNNaaD//pZ/tvfzh/ew7/vTXcG/9btbMWNWDUYpZatU0kq3ov3k0fZHkfau3RncCCaOGwxFrbd6exVDsFbgILooXBEhSihcXiap2inEyPRdFEm131DfzmUuOIYbXTvMsxrHb+3iyG2g7XR3rEsNbyqSDDaueeFWRoa021JRkiL5/D0PddJE2v5THDaudazGLo9vblVaM4rHauRUGG1c61KMkQtY2YYbVzLWYxJNNfH5EaMaz129WCDCPiUM4QeVnMMDkwFDKM1XarlmSI2kbMEP2HBRiiH1vMsNrFx0oyRByKGVa7f848hqGfi0vpePmmWO3+LyUZog9WzJCQU+QMkVPEDD1yipwh+g/FDKvdr7wkQ/QfnsHQDt9qWXs8nhKr3TekJEPkZTHDhLwsZ4i8LGWYMBZQgCFyipwhahsxQ404lDNEbSNmaFDbyBmithEzxJz2sxi60DP0asQQcShmWO0GNCUZIi+LGZIDQzFDtFPEDPFdgJwhvgsQf1uRql2DsSRDvA/FDKtdK6YgQ3wXMGLYYNGa75sO/QpowdmRDv89fXKdoURjO/zeJad1+L06JnTCfB3H58qTi1s0Wj5Hi1SWFuVo+SxbPstWyLIVsmzFLFsx636lLFsp67pSytAyX+zWN6UVcrS0ztLys98xhl9JsxlK655jw+jMfy8Z/ik+bYcyfOPb1hM6cb4OP5/vNAM//51pQoYd/rmd0Mm4pynDTsqxw+c06uI6heMpWtry+XZCJ8MOv27QaR1+XGZCJ8OOzbDD9zPv3R9Gh8/rJ++pdX6+DmXYofn1kPVuvk5QGTrz3wc2mgydOF8n2Qyd+XacMhk682PHaZWhMzMO3pqjf693q+ub9f1To9H++LK5fV5tN5+Hz/89dr/c7Fbr9erh6nG3vb2/e9ndX623t+1vC/X557eJcdm8lFpf2kOd4rKpQt5LmObQarVsxt0aq43l/wE=",
      "brillig_names": ["_check_order_status"]
    },
    {
      "name": "get_config",
      "is_unconstrained": false,
      "custom_attributes": ["private", "view"],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5276036973553878575": {
            "error_kind": "string",
            "string": "Function get_config can only be called statically"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+1dB3gc1fHf051sS7YsYWOMMZhijDHY+Pbu1ACDjHvFvRuQdCdjMBiwIZQAorcUIAkQCEkIJEASII1AIAmEhJAESCMFUkgj//SE9ELKf569TxqN5lZ7vnnSDvb7vvlub9/beb+ZNzOv7NvdhLczbar0vKdTO48TQMngtwLoIHKukjk3lDlXw5yrZc7txZzbB6iFnDuQKXcQc+5g5twhzLmJwTmcKoLfluA3XV7yJyJe2XRDLldozBT8rN+azjS3NdWnc/VtDU1+k1/fVJ/PNGWzhaZcU2NzW3NjutnPZQt+R31ztiNgVpOUw9WjnZLu9YCxl6uH4Y70MJzRQ0JYD0lBe0iRtnKJOyHHK83AleLd1MXQKGdwPylnby/WyvHtAdZFbXLnb521/q4IDQcvk3N1jGckHSpxFz0jE3iGXysYberkos0Ojx3idRtgmFGWi7uWwb2rPDHevZIOARvmxbqeXeW/l2B3MULQsFzp0GBMCOtwRFI2wknLXRfILTVssXwl23ukoA5xcDZ8zZA35XUHbZp20+GA71IHdcLtadPeyT4ar1xDHJV003jSOPfZdZw+PWGwjfB2OonFahT93+B4VJHjfYJje91o+L8v0Big/ZLd513pYKxYW/mNLnHuL2dTGZc4D9h1nFl6grOpsch2DNnj/dH5A4hNjYP/B5oRtgnkgU0ZqvD6Z/pS10/xIF1e8scJ4hyEcB4SBNzxwe+hwe+E4PewYEB1eFB+Ivw/HGgS0BFARwJNBpoCdBTQVKA0kJnsZ4CyQDmgeqAGoEagJqBmoKOBjgE6Fmga0HFAxxs5gaYDnQA0A2gm0Cyg2UBzgOYCzQOaD7QAaCHQIqDFdDp3WDB1K2XqkS4v+eMd9YwnJh0CPjEpz3eJ4+lCury0Q+4laLghxDfdn8Z2qCNjW5p0CHipA2NbFnNjM3IvU25sExwZ2/KkQ8DLHRjbipgbm5F7hQNjc4F1SeAY0mPdlUmdTnaYIydblXQIeJUDJ1sdcyczcq9W4mQmGKx04GRrlCymrN11nDl6gpv4jkcT3EPR8WHoeC2Z+K6D/+uBNgBtZBZTksI2INh7++sEffMk4YBH2+Yk1Abr0fEGdLyRtM3J8P8UoFagtmRPfpJ2aeLHGgd+2S7Y1kb2Kq9/VtYPcRRPPFGcmSZ3vNOZBNKtXXTJg14KQB1Am4BOBdoMdBrQ6UBbgM4AOhNoK9BZQGcDnQO0DWg70LlA5wG9Aeh8oAuALgS6COiNQBcDXQJ0KVAn0GVAlwNdAXQl0FVAVwNdA3Qt0HVA1wPdQBdd8snuFUB7rsCc62DObWLOncqc28ycO405dzpzbgtz7gzm3JnMua3MubOYc2cz585hzm1jzm1nzp3LnDuPOfcG5tz5zLkLmHMXMucuYs69kTl3MXPuEubcpcy5TubcZcy5y5lzVzDnrmTOXcWcu5o5dw1z7lrm3HXMueuZczcku4OkTZOC35bgN11e6hE0y+048gK8Ch07U0GOV75DjlfzJjle/qlivAr+ZjFe7f5pYrya/NPFeKX9LVK8Cmn/DCle7Wn/TCleTWl/qxQv8O2zhHgVgNfZQrzagdc5QryagNc2IV4mFm6X4VUwvM6V4dVueJ0nw6vJ8HqDDK8dfcf5IrwKO3hdIMKrfQevC0V4Ne3gdZEIr5197RsleBV28rpYglf7Tl6XSPBq2snrUglewdikU4BXPuB1mQCvtoDX5QK8GgNeV5TPq2vv7pXl8/Itr6vK5tXUYXldXT6vNsvrmvJ52fGqf23ZvBq7eF1XNq/6Ll7Xl83L7+J1Q9LNogjdLhqHuYPl9SY5mXdsg5ReqDILhO1J+YW7Nwu3tdSW4CD5ZvdPXrBtTDu/2YEe36JAj5I2nnekx7c6ij3SOG/cdZwZesJgozcRjD3ZmwVvTfK7ZW9M9ryJcBP8vxnobUBvTxa/iZAuL/lmN17BQdv/OeX2pma5+IzMNzmQ+y8pNzafEm73mwT723cIxiJBu/G1tMXhgm1xS9KND8fJL7gY+w4US2+JGGNvhf+3Ab0T6HaHMdbsdu5wEGv+GvMYa2S+1YHcf1Pi17cK+uIdgjFW0G58LW0xSbAt3pV048Nx8gsuxt6BYum7IsbYO+H/u4HeA/RehzHWPE2yyUGs+XvMY6yR+U4Hcv9DiV/fKeiLdwnGWEG78bW0xRGCbfG+pBsfjpNfcDH2LhRL3xcxxt4N/+8Bej/QBxzGWPO03qkOYs0/Yx5jjcx3O5D7X0r8+m5BX7xXMMYK2o2vpS2OFGyL+5JufDhOfsHF2HtRLL0vYoy9H/5/EOhDQB92GGPN09CbHcSa12IeY43M9zuQ+99K/Pp+QV98QDDGCtqNr6UtJgu2xYNJNz4cJ7/gYuwDKJY+GDHGPgT/PwL0UaCPOYyx5m0TpzmINf+JeYw1Mj/kQO7/KvHrhwR98eOCMVbQbnwtbTFFsC0+kXTjw3HyCy7GfhzF0k9EjLEPw/9PAj0C9KjDGGve5nO6g1jzv5jHWCPzww7kNq8Ol5TbJmm/fljQFz8lGGMF7cbX0hZHCbbFY0k3Phwnv+Bi7KdQLH0sYox9HP5/GugzQJ91GGPN29K2OIg1icp4x1gj8+MO5K5Q4tePC/riE4IxVtBufC1tMVWwLZ5MuvHhOPkFF2OfQLH0yYgx9nPw/ymgzwN9wWGMNW+jPMNBrEnGPMYamT/nQO6UEr/+nKAvPi0YYwXtxtfSFmnBtvhi0o0Px8kvuBj7NIqlX4wYY5+B/18C+jLQVxzGWPO23zMdxJrKmMdYI/MzDuQepMSvnxH0xWcFY6yg3fha2sIXbIvnkm58OE5+wcXYZ1EsfS5ijH0e/n8V6GtAX3cYY83b1Lc6iDWDYx5jjczPO5B7iBK/fl7QF78hGGMF7cbX0hYZwbb4ZtKND8fJL7gY+w0US78ZMca+AP+/BfRtoO84jLHmaxVnOYg1VTGPsUbmFxzIXa3Er18Q9MXvCsZYQbvxtbRFVrAtXky68eE4+QUXY7+LYumLEWPsS/D/e0DfB/qBwxhrvgZ0toNYMzTmMdbI/JIDuYcp8euXBH3xh4IxVtBufC1tkRNsi5eTbnw4Tn7Bxdgfolj6csQY+yP4/2OgnwD91GGMNV9bO8dBrKmJeYw1Mv/IgdzDlfj1jwR98WeCMVbQbnwtbVEv2BavJN34cJz8gouxP0Ox9JWIMfbn8P//gH4B9EuHMdZ8zXKbg1hTG/MYa2T+uQO565T49c8FffFXgjFW0G58LW3RINgWv0668eE4+QUXY3+FYumvI8bY38D/3wL9Duj3DmOs+VrwdgexZq+Yx1gj828cyD1CiV//RtAX/yAYYwXtxtfSFo2CbfFq0o0Px8kvuBj7BxRLX40YY/8I//8E9GegvziMseZr7Oc6iDUjYx5jjcx/dCD33kr8+o+CvvhXwRgraDe+lrZoEmyLvyXd+HCc/IKLsX9FsfRvEWPs3+H/P4D+CfQvhzG2Odn9vT7Mt1ydjop5jDUy/92B3Pso8eu/C/ria4IxVtBufC1t0SzYFv9OuvHhOPkFF2NfQ7H03xFj7H/Mf6D/JXeedBVjj052f/8U8y1Xp6NjHmONzP9xIPe+Svz6P4K+mBB8x4Cg3fha2uJowbaoSLnx4Tj5BRdjjQ3aWFqRihZjkyauAlUCDXIYY49Jdn9PGvMtV6djYh5jjcxGx9J891Pi10lBXxwsGGMF7cbX0hbHCMbYISk3Phwnv+Bi7GAUV4dEjLFVcFANNBRomMMYeyzUe4GDGDs25jHWyFzlIMbur8SvqwR9sUYwxgraja+lLY4VjLHDU258OE5+wcXYGhRXh0eMsbVwUAe0F9AIhzF2GtR7oYMYe0DMY6yRudZBjB2nxK9rBX1xpGCMFbQbX0tbTBOMsXun3PhwnPyCi7EjUVzdO2KMHQUH+wCNBtrXYYw9Duq9yEGMPTDmMdbIPMpBjD1IiV+PkpxTCsZYQbvxtbTFcYIxdr+UGx+Ok19wMXYMiqv7RYyxY+Fgf6ADgMY5jLHHQ71vdBBjD455jDUyj3UQYw9R4tdjJX1RMMYK2o2vpS2OF4yxB6Xc+HCc/IKLsQeiuHpQxBh7MBwcAjQe6FCHMbYF6r3YQYwdH/MYa2Q+2EGMPVSJXx8s6IsTBGOsoN34WtqiRTDGHpZy48Nx8gsuxk5AcfWwiDF2IhwcDjQJ6AiHMXY61HuJgxg7IeYx1sg80UGMPUyJX08U9MUjBWOsoN34WtpiumCMnZxy48Nx8gsuxh6J4urkiDF2ChwcBTQVKO0wxp4A9V7qIMZOjHmMNTJPcRBjD1fi11MEfdEXjLGCduNraYsTBGNsJuXGh+PkF1yM9VFczUSMsVk4yAHVAzU4jLEzoN5OBzF2UsxjrJE56yDGHqHlnaWCvtgoGGMF7cbX0hYzBGNsU8qND8fJL7gY24jialPEGNsMB0cDHQN0rMMYOxPqvcxBjD0y5jHWyNzsIMZO1vL8pqAvThOMsYJ242tpi5mCMfa4lBsfjpNfcDF2Goqrx0WMsccbXQFNBzrBYYydBfVe7iDGTol5jDUyH+8gxh6l5V62oC/OEIyxgnbja2mLWYIxdmbKjQ/HyS+4GDsDxdWZEWPsLDiYDTQHaK7DGDsb6r3CQYydGvMYa2Se5SDGprX4taAvzhOMsYJ242tpi9mCMXZ+yo0Px8kvuBg7D8XV+RFj7AI4WAi0CGixwxg7B+q90kGM9WMeY43MCxzE2IwSv14g6IsnCsZYQbvxtbTFHMEYuyTlxofj5BdcjD0RxdUlEWPsUjhYBrQcaIXDGDsX6r3KQYzNxjzGGpmXOoixOSV+vVTQF1cKxlhBu/G1tMVcwRi7KuXGh+PkF1yMXYni6qqIMXY1HKwBWgu0zmGMnQf1Xu0gxtbHPMYamVc7iLENSvx6taAvrheMsYJ242tpi3mCMXZDyo0Px8kvuBi7HsXVDRFj7EY4OAnoZKBTHMbY+VDvNQ5ibGPMY6yReaODGNukxK83Cvpiq2CMFbQbX0tbzBeMsW0pNz4cJ7/gYmwriqttEWNsOxzkgQpAHQ5j7AKo91oHMbY55jHWyNzuIMYercSv2wV9cZNgjBW0G19LWywQjLGnptz4cJz8gouxm1BcPTVijN0MB6cBnQ60xWGMXQj1Xucgxh4T8xhrZN7sIMYeq8SvNwv64hmCMVbQbnwtbbFQMMaemXLjw3HyCy7GnoHi6pkRY+xWODgL6GygcxzG2EVQ7/UOYuy0mMdYI/NWBzH2OCV+vVXQF7cJxlhBu/G1tMUiwRi7PeXGh+PkF1yM3Ybi6vaIMfZcODgP6A1A5zuMsYuh3hscxNjjYx5jjcznOoixLUr8+lxBX7xAMMYK2o2vpS0WC8bYC1NufDhOfsHF2AtQXL0wYoy9CA7eCHQx0CUoxtpUIdzOdZ6cPi9KubHtpLDM4wRte7wgr0sF9WfsZojX3ZfgJN1fS+LGeDtTDgF3puT5XiYY6FzJfRmKKEJ8dxibcdIKz72xYedNl5lc4hyfdOMUlyO7lX/TgOCoKREYRQKBTgXUH1FJsgGwYV8RONCVRiYXDXC5g8h0uXDX7EruCodyl73t27EO0+Ul3xjmVQ6mj1cLd+82KBi+nQFfaV1c6UgX1zjSxTUhuij7sVtHujhhYJdT2vvA58wGZlTGOw6Yju8qB7FUsL19SR2a/hjYsaNPr0Qd9GVTmKeL+C2lEzzAujZsxJguL/lXOQqIGHSJmP2+6jGYr3UQGGbGZG2vlIFM2XsvUvEMMDMr3djldaij3tX26Uvnku1zPeLlZ7PgG/lGvyPfka1vbM60+Q3ZhoaOXEdjQ1Mu31Gfa803FvxcazbTXGhMd/hNhUJjfba9saGjOd/e0IGDtp/PZnP55rZ2vz7T0NqWbspnW9MducZsJt2azzbm89mmhobWbDbf0NTR1NyUybR2ZJvS9Y2NzemGTLY546p9rg/apz9nmuMczTRvCAzrTVoCuCt8NzgI1m921HG92eGsxujiTQ508RZHuniLw1mNK7uYHfNZjSsbmBPzWc04R7Mawfb25+yZ1dDk3+BoVvNWjbOatzqe1bzVQWCYuxvOam5MxTPAzHU0ar5R2azmJsFZzRzBWY2r9rkJzWqKdQpxXo5yidNVB3Ozxg7mZscdzM0OOph5jjqYSmGckgHsbYK8JJfNJDureY6C4dsidFbl6vTtKblOoceyWYw6K1ft8/bX0RLcOwLDuoXb7JEuL/nFNj1I7uIp+734giNhFw1vdZhUosNyed0a8/YwDnOrg0HCbY4GTLc5XK69xZEu3ulIF+90uFzryi4Wxny51pUNLFKwXHurg+Vawfb2F+1ZrqVpR/yW0gke+N3ucjZ9q6OAeLvD2bTBfLuDwLBYyXLtrYKDojtS8Qwwix3NsO7oh+VayfZ5l+By7SLBGbCr9nnXAMyAXT3ucGdgWO/WEsBd4bvTQbB+j6OO6z0OZzVGF+92oIv3OtLFex3OalzZxZKYz2pc2cBSBVvrXcxqBNvbX7pnVkOTf6ejWc1dGmc1dzme1dzlIDAs2w1nNe9LxTPALHM0an6fslnN3YKzmqWCsxpX7XP3AGxCkVyOconTVQdzj8YO5h7HHcw9DjqY5Uo2oUgGsPcL8pJcNpPsrJY7Cobv74dNKB8Q3ISyqDKenZWr9vkA0z7SewQEN534EwTfI3WvYFw3Nt1f75G611Enel/KIeD7UvJ87xcMzK7kvj/VrWAhvv36HqkJSt4jJbmzDTvFB1MO3yN1v+DUFUd1C/r1sLXwQ4EDfTjl4D1SpgE+6CAyfdDxjRopuSscyl0uxgdifrPLGOYDDqZYDzqabj7o8GbXhx3p4iFHunjI4c0uV3axKuY3u1zZwGoFW/gecBBLBdvbX73nZhdNO+K3lE7wAOsjLtciH3AUED/icC3SYP6Ig8CwRsnNrgcEB0UfTcUzwKxxtD710X642SXZPh8TvNm1WnD90FX7fGwAtvBNcDTT/HhgWJ/QEsBd4fu4g2D9sKOO62GHsxqji0840MUnHenikw5nNa7sYl3MZzWubGB9zGc1ExzNagTb21+/Z1ZDk/9xR7OaRzTOah5xPKt5xEFg2LAbzmoeTcUzwGxwNGp+VNms5lOCs5r1grMaV+3zqQHYwie5HOUSp6sO5jGNHcxjjjuYxxx0MBuVbOGTDGCPC/KSXDaT7Kw2OgqGj/fDFr5PC27hW10Zz87KVft8+nW0BPeZwLA+y232SJeX/GKbHiR38ZTLS3DjiJP3FlkdSu8RdaXDcnk9EfP2MA7zhINBwpOOBkxPOlyu/awjXXzOkS4+53C51pVdnBLz5VpXNtCqYLn2CQfLtYLt7bfuWa6laUf8ltIJHvg95XI2/YSjgPiUw9m0wfyUg8DQpmS59gnBQdHnU/EMMG2OZlif74flWsn2+YLgcm2r4AzYVft8YQBmwK4ed3g6MKwvagngrvA97SBYP+Oo43rG4azG6OKLDnTxJUe6+JLDWY0ru8jHfFbjygYKCrbWu5jVCLa3X9gzq6HJf9rRrObLGmc1X3Y8q/myg8DQsRvOar6SimeA6XA0av6KslnNs4KzmoLgrMZV+zw7AJtQJJejXOJ01cE8p7GDec5xB/Ocgw5mk5JNKJIB7HlBXpLLZpKd1SZHwfD5ftiE8lXBTSitlfHsrFy1z1cdroCsgEpWJ+Vj0Nccr4JJxJ6vMXst0uUlyX7I/5pgTPt6zNvDvFPw6w76wm8I7zGR3t9kVmEkMY4P+Hmydu1kBerQAKt0m39T0NaNKvvr3XPfdDTwfiHlEPALKXm+3xIMfK7k/tZu7mTfdjSblQ6wkrb0nZh3JqOhrSUxmjb+jhI73zvpxicNy0GezG2DvmRIeL07Ghd6EuKVZpUhHWi+K2bQmXaDbYTXPbs1/w3//wbHRjn2eBQ6vjE4tte9CAcvAX0P6Pup7vM2STu2pAEc7ukI3AlBmScpkblCUOYjHMksHZCOFPYTVzgne/1jQ+nykj9FUJ8vKrllcZSnA+dUJTjTSnD6SnBmlODMKsGZU4KzXgnOBiU4G5XgbFKCs1kJzqOV4DxGCc5jleCcpgTncUpwHq8EZ4sSnNOV4DxBCc4ZSnDOVIJzlhKcs5XgnKME51wlOOcpwTlfCc4FSnAuVIJzkRKci5XgPFEJziVKcC51hDPO9/KW9ZPM6fKSv1xQfzVKPhS5wtOBc6USnKuU4FytBOcaJTjXKsG5TgnO9UpwblCCc6MSnCcpwXmyEpynKMHZqgRnmxKc7Upw5pXgLCjB2aEE5yYlOE9VgnOzEpynKcF5uhKcW5TgPEMJzjOV4NyqBOdZSnCerQTnOUpwblOCc7sSnOcqwXmeEpxvUILzfCU4L1CC80IlOC9SgvONSnBerATnJUpwXqoEZ6cSnJcpwXm5EpxXKMF5pRKcVynBebUSnNcowXmtEpzXKcF5vRKcNyjB+SYlON+sBOdblOB8qxKcNyrBeZMSnDcrwfk2JTjfrgTnO5TgvEUJzluV4LxNCc53KsF5uxKcdyjB+S4lOO9UgvPdSnC+RwnO9yrBeZcSnO9TgvNuJTjvUYLz/UpwfkAJznuV4LxPCc77leD8oBKcH1KC88NKcD6gBOeDSnA+pATnR5Tg/KgSnB9TgvPjSnB+QgnOh5Xg/KQSnI8owfmoEpyfUoLzMSU4H1eC89NKcH5GCc7PKsH5hBKcTyrB+TklOJ9SgvPzSnB+QQnOp5Xg/KISnM8owfklJTi/rATnV5TgfFYJzueU4HxeCc6vKsH5NSU4v64E5zeU4PymEpwvKMH5LSU4v60E53eU4PyuEpwvKsH5khKc31OC8/tKcP5ACc4fKsH5shKcP1KC88dKcP5ECc6fKsH5MyU4X1GC8+dKcP6fEpy/UILzl0pw/koJzl8rwfkbJTh/qwTn75Tg/L0SnH9QgvNVJTj/qATnn5Tg/LMSnH9RgvOvSnD+TQnOvyvB+Q8lOP+pBOe/lOB8TQnOfyvB+R8lOP+rBOf/lOA0DDXgTCjBWaEEZ1IJzpQSnJVKcA5SgnOwEpxDlOCsUoKzWgnOoUpwDlOCs0YJzuFKcNYqwVmnBOdeSnCOUIJzpBKceyvBOUoJzn2U4BytBOe+SnCOUYJzPyU4xyrBub8SnAcowTlOCc4DleA8SAnOg5XgPEQJzvFKcB6qBOcEJTgPU4JzohKchyvBOUkJziOU4DxSCc7JSnBOUYLzKCU4pyrBmVaC01eCM6MEZ1YJzpwSnPVKcDYowdmoBGeTEpzNSnAerQTnMUpwHqsE5zQlOI9TgvN4JThblOCcrgTnCUpwzlCCc6YSnLOU4JytBOccJTjnKsE5TwnO+UpwLlCCc6ESnIuU4FysBOeJSnAuUYJzqRKcy5TgXK4E5wolOFcqwblKCc7VSnCuUYJzrRKc65TgXK8E5wYlODcqwXmSEpwnK8F5ihKcrUpwtinB2a4EZ14JzoISnB1KcG5SgvNUJTg3K8F5mhKcpyvBuUUJzjOU4DxTCc6tSnCepQTn2UpwnqME5zYlOLcrwXmuEpznKcH5BiU4z1eC8wIlOC9UgvMiJTjfqATnxUpwXqIE56VKcHYqwXmZEpyXK8F5hRKcVyrBeZUSnFcrwXmNEpzXKsF5nRKc1yvBeYMSnG9SgvPNSnC+RQnOtyrBeaMSnDcpwXmzEpxvU4Lz7UpwvkMJzluU4LxVCc7blOB8pxKctyvBeYcSnO9SgvNOJTjfrQTne5TgfK8SnHcpwfk+JTjvVoLzHiU4368E5weU4LxXCc77lOC8XwnODyrB+SElOD+sBOcDSnA+qATnQ0pwfkQJzo8qwfkxJTg/rgTnJ5TgfFgJzk8qwfmIEpyPKsH5KSU4H1OC83ElOD+tBOdnlOD8rBKcTyjB+aQSnJ9TgvMpJTg/rwTnF5TgfFoJzi8qwfmMEpxfUoLzy0pwfkUJzmeV4HxOCc7nleD8qhKcX1OC8+tKcH5DCc5vKsH5ghKc31KC89tKcH5HCc7vKsH5ohKcLynB+T0lOL+vBOcPlOD8oRKcLyvB+SMlOH+sBOdPlOD8qRKcP1OC8xUlOH+uBOf/KcH5CyU4f6kE56+U4Py1Epy/UYLzt0pw/k4Jzt8rwfkHJThfVYLzj0pw/kkJzj8rwfkXJTj/qgTn35Tg/LsSnP9QgvOfSnD+SwnO15Tg/LcSnP9RgvO/SnD+TwlOr0IHzoQSnBVKcCaV4EwpwVmpBOcgJTgHK8E5RAnOKiU4q5XgHKoE5zAlOGuU4ByuBGetEpx1SnDupQTnCCU4RyrBubcSnKOU4NxHCc7RSnDuqwTnGCU491OCc6wSnPsrwXmAEpzjlOA8UAnOg5TgPFgJzkOU4ByvBOehSnBOUILzMCU4JyrBebgSnJOU4DxCCc4jleCcrATnFCU4j1KCc6oSnGklOH0lODNKcGaV4MwpwVmvBGeDEpyNSnA2KcHZrATn0UpwHqME57FKcE5TgvM4JTiPV4KzRQnO6UpwnqAE5wwlOGcqwTlLCc7ZSnDOUYJzrhKc85TgnK8E5wIlOBcqwblICc7FSnCeqATnEiU4lyrBuUwJzuVKcK5QgnOlEpyrlOBcrQTnGiU41yrBuU4JzvVKcG5QgnOjEpwnKcF5shKcpyjB2aoEZ5sSnO1KcOaV4CwowdmhBOcmJThPVYJzsxKcpynBeboSnFuU4DxDCc4zleDcqgTnWUpwnq0E5zlKcG5TgnO7EpznKsF5nhKcb1CC83wlOC9QgvNCJTgvUoLzjUpwXqwE5yVKcF6qBGenEpyXKcF5uRKcVyjBeaUSnFcpwXm1EpzXKMF5rRKc1ynBeb0SnDcowfkmJTjfrATnW5TgfKsSnDcqwXmTEpw3K8H5NiU4364E5zuU4LxFCc5bleC8TQnOdyrBebsSnHcowfkuJTjvVILz3UpwvkcJzvcqwXmXEpzvU4LzbiU471GC8/1KcH5ACc57leC8TwnO+5Xg/KASnB9SgvPDSnA+oATng0pwPqQE50eU4PyoEpwfU4Lz40pwfkIJzoeV4PykEpyPKMH5qBKcn1KC8zElOB9XgvPTSnB+RgnOzyrB+YQSnE8qwfk5JTifUoLz80pwfkEJzqeV4PyiEpzPKMH5JSU4v6wE51eU4HxWCc7nlOB8XgnOryrB+TUlOL+uBOc3lOD8phKcLyjB+S0lOL+tBOd3lOD8rhKcLyrB+ZISnN9TgvP7SnD+QAnOHyrB+bISnD9SgvPHSnD+RAnOnyrB+TMlOF9RgvPnSnD+nxKcv3CEs4LgzKYbcrlCY6bgZ/3WdKa5rak+natva2jym/z6pvp8pimbLTTlmhqb25ob081+LlvwO+qbsx0B74mCMv+yn2ROl5f8X1XI6W94Ukc7pwT192sltl0pKPNvlMg8SFDm3yqRebCgzL9TIvMQQZl/r0TmKkGZ/6BE5mpBmV9VIvNQQZn/qETmYYIy/0mJzDWCMv9ZiczDBWX+ixKZawVl/qsSmesEZf6bEpn3EpT570pkHiEo8z+UyDxSUOZ/KpF5b0GZ/6VE5lGCMr+mROZ9BGX+txKZRwvK/B8lMu8rKPN/lcg8RlDm/ymReT9BmT0la71jBWVOKJF5f0GZK5TIfICgzEklMo8TlDmlROYDBWWuVCLzQYIyD1Ii88GCMg9WIvMhgjIPUSLzeEGZq5TIfKigzNVKZJ4gKPNQJTIfJijzMEGZgdWOPT4/DwQ+HGgS0BFARwJNBpoCdBTQVFMfkA+UMToBygHVAzUANQI1ATUDHQ10DNCxQNOAjgM6PtDBdKATgGYAzQSaBTQbaA7QXKB5QPOBFgAtBFoEtBjoRKAlQEuBlgEtB1oBtBJoFdBqoDVAa4HWAa0H2gC0EegkoJOBTgFqBWoDagfKAxWAOoA2AZ0KtBnoNKDTgbYAnQF0JtBWoLOAzgY6B2gb0Hagc4HOA3oD0PlAFwBdCHQR0BuBLga6BOhSoE6gy4AuB7oC6Eqgq4CuBroG6Fqg64CuB7oB6E1AbwZ6C9BbgW4EugnoZqC3Ab0d6B1AtwDdCnQb0DuBbge6A+hdQHcCvRvoPUDvBboL6H1AdwPdA/R+oA8A3Qt0H9D9QB8E+hDQh4EeAHoQ6CGgjwB9FOhjQB8H+gTQw0CfBHoE6FGgTwE9BvQ40KeBPgP0WaAngJ4E+hzQU0CfB/oC0NNAXwR6BuhLQF8G+grQs0DPAT0P9FWgrwF9HegbQN8EegHoW0DfBvoO0HeBXgR6Ceh7QN8H+gHQD4FeBvoR0I+BfgL0U6CfAb0C9HOg/wP6BdAvgX4F9Gug3wD9Fuh3QL8H+gPQq0B/BPoT0J+B/gL0V6C/Af0d6B9A/wT6F9BrQP8G+g/Qf4H+B2ScLQFUAZQESgFVAg0CGgw0BKgKqBpoKNAwoBqg4UC1QHVAewGNABoJtDfQKKB9gEYD7Qs0Bmg/oLFA+wMdADQO6ECgg4AOBjoEaDzQoUATgA4Dmgh0ONAkoCOAjgSaDDQF6CigqUBpIB8oA5QFygHVAzUANQI1ATUDHQ10DNCxQNOAjgM6HqgFaDrQCUAzgGYCzQKaDTQHaC7QPKD5QAuAFgItAloMdCLQEqClQMuAlgOtAFoJtApoNdAaoLVA64DWA20A2gh0EtDJQKcAtQK1AbUD5YEKQB1Am4BOBdoMdBrQ6UBbgM4AOhNoK9BZQGcDnQO0DWg70LlA5wG9Aeh8oAuALgS6COiNQBcDXQJ0KVAn0GVAlwNdAXQl0FVAVwNdA3Qt0HVA1wPdAPQmoDcDvQXorUA3At0EdDPQ24DeDvQOoFuAbgW6DeidQLcD3QH0LqA7gd4N9B6g9wLdBfQ+oLuB7gF6P9AHgO4Fug/ofqAPAn0I6MNADwA9CPQQ0EeAPgr0MaCPA30C6GGgTwI9AvQo0KeAHgN6HOjTQJ8B+izQE0BPAn0O6CmgzwN9AehpoC8CPQP0JaAvA30F6Fmg54CeB/oq0NeAvg70DaBvAr0A9C2gbwN9B+i7QC8CvQT0PaDvA/0A6IdALwP9COjHQD8B+inQz4BeAfo50P8B/QLol0C/Avo10G+Afgv0O6DfA/0B6FWgPwL9CejPQH8B+ivQ34D+DvQPoH8C/QvoNaB/A/0H6L9A/wMyA4sEUAVQEigFVAk0CGgw0BCgKqBqoKFAw4BqgIYD1QLVAe0FNAJoJNDeQKOA9gEaDbQv0Big/YDGAu0PdADQOKADgQ4COhjoEKDxQIcCTQA6DGgi0OFAk4COADoSaDLQFKCjgKYCpYF8oAxQFigHVA/UANQI1ATUDHQ00DFAxwJNAzoO6HizNgo0HegEoBlAM4FmAc0GmgM0F2ge0HygBUALgRYBLQY6EWgJ0FKgZUDLgVYArQRaBbQaaA3QWqB1QOuBNgBtBDoJ6GSgU4BagdqA2oHyQAWgDqBNQKcCbQYy36s334I331k33zA33wc3394237U234w232M23zo23xE23+g1378135Y1320130Q13xs13/I038k036A033c0307sBDLf/DPf0zPfqjPfgTPfWDPfLzPfBjPf3TLftDLfizLfYjLfOTLfEDLf5zHfvjHflTHfbDHfQzHfGjHf8TDfyDDfnzDfdjDfTTDfJDDv+zfv0jfvqTfvgDfvVzfvLn8vkHnntnmftXlXtHkPs3nHsXl/sHk3r3nvrXmnrHlfq3kXqnnPqHmHp3k/pnn3pHmvo3lnonkfoXnXn3mPnnlHnXn/m3m3mnlvmXknmHnflnmXlXlPlHkHk3m/kXl30JNA5p035n0y5l0t5j0o5h0j5v0d5t0Y5r0T5p0O5n0J5l0E5jl/8wy9eT7dPPttnqs2zyyb54HNs7bmOVbzjKh5/tI822ieGzTP5Jnn3cyzZOY5LfMMlHm+yDy782Mg88yJeZ7DPCthnkMwY1+zf97sTTd7tc0+aLOX1+xtNXs9zd5HsxfQ7I0ze8XM3imzl8jsrTF7TczeC7MXwdybN/eqzb1bcy/T3Nsz97rMvR9zL8TcGzBr5Wbt2KylmrVFs9Zm1p7MWoxZmzBzdTN3NXM5M7cxY/2KncMGz+xVNulwrzsFIcWw3ZFv9vaava5m76fZC2n2Bpq9cmbvmNlLZfYWmb02Zu+J2Yth9iaYe/Xm3rW5l2vubZp7febel7kXZO6NmHsFZu3crCWbtVWz1mjW3g4COhjoECAzdzdzWTO3M3OdiV7vNBUd1wS/o16ZPubsr9w7C5erDcmrs7yuvuySDx/fNA/nmfGKSRfNnJZ924sfvBTn1Qd577l/3MNjX6lYh/MaQ/KOD8mbHpI3MyRvdkje4pC8JSF5K0PyVofkrQ/J2xiSVwjJ2xSSd1pI3paQvO0heeeF5F0UkndxSN41IXnXheTdFJL3tpC8W0LybgvJe29I3vtC8u4Nybs/JO+BkLyHQvIeCcn7VEjep0PyPhuS98WQvC+F5D0fkve1kLwXgrzHnr7otbteevJ0nPe9IO/xpqfnv3hv7T447/tB3vPL7vjWqhFvsOFtR8w26QvDd/5WBf8rgl9zmYn5LcH/dHnJr0J8pfk3pRuaqryeSRh/tgrxdMA/Y/mn3PDf8ayGSR2dPfl7pN6a4H8C6dJeY/MqUN6mIG+I193nmmM/OK4i/Fy0O8YkrbeRDP4KJJtJMzq79SFTby5vec/sdCJXxvKfVT52n56wvGe7wd4VS+aUjz1dDPtcN9izlv88N/xzlv98xD/hAP8CN/y77HKhG/10WP6LEH8X9rPYDf4u/ie6wd/lW0sC/i54L+10YTuZLt0sc8K/oQv/cjf8u3xrhRv+XbFhpRv+9Zb/Kjf8Gyz/1W74N1r+a9zwb7b817rh3275r3PDv2tMst4N/4Llv8EN/67Yv9EJ/8au+HOSG/5dfePJbvh3xZ9T3PDvij+tbvh3xYc2N/y7/LfdDf82yz/vhn+X/xYC/t6u887SE2b918z7Xgn4cfNlOVnq03YumuoWpWssZOuuROflxmB+a4LU5xE5PVJ/ted0bu8nSH0WD9WPnbda3Q1isNYxebQNBzH1DGLqqWPy6NijHF4nCfJaJchrgyAvSRnXCfJaI8hrvSCv1YK8lgrykpRR0r5OEeQl6duSul8hyEvS7k8W5LVckJekfbUK8opr32HHm27HHTvXfgzPwW74Z8N0gWWy9dcgDB7K5349jx8j2bqqvd5jDRdjJE42jL9YO1MdlGMzmFcVk+eiTStD5Kb1FyvPjSVt+SEh/HH5Wq+3DQ8huqhyo4tMWLsNQXXa+oeh8/lC27mbFm7d5JFEx8ZWb2NIObseXOH11vfgIrw88n8MOZdE/HAahmTYdsGZ7Yu3bi9s8/pIYc7s9uak3xw1WNj6+ytYpAieYkZtdVfJYK3zejsUXUDgnK2SqYfjlRfktVSQ10ZBXisFea0X5LVCkNcaQV6SMq4W5BVX+1omyOskQV6nCPKStC9Jfa0V5CVpX5I+tEGQl6RNSMZVO5l1PAlqoIuXONk8PLhMkDw8UJ2B5KcpSf5jmQyPXyO+tBzFg8dNeLBXbMxgkuOJgV9F9CHMv2viMdjrqVMq05AiurL53K/lRfNsXf214M7Jxk2S6rzedkknXByvwSXyGsgFAs7Ga0KwcnLQCXbYpBXrxJYfEoILl99dJqH7knJ2Q145k9B9yblik9ByF4csTpPqGF52Qk3npia1BL/pslJbnvZlgrzbHcf3Rup7ONG+EOvW5mH7p31oNeJl+1CbNxRdV0muGxbCsyaE5/AQnLUhPOtQHp2r74XycOyiiRsH2DYz+vsX4kvL2WR0YvWZ6vR6yNISnE+XkRqb0mlbXzLgX+n1xo7rryTlfxX8ryb4rX5adhFnR2Or35Ft7Witb83nc+2tIwh/kyqQnvAmgoG7yb8zTlOcmm7yD/O6fXHL1tb8jNaztp27pVBBVFms60gQdlRs6ipd5kfO0S6kglxnuyTOVCnOBMODU4HlWev1xICvTZL/tHuh5yqY8okIvOxxMgRLMR4JwqMmhAd1HSv7UIafdZ0awr8l+J8uLxVo2MaJC9s0NNcRXJ4XPTTjZ1BKmaLhrol2KfZ6G1KpXoehfFx+cFCR6S7yg3vWN4LBEyXkmESHRTik0i53pGA9I1GZQaSevQXr2RuVoVOJUYL1jEJl6DR0H8F69kFl7DDA+udolGdltf45BuUJ3m5ptTLu5/VONm8sqpva1P4oDw9faeL808pUqn/ui/IwNswT+yfW674oH5c/JNGNZe+anvXTaQ6ertlnI5Je73Ya7fWWZbTH88bX1pD/Nt8kaw/7ofOC9pCOYte4/mrPpX12D3X2I3iofkoc6mC1Y/a1hJ0tg8viVIsg4fKV5D81BftIU5ShTpXX24wFVdzu1qTSzZb/WDf8Gyz//d3wb7X8D3DDv9HyH+eGf9fKxYFu+LdZ/ge54d/1WO/BbvjX267AxoR1aKjWEBzTrsfiMMltF51uixqSbf3VXu8Y5yIkjyF4qH7oUP4QBmsdyTNpTmd3OZqXZM5V7OG1h9cA87JDeBwD6BiD85cxIfWEDQ2Houvs48t0+orxcSurNG94SF4tIxedopu0mFy3F8PTxNW7E938irUB1g1dxsG6wXHF0Pg+eM0kvPD14wmvQ/vgNZfwwtcfSnhN6IPXPMILXz+B8DoshBfuK2uZ6w8jvCb2wWss4YWvn0h4Hd4HrwMIL3z94YTXpD54HUR44esnEV5H9MFrP8ILX38E4XVkH7z2J7zw9UcSXpP74HUg4YWvn0x4TemD12jCC18/hfA6qg9e4wgvfL29tobhFbh915hpKjo/EGMmW381wSqMp2vMNJXRK9YPHTOlGax1TB6NNWmmnjRTD8drgiCvwwR5TRTkdbggr0mCvI4Q5EVjTTm8JgvysrHCxgBsu5K3HqL2lbb+sL4y6fW25wkEd5KRh6t7AlO35cH1/Tgm4TyPqdMkqvujitTXl25MsutUtSGycWNfirnUsS++Pmzsa199w926oeNUfIvrEJKHdxWMJ3m1jFzc7akJJA/vKrB6w2PfSiLPB4LzVQS/sF+k6V13TlcDsM5RSJD6PG9g1zmsLsaH6MJN7Mr5UXVxKNHFeEe6CIsX3JqPLc/NLcYz5fGy/abC9oVbN51wwYrWTXjDEnYVCqeGlKN3Tg4pAquFlDuU/LcuTXFgXjhRHEnyn5Zv6aM8Ph7GnDeJm5bRpQeu2fC5sKUHW86a/ESCtyX4ny4vdW1CnuSGf9eGVW6KimWy9dcwekoU+bW8aJ6tq9rr3UYu3JOTLayd8TA4ylT+8BJ5VTF5Ltp0YojcuP6aEKycHMOIHFRHLSJyNDZyepLj3/1m1ElO+Oe6bsEd4UY/9XSoNDMwPjOcsm9Y5oaHCdJ+OIbK2WG2IWo8sPVXe737MxfxYBjBQ/VDlxtqGKx1TB61oxqmnhqmnjomjz4Qtau8OPsrB9d6IVwmrRDktVSQl6SMUu3oCcu4XJCXpIzrBHltFOS1VpDXSkFepwjyWiPIS9ImJP1R0ockbUJSX6sFeZ0syEtS96sEeUnq/iRBXpL6koyFywR5SeorrrFQUl+SMWd3GDNJ2oRkvy2le3NM599xsXsp3ZtjugYQF7uXtC/JOCE5BpDUV7sgrzzhFXVeb8vXMuW5dUG7loxvh9lr7RoKvuUluGaRCdMTvgVn69+Vh+Gt3upJObu9rMLr7Y/Di/DyyP96ci7p8Q/Dc0/jDS6C09ZL29fipTobxJTH/OhTaScEDW/0ODo4yb2MYRjivyLIsPZAtwa0BP/TZaVctibgN8XrTlaXtm4323WykR/4tfVXE6zCvtG1nsdty8L6oet5UxmsdUwebUNum9JUpp46Jo+OacrhtU6Q10ZBXmsFea0U5HWKIK81grwkbWK9IK+lgrwkbUJSX6sFeUnqa5UgLyl9mWN6DyEutrpCkNfrvR1NOkmQl6S+JPuhZYK8JPUV135IUl+S8V7SviRjjqQ/StqE5JhJSvfmmK5PxcXupXRvjun6VFzsXtK+JONEXMdf7YK88gGv2iAPzyfpIyDcI0+TQ+rB10+OwIubD9vyaaZ82DoYtnt7rV178FGei3Uwbq6PH6Ow9e/KOpjVm0/K0XUwvL4ytQgvj/z3ybli62B0T9ejgfKtfh3tlWS3v9NHGfDaGd1Li9fhwtZeub20Q4vwwi/ow18Lxm+zweU/i9bt9qvpybOvLdq2jTlZ6V7Xw4rUn/C6ba6SlP08wnZAgK3G660nq3/H7d2eIPVZveBzuP7+2pvHtRNnR9w6qyCetihxGeOl67JcjLdxA7+FCZefjGSkcQbHvUpy7huBUuq83rF+TmdPDFMYebi+waxpP1vRU7Zd3fON+XL9l21fWw9+lNj6vcHznYqestA4ga81xweifFz+38O6eb4U8KxlrqftR30RxyKTZnb2LG/b095/oGVoHLPlX0ax4iASx7g3eR0YgtnyxC/dxJjtaxIohp+RfsfRGj7b79i6agle2j5UFq5NqN0dyeihhrmOxmFHcSZyHLb199ebxcIewcd6dWwfbVHiFsZr2/IoJs/ysmM27EO4/BQkIy6Pj+31+NxfSBzGMZvGYW4cyz3ybmLH70mMwvKMIbKVOo/A11Md4uvKjfcc5jC/29V6MC88ZsTtWix24nv4uD1w7MR2SGNnlw0FQE38Hh8y1sN9WzLZN9ahDNZKUv5HqG8bFPC0dlOLrrftwbVPLckbw9SbIGU9hBOXof2RxTmoSPnaInLVIJ2OJn0i1gXXrrVFMKQYuUyi7WrL77UL7Toy2TdWbq5RSco/hdp1H9KuWH9h7VpH8nC7Wh1xfS5t81L7XHz9mJB6RpE8bDv2DbE15L/NN8n2RbiPl+uL2iM/fmzrryZYXfXV3Kt3sH76Z87Uno7SB2G8jscOWW6/R7HXf2B/xOXpnAyvNeF1s0pyLhMYBjcesfwlxwn9zStsXZTG+YlEF9heE0V+LV96Lmw8T2OEi/GLSTa+2zg1hcFA+xpbDz1H68HX23KcnxhqCf6ny0rZNLdvTJC/z73WSpB/xvJPO+Gf63rlBV3DxW2TQeflYlh95Gdobf3VBKurPidD8FD90D13WQZrHZNH2zDL1JNl6qlj8ui9r7jwWinIa50gr42CvCT1tUaQ13pBXqsFeS0V5CUp4wZBXnH1IUndrxDkJWn3JwvyWi7IS9K+WgV5SdrXSYK82gR5Sdq9ZDtKxi9JGduFeJljOpYvB1e+U46XpL4kxxO7Qz8kafdxHX8tE+S1VpDXnvHXwNm95NhkT59WGq+4juXiGgslx3KSsVCyHSX1FdfxF13rfD2Ov1YJ8pL0bUkfktSXZD8k6UNx1b1k/FotyCuua0OS9iU59o3rGDOufQe9jyXRd3D3UPF7t93eZ0pnLf+cI/5husIy2frtfaM0Kp8o8mt50TxbVzXhJSybHyYbxh9mU1gH5dqn5VXF5Llo00yI3Lj+Uu8FSvmZOR4jyKuG8OL2QnD3Qm35HFOes5Napm57rW3bepQn2LaZsLbFMcLWvyvPW1m9rSTl7OfjKrzevpEtwssj/1eSc0mPf96Ke6atrghOWy89F7bfbWpIPfuUWc8+EevRLA/lbfdZcZ9ldLvPpL7D7T6Thgz3DKUc/1w9N4aQ49/YxPU3gvpps/1HjtgGbns38bAhG3XMYeuv9nrHShdjjnqCh+qH7sNpYLDWMXnUBhuYehqYejheGSFeJtF7SuXwWinIa7kgr1MEeUnKuEKQ11JBXpI2sUyQl5RNcDF1j02E81ovyGuDIK+4+rak7iX1tUqQl6SMawV5SbajpN2vFuQlZffmmL5rJy420S7IS8omzPGe8dfA2KrnxbOvNcd0jrwnFobzygvykoo55jjtyfE6QoiXSZI+JBmjJfu0uI4L49qnLRPkFcd4L+1DkvqSitF7+o7XR99hkuTcSjIWniTIa8+awsD5kKTuJWVsE+QV1/mQpO7XCPKK63qh5DhnT5wYuPHEnjgxcLqPa5zIE17c3p86dG52UN7uccD3Qul9mPo+eM0kvPD19V7fMmJecwkvfH0Dua6xSD34PTfYDhqZujn+lkcVc95QS/A/XVbKFaoYOeT4N7Za/k1O+Gfy9n57M9JrIvi1dR+NzsvtDchFfqekrb+aYJXF071X4WiCh+qH7lU4hsFax+RRGzyGqecYpp46Jo/2t+XwOkWQ10pBXkuFeJljei+mHFzLhHCZdLIgLyl9ecIySrYjjbNxsdWTBHlJ+rakTawX5LUnfu2JXy5llLT75YK8pOzeHNM1/Lj4dlz9UTJGx7WvlWzHFYK8dod+aHeQURKXZFyNa79N5+1xsS8pfZljum+rHFxrhHCZJDU2MSmufdoefxw4GePab+8O8zTJGJ32ZHiZFFe73yjIK65rHa2CvFzEaPpcpkktwW+6rJTN2bVo/Bx0wutZL15/Flw3LyRIfVZH+Byuv9rrPW5wsY7P3afC+qkg+ml0gyefIPwxnkZGP7Ytm5g8y8veZ8D3yXD5RiQjLo+P7fX43G2VO3/rGJ40TjYx8uBzVr/m2wo3B3xL8IFMe4efrS801qcbWnP1+YZsJp9pTOdz9R2+3+RnmnNN2WxHe64p35TJdmQaM+302VGLFdfrqI1zUX3A1l/tOfVJP8zmuPvRnM3Za6ktmLSks7tcKbYgaVccLvtNpLD3sri1hWzbrtpC2gmecFtIM3otxRbM8SR0XG770TF1ObzWCPJaK8hrpSCvFYK8lgryOkWQ1wZBXpIyLhfkJSnjOkFeG4V4mWN6vyIu9iXpj5L2JRkLJXGtF+Qlafevd5swx/QeaVzs62QhXtIyStr9KkFeknZ/kiCvPXHi9dF3SMrYJshLajxhUlx13y7Ia48PldZ30OcE9viQTt1Lzt0l58j5gJddQ5qE8lqC33RZKdv1/sMjxHl3vz95avm88/QEXVcTxJ3jnoOQWyPLpblnHRJy+Lv4HyOvm673fR4rzzvT13fjJw7qqa9pQZli340/FOXj8jcO7uZ5RMDTyjXcSZvkclG+0T4anZezt0w6QerzPH6N2NbfX99oH03wUP3QNeIxDNY6Jo+24RimnjFMPXVMHu0byuF1siCv5YK8NgjyahXktVKQ10kxxbVCkNdSQV7LYorrFEFeknYviUtS92sFeUm2o6TuVwnykpSxXYiXOabfRi0HV75TjpekvtYL8oqrb0v2HXY8YZ99x+PHI72eediWJpP69kN5mL8dl+6P8iXHgZb/ODf8u77FcoDXW8dYJlu/HWeOReUTRX4tL5pn66omvKR1FyYbxk/t5wCEB+ugGK8DSuRVxeS5aNP9Q+TG9deEYOXk2I/ohKuHm6PY8geG4MLlrV9i27fXWh0ehPIEdZgJa+8DUZ22/l35jo3V24Gk3OzObj1Q3Y8rwssj/w8k55KIH05Wx3geO5rw2ofIUKx965jrbbkoc3s3cSAb+Rsctv7+mtuPjahXq7v9Gax1TB6d23P+uT9TTx2TR+f25fA6WZDXckFeGwR5tQryWinI66SY4lohyGupIK92IV7mmM5LysGV75TjJamv9YK8JP3xFEFeknYvGQsl23GVIC/JdpSMX5L62ijIa5kgL0l9SfqQ5HhCUl9rBXntiasDF1eldG+OJ3oyvEyStHsp3ZtjurczLnYvaV+ScWK1IK+4jleP8mR4mZTv3Pnrdo6fzsR1TQ1/bzZR5Nfyonm2rmrCS1g2P0w2jD/MZrAOyrU/y8vx2npXm44NkRvXX+o6TJR10qg6GUZ4DWN4ha25Rm3bWq93e9prHftY15rrfl5xPeH6d2XN1eotQ8rN7OzWA227sUV4eeQ/fda/rzVX3KajSB62vzpSz3AiX19+iq8fHlLPvmXWs2/EejTL09f+u30G83UW2383BuXj8gW0/27M4J4y4utHeD3zsE2NJHk1KG9vkof1ZstZf69FeXL+7qetLm174mTz9kJ1DyV5I1AelpumJPmPZTLx49eILy1H8WAdYmyYJ25rTq+VpPzhg7uxHFbD80wgnhinvVdky1tdDvK65cZlKAZbfjLCcFANzzNVRK7aIjxnIBueOpjn6Xm8L1K59iJyFYsplaR8Fsk1GikOl7H/cZ9q36dg6xrB1OUVOUdtY0SRvFLrxfqx50ZGqDfB5FFbovrE1xfTObUlW35aiC3VMBiwPmi7DycYaJm9CAZbfjqDwejZxpD2rWddMKP1rG3nbil4JKXQMQ31XFPTJqhh+BRLVg1GPOsulI/9H2YmnDt6Rc4Va/Zh6Hy+sKWwvVBEQRWE2dAilVV4fKKx1F5nkts+Z+cYE9fnefzcy9Zf7fF22yKDx6dx3uKh+qH3gusYrKWOj7BMNL5EGR+FxY7hEeUZ5nUb9rbtW88pZnO4D+dsbliR+hPM9R65NsGcM8k45YrAKatIvcJ20PWupGEMRm7skSB5WF5qK9SXcB62lRTJw/1FJcnDfcsgkjcS5Q0meXujvCEkbxTKqyJ5eC9GNTqmiRvr2TYz9f0L8aXlbDLy5APg5trX2xyG8qrwes9NTLLfDbK272Y/THva4rFz7mLj531QPi5/FurrJ5HxBrd3aTSjL4oBl8dy07bCNkvXe7i6uTGu27XRbv3uj/THyTYW5ePy54fol1s7C9NvX+unFo/VL9bp/oRXX/qd2bnzN+767RxA/XLrnNyeQBrvSt0TWBeCAdezb5n17MvUE8arjuGF5wkwEN58XuGcxVu3d71W07LEavXIcRU5N4z8p0PfUUWgFhta2//7kf/0dsMh5P9eDD4uWRw4USxJr+9kTd3q6s3I1CcTU+e6NlynDZd0CQ5fi5fgrHkdh8pRMz6OqROfCzNjW46rhz5acDxzXYLkYQzHh2DA19tyNsS1oDy5EJfrCnHTA37FljNbUD4uf0dIiLPXYPnHM/JTDLh8Cypj8XC6t9fWMHUnivzaeug52i4tqMyEfqrnsOC4lsmjtt5C6qHnwmy9pZ/kqeunemr7qZ6afqqH3p6YLljPdFTG3q6w9nYCyqNx7QRSDz0XFtdOIPIcJygPF6dtPRhfufVg3dDHyWagPNzHWRwzGRw2xs9C5wWXICK/MtnWX02wCuPpWhqbRfBQ/dDljtkM1jom71h0jPNwPbOZejheEwR5Wduo9XrbykxSzwymnhkh9cxk6rF2NRflCY4dmm27zPN6J5s3H50rdHbjoIlb3rG4zdhiak03X1qO1on1Op/kYR9bQPJwWy0keXNQ3qLguNbrrV9cN86zMtJztB3x9XMJBnxduTGMw8zZ5SwiT6l2OYupp4a5rlx5OMy0zSXqwfLMJvXMFqwH2+IcUs80dB3eovBbcivWXofH9PhauwxYScp/aFg3zz+QZfL5CJdgLGmzsi3weiebtxDVTX1jEcqjdrYY5VHbOBHlYZ3TxMUnqwsTn5aUEJ/moTwrk20Duz7wP3SL/bXBPa/HbUhfw4/7zzkkbw6TZ/j/rrobD9YD3haA1yeo3djyY4J1f7f9TkMj17fQsdQCR3VH8Weub8F4LO5qJi9VBtaO9qZ0Nt3QkC805Nrqcx0Jr7dPJZlzdB6+kCmfY8pbXS9yo+uM9aVkZzd/3C+blEJ5C0heJcqzGI2Jbq7piX+hI/xR9I/rr2PKz0UylNKWLnnheCDBa/gu8hrh9e6TbMxxPPZt5WKQTZzP+yQP21yW5GF/qid5uC/Dt41p6ms8vb2E/gr3iwuK8LR9AZ4L2D6mkpSdFPQTpu85bEjPuvCYcH5nzzw89rL1GB4tQ7rP43rwPh3bT5p0YhFc00j/5Wisk+fGOrT/Wuio7qj9F53/YDwWdzWTV07/1eZ3ZAvptrZcpi1f39DQENYf4XO0/1rElG9myltdL3aj6zau/1qE9GpSCuXRvg33XxYj13+56X9zbVH0j+uvY8ovRjKU0pY2tnPjJm6efzTJw3M+PNZtIT7uZpyYa6d+gxMX52n/gG2S9g94zkL7hyUor9T+weqi1P4Bx0ksE+aZQue4GF9Jyp+I+ohFpI/Afbqt25R7hpRbyOB26zPR11pt/VwMdbHWysVEzu84+6P+jfPwp91wHq5nMVMPx2uMIC9rF7VebxtdSOqZz9QzP6SehUw91q6w/8m1Y71v22Wp1zvZvGXoXKGzGwdNnO9b3KWutWK9LiN52MeWkzzcVitIHo5vK4PjWq+3fnHdOM/KSM/RdsTXLyEY8HWJIr+2HnqO1sNh5uySxs5S7XIRU0/YWsmuysNhpm0uUQ+WZzGpZ7FgPdgWTyT14DE6Xmu9iMw57HV4rZWbe1eS8m9Ha62XkLEJ9oOBiiWcbyxHedTOVqA8ahsrUR7WOU1cfLK6KHWtFcdqLBPGHnVsYsu/ibSTo7FEegSRi9Np2Bpo3MY4bubT4WMcLl6WOsY5Ah3T2FPquGSWIC9r27WeV3RckiB5uJ6FIfVw46XddYzDxZD+GuPQsWqpYxx8fX+NccLsko5xSrXLRUw9YfO9XZWHw7y7jXEeFRrjXIzGOI/3y/qL7BiH2pmrMQ5efylljBM2B+trrSRB6i42FlrQufOXrtM8h9ZpvjKkOK65qO6ZVT3L7Vmn2X3XaaxdcHupaN9X6l4qbr/I7jqGwXrt7zEMrhvnWRnpubC9av01hgmzSzqGKdUuFzH11DDXlSsPh3l3G8P8Q2gM04HGMK8pXKehdqZpnQbfz48yNumK9cE4Iw7rNNxeV7d7VKKPcWz91QSrqzEOFy+5PcRc/2Sv5WIPXafhxlKLmHo4XrMEedH5MLcnOkHycD2zQurh9j073tfQQft/nLh+udQxDt7rUMoYB+uVxkLsY0tJXqnrO7Veb/2Wu66Hr++vPnQWkQdjoGO2Uu1yLlNPDXNdufJwmF2PpQZq3anYGKe+qvsafF3UMY4tfyIa4zSRvtPRPpmSYgnnG0tRHrUzPI6gtsGt70SNT7u6ToNjNY1PeK3EluPWSjjfcTyOKESxZW4c4eh5xtBxBBeTjFnbz2ttKmxfcm7bls3tCwoXbJt+Zn5J6znbN7dumZ7Pn1PYtg1LQ62GSkuthZaxxz5zHvNY0IcUszt3/nIz0QWE18I+eM0kvLhd6DSKFOM1l/DiIhft+Thvo6MpXB7jWdwHnnmdxfEsJrxODOFljg/2evLiZp6W15I+eI0lvPD1S8h1S4vUg8vgaLiUqZvjT+12WR+YDyCYMS46O1veB6+DCC98/XLCa0UfvPYjvPD1K8h1K4vUg8vgWfBKVHeCOcfh2T8Ez0rCa1UfvA4kvPD1qwiv1X3wGk144etXk+vWFKkHl1mNzq9BdSeYcxyecSF47LVRejiMVbBHibwr3tbfXz1cmF5NojPltQzWOiaPju7XMvWsZerheC0Q5LVIkNdCQV6LBXktEeS1VJDXMkFeKwR5LRfktVKQl42J3B2PDKmn1Dse+Pr+uuORIfXMQNfh2ebNZLZpbRDPNvFMZzTKx+Wb0GzzHQFPbiXCYuT0TFddStUzV4/ta7ANC67qdz29jPtwm2we7uemomOauNmpxV3q6hnWK+2TcZxZS/Jw3FhH8rDvrg+Oa73e+qUxkRsH4nNhdkzvUuLryvUXDjNnlzQul2qXS5l6XPs/XRVdKlgPN3+g9iNRDze36CuePULimb2uWDwbh/Jx+YNRPHuMrJ5hPxjIWEJ9gxuX2Lx1KI/axnqUh3VOExefrC5KXT3DsZrGJ84nqrzetjcQd9ds/dVeb59zMWfg1gS4WMPFb3st50/HoGPqt0nmXJhvzhLkZeeSYWOHBMnD9YTdxeDGGo7HB/X0LjxONURmkwqd3ThokhwfYL2uInnYx1aTPNxW1G9xXLSxiBsfUHspdXyAr++v8UHY3TU6PijVLsPueri6u7a7jg9eLWF8YBK9u2bLV6PxwZ/J+MDRbsSSYgnnG3jdj9oZHldQ2yi2rkBTXzscd/XumpXJ7RigPsPZKMWFY9wMBn+YLpYiXYwd3s2XlqN1Yr+lds7Nlbg3/zWgY2rjnN1TX8PXzyAYwnZDORqvZaPEDFx/f+2GWhpRr6WO1yTHWHRuELZG72h8G3m8bevvrzV6bm7fwOi1P+y7WDvPCMHjZm7a/dHXsHt6GI/5gsEgr7cNFbv3WOzenz1XrG3C7q1zOzTC/DTs3nrYetCyPnjRe+ucDqgP03Ic72J1c+NJ7Gf4vB3XYF3RHVDLSFluBw8dT1UUwbAM5eO2prIkmPIcP3qfmBuzY570vvAMhlfYXML6GR5nDURctPVXM3K7iIvc/W5ujmb8fjDRNbUZ3H7F9nWcyMhK40FfmGg8KPUePOY1k/Di7sFLzkG5tcByea0R4MXNjVeSPDzPWEXy8DyDzkHWMvisv+H1y4HwN1t/NcHqyt/WETxUP5y/FevvcH8Qpcw6VK89Z2h9H5iov+E2W094beiD10zCC19vr63wercFt39pQx/53LqVh85tJPVhfutI2XWkLLeHqNj/jSXwxRjWk7LrQzCsImWXF6mHa7NViK89j3VPv+IQNUYsJ3ncHiZ6v3l19c5fM8ZcX1283oUh9S4Oqdf2P5g/fYpsI8LQGoJhRgiGJSEYlnq9+ds25dbycP5CRhb7H8tebFxF99vMYsrjsarlx+3XpOsSuJ9fTepZwtRTbB8l/j+kiBxUv5K2Qeuz9uEzdVSSsluru3FPQmtBuIzlYZLbN8lG7wdt/f01H+9rD3TYE/S0fbkn1ak/4HqiPvW+QJDXouB4d33qK+zpcKxnF099lWsT+Pr+euor7Ml2apelPtm+gKmnhrmuXHk4zLTNJerhno+g9iNRT9hTX8XuS91GvtrBPfUVdl/Klv/z0G6edwQ8Hb9ZWvSpL2pneIxBbaOcp76sLsrZt1LsqVR8rdsn7tL1Uftt+pZ3R0+XdfXb3HNQXKwxt1HtntJNhe0LChesat2yOd+6ffPWM5cVzj63sG07FgOzTjFi0uZPkepsObo0OKezdzmc+uuh2qjqo49H4eupmwyAWea0myU3rLDXcmF+Ejqm3UmSORfWZZT7skfMq78fCnfc1RS44ZRNXDdU6OzGQVNf3cKubqeiL7MJezF1qUPaWq+3fst9uQW+ng5X8HWJIr+2Hnouygs5OLuk9l+qXc5n6nG9naq/XtA9UMPjYsPWH5BhK17uiDJsteV/gIatPyLDVkcffSoplnC+wd3S4oa01Da4IW3U+IQ/+rSr26lofMIfILQfU7J5+EO09AOZ+COqlj/+ACHn2y1ez7wWlDc9OK4kuFKBbVSRcrL2kO36kBP34U+3tpiN/MhqsWk4xs2Npcr5kFOm0Nbe0NrakW3vSLe3dhQShL/FSs/hJVwaE235NFPe7dg022r9BX/ICfuoSSmUR18bUYny8MtD6Iec3LwgPdsaRf+4/jqm/GwkQyltGWXuEpXXCK+n3WLf5mIT9UU3cSD63MXWX02wCuPpmrtM93rrdRqjV25Maq/lxi70ZbKljre4+C7By/Y9XF8xjdTTwtTTElLPNAZznD4yaVKhsxsHTX2NDUqZu7SgPDq+xD5Gx4Rh8wbs0/TWINZvCzrelTiEr++vJeoWIg/GgPW1K3Y5namnhrmuXHlaGMy0zSXqwfL011yMjlOLzV3SQ7uvwddFnbvY8k+juUuWjFWxHwxULOF8A68ttJA8PE+ntlHsJYk0cfHJ6qKcuQuNTy3MtXEdH7S4wRM6PmhB53Z1fEBfxFpOnz5PkJe1i1qveOwM0830kHrw9bbc7jo+wHql/sdtG5ccH+C6cZ6VkZ4L63/6a3wwnciDMcwg8pRqlzOYelz32zNIPTME68HyDNT4AM+h8Phgc4TxAb622PjgQTQ+2ELGBy0IV1zHB9TO8PiA2kY544OW4LjU8QGeyy0owrOSKXs8ybNlL0Dt9aHguJa5/jivZ95xKO8Eknc8yptG8loYnjQ+YJvD5ZuIDLZ8Z4Db6HLycJ5nhcePE6wdWxvFPipno+1pi2cWIyMXf+gWyquQjJOIveC1Pav74CltL9XpRB5/R79KtnJaO9iBH9VL42iSKU/XT7mxEtcfRBl3Hc/wmo7O2fXBgbQB7DPFbOCmiDZg9ToQNoD1GsUGuP4/qg1YnYWtpyW83rZGdW5Sf9uAxYdt4ARUJ7UBW/7OiDZg9ToQNoD1GsUGcHlqAzOZ8rhtrM7qvN7tPofwms7wakHn6H0Cy3uQx/dHuL/C5e9DbTS6pic+rk+2eccxvHG/nCA8sBxDGTlqSB6+1vCdOKgnfjuG+wgaEzxFxnCOPoTb9Qi4HdNw405cfyUp/wnGLxLkGqyvFnSO2hy3b2o+o8Naojd8rVt95dq4ObJN3LiWjnmjrnvRMS/eI0DnMHiPANYJTdx42OrJtN+sCK8LwbaZIHXaOqivUL+YxuDFcyHqF88gv3gpBn6B42Axv3i2RL/g7rFF9Qu6RqXdL1pIHvYL6jNx8ouXIvgF7oepX8xg8OJ7CHQ/08vIL14lfuHmkZ5uv+A+iofxL/Z6YrblfxriF9yjMGF7PbhPMnAxlHtc0F4bp0egsB9we7yofeM9XnT/F35sga6nco8nRvUL/MhVVL94lfgFt9c4ql8sRHx/QB6Ztbr7K/KLwcN2Hrv98GK3X9i2LOYX2G9w+X+G+EXYp0dMon7BvcIGy039Asdee63jD1WmaxisNnG2Tx/nifqhpii2b/PwqzuwTmji/AI/IhzVL6xtJkidto5S/GIR4nsb8Qurj2HodYLjiF9g2V34BX7EnvOLlV5PzF2v9Ahwcn7BfWqFe20txYDLY7mpX3CvNHCrr/qGGgarTTYPP0JOXycU5dUn2LdsHn4lA320Fb+igX4WByfOL6yeSvGLccQvuNdpRPWL5YivfS0n9YvxyC/q+8cv8lY225ZR/cKWn1iiX4T1F9xriaL6hb3WsV/E6rXlNo975YtLv6h35BePkE9pcJ8SsHX29apAup7r6JVh7dTWi/nPCpSPyx8X4j9RXz8Y5m/cq1nCPvk1kPFmGYOHxptZjL649e+lSB6TUp1O5Clw69+43SpRvX21kUmlxkSrsyivGuJen8v5pOWJP5lD5zZLUV/VHoO5Db6/X2xuszLE17i5DY4npc5tLJ7Xy9yGjuFw7KDznjjNbdojzG3wWiHtqxYwePGHi+m60qnILy4kftFfr88t5hf4c1e4/JYQv+BeHcs9jx3WL2O5qV9g27fXxu3V53Schu2b2j5n33QuxfkajttYJzRxfoFftR7VLy4kfsHFv6h+gV8f948hO4+pX1yK/OImJX5xRYl+ge+n7O5+ESXux9EvbnLkF48W8YtbkF/cp8Qvbt/TX3SlUv2C3h/R4hf3OfKLi4hf2D07DyC/eIL4Bd7f58Iv8L10bg/KPK8nZlv+oyF+Ya/B+sJ7m6hfcPfmsdx0Dwre62Svdasv2X3XM0genhvQuQe+R0r3t2NfwDqhifMLq6dS/OIJ4hdzSB24rUwK24MyB/H97eCdx7Z961C5yV7PvCkob4zXE89RDB5cfigpPxVh4MpbfpWk/JeQ7ds9b9b+0uh6QX9ts5h9hCnJyJUmmG3550L8Nc3o7Uh0jvqrz5THcls8tURv+Noq8t+VvjKMvo5i8FSS8i9EXHurQ/KYlOp0Ik87t/aG260S1dtXG5lE2zTDlMdtY3VWR8rj9rV5k1FemuRhn51CMNQxGKLu9bTXGl8eGQQ8LmbQeIJtgcaTqQweXJ7GkzTCwJW3/CpJ+Z+HxBNH/tEa5h9YrmL+8auQeMLZXi06V6rt0XiCY429tsrrbZcu4kmW0ddUBk8lKf9qxHgyBcljUqrTiTxsPMHtRuNJWBuZRNs0y5QPixlZlEdjBo4nPsnDPnsUwTCFwRA1nthrd/gyiSe43GGkzslMnbgvndm587eKwezi3hOOOUmvtz6LjXEqAuPk/JsbZ+2LzlFb6CuOho3x7LWO9dUWpq8jI+iritEX599DkTwmpTqdyMP6N7ZN6t9cm+Lypbap1Vmd1ztGTiF52Icmk3qGMvVgf6I+jNvKXmt8+DuBANUo3/6W8w619raGtpx5j5qfa8jm0vkRhL9JVndDHdSfq29tbG9t9P3mnF/I+fX9XX+hLdfc2NbcXp/Op5v95mx/19/Y2gS1N+dacw3p9nRjQ3/Xn2lqamjOtKVzjfn2jnyu3+Vvyze0p5uzfr61tRHEb+p3+fP5gp/zG5ubCrlcvrn/7a+pGQyvo9Dq+34mny70d/31+bamdGOmtTnf3pDP1rf3Vb+Jy68E/23MqkBl7XW2v0ui84L9Q+R33dhz1QSrMJ6ud90kCR6qnwqiuxSDtY7kmTSns7sczUsy5yr6mVet17u9aZ/L6SYZUg9tK5NqmOuozVGdtgT/0+WlyJ80sPVXe059wA9rP06vVneVDNY6kmcStZNKpp5Kph4tvOz1JlF/NGlRZ8883MZUp1Ft1b7HhcbSWq9429i6g0eAe5yvZPBWkvKryJrMYIK1JfifLjPRvgPXVcXIJ1h31x74QV7vVMPITdt9CMqjbVtFMOM83B/T737glCT/sS5M3Z0R7mFwNpIgeYMYOWwebXeT6rzetl1J8rBtDyJ5OLYNJnnYl+z7uxOEp+d1+yxuOzsvqvWK+95QdH5wZ09+O37Rucrg2Op3CC5P8qpQXqqzu16TqoP/KVQP5mVxVJLy2wLmdh1xELrGXl/H1D+I1N8DN3MOtxXllWTO2fI73gEVYCw2zsPtQ/tcRzElcp9r66/2evuBiz53MMFD9UNjyBAGax3JM2lJZ3c5mpdkzlUU4UV9plxeFYK8bFzgfHsQqSfB1JMIqYdeb1IVc11L8JsuLeXoCcub9hG7yJ+mVtrP4MSt+3L+gvWHE8Zd6rsXsT0MJXm4HxxG8nCcqCF52EaC7jA0/u+qjdDrMQZ8XaLIr63H66MeDnMtg4GO87i+sSKknhRTT9jcfFfl4TBz4+Zy68HyDCb1DBasB9viEFIPHlfjdy/eQ+4l2Ovweju+dl5ndz4unxrezfNeMj7HfiAYS5rpeBYnbjxLfQPHGWpnw1AetY0alId1ThMXn6wuSn33Iu4HqhF/6pdJ5to961nu17PoOGdX16BoW5fLy+q6v/odx+PnJtq34sTFg0JnNw6aOP+0uEsdP2C9VpE8bPfVJA+3FR13YDuw8Yib+ybIMTeWx+fC+vX+6p/C7DJJypVql0mmHtfjoSjrubtaDy7TX+OUQaSeYuOHl8n4wV5XbPxA391sy/+uppvnT8j4wdEaW0mxhPONqGMLahvc2CLBYOhrja2U8QOO1TQ+cX3CUK93G/0BtVEiGO85HuN17Yu3mDm7wvVXkvJ/Dtk3w835ubEAxYDLY7ktHm7t0l4btzExtWlu7s3ZLbVpPCamMWo4ysM6oamv8XLUffEJ8h7uQaQOGpPonpVKBi+OdXTuMwjNffYlfuFoHSVnZbNtWcwvsN/g8tUBTs4vODvn1gIpBlwey039Atu+vTau606c7dM5QlTbp75Wi/KwTmjqa50rql/sS/yCi39R/WII4nsPirGvEH7cWMzqicZcXN5jziW84v0VrSPJ8JvV2TMvFQEbN/bymHMctmQf2FIMNsq3IkSOYvVEWT/jbJzD7mSPWKa9vjVb35xuL9Q3tjY09vsevQ6otaMxXZ/J5wqZfGtf9XP3uPAeUpPsfTJ8Hw2Xt/wqSfks6jvqiR9XMvWZcjNDyiWK/O7gwZxLdfY8x91fw/cdbXlbd3Vnb4w2byjKqyT1DAv+Y31hXhZHJSk/PZDdtgm+V2ivr2PqH0Lq74GbOUfvOw5lyg9lypv2OTrA2NU3o7ql17R21En443MUm7WdYvs16H1GnIfn7zTuda0Do/N47YDu5bDlF/bPeIndy1FFZBiMZODGPXTuastvQj584vCeOuPu33H6pPdT6PwA52HcVt9Wf0Pd6K9rHmbHQXi8ibEO9XrqyJZfzYw3uf34g5A8JqU6nciT4/bj47Eh9lksl+d1y43L0351GFMet43VWR0pT8dZ+D/mhcduswlWPGcJm6fS+X0baiP67QjsN9UEO5ad7gVIMvVy601VCPOlJCY42vvQyK1x2sTdw6XjJeyHdJxVTTDjPGwHpa7/WF2UusdKIg7huc0OfJ29cQ2E3+L5KvXbsLmp5/X227783K591nm925LaN9fXlOIzJs0m9WF7wXOwS4v0632t315RZK2k1PXb21EfeDXpAyX39/Vll7R9bX02llC/bAn+p8tLkfd1da2/eJ7L8Y4fZv/cWo7j8UMurF/k/HEvb+faCW0zjM/ywvNouz8hbA2W2npfuqljrqf7RnEbh+03pXEgyn5TbO9DvfCxeoLwKrYuSPuDqGukdOz7HuT3TxG/D7vfx+3F48a31O+5/cnWdun6dEvwP11e6rLdrvm2x+sUj41x+XtD1lo5f+D2HVIMuDw3duSeje7aD0z+C+ura64wvA991RB92fIPhuiLk39wiL6GM+VrQvSFdYmvpXUXi0X9ZYt96Zbaoi3/yYjzsCFIHpNSnU7kqefGc3gMVonqLeYvuHyU9uf8pY6Ux+0dtk+Ci/FDSR6OzTT+4xhvYxuOpX3dk7LjN/ucdhWjB8lxBY7N0vyb0rkmet9SOjY5fqYu63jPQtra3czObv7c81PW5my/jY8tJm5PjOXL7R2cRfK4eYrxZ7v+ao7tupv1pTkIg623yuvtQ4I21eh4r6M/sgh+K5tJMzrd1G3ne+MDfty9LdxOVcw5KSzcXJO2saO1nEyC1Od5/PzL1l/tOfVTP+q42tqM6ZNsv7Ft+9ZzWjcVlhVa8xg6VR/9xaLjPLpFLEH+01uotHyS4ROWEgxfTnTrEmFbU7lbxBj/rphzR8TkEX0M9oq7eSUpe0jwu2OYFRwP9dwOpxqb0mmrGzuUq/R6LyPi+itJ+cOD/9K3XOGOq9+Rbe1orW/N53Ptrf3+WojWdKaQ89va6v1Ca3NzR1/1vzM41j2camzsr+GUo64143i41jWcssuaVBZbb5KU467hhlO2DDecsktVJkbs53UfH+R1X2PSfFRPguQtQHkVJG8hwYfzFqE8uqy/GOXRpduoj4m63OYIQ7oOt7eLM03clBhv3zIphfKGkDw8bcVbtbYS/bh4TAL00+p2m2kmP5LBT5cMHA15M5b/TDf8u2Kyne54crzTlvdsN9izlv8cN/xzdrpxYcAv7DEEt1PhTCHqkL/r1QWe076ka8jP3a7nHtcyQ377msZNhe1Lzm3bsrl9Zuv21hXnFAqrN28/s7BtGx3fW95T0Hmcj9MUUh9XDvcbtFySua6iD9lmdu78jfK4WV96ovMDfD3tlwb1wWs24RV2K2RwH7zmEF74+sHkuiFF6kl6vZevcXnMg+NvebjsR9LBbU3ch3E6wfVzt3fo4yb9f3s20xw1VsTh9ix3O9Tt7dlMU4Lwx3iGMvrhtsXTx6G422W4/FAkIy6Pj+31+NyM4JdunTLJ9tkJJi/JnMNbI6cR2XDbJIr8Wr70HL11jHVDHwVyNYZ1fEs/TZeBcV1Gn/PReZyH7YG7NVJJyq9GPBcFx9zr+apJHrcEmvB6x/OwPjrKI5jcNhVON5Ukj+uDuEd/6WMjfW0L4Pw1zB+4LQjWdoYT2VqC/+myUqbrddh2G3exGIFvc+LyG4PfHdvgiIzcLT+ubSkGXB7LTR+9xnGqtn/01RSmr2QEfeUZfXFz3P55HXam2eC4AuGgtlmJ6i3Wplwcj9qmVmd1pDxuXy52DyP1cP0lHjfP7PR6yBglVpo0uLMn3x2/6Fwl4mtSf7/+7YLgf5xf/3ZOcKxh3f3S4P/rbd291NdBu3zU6hpbFui64LivR61uCymXKPK7gwdzLtXZ81zcH7V6R/A/zo9avcXyC36x7NLztR11Ev74HMVmbcfYtf0sivLtOXvuJ/WRuO05YXMHHB/sNWFbb8y4yY5jzHEt4mcSXlfuijOEn7BNNAzk9hq7Hj3S6049fJPoAvOpYfIw37iPGeza8UCPGdLB8Z7YFpqyLv0wHejHoR+ysY3zybDYRuNXHbrGpFmId4LkzWbqdSkz2ES94/4iM9Ir3kfQ+6jertfr0xM2bu5P9OjqUxPc1kAPta/J4x5RTDDlaYzEuI1MhyC+tBytE9svXYPj1sW4PqMihKem/uTg4P9A9yfYLrk1LorLluH07jHnEl7xNqR1cGs61h+5+2DFsHH+7THnOGzcfViufoyN8q0IkaNYPdKvkbH2tWecEJr2zIG8PXMgkiLNgcZ63QnrudIrHu/ovuV9gt8dn20uwi/KnCpZ5Dq8DsL18y2ejL44HAkGh/Y54EHB/4Hus5uCY+WxvWFPbA9PUWN7kpTjrgmL/47jtet5ne/4caeuR6zD9tDh+rlH9hJFfj2v9/0LXFd/fQaQkw3jp3s0wj41x/GK+kk9+pqBgWhTrGvcpjvKdHbnVZC8FMqrJHmVnb1lNOOIA1G5YmMOU+4IdHwk0ZHL+OwqLpg00is+trHn4n5vflLwP8735u0azVCve/yaQfyK+QGeD9hjbr+XvbY/HjulcYnGF1y/2T8yKjg2j3kW5p056/xC+7nbN289c0Zr+6kFHIQpE48R3uYl0PlinTK9JonK46Rh4NsY/I/DYpWH9OXo/VJdD7242szJvQMPb4AdSvKsDriHghNF/leQ37Cy9Dw+V8PkWZ520orx4neM499RiK+LScrebvizbTUKHe9N5MT6bhHCYPlZn+UW9itIHh48YHwJeXy+R1KSqcsmazN7o3NWn3sRrK7e64Hff+mAf5dNOnpQJMvZJD5HbYD2cxgT9VNhrK1dAzmEIUnqpBhxGS7mVZD/tM9NRijL2abN6xqwhVxHH9Kh5+jEwWPKdw3+gt/KIrzw++Vw+cGkrKs2HMlgstj/HyX6OffmTgYA",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_notes",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": ["public", "initializer"],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "portal",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["constructor"]
    },
    {
      "name": "get_config_public",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15520311074722577191": {
            "error_kind": "string",
            "string": "Function get_config_public can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "portal",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::eth_address::EthAddress"
                }
              }
            ],
            "kind": "struct",
            "path": "config::Config"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAADOHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAAD3HgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAABCS8MAAIAARwMAQIALAIAAwAAAAAAAAAAAAAAAAD//////////////////////////w44AgMEJAIABAAAAM0lAAABGyYoAIAEBHgADQAAAIAEgAMkAIADAAAA9ioBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF12M4sTxmeyc8AQECJioBAAEFWgLkG7UeqZ88AQECJi4AGMoYyg==",
      "debug_symbols": "7Zffa8JADMf/lz73IbnLj7v9K2OMqnUUSpWqgyH+77uK13buWIeI9EEfxMgnJpdvcjbHbFUuDh/vVbPe7LKX12NWb5bFvto0wTqe8mzRVnVdfbyPv86ge1M+87tt0XTmbl+0++wFyQHkWdmsus/ecviNdVWXwTJwyn/zYEzEgcxAoyZoEuILTcLU04oJ2JHzF9gx8Bh+yzMH90nfxxiI6B+Y/p2qz66vvpuqPrJqpMXav9P3rPGsXtBdpe/tvdNH8zP9Loh7QBAEeUQUxHQUUOyjgLcTUTQgF1xD604oaEiigkb8lYKI8p+Mfp678zN4o9+N8Szd6OeTfuFlhom32PsxJ2pomSJtZTTEKC7VBMbFmUE7pn2KVpbYMspuQky1EmdXCeRvOJxL+uYNhbDX2hPPvjb9OKnAxE1L6mOjk7PDVWV8ciz6ew0BYIAlOXDG92mYCRaRbF89cRM0a4TZj/533Fkfhqc+c9bH6VOfOevjzVOfGetj4Hm/zVefU7A+i7YqFnV52SLXh2Y5Wir3X9vyar/ctptluTq0ZbdpDksmdkJbk1s9P3IGgygnCTFCnG8=",
      "brillig_names": ["get_config_public"]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "log_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["process_log"]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["sync_notes"]
    },
    {
      "name": "_update_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9169818942746597700": {
            "error_kind": "string",
            "string": "Function _update_order_status can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "status",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_update_order_status"]
    },
    {
      "name": "_trigger_settlement",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13594925270014003382": {
            "error_kind": "string",
            "string": "Function _trigger_settlement can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_trigger_settlement"]
    },
    {
      "name": "_check_order_commitment",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14563046062317426044": {
            "error_kind": "string",
            "string": "Function _check_order_commitment can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 268,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_check_order_commitment"]
    },
    {
      "name": "_assert_nonce_and_set_order_details",
      "is_unconstrained": true,
      "custom_attributes": ["internal", "public"],
      "abi": {
        "error_types": {
          "11094545764365153162": {
            "error_kind": "string",
            "string": "Function _assert_nonce_and_set_order_details can only be called internally"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "order_data",
            "type": {
              "kind": "array",
              "length": 268,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_assert_nonce_and_set_order_details"]
    },
    {
      "name": "open",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order",
            "type": {
              "fields": [
                {
                  "name": "fill_deadline",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                },
                {
                  "name": "order_data_type",
                  "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                },
                {
                  "name": "order_data",
                  "type": {
                    "kind": "array",
                    "length": 268,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                }
              ],
              "kind": "struct",
              "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["open"]
    },
    {
      "name": "fill",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8412360910299423372": {
            "error_kind": "string",
            "string": "Invalid order destination domain"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 268,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["fill"]
    },
    {
      "name": "fill_private",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "10852400770788842366": {
            "error_kind": "string",
            "string": "Invalid order domain"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 268,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["fill_private"]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "AztecGateway7683"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claimable_orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "open_orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "order_status",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "used_nonces",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "order_id",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            },
            {
              "name": "origin_data",
              "type": {
                "kind": "array",
                "length": 268,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            },
            {
              "name": "filler_data",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::Filled"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "status",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_check_order_status_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_check_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "status",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_update_order_status_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_update_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 268,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_check_order_commitment_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_check_order_commitment_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 268,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::fill_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::fill_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 268,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::claim_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::claim_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 268,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::fill_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::fill_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_trigger_settlement_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_trigger_settlement_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "order_data",
                    "type": {
                      "kind": "array",
                      "length": 268,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_assert_nonce_and_set_order_details_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_assert_nonce_and_set_order_details_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AztecGateway7683::get_config_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_config_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AztecGateway7683::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "fill_deadline",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        },
                        {
                          "name": "order_data_type",
                          "type": {
                            "kind": "array",
                            "length": 32,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        },
                        {
                          "name": "order_data",
                          "type": {
                            "kind": "array",
                            "length": 268,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::open_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::open_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "fill_deadline",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        },
                        {
                          "name": "order_data_type",
                          "type": {
                            "kind": "array",
                            "length": 32,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        },
                        {
                          "name": "order_data",
                          "type": {
                            "kind": "array",
                            "length": 268,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::open_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::open_abi"
        }
      ]
    }
  },
  "file_map": {
    "104": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "109": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "113": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "116": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "117": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\n    // Top-level unconstrained fns are contract entrypoints, but they're not explicitly designated in any way. They're\n    // the fallback case for a function that matches no other rules.\n    // TODO(#12743): improve this\n\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\n    // public, but which *are* contract entrypoints (i.e. they're not opting out via the #[test] or\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\n        !is_fn_private(f)\n            & !is_fn_public(f)\n            & !f.has_named_attribute(\"contract_library_method\")\n            & !f.has_named_attribute(\"test\")\n    });\n\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\n    // https://github.com/noir-lang/noir/issues/7714). We can't simply print a message since that'd otherwise break the\n    // output of utils such as `nargo test --list-tests`.\n    // // We don't expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr's\n    // // #[private] macro, possibly resulting in a non-standard interface).\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n    //     !f.is_unconstrained()\n    // }) {\n    //     let name = f.name();\n    //     warn(\n    //         f\"found private contract function '{name}' which does not have the #[private] attribute - make sure you know what you're doing!\",\n    //     );\n    // }\n\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n        f.is_unconstrained()\n    }) {\n        transform_top_level_unconstrained(f);\n    }\n}\n\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n"
    },
    "121": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{\n    stub_registry,\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\n};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    find_and_transform_top_level_unconstrained_fns(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The note discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_ciphertext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let note_discovery_call = create_note_discovery_call();\n    quote {\n        unconstrained fn sync_notes() {\n            // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n            // unconstrained execution context since it will not be available otherwise.\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n            $note_discovery_call\n        }\n    }\n}\n"
    },
    "122": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/notes/mod.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "123": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr",
      "source": "use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "124": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ.get_trait_impl(trait_constraint).expect(f\"Type does not implement trait\").methods().filter(\n        |m| m.name() == target_method,\n    )[0]\n        .as_typed_expr()\n}\n"
    },
    "135": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "138": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "141": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "142": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "143": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "144": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "145": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "146": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n    traits::{Deserialize, FromField},\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "150": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "151": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::{\n    abis::validation_requests::{\n        key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n    },\n    traits::Deserialize,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "152": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "155": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "158": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress,\n    point::{Point, POINT_LENGTH},\n    traits::Deserialize,\n};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(\n    address: AztecAddress,\n    ephPk: Point,\n) -> [Field; POINT_LENGTH] {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    let fields = get_shared_secret_oracle(address, ephPk);\n    Point::deserialize(fields)\n}\n"
    },
    "159": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "161": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "168": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "169": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "183": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "185": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "186": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "187": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "189": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "190": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "192": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "194": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "198": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "216": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "252": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "259": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "260": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "274": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "276": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "277": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "287": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "291": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "293": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "294": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "303": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "314": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "328": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "332": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "333": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "349": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "350": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "352": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "364": {
      "path": "/Users/eidoo/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "393": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    encrypted_logs::log_assembly_strategies::default_aes128,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        // TODO: we're abusing the note encoding scheme by computing the log for a fake note type with such a note type\n        // id that the recipient will realize that these are the private fields of a partial note. Ideally we'd not rely\n        // on this crude mechanism and we'd instead compute it as a proper event log. However, given the current state\n        // of the log library it's far easier to do it this way.\n        let encrypted_log = default_aes128::note::compute_log(\n            *context,\n            private_log_content,\n            storage_slot,\n            recipient,\n            sender,\n        );\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        // We abuse the fact that note type ids are 7 bits long to use the 8th bit indicate the log corresponds to a\n        // partial note. Ideally we'd use proper events with selectors, but those are not handled well at the moment.\n        UintNote::get_id() + 128\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "55": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/main.nr",
      "source": "mod config;\nmod types;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract AztecGateway7683 {\n    // context.chain_id() returns 1, which corresponds to the mainnet, making it unsuitable for our use case.\n    // Instead, we designate 999999 as the destination domain.\n    global LOCAL_DESTINATION_DOMAIN: u32 = 999999;\n\n    global UNKNOWN: u32 = 0;\n    global OPENED: u32 = 1;\n    global FILLED: u32 = 2;\n    global INITIATED_PRIVATELY: u32 = 3;\n\n    global SETTLE_ORDER_TYPE: [u8; 32] = [\n        100, 26, 150, 232, 234, 193, 205, 65, 73, 216, 31, 243, 122, 123, 194, 24, 136, 159, 246,\n        156, 124, 228, 38, 13, 122, 9, 202, 154, 234, 92, 186, 189,\n    ]; // sha256(\"SETTLE_ORDER_TYPE\")\n\n    use crate::{\n        config::Config,\n        types::{\n            helpers::InternalRCOParams,\n            onchain_cross_chain_order::OnchainCrossChainOrder,\n            order_data::{ORDER_DATA_LENGTH, ORDER_DATA_TYPE, OrderData},\n            resolved_cross_chain_order::{\n                FILL_INSTRUCTIONS_MAX_INSTRUCTIONS, FillInstruction, MAX_SPENT_MAX_OUTPUTS,\n                MIN_RECEIVED_MAX_OUTPUTS, Output, ResolvedCrossChainOrder,\n            },\n        },\n        utils::{u8_32_to_aztec_address, u8_32_to_u128},\n    };\n    use dep::aztec::{\n        event::event_interface::EventInterface,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        prelude::{AztecAddress, EthAddress, Map, PublicImmutable, PublicMutable},\n        protocol_types::{hash::sha256_to_field, traits::Serialize},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n    use token::Token;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Filled {\n        order_id: [u8; 32],\n        origin_data: [u8; ORDER_DATA_LENGTH],\n        filler_data: [u8; 32],\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n        claimable_orders: Map<Field, PublicMutable<Field, Context>, Context>,\n        open_orders: Map<Field, PublicMutable<[u8; 32], Context>, Context>, // order_data + order_type\n        order_status: Map<Field, PublicMutable<u32, Context>, Context>,\n        used_nonces: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(portal: EthAddress) {\n        storage.config.initialize(Config { portal });\n    }\n\n    #[public]\n    fn open(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, \"Invalid order data type\");\n\n        let data = _resolve(order, context.msg_sender(), context.timestamp());\n        let order_data = data.order_data;\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(order_data.sender_nonce);\n\n        assert(order_data.origin_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order origin domain\");\n        assert(!storage.used_nonces.at(context.msg_sender()).at(nonce).read(), \"Invalid nonce\");\n\n        // We cannot store the entire order_data + ORDER_DATA_TYPE as it raises the following error:\n        // Reached the limit (63) on number of 'public data (contract storage) write' per tx 'storage_write_opcode(storage_slot, value).\n        // For this reason we store a commitment of it.\n        storage.open_orders.at(order_id).write(_get_open_order_commitment(order.order_data));\n        storage.order_status.at(order_id).write(OPENED);\n        storage.used_nonces.at(context.msg_sender()).at(nonce).write(true);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n\n            Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_in_public(\n                    context.msg_sender(),\n                    context.this_address(),\n                    u8_32_to_u128(min_received.amount),\n                    0,\n                )\n                .call(&mut context);\n        }\n\n        // TODO emit event Open(order_id, resolved_order);\n    }\n\n    #[private]\n    fn open_private(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, \"Invalid order data type\");\n\n        // NOTE: Force the sender to be zero in order to avoid creating a connection between the sender and the recipient.\n        let data = _resolve(order, AztecAddress::zero(), 0 as u64);\n        let order_data = data.order_data;\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(order_data.sender_nonce);\n\n        assert(order_data.origin_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order origin domain\");\n        AztecGateway7683::at(context.this_address())\n            ._assert_nonce_and_set_order_details(order_id, order.order_data, nonce)\n            .enqueue(&mut context);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n\n            Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_in_private(\n                    context.msg_sender(),\n                    context.this_address(),\n                    u8_32_to_u128(min_received.amount),\n                    0,\n                )\n                .call(&mut context);\n        }\n\n        // TODO emit event Open(order_id, resolved_order);\n    }\n\n    #[internal]\n    #[public]\n    fn _assert_nonce_and_set_order_details(\n        order_id: Field,\n        order_data: [u8; ORDER_DATA_LENGTH],\n        nonce: Field,\n    ) {\n        assert(!storage.used_nonces.at(context.msg_sender()).at(nonce).read(), \"Invalid nonce\");\n        // We cannot store the entire order_data + ORDER_DATA_TYPE as it raises the following error:\n        // Reached the limit (63) on number of 'public data (contract storage) write' per tx 'storage_write_opcode(storage_slot, value).\n        // For this reason we store a commitment of it.\n        storage.open_orders.at(order_id).write(_get_open_order_commitment(order_data));\n        storage.order_status.at(order_id).write(OPENED);\n        storage.used_nonces.at(context.msg_sender()).at(nonce).write(true);\n    }\n\n    #[private]\n    fn claim_private(\n        secret: [u8; 32],\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n\n        AztecGateway7683::at(context.this_address())\n            ._check_order_status(order_id, INITIATED_PRIVATELY)\n            .enqueue(&mut context);\n\n        // verify that a commitment exists for the given order.\n        AztecGateway7683::at(context.this_address())\n            ._check_order_commitment(order_id, origin_data_bytes, filler_data_bytes)\n            .enqueue(&mut context);\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        // if a commitment exists, the order is valid, allowing us to compare the recipient with hash(secret).\n        assert(sha256::digest(secret) == order_data.recipient, \"Invalid secret\");\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_to_private(context.msg_sender(), u8_32_to_u128(order_data.amount_out))\n            .call(&mut context);\n\n        AztecGateway7683::at(context.this_address())._update_order_status(order_id, FILLED).enqueue(\n            &mut context,\n        );\n\n        // TODO: store filled order\n        // TODO: emit event\n\n        AztecGateway7683::at(context.this_address())\n            ._trigger_settlement(\n                order_id_bytes,\n                filler_data_bytes, // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn fill(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        AztecGateway7683::at(context.this_address())._check_order_status(order_id, UNKNOWN).call(\n            &mut context,\n        );\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_id_bytes == sha256::digest(origin_data_bytes), \"Invalid order id\");\n        assert(context.timestamp() as u32 <= order_data.fill_deadline, \"Order fill expired\");\n        assert(\n            order_data.destination_domain == LOCAL_DESTINATION_DOMAIN,\n            \"Invalid order destination domain\",\n        );\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_in_public(\n                context.msg_sender(),\n                u8_32_to_aztec_address(order_data.recipient),\n                u8_32_to_u128(order_data.amount_out),\n                Field::from_be_bytes(order_data.sender_nonce),\n            )\n            .call(&mut context);\n\n        storage.order_status.at(order_id).write(FILLED);\n        // TODO: store filled order\n\n        AztecGateway7683::at(context.this_address())\n            ._trigger_settlement(\n                order_id_bytes,\n                filler_data_bytes, // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n            )\n            .call(&mut context);\n\n        // TODO: \"Emitted public log is too large, max: 13, passed: 333\"\n        // Filled { order_id: order_id_bytes, origin_data: origin_data_bytes, filler_data: filler_data_bytes }.emit(encode_event(&mut context));\n    }\n\n    #[public]\n    fn fill_private(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        AztecGateway7683::at(context.this_address())._check_order_status(order_id, UNKNOWN).call(\n            &mut context,\n        );\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_id_bytes == sha256::digest(origin_data_bytes), \"Invalid order id\");\n        assert(context.timestamp() as u32 <= order_data.fill_deadline, \"Order fill expired\");\n        assert(order_data.destination_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order domain\");\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_in_public(\n                context.msg_sender(),\n                context.this_address(),\n                u8_32_to_u128(order_data.amount_out),\n                0,\n            )\n            .call(&mut context);\n\n        storage.claimable_orders.at(order_id).write(sha256_to_field(_get_order_pre_image(\n            origin_data_bytes,\n            filler_data_bytes,\n        )));\n        storage.order_status.at(order_id).write(INITIATED_PRIVATELY);\n    }\n\n    #[private]\n    #[view]\n    fn get_config() -> Config {\n        storage.config.read()\n    }\n\n    #[public]\n    #[view]\n    fn get_config_public() -> Config {\n        storage.config.read()\n    }\n\n    #[contract_library_method]\n    fn _get_open_order_commitment(order_data: [u8; ORDER_DATA_LENGTH]) -> [u8; 32] {\n        let mut data: [u8; ORDER_DATA_LENGTH + 32] = [0; ORDER_DATA_LENGTH + 32];\n        for i in 0..32 {\n            data[i] = ORDER_DATA_TYPE[i];\n        }\n        for i in 0..ORDER_DATA_LENGTH {\n            data[i + 32] = order_data[i];\n        }\n        sha256::digest(data)\n    }\n\n    #[public]\n    #[internal]\n    fn _check_order_status(order_id: Field, status: u32) {\n        assert(storage.order_status.at(order_id).read() == status, \"Invalid order status\");\n    }\n\n    #[public]\n    #[internal]\n    fn _update_order_status(order_id: Field, status: u32) {\n        storage.order_status.at(order_id).write(status);\n    }\n\n    #[public]\n    #[internal]\n    fn _check_order_commitment(\n        order_id: Field,\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_commitment = storage.claimable_orders.at(order_id).read();\n        assert(\n            order_commitment\n                == sha256_to_field(_get_order_pre_image(origin_data_bytes, filler_data_bytes)),\n            \"Invalid order\",\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _trigger_settlement(order_id_bytes: [u8; 32], filler_data: [u8; 32]) {\n        let mut settlement_message_bytes: [u8; 96] = [0; 96];\n\n        for i in 0..32 {\n            settlement_message_bytes[i] = SETTLE_ORDER_TYPE[i]; // order_type\n            settlement_message_bytes[i + 32] = order_id_bytes[i]; // order_id_bytes\n            settlement_message_bytes[i + 54] = filler_data[i]; // recipient\n        }\n\n        let config = storage.config.read();\n        context.message_portal(config.portal, sha256_to_field(settlement_message_bytes));\n    }\n\n    #[contract_library_method]\n    fn _resolve(\n        order: OnchainCrossChainOrder,\n        sender: AztecAddress,\n        timestamp: u64,\n    ) -> InternalRCOParams {\n        let mut order_data = OrderData::decode(order.order_data);\n\n        assert(order_data.fill_deadline == order.fill_deadline, \"Invalid fill deadline\");\n        assert(u8_32_to_aztec_address(order_data.sender) == sender, \"Invalid order sender\");\n\n        let order_id_bytes = sha256::digest(order.order_data);\n        let order_id = Field::from_be_bytes(order_id_bytes);\n\n        let min_received_output = Output {\n            token: order_data.input_token,\n            recipient: [0; 32],\n            amount: order_data.amount_in,\n            chain_id: order_data.origin_domain,\n        };\n        let min_received: [Output; MIN_RECEIVED_MAX_OUTPUTS] =\n            [min_received_output; MIN_RECEIVED_MAX_OUTPUTS];\n\n        let max_spent_output = Output {\n            token: order_data.output_token,\n            recipient: order_data.recipient,\n            amount: order_data.amount_out,\n            chain_id: order_data.destination_domain,\n        };\n        let max_spent: [Output; MAX_SPENT_MAX_OUTPUTS] = [max_spent_output; MAX_SPENT_MAX_OUTPUTS];\n\n        let fill_instruction = FillInstruction {\n            destination_chain_id: order_data.destination_domain,\n            destination_settler: order_data.destination_settler,\n            origin_data: order.order_data,\n        };\n        let fill_instructions: [FillInstruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS] =\n            [fill_instruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS];\n\n        let resolved_order = ResolvedCrossChainOrder {\n            user: sender,\n            origin_chain_id: LOCAL_DESTINATION_DOMAIN,\n            open_dealine: timestamp as u32,\n            fill_deadline: order.fill_deadline,\n            order_id: order_id_bytes,\n            min_received,\n            max_spent,\n            fill_instructions,\n        };\n\n        InternalRCOParams { order_id, resolved_cross_chain_order: resolved_order, order_data }\n    }\n\n    #[contract_library_method]\n    fn _get_order_pre_image(\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) -> [u8; ORDER_DATA_LENGTH + 32] {\n        let mut pre_image: [u8; ORDER_DATA_LENGTH + 32] = [0; ORDER_DATA_LENGTH + 32];\n        for i in 0..ORDER_DATA_LENGTH {\n            pre_image[i] = origin_data_bytes[i];\n        }\n        for i in 0..32 {\n            pre_image[i + ORDER_DATA_LENGTH] = filler_data_bytes[i];\n        }\n        pre_image\n    }\n}\n"
    },
    "58": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/types/order_data.nr",
      "source": "use crate::utils::u8_4_to_u32;\nuse dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n\npub global ORDER_DATA_LENGTH: u32 = 268;\npub global ORDER_DATA_TYPE: [u8; 32] = [\n    173, 204, 173, 178, 32, 162, 60, 236, 175, 247, 61, 145, 92, 30, 0, 53, 229, 56, 188, 175, 1,\n    140, 3, 218, 24, 138, 249, 243, 35, 40, 184, 19,\n];\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OrderData {\n    pub sender: [u8; 32],\n    pub recipient: [u8; 32],\n    pub input_token: [u8; 32],\n    pub output_token: [u8; 32],\n    pub amount_in: [u8; 32],\n    pub amount_out: [u8; 32],\n    pub sender_nonce: [u8; 32],\n    pub origin_domain: u32,\n    pub destination_domain: u32,\n    pub destination_settler: [u8; 32],\n    pub fill_deadline: u32,\n}\n\nimpl OrderData {\n    pub fn decode(bytes: [u8; ORDER_DATA_LENGTH]) -> OrderData {\n        let sender = u8_order_data_length_to_u8_32(bytes, 0);\n        let recipient = u8_order_data_length_to_u8_32(bytes, 32);\n        let input_token = u8_order_data_length_to_u8_32(bytes, 64);\n        let output_token = u8_order_data_length_to_u8_32(bytes, 96);\n        let amount_in = u8_order_data_length_to_u8_32(bytes, 128);\n        let amount_out = u8_order_data_length_to_u8_32(bytes, 160);\n        let sender_nonce = u8_order_data_length_to_u8_32(bytes, 192);\n        let origin_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 224));\n        let destination_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 228));\n        let destination_settler = u8_order_data_length_to_u8_32(bytes, 232);\n        let fill_deadline = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 264));\n\n        OrderData {\n            sender,\n            recipient,\n            input_token,\n            output_token,\n            amount_in,\n            amount_out,\n            sender_nonce,\n            origin_domain,\n            destination_domain,\n            destination_settler,\n            fill_deadline,\n        }\n    }\n}\n\nfn u8_order_data_length_to_u8_32(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 32] {\n    let mut result = [0; 32];\n    for i in 0..32 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8_4(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 4] {\n    let mut result = [0; 4];\n    for i in 0..4 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/utils.nr",
      "source": "use dep::aztec::{prelude::AztecAddress, protocol_types::traits::FromField};\n\npub(crate) fn u8_32_to_u128(input: [u8; 32]) -> u128 {\n    let mut result = 0;\n    for i in 0..16 {\n        result = result + (input[31 - i] as u128) * (1 << (i * 8));\n    }\n    result\n}\n\npub(crate) fn u8_4_to_u32(bytes: [u8; 4]) -> u32 {\n    let field = Field::from_be_bytes(bytes);\n    field.assert_max_bit_size::<32>();\n    field as u32\n}\n\npub(crate) fn u8_32_to_aztec_address(bytes: [u8; 32]) -> AztecAddress {\n    AztecAddress::from_field(Field::from_be_bytes(bytes))\n}\n"
    },
    "62": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "63": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.set_public_teardown_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "70": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "72": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "73": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "75": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod private_logs;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size, encryption\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\n///\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\n/// along with its `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_notes<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing note discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "76": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "77": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\n    },\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = &mut 0;\n    whyle(\n        || *i < pending_partial_notes.len(),\n        || {\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\n\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n            if maybe_log.is_none() {\n                debug_log_format(\n                    \"Found no completion logs for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                *i += 1 as u32;\n                // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\n                // is somehow removed from the PXE DB.\n            } else {\n                debug_log_format(\n                    \"Completion log found for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                let log = maybe_log.unwrap();\n\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\n                // that we're getting the logs from the expected contract.\n                // TODO(#10273): improve how contract log siloing is handled\n                assert_eq(\n                    log.log_content.get(0),\n                    contract_address.to_field(),\n                    \"Got a public log emitted by a different contract\",\n                );\n\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n                // complete packed content.\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n                let complete_packed_note_content = array::append(\n                    pending_partial_note.packed_private_note_content,\n                    packed_public_note_content,\n                );\n\n                let discovered_notes = attempt_note_nonce_discovery(\n                    log.unique_note_hashes_in_tx,\n                    log.first_nullifier_in_tx,\n                    compute_note_hash_and_nullifier,\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.note_type_id,\n                    complete_packed_note_content,\n                );\n\n                debug_log_format(\n                    \"Discovered {0} notes for partial note with tag {1}\",\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n                );\n\n                array::for_each_in_bounded_vec(\n                    discovered_notes,\n                    |discovered_note: DiscoveredNoteInfo, _| {\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                        // temporary node connectivity issue - is simply throwing good enough here?\n                        assert(\n                            deliver_note(\n                                contract_address,\n                                pending_partial_note.storage_slot,\n                                discovered_note.nonce,\n                                complete_packed_note_content,\n                                discovered_note.note_hash,\n                                discovered_note.inner_nullifier,\n                                log.tx_hash,\n                                pending_partial_note.recipient,\n                            ),\n                            \"Failed to deliver note\",\n                        );\n                    },\n                );\n\n                // Because there is only a single log for a given tag, once we've processed the tagged log then we\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n                // being completed.\n                pending_partial_notes.remove(*i);\n\n                // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n                // shifts the elements to the left if the removed element is not the last element.\n            }\n        },\n    );\n}\n\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\n/// supports looping in unconstrained code.\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\n    if condition() {\n        body();\n        whyle(condition, body);\n    }\n}\n"
    },
    "78": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    capsules::CapsuleArray,\n    oracle::note_discovery::{deliver_note, sync_notes},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier,\n    MAX_NOTE_PACKED_LEN,\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\n    partial_notes::{\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\n    },\n};\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\n// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\n/// the note completion log tag).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\n/// which the notes would've been created (typically the same transaction in which the log was emitted), along with the\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let log_plaintext = decrypt_log(log, recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\n    // improved upon in the future to also handle events, etc.\n\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\n        destructure_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        attempt_note_discovery(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            storage_slot,\n            note_type_id,\n            log_payload,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            log_payload,\n            recipient,\n        );\n    } else {\n        // TODO(#11569): handle events\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id],\n        );\n    }\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\n        \"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\n    // distinguish private note logs and partial note logs.\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we'd be able to\n    // leverage enums and tagged unions to achieve this goal.\n    let combined_type_id = log_plaintext.get(1);\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\n\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, log_type_id, log_payload)\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note_content,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nunconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    recipient: AztecAddress,\n) {\n    // We store the information of the partial note we found so that we can later search for the public log that will\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\n    static_assert(\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\n        \"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\",\n    );\n\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag: log_payload.get(0),\n        storage_slot,\n        note_type_id,\n        packed_private_note_content: array::subbvec(log_payload, 1),\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n"
    },
    "79": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "85": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note/encryption.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle,\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse protocol_types::{address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, traits::ToField};\nuse std::aes128::aes128_encrypt;\n\n// contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48;\n\nglobal TAG_AND_EPH_PK_X_SIZE_IN_FIELDS: u32 = 2;\nglobal EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 = (\n    PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS\n)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES / 32;\n\n/// Computes an encrypted log using AES-128 encryption in CBC mode.\n///\n/// The resulting log has the following format:\n/// ```text\n/// [\n///   tag: Field,                    // Tag for note discovery, derived from sender/recipient\n///   epk_x: Field,                  // X coordinate of ephemeral public key\n///   log_bytes: [Field],            // Encrypted data converted from bytes to fields, containing:\n///     [\n///       epk_sign: u8,              // Sign bit of ephemeral public key Y coordinate\n///       header_ciphertext: [u8],   // AES encrypted header containing:\n///         [\n///           contract_address: [u8; 32],  // Contract address that emitted the note\n///           ciphertext_length: [u8; 2],  // Length of main ciphertext in bytes\n///           padding: [u8; 14]            // PKCS#7 padding to AES block size\n///         ],\n///       ciphertext: [u8],          // AES encrypted note data containing:\n///         [\n///           plaintext_bytes: [u8],       // The plaintext\n///           padding: [u8]                // PKCS#7 padding to AES block size\n///         ],\n///       padding: [u8]              // Random padding to make log_bytes multiple of 31\n///     ],\n///   padding: [Field]               // Random padding to PRIVATE_LOG_SIZE_IN_FIELDS\n/// ]\n/// ```\n///\n/// The encryption process:\n/// 1. Generate ephemeral key-pair and ECDH shared secret with recipient\n/// 2. Derive AES key and IV from shared secret using SHA-256\n/// 3. Encrypt header and note data separately using AES-128-CBC\n/// 4. Format into final log structure with padding\npub fn encrypt_log<let PT: u32>(\n    contract_address: AztecAddress,\n    plaintext: [Field; PT],\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n    // (This process is then reversed when processing the log in `do_process_log`)\n    let plaintext_bytes = fields_to_bytes(plaintext);\n\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    // (not to be confused with the tagging shared secret)\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + (PT * 32) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 = get_arr_of_size__log_bytes_padding__from_PT::<PT * 32>();\n    // Safety: this randomness won't be constrained to be random. It's in the\n    // interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PT * 32>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n    // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n    // should cover a full field.\n    let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // Safety: We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n        // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n        // TODO(#12749): Long term, this is not a good solution.\n\n        // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n        // contents publicly. It is therefore fine to trust the sender to provide random padding.\n        let field_bytes = unsafe { get_random_bytes::<31>() };\n        final_log[i] = Field::from_be_bytes::<31>(field_bytes);\n    }\n\n    final_log\n}\n\npub unconstrained fn decrypt_log(\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    recipient: AztecAddress,\n) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n    // let tag = log.get(0);\n    let eph_pk_x = log.get(1);\n\n    let log_ciphertext_fields = array::subbvec::<Field, PRIVATE_LOG_SIZE_IN_FIELDS, PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS>(\n        log,\n        TAG_AND_EPH_PK_X_SIZE_IN_FIELDS,\n    );\n\n    // Convert the ciphertext represented as fields to a byte representation (its original format)\n    let log_ciphertext = bytes_from_fields(log_ciphertext_fields);\n\n    // First byte of the ciphertext represents the ephemeral public key sign\n    let eph_pk_sign_bool = log_ciphertext.get(0) as bool;\n    // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n    let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n    // Derive shared secret and symmetric key\n    let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Extract the header ciphertext\n    let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n    let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), header_start);\n    // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n    // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n    // is fixed. But we do it anyway to not have to have duplicate oracles.\n    let header_ciphertext_bvec =\n        BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n    // Decrypt header\n    let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n    // Extract ciphertext length from header (2 bytes, big-endian)\n    let ciphertext_length =\n        ((header_plaintext.get(32) as u32) << 8) | (header_plaintext.get(33) as u32);\n\n    // Extract and decrypt main ciphertext\n    let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n    let ciphertext_with_padding: [u8; (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), ciphertext_start);\n    let ciphertext: BoundedVec<u8, (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n        BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n    // Decrypt main ciphertext and return it\n    let log_plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n    // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n    fields_from_bytes(log_plaintext_bytes)\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{decrypt_log, encrypt_log, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS};\n    use protocol_types::{address::AztecAddress, traits::{FromField, Serialize}};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn test_encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log =\n            BoundedVec::from_array(encrypt_log(contract_address, plaintext, recipient, sender));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret.serialize());\n\n        // Decrypt the log\n        let decrypted = decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n    }\n}\n"
    },
    "92": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
