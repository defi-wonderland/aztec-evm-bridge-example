{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "AztecGateway7683",
  "functions": [
    {
      "name": "get_filled_order_block_number",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5048864367174250545": {
            "error_kind": "string",
            "string": "Function get_filled_order_block_number can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["get_filled_order_block_number"]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "log_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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+1uufX/Lte9vufb9Lde+v+Xa97dc+/6Wa9/fcu2HW679cMu1H2659sMt13645doPt1z74ZZrP9xy7Ydbrv1bnuuztzzXZ295rs/e8lyfveW5PnvLc332luf67C3P9dlbnuuztzzXZ295rs/e8lyfveW5PnvLc332luf67C3P9dlbnuuztzzXZ295rs/e8lyfveW5PnfLc33uluf63C3P9blbnutzk73lW9wt31Lk2rcqLHs5PFamM69uKPebLFfmecFqo4+iR58kj77Mc5PVRq9Ej16LHr0RPXorevRO9OhFz7VK9FyrRM+1SvRcqxufa/26x+g06Y3hNz7Z5obf+GybG37j021u+I3Pt7nhNz7h5oZfaL+kw90dXKHnynPfku74lkLPlee+Rd3yLfqWbzG3fIu95VvcLd/ib/mWW659c8u1b2659u0t17695dq3t1z79pZr395y7dtbrn17y7Vvb7n27S3Xvr3l2ne3XPvulmvf3XLtu1uufXfLte9uufbdLde+u+Xad7dc++6Wa9/fcu37W659f8u172+59v0t176/5dr3t1z7/pZr399y7ftbrv1wy7Ufbrn2wy3Xfrjl2g+3XPvhlmv/lj1WXbjl2g+3XPvhlms/3nLtx1uu/XjLtR9vufbjLdd+vOXaj7dc+/GWaz/ecu3HW679dMu1n2659tMt13665dpPt1z76ZZrP91y7adbrv10y7Wf7rj2/TTd8i3qlm/p6P0Tx4vZfuroJV25Uu04pXb0mq5cqR29pytXakcv6sqV+ulfXG0M/0cvi9HrC2CMUc93Ivvv4SfRw//4/s8fHr66f/gmLQdHq3XmovrZC+inpVav/cux31fKx/e3bqpYM1KxdqRi3UjF+pGKDSMVG0cqNg1UrJ5GKnYkB6VHclB6JAf18XcmNFXsSA5Kj+Sg9EgOSo/koPRIDsqM5KDMSA7KjOSgzEgO6uNvnmmq2JEclBnJQZmRHJQZyUHZvuZZuxzsndootq+7sV8+2fu4UWzrd2On3Fqssb8VOxfQ+h02W0Drd81sAa3fCbMFNN8fWvUswGUueOWDX7Zsefwdp/X474V713yHWLbc5ueusuU23yWWLbf5PrFsubalcuchNeUg5iE15QnmIVWY5a1b5r3oYuZgFfyq0+CfDxZ6szmjrp/86yHC44PjWmG0z89V1nwDEwFmG5gE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",
      "brillig_names": ["process_log"]
    },
    {
      "name": "open",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order",
            "type": {
              "fields": [
                {
                  "name": "fill_deadline",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                },
                {
                  "name": "order_data_type",
                  "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                },
                {
                  "name": "order_data",
                  "type": {
                    "kind": "array",
                    "length": 301,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                }
              ],
              "kind": "struct",
              "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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Aw0oAAWAfgACJAIAAgAANNIlAABHlC0MAwEjAAA02wA4BAECDjgEAgMkAgADAAA08iUAADWFLQwCASYuAYADgAYLAIAGAAKAByQAgAcAADUSIwAANR0uAIADgAUjAAA1hC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAADVwLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAADU/KAGABQQAAQMAgAYAAoAGIwAANYQmKgEAAQVFp8pxGUHkFTwBAQImJQAALEQtDQEEACgEAgQtDgQBLQgBBAAAAQIBLQ4BBC0IAQUAAAECAS0OAgUnAgcEBAY4AgcIBDgIBwkCOAIJBgsoAAaAdgAHJAIABwAANyIjAAA17AcoAAKAbwAIAzCAbwAGAAkPKAAGgG8ACiQCAAoAADYRJQAASPUnAgoEEAw4CAoLJAIACwAANiglAAAzYAAoAQIKADgKCAstDQsGHAwJCwIcDAsKBBwMCgsCBTCAfAALAAonAg0CAAo4DQsMJAIADAAANnkGOAoLDwsoAA+AfAAOJAIADgAANnklAABHpho4BgoMDSgAC4B7AAYkAgAGAAA2niMAADaTLgiAdgAHIwAANsEYOAwKBg0oAAqAfgALJAIACwAANrglAABHlC0MBgcjAAA2wScCCgQQDDgICgskAgALAAA22CUAADNgLgQAAYADKACABAQAESUAADT3LgiABQAGACgGAgoAOAoICy0OBwstDgYEADgCCQEOOAIBBiQCAAYAADcZJQAANYUtDgEFIwAANyItDQUCBygAAoBvAAUtDAUBIwAANzcNKAABgHIAAiQCAAIAADmSIwAAN0wFMIB9AAMAAicCBgQACjgGAwUkAgAFAAA3gAY4AgMICygACIB9AAckAgAHAAA3gCUAAEemHAwCAwAnAgUBAC0IAQInAgYECQAQAQYBJwMCBAEAKAICBicCBwQIQwOwAAOAcwAHAAUABi4IgHYAASMAADe/DSgAAYB6AAMkAgADAAA32SMAADfULQ0EASYFKAABgG8AAy0NBAUBMIByAAEABicCCAQIDDgDCAkkAgAJAAA4BCUAADNgACgCAggAOAgDCS0NCQcBKAADgGMACA44AwgJJAIACQAAOCwlAAA1hScCCgQIDDgICgskAgALAAA4QyUA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",
      "debug_symbols": "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",
      "brillig_names": ["open"]
    },
    {
      "name": "_check_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "12018683598614887596": {
            "error_kind": "string",
            "string": "Function _check_order_status can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "status",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_check_order_status"]
    },
    {
      "name": "_update_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9169818942746597700": {
            "error_kind": "string",
            "string": "Function _update_order_status can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "status",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_update_order_status"]
    },
    {
      "name": "fill_private",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "10852400770788842366": {
            "error_kind": "string",
            "string": "Invalid order domain"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["fill_private"]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": ["public", "initializer"],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "portal",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["constructor"]
    },
    {
      "name": "open_private",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "error_types": {
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "order",
            "type": {
              "fields": [
                {
                  "name": "fill_deadline",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                },
                {
                  "name": "order_data_type",
                  "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                },
                {
                  "name": "order_data",
                  "type": {
                    "kind": "array",
                    "length": 301,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                }
              ],
              "kind": "struct",
              "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_notes",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "fill",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8412360910299423372": {
            "error_kind": "string",
            "string": "Invalid order destination domain"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["fill"]
    },
    {
      "name": "_check_order_commitment",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14563046062317426044": {
            "error_kind": "string",
            "string": "Function _check_order_commitment can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_check_order_commitment"]
    },
    {
      "name": "_trigger_settlement",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13594925270014003382": {
            "error_kind": "string",
            "string": "Function _trigger_settlement can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_trigger_settlement"]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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PYLeMrPWI2x8FvTOlrUeYeOzoDegrPUIG58FvU9krUfY+Czo7RxrPcLGZ0HvuljrETY+C3pzxFqPsPFZ0HsY1nqEjc+C3mqw1iNsfBb0joC1HmHjs6An7td6hI3Pgp5fX+sRNj4Lehp8rUfY+Czo2eq1HmHjs6Anldd6hI3Pgp77XesRNj4Leop2rUfY+CzomdS1HmHjs6AnPNd6hI3Pgp6XXOsRNj4/++lDn5Pd6imLu6/HPLue5VqPMbf13B+cF/9+bHZlP9RWjy05vh9bys/Hru20StrplLTTK2lnUNLOqKSdSUk7s5J2Fh3tjIuSdirxQ1GJH4pK/NCznwt8WTun8UNxO9Ysi600dBpD1GroNI6o1dBpLFGrodN4okZD0zSmqNXQoa5ovYQdfwk3/hJ+/CXC+EvE8ZdI4y+Rx1+iDL/E2Aey10uM7915fO/O43t3Ht+78/jencf37jy+d+fxvTuP791lfO8u43t3Gd+7y/jeXcb37jK+d5fxvbuM791lfO8uw3t3WpbxlzDjL2HHX8KNv4Qff4kw/hJx/CXS+Evk8ZcY37vN+N5txvduM753m/G924zv3WZ87zbje7cZ37vN+N5txvduO7532/G9247v3XZ877bje7cd37vt+N5tx/duO7532/G9243v3W5873bje7cb37vd+N7txvduN753u/G9243v3W587/bje7cf37v9+N7tx/duP753+/G924/v3X587/bje7cf37vD+N4dxvfuML53h/G9O4zv3WF87w7je3cY37vD+N4dxvfuOL53x/G9O47v3XF8747je3cc37vj+N4dx/fuOL53x/G9O43v3eP3qqXxe9XS+L1qafxetTR+r1oav1ctjd+rlsbvVUsd9qoFF7aHm0OI5fOD+236Tx32wL2sdHPe0u15S3fnLd2ft/Rw3tLjeUtP5y09n7f0886m5byzaTnvbFrOO5uW886mHfb0vqx0ybPp58+LpSJ5Om3VLnk+bdUueUJt1S55Rv289rxInlJbtQ+dU9dL2PGXcOMv4cdfIoy/RBx/iTT+Enn8JcrwS5hl/CXG924zvneb8b27w97rEPL2beUYnfn84M+/w5w77HD+pJy3S3TY4dy8hBl/CTv+Eo+rLy3ObAcvoTG722TS+8E22es7RKN7r8cLqycIqycKqycJqycLq6fIqqfD5vC+9Zhn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",
      "brillig_names": ["sync_notes"]
    },
    {
      "name": "claim_private",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15663063161611103517": {
            "error_kind": "string",
            "string": "Invalid secret"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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gINDLsDBIWfhqGXBIpfo4JFLdDDJJTq45BIdgU6BDj65RAejXKKDUy7RwSqX6OCVC3QUXrlEB69cooNXLtHBK5foCHQKdPDKJTp45RIdvHKJDl65RAevXKCj8colOnjlEh28cokOXrlER6BToINXLtHBK5fo4JVLdPDKJTp45QIdg1cu0cErl+jglUt08MolOgKdAh28cokOXrlEB69cooNXLtHBKxfoCF65RAevXKKDVy7RwSuX6Ah0CnTwyiU6eOUSHbxyiQ5euUQHr1ygY/HKJTp45RIdvHKJDl65REegU6CDVy7RwSuX6OCVS3TwyiU6eOUCHTbkK9LBK5fo4JVLdPDKJToCnQIdvHKJDl65RAevXKKDVy7RwSsX6LA1X5EOXrlEB69cooNXLtER6BTo4JVLdPDKJTp45RIdvHKJDl65QIdN+op08MolOnjlEh28comOQKdAB69cooNXLtHBK5fo4JVLdPDKBTps11ekg1cu0cErl+jglUt0BDoFOnjlEh28cokOXrlEB69cooNXztNR7NtXpINXLtHBK5fo4JVLdAQ6BTp45RIdvHKJDl65RAevXKKDVy7QYd++Ih28cokOXrlEB69coiPQKdDBK5fo4JVLdPDKJTp45RIdvHKBDvv2FenglUt08MolOnjlEh2BToEOXrlEB69cooNXLtHBK5fo4JULdNi3r0gHr1yig1cu0cErl+gIdAp08MolOnjlEh28cokOXrlEB69coMO+fUU6eOUSHbxyiQ5euURHoFOgg1cu0cErl+jglUt08MolOnjlAh327SvSwSuX6OCVS3TwyiU6Ap0CHbxyiQ5euUQHr1yig1cu0cErF+iwb1+RDl65RAevXKKDVy7REegU6OCVS3TwyiU6eOUSHbxyiQ5euUCHffuKdPDKJTp45RIdvHKJjkCnQAevXKKDVy7RwSuX6OCVS3TwygU67NtXpINXLtHBK5fo4JVLdAQ6BTp45RIdvHKJDl65RAevXKKDVy7QYd++Ih28cokOXrlEB69coiPQKdDBK5fo4JVLdPDKJTp45RIdvHKejmbfviIdvHKJDl65RAevXKIj0CnQwSuX6OCVS3TwyiU6eOUSHbxygQ779hXp4JVLdPDKJTp45RIdgU6BDl65RAevXKKDVy7RwSuX6OCVC3TYt69IB69cooNXLtHBK5foCHQKdPDK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XMHfwxnrqmzGuiqbsa7KZqyrshnrqmzGuiqbsa7KZqyrshnrqmzGuiqbsa7KMtZVWca6KstYV2UZ66osY12VZayrsox1VZaxrsoy1lVZxroq27Guynasq7Id66psx7oq27Guynasq7Id66psx7oq27Guynasq7Ib66rsxroqu7Guym6sq7Ib66rsxroqu7Guym6sq7Ib66rsxroq+7Guyn6sq7If66rsx7oq+7Guyn6sq7If66rsx7oq+7Guyn6sq3IY66ocxroqh7GuymGsq3IY66ocxroqh7GuymGsq3IY66ocxroqx7GuynGsq3Ic66ocx7oqx7GuynGsq3Ic66ocx7oqx7GuygO9S3sJJw70fux7OENdleNA77G+hzPUVTkuQ12V40DvkL6HM9RVOQ70rud7OENdleNA72S+hTPQe5bv4Yx1VR7ofcj3cMa6Kg/03uJ7OGNdlQd6v/A9nLGuygO9B/gezlhX5bHe7YtjvdsXx3q3L471bl8c692+ONa7fXGsd/viWO/2xbHe7YtjvdsXx3q3L471bl8c692+ONa7fXGsd/viWO/2xbHe7YtjvdsXx3q3L471bl8c692+ONa7fXGsd/viWO/2xbHe7YtjvdsXx3q3L471bl8c692+ONa7fXGsd/viWO/2xbHe7YtjvdsXx3q3L471bl8c692+ONa7fXGsd/viWO/2xbHe7YtjvdsXx3q3L471bl8c692+ONa7fXGsd/viWO/2xbHe7YtjvdsXx3q3L471bl8c692+ONa7fXGsd/viWO/2xbHe7YtjvdsXx3q3L471bl8c692+ONa7fXGsd/viWO/2xbHe7YtjvdsXx3q3L471bl8c692+ONa7fXGsd/viWO/2xbHe7YtjvdsXx3q3L471bl8c692+ONa7fXGsd/viWO/2qWWsl/su8Qx1Xb7EM9SF+RLPUFfmSzxDXZov8Qx1bX7bEnmweH766hyX9ZdVNIl4fvzy7N0WT1zu43k8OCzycWy4C10nj70sjj6OvVzjPx177Weco58//1rii/qpJumnnqSfZpJ+yiT9tJP0003STz9JPyfxQ2oSP6Qn8UN6Ej+kJ/FDehI/9PMvXb+on5P4IX0aP+TWY9+KkImOnsYQ7XX0NI5or6OnsUQ7HTWn8UR7HT2NKdrr6Diu6BrPOO7lGo8MFs84buAazziz9jWe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",
      "brillig_names": [
        "discover_new_notes",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAAES36m5K+\nPhy60YelKz9dgwmWA2TD4mRpu8jznugjpYgS7raFvCn7fZaLjVWL0vSDQ7KxKwgB/qqYjZCZsNYQ\nERxPC4fmTYnnby7eHFyXcth408F6+BtMHlgaAgiP+JYKEBVyMUz1ShM1Pk+D1H31230BZPX4CjJK\nagDXBEZoXvIbq02SrAxh4/LoarYVbzrxsDQBrxEa3eplI2fVav4DpSRhYf01azpMu9MF+LkxYoSE\naIiQzW7+QPKCSqNv5iv1Jc4Y88o+hQH85S8c1eTtnUd4VWYpqJPY3DcV9PYh6IIXS6X2K8ukjus6\nXbwuaUwmvtcvOl49yictDwBSjvCIkA3902HVvsbx3rpfNYQr/PJmApKG2vBOcq4D+EjEUZcZGX5s\nmA6T4zWmpyIIB9+NliqeYshHyjk8cnaotzcBI98Vbhd+af9n63FqQuLeN5ozgIiReV53blWpzYX8\nAWhdwykxDPVlWIKZyr+HWTJPV0tzKJO+S85iAFWM3Wtd/HpIBFa7cBtbC0Y7vPDE/nGQVSOT0JUz\n4bIAS9hOn4pTqI8DgPTmuzBHdr/U+yLiCYd0FWSB6aP48JHTDbEAOm2qtBeLX7pkty84W07XnANO\nffS98tL2pzWC4p73hAiC46JREAhmzOvN0rd8TPt/+R2+rZKv2lChktlaXccxjKozEaso4On2noWS\n555QFYY1H/wH2ThPP2xOQpWmZGVLQtHyvSDPWXb8/e0cC6lg7T+SmzD8vjdJ45UbjtJlg5b+DC/U\nFVDY7FUJeTw+GunLkan5I7iyT/czRqmxN9ekGmWzfsAc3m7s5Zf3DyktkY/GITdtg2nKuKa4XZ5J\nTiS8n8nRIwCmHerHazcMpPQvc6Zly3Wp69xYzUvfivfn/P+jbVtxLll4nw2duz8VreU4S3hJDbHY\nM3nHO+QRI96/yIyfyNYrcq3BN0OMoNM3FEWlepaQ5kT1hLr6RUEkzwGtW+CxOQEZ4kHuu+v/XH1/\nINxsWtG2r3jcIG1/d4U/Bf3n69NyIgWbBOk3VT2AJgYIwVfvFo3lCtDx8baLcvbynCJ7pEsVvfAX\nIZDZRmU6h64y8P9JhBmCUyRtjF9vpdo2C4GbrCKtyu4S565qbJItZupNEaupVBPGe0DfG5877Vz0\n8xYlLdGyTGFfzDj/+X1bhiLPk6y6xhiwt1bRiYDlXEfRFToEWJtfQDxCeADJqRwDqc0zSeCE1pf3\nQdEtCjI32pPCPxMJPAH0rU8cyvHQDNAVta+Iv9Fz2E1KJf1fCsFOjnYxHuDlbEX8w9zyDUfnjkO/\n1m7KQ13eVFsiATmtgr9vzZsVbq+RJyyRqjPRqShMQq35ResBALnlfIxVlHLdxhH8MAlofJLeGztw\njzWRsVDyMEpFGw7q1Daw8SSZZYMQvBDGJ/KLII04jt+f8S/zh4N6UYZo0RwjKReep261PlUZrCov\n3GfJvMIG8IdUo9l+cwaPQvXIFahbjV9QumeWSvbqwCN3ilHIuw9Aiq+TX13XMQ20QVbJo/D/Qct4\nfVzaJTG5DLww3GUpNsN0u7Jjqq3JKEuQhqUkslIZJaJYv3Rt6WcNJ0U4l5jYes7MId5Dm3nM4RYk\nsJDV+PmV+Ndu2nq2TQ3BjRpIHLxZ4JepnfaQPdk4qSQbsczdHkPokWChiLhMLlwV5rhArMQwiUC/\nQRtCODB5d17NwFovQoOeCgQbHuwvXEVWzHSLcxgVH6DCLe+IzcwKJR/ys2uwIr/Q/Lt6ZhAzecR0\n2nhzbvCgS+Ybh8EqxhFGvUJDFZ8n8NejEWEzB5ZI2fRsZYnzVvsrN6JgZOSRLIi+t3pkFnBN4dk8\nlmIqk/942vP7Ckb6/0cKSEXbZ3P8LCfOKbDXiO5VioStfhAoqtx1Nsj14OtC+xqxo1GsW0GdqFah\nvIm0lDIYUvfLAHYXaAmc4dFUb8HF2T8KO2o9Ml9fz2XeBm/nwG55ldcBazN1btkZIJ9Nb1xpPOIS\nQctqyc8U7pzyCvnJ83Em6gMIU1PxSp2rBzzBk7mLR7GQkPwwLqaUFvfU+HMKjogaLESUKWtigfab\nefMtYKTgpFbKL/hvYxhz/mw3BiBl7EAtm+c5KAbUenket2ewpJYNTV7J9tYNWNz+Y4AqqMsQoA6e\nfOievCZP3GlpR5CVadLo3HzKsWxO4cFJtAqHGXu8IO1CrgTw2toWiVQkdyQBK/11f+E0D/PzBUjh\nc8VPLg0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAACI3MvVfsLGPShpqpwQs1tLapUsGXRc2mQkzlgzOuHtsUjEM/lD/uh91RSbP2b\n/3gtKT3J8CRgvGGaxi5o+ljhsADENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04s\nAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJ\niS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "get_config",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5276036973553878575": {
            "error_kind": "string",
            "string": "Function get_config can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "portal",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::eth_address::EthAddress"
                }
              }
            ],
            "kind": "struct",
            "path": "config::Config"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAADOHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAAD3HgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAABCS8MAAIAARwMAQIALAIAAwAAAAAAAAAAAAAAAAD//////////////////////////w44AgMEJAIABAAAAM0lAAABGyYoAIAEBHgADQAAAIAEgAMkAIADAAAA9ioBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFSTg/rH6Bhi88AQECJioBAAEFWgLkG7UeqZ88AQECJi4AGMoYyg==",
      "debug_symbols": "7VfBbsIwDP2XnnuwEzuJ9yvTNBUoU6WqoAKTJsS/L2EkLVDRCSHUAxdUo+e8V7/Y4H22KGe7r8+qWa422dv7PqtX82JbrRof7Q95Nmuruq6+PvtfZxA+LB/xm3XRhHCzLdpt9obkAPKsbBbhWTT7M5ZVXfpI4SG/xoNSEQ6kOjS6ATQZ4hOaDFNCWzUAduTkBHYM3Ad/5JmDx8iXyIGI8kT5D6o+u1R9N1Z9ZGsj2mh9W76wje8qJhx3Jl/0o+WjOpcfSNwTSBDMM1gQh1nAYmIB0SMs1kNOcOuv7oiDikx0UBm5cBDR/EfR+XuHPIV35t3Jp+nOPBnMA05V8c+my2MeqKFmiuNNm14TY6jn9eHKxZ5B3UfLENqyiVfGshsx02oTe9cSmNtgRC823UYt+tJ74snXJrWTNTAyaclKlE1Od6NKyWBbpLmGANCBzWDDKUky1AgWkXQqunEjaLYRzNL73fmbFgwvf6bsj7Mvf6bsj6iXPxP2R8Frvk3Xn4OPvou2KmZ1edoil7tm3lsqtz/r8mK/XLerebnYtWXYNLslE4PRWuXaHv9y+oAoJ+M5PM8v",
      "brillig_names": ["get_config"]
    },
    {
      "name": "get_config_private",
      "is_unconstrained": false,
      "custom_attributes": ["private", "view"],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6006283915776163582": {
            "error_kind": "string",
            "string": "Function get_config_private can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_notes",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6017907102598075401": {
            "error_kind": "string",
            "string": "Function get_order_status can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["get_order_status"]
    },
    {
      "name": "_assert_nonce_and_set_order_details",
      "is_unconstrained": true,
      "custom_attributes": ["internal", "public"],
      "abi": {
        "error_types": {
          "11094545764365153162": {
            "error_kind": "string",
            "string": "Function _assert_nonce_and_set_order_details can only be called internally"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "order_data",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_assert_nonce_and_set_order_details"]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "10852400770788842366": {
            "error_kind": "string",
            "string": "Invalid order domain"
          },
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "11094545764365153162": {
            "error_kind": "string",
            "string": "Function _assert_nonce_and_set_order_details can only be called internally"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "12018683598614887596": {
            "error_kind": "string",
            "string": "Function _check_order_status can only be called internally"
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13594925270014003382": {
            "error_kind": "string",
            "string": "Function _trigger_settlement can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14563046062317426044": {
            "error_kind": "string",
            "string": "Function _check_order_commitment can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5048864367174250545": {
            "error_kind": "string",
            "string": "Function get_filled_order_block_number can only be called statically"
          },
          "5276036973553878575": {
            "error_kind": "string",
            "string": "Function get_config can only be called statically"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6017907102598075401": {
            "error_kind": "string",
            "string": "Function get_order_status can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8412360910299423372": {
            "error_kind": "string",
            "string": "Invalid order destination domain"
          },
          "9169818942746597700": {
            "error_kind": "string",
            "string": "Function _update_order_status can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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Lg0BDwEOHQwBDgEPAh0MAQ8BAwAdDAEDAQ4CKAIBAwQBGQE4ABQBAwEQLg0BEAEPHQwBDwEQAh0MARABAwAdDAEDAQ8CKAIBAwQBGgE4ABQBAwERLg0BEQEQHQwBEAERAh0MAREBAwAdDAEDARACKAIBAwQBGwE4ABQBAwESLg0BEgERHQwBEQESAh0MARIBAwAdDAEDARECKAIBAwQBHAE4ABQBAwETLg0BEwESHQwBEgETAh0MARMBAwAdDAEDARICKAIBAwQBHQE4ABQBAwEULg0BFAETHQwBEwEUAh0MARQBAwAdDAEDARMCKAIBAwQBHgE4ABQBAwEVLg0BFQEUHQwBFAEVAh0MARUBAwAdDAEDARQCKAIBAwQBHwE4ABQBAwEWLg0BFgEVHQwBFQEWAh0MARYBAwAdDAEDARUCKAIBAwQBIAE4ABQBAwEXLg0BFwEWHQwBFgEXAh0MARcBAwAdDAEDARYCKAIBAwQBIQE4ABQBAwEYLg0BGAEXHQwBFwEYAh0MARgBAwAdDAEDARcCKAIBAwQBIgE4ABQBAwEZLg0BGQEYHQwBGAEZAh0MARkBAwAdDAEDARgCKAIBAwQBIwE4ABQBAwEaLg0BGgEZHQwBGQEaAh0MARoBAwAdDAEDARkCKAIBAwQBJAE4ABQBAwEbLg0BGwEaHQwBGgEbAh0MARsBAwAdDAEDARoCKAIBAwQBJQE4ABQBAwEcLg0BHAEbHQwBGwEcAh0MARwBAwAdDAEDARsCKAIBAwQBJgE4ABQBAwEdLg0BHQEcHQwBHAEdAh0MAR0BAwAdDAEDARwCKAIBAwQBJwE4ABQBAwEeLg0BHgEdHQwBHQEeAh0MAR4BAwAdDAEDAR0CKAIBAwQBKAE4ABQBAwEfLg0BHwEeHQwBHgEfAh0MAR8BAwAdDAEDAR4CKAIBAwQBKQE4ABQBAwEgLg0BIAEfHQwBHwEgAh0MASABAwAdDAEDAR8CKAIBAwQBKgE4ABQBAwEhLg0BIQEgHQwBIAEhAh0MASEBAwAdDAEDASACKAIBAwQBKwE4ABQBAwEiLg0BIgEhHQwBIQEiAh0MASIBAwAdDAEDASECKAIBAwQBLAE4ABQBAwEjLg0BIwEiHQwBIgEjAh0MASMBAwAdDAEDASICASgAFICCASMuDQEjAQMdDAEDASQCHQwBJAEjAB0MASMBAwIoAgEjBAEuATgAFAEjASUuDQElASQdDAEkASUCHQwBJQEjAB0MASMBJAIBOAAUABEBJS4NASUBIx0MASMBJgIdDAEmASUAHQwBJQEjAigCASUEATABOAAUASUBJy4NAScBJh0MASYBJwIdDAEnASUAHQwBJQEmAigCASUEATEBOAAUASUBKC4NASgBJx0MAScBKAIdDAEoASUAHQwBJQEnAigCASUEATIBOAAUASUBKS4NASkBKB0MASgBKQIdDAEpASUAHQwBJQEoAigCASUEATMBOAAUASUBKi4NASoBKR0MASkBKgIdDAEqASUAHQwBJQEpAigCASUEATQBOAAUASUBKy4NASsBKh0MASoBKwIdDAErASUAHQwBJQEqAigCASUEATUBOAAUASUBLC4NASwBKx0MASsBLAIdDAEsASUAHQwBJQErAigCASUEATYBOAAUASUBLS4NAS0BLB0MASwBLQIdDAEtASUAHQwBJQEsAigCASUEATcBOAAUASUBLi4NAS4BLR0MAS0BLgIdDAEuASUAHQwBJQEtAigCASUEATgBOAAUASUBLy4NAS8BLh0MAS4BLwIdDAEvASUAHQwBJQEuAigCASUEATkBOAAUASUBMC4NATABLx0MAS8BMAIdDAEwASUAHQwBJQEvAigCASUEAToBOAAUASUBMS4NATEBMB0MATABMQIdDAExASUAHQwBJQEwAigCASUEATsBOAAUASUBMi4NATIBMR0MATEBMgIdDAEyASUAHQwBJQExAigCASUEATwBOAAUASUBMy4NATMBMh0MATIBMwIdDAEzASUAHQwBJQEyAigCASUEAT0BOAAUASUBNC4NATQBMx0MATMBNAIdDAE0ASUAHQwBJQEzAigCASUEAT4BOAAUASUBNS4NATUBNB0MATQBNQIdDAE1ASUAHQwBJQE0AigCASUEAT8BOAAUASUBNi4NATYBNR0MATUBNgIdDAE2ASUAHQwBJQE1AigCASUEAUABOAAUASUBNy4NATcBNh0MATYBNwIdDAE3ASUAHQwBJQE2AigCASUEAUEBOAAUASUBOC4NATgBNx0MATcBOAIdDAE4ASUAHQwBJQE3AigCASUEAUIBOAAUASUBOS4NATkBOB0MATgBOQIdDAE5ASUAHQwBJQE4AigCASUEAUMBOAAUASUBOi4NAToBOR0M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AgoEEAw4CAoLJAIACwAAyHolAADFxAAoAQIKADgKCAstDQsGHAwJCwIcDAsKBBwMCgsCBTCAmgALAAonAg0CAAo4DQsMJAIADAAAyMsGOAoLDwsoAA+AmgAOJAIADgAAyMslAADUbxo4BgoMDSgAC4CYAAYkAgAGAADI8CMAAMjlLgiAZAAHIwAAyRMYOAwKBg0oAAqAowALJAIACwAAyQolAADbDi0MBgcjAADJEycCCgQQDDgICgskAgALAADJKiUAAMXELgQAAYADKACABAQAESUAAMdbLgiABQAGACgGAgoAOAoICy0OBwstDgYEADgCCQEOOAIBBiQCAAYAAMlrJQAAi/EtDgEFIwAAyXQtDQUCBygAAoCOAAUtDAUBIwAAyYkNKAABgJIAAiQCAAIAAMvkIwAAyZ4FMICbAAMAAicCBgQACjgGAwUkAgAFAADJ0gY4AgMICygACICbAAckAgAHAADJ0iUAANRvHAwCAwAnAgUBAC0IAQInAgYECQAQAQYBJwMCBAEAKAICBicCBwQIQwOwAAOAkwAHAAUABi4IgGQAASMAAMoRDSgAAYBlAAMkAgADAADKKyMAAMomLQ0EASYFKAABgI4AAy0NBAUBMICSAAEABicCCAQIDDgDCAkkAgAJAADKViUAAMXEACgCAggAOAgDCS0NCQcBKAADgGMACA44AwgJJAIACQAAyn4lAACL8ScCCgQIDDgICgskAgALAADKlSUAAMXEACgCAgoAOAoICy0NCwkBKAADgGUACA44AwgKJAIACgAAyr0lAACL8ScCCwQIDDgICwwkAgAMAADK1CUAAMXEACgCAgsAOAsIDC0NDAoBKAADgGYACA44AwgLJAIACwAAyvwlAACL8ScCCwQIDDgICwwkAgAMAADLEyUAAMXEACgCAgsAOAsIDC0NDAMcDAcIBBkoAAiAmgAHHAwJCAQAOAcICQ44BwkLJAIACwAAy0olAACL8RkoAAmAmgAHHAwKCAQAOAcICQ44BwkKJAIACgAAy24lAACL8RkoAAmAmgAHHAwDCAQAOAcIAw44BwMJJAIACQAAy5IlAACL8ScCCAQQDDgGCAkkAgAJAADLqSUAAMXELgQABYADKACABAQAESUAAMdbLgiABQAHACgHAggAOAgGCS0OAwktDgcEASgAAYBjAAMtDAMBIwAAyhEtDQQCJwIGBBAMOAEGByQCAAcAAMv/JQAAxcQuBAACgAMoAIAEBAARJQAAx1suCIAFAAUAKAUCBgA4BgEHLgqAZAAHASgAAYBjAAItDgUELQwCASMAAMmJJQAAiOwtDQIEACgEAgQtDgQCLQgBBAAAAQIBLQgBBScCBgQhABABBgEnAwUEAQAoBQIGJwIHBCAAOAcGBy0MBggMOAgHCRYMCQkkAgAJAADMni4KgGEACAAoCAIIIwAAzH0tCAEGAAABAgEtDgUGLQgBBScCBwQJABABBwEnAwUEAQAoAQIHACgCAggAKAUCCUA/AAkACAAHLQ0FAQAoAQIBLQ4BBS0OBQQuCIBkAAMjAADM8Q0oAAOAmwABJAIAAQAAzQsjAADNBi0NBgEmLQ0EAicCBwQIDDgDBwgkAgAIAADNJiUAAMXEACgCAgcAOAcDCC0NCAUcDAUCACcCBwEALQgBBScCCAQFABABCAEnAwUEAQAoBQIIJwIJBARDA7AAAoCTAAkABwAIBTCAjgADAAIuCIBkAAEjAADNew0oAAGAjgAHJAIABwAAzaEjAADNkAEoAAOAYwABLQwBAyMAAMzxLQ0GBwA4AgEIDjgCCAkkAgAJAADNvCUAAIvxJwIKBAQMOAEKCyQCAAsAAM3TJQAAxcQAKAUCCgA4CgELLQ0LCScCCwQgDDgICwwkAgAMAADN+CUAAMXELgQAB4ADKACABAQAISUAAMdbLgiABQAKACgKAgsAOAsIDC0OCQwtDgoGASgAAYBjAActDAcBIwAAzXslAACI7C0IAQMAAAECAS4KgJcAAy0IAQQAAAECAS4KgJUABC0IAQUAAAECAS4KgJUABS4IgGQAAiMAAM5wDSgAAoCgAAYkAgAGAADOvyMAAM6FLQ0FAgEoAAGAkQAHLQ0HBhwMBgEALQ0DBgQ4AQYDADgCAwEtDgEFLQ0EAgQ4AgYDADgBAwItDAIBJi0NBQYDMIChAAIABycCCQQgDDgHCQokAgAKAADO4iUAAMXEACgBAgkAOAkHCi0NCggcDAgHAC0NAwgEOAcICQA4BgkHLQ4HBQUoAAiAswAGLQ4GAy0NBAcDMICSAAIACA8oAAKAkgAJJAIACQAAzzQlAADUXScCCgQgDDgICgskAgALAADPSyUAAMXEACgBAgoAOAoICy0NCwkcDAkIAAQ4CAYJADgHCQYtDgYEASgAAoBjAAYtDAYCIwAAznAqAQABBX9Bvb6hDxlEPAEBAiYBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAAz9QuAYAIgAYuAoAGgAkBAIAIAAKACAEAgAkAAoAJIwAAz6MmKgEAAQVaAuQbtR6pnzwBAQImJQAAiOwuCIBkAAUjAADP9w0oAAWAZgAGJAIABgAA0GIjAADQDC0NAQUtDQIGLQ0DBy0NBAgtCAEJJwIKBAUAEAEKAScDCQQBACgGAgonAgsEBAAoCQIMPw8ACgAMLQ0JBgAoBgIGLQ4GCS0OBQEtDgkCLQ4HAy0OCAQmLQ0DBgw4BQYHASgABYBjAAYkAgAHAADQgCMAANExLQ0BBy0NAggtDQMJLQ0ECicCDAQEDDgFDA0kAgANAADQpyUAAMXEACgIAgwAOAwFDS0NDQsnAg0EAww4BQ0OJAIADgAA0MwlAADFxAAoBwINADgNBQ4tDQ4MADgLDA0nAgwEBAw4BQwOJAIADgAA0PYlAADFxC4EAAiAAygAgAQEAAUlAADHWy4IgAUACwAoCwIMADgMBQ4tDg0OLQ4HAS0OCwItDgkDLQ4KBCMAANExLQwGBSMAAM/3KgEAAQW+Hj//PqT2+jwBAQImJQAAiOwtCAEEJwIFBCEAEAEFAScDBAQBACgEAgUnAgYEIAA4BgUGLQwFBww4BwYIFgwICCQCAAgAANGYLgqAYQAHACgHAgcjAADRdy0IAQUAAAECAS0OBAUuCIBkAAMjAADRsA0oAAOApAAEJAIABAAA0cojAADRxS0NBQEmLQ0FBAA4AgMGDjgCBgckAgAHAADR5SUAAIvxKAIACAQBLQw4BggJJAIACQAA0f4lAADFxAAoAQIIADgIBgktDQkHJwIIBCAMOAMICSQCAAkAANIjJQAAxcQuBAAEgAMoAIAEBAAhJQAAx1suCIAFAAYAKAYCCAA4CAMJLQ4HCQEoAAOAYwAELQ4GBS0MBAMjAADRsCUAAIjsLQgBBCcCBQQFABABBQEnAwQEAQAoBAIFLQwFBi4KgGEABgAoBgIGLgqAYQAGACgGAgYuCoBhAAYAKAYCBi4KgGEABi0IAQUAAAECAS0OBAUuCIBkAAMjAADSvg0oAAOAjgAEJAIABAAA0tgjAADS0y0NBQEmLQ0FBAA4AgMGDjgCBgckAgAHAADS8yUAAIvxKAIACAQBLQw4BggJJAIACQAA0wwlAADFxAAoAQIIADgIBgktDQkHJwIIBAQMOAMICSQCAAkAANMxJQAAxcQuBAAEgAMoAIAEBAAFJQAAx1suCIAFAAYAKAYCCAA4CAMJLQ4HCQEoAAOAYwAELQ4GBS0MBAMjAADSviUAAIjsLQgBAwAAAQIBLgqAlwADLQgBBAAAAQIBLgqAlQAELgiAZAACIwAA05oNKAACgI4ABSQCAAUAANPjIwAA068tDQQBHAwBAgApAgADAP////8OOAIDBCQCAAQAANPTJQAAz9UcDAEDBBwMAwIAHAwCAQQmLQ0EBQMwgGYAAgAGDygAAoBmAAckAgAHAADUBCUAANRdJwIIBAQMOAYICSQCAAkAANQbJQAAxcQAKAECCAA4CAYJLQ0JBxwMBwYALQ0DBwQ4BgcIADgFCAYtDgYEBSgAB4CzAAUtDgUDASgAAoBjAAUtDAUCIwAA05oqAQABBSiGkrBH3P1DPAEBAiYqAQABBWRhiKjGz5TLPAEBAiYlAACI7C0IAQUnAgYEEQAQAQYBJwMFBAEAKAUCBicCBwQQADgHBgctDAYIDDgIBwkWDAkJJAIACQAA1M0uCoBkAAgAKAgCCCMAANSsLQgBBgAAAQIBLQ4FBgw4AgMFJAIABQAA1UwjAADU7AEoAAOAjQAHDjgDBwgkAgAIAADVBiUAAIvxDDgCBwgkAgAIAADVIyMAANUYLgiAjQAFIwAA1UMCOAIDBw44AwIIJAIACAAA1TolAADUXS0MBwUjAADVQy0MBQQjAADVVy4IgGQABCMAANVXBygABICOAAItCAEFAAABAgEtDgIFJwIIBAQGOAQICQQ4CQgKAjgECgcLKAAHgGQACCQCAAgAANW4IwAA1ZUBKAACgGMABw44AgcIJAIACAAA1a8lAACL8S0OBwUjAADVuC0NBQcuCIBkAAIjAADVxww4AgcFJAIABQAA1eIjAADV2S0NBgEtDAQCJi0IAQgAAAECAS4KgGQACC4IgGQABSMAANX8DSgABYCOAAkkAgAJAADWayMAANYRLQ0GBS0NCAknAgoEEAw4AgoLJAIACwAA1jAlAADFxC4EAAWAAygAgAQEABElAADHWy4IgAUACAAoCAIKADgKAgstDgkLASgAAoBjAAUtDggGLQwFAiMAANXHBSgAAoCOAAonAgwEAAsoAAyAjgALJAIACwAA1qIHKAAKgI4ADgo4DgINJAIADQAA1qIlAADUbwA4CgULDjgKCwwkAgAMAADWuSUAAIvxDDgLBAokAgAKAADW1iMAANbLLgiAYQAJIwAA1x0AOAMLCg44AwoMJAIADAAA1u0lAACL8SgCAAwEAS0MOAoMDSQCAA0AANcGJQAAxcQAKAECDAA4DAoNLQ0NCy0MCwkjAADXHS0NCAoZKAAKgJoACxwMCQoEADgLCgkOOAsJDCQCAAwAANdFJQAAi/EtDgkIASgABYBjAAktDAkFIwAA1fwlAACI7BwMAgUEHAwFBAUcDAQCBA0wgLgAAgAECygABICUAAUkAgAFAADXjycCBgQAPAkBBgcoAAKAjQAELgmAjAAFACgFAgUuBgAFgIwtCAEFAAABAgEuCoCMAAUuCIBkAAMjAADXwgw4AwQGJAIABgAA2lIjAADX1CcCCARABjgCCAkEOAkICgI4AgoHCygAB4BkAAgkAgAIAADYdiMAANf9BTCAjQAEAAcnAgkEAAo4CQQIJAIACAAA2DEGOAcECwsoAAuAjQAKJAIACgAA2DElAADUbycCCQQKLQgACi0MAQstDAIMLQwHDQAQAAkAJQAA3ZMtBAAALQwLBC0MDAgtDQQBACgBAgEtDgEELQwEAy0MCAYjAADYzC0IAQEnAgQEEQAQAQQBJwMBBAEAKAECBCcCBwQQADgHBActDAQIDDgIBwkWDAkJJAIACQAA2L0uCoBkAAgAKAgCCCMAANicLQwBAy4IgGQABiMAANjMLQ0DBwAoBwIHLQ4HAwcoAAaAjgAHJwIJBBAMOAcJCiQCAAoAANj4JQAAxcQAKAMCCQA4CQcKLQ0KCCcCCgQLLQgACy0MCAwtDAYNLgiArAAOABAACgAlAADF1i0EAAAtDAwJJwIKBBAMOAcKCyQCAAsAANlGJQAAxcQuBAADgAMoAIAEBAARJQAAx1suCIAFAAgAKAgCCgA4CgcLLQ4JCw0oAAaAjwADJAIAAwAA2b4jAADZgS0NBQMtCAEFJwIGBAkAEAEGAScDBQQBACgIAgYAKAMCBwAoBQIJQD8ACQAHAAYtDAUBLgiAZAAEIwAA2ektDQUDASgABoBjAAUOOAYFByQCAAcAANncJQAAi/EtDAMBLQwFBCMAANnpLQ0BAwAoAwIDLQ4DAScCBQQJLQgACS0MCAotDAQLLQwCDAAQAAUAJQAAx+ktBAAALQwKAy0NAwIAKAICAi0OAgMnAgQEBS0IAAUtDAMGLQwBBwAQAAQAJQAAzDwtBAAALQwGAi0MAgEmBTCAjQADAAYnAggEAAo4CAMHJAIABwAA2oYGOAYDCgsoAAqAjQAJJAIACQAA2oYlAADUbycCCQQKLQgACi0MAQstDAIMLQwGDQAQAAkAJQAA3ZMtBAAALQwLBy0MDAgtDQcGACgGAgYtDgYHLQ0FBi0IAQknAgoECQAQAQoBJwMJBAEAKAcCCgAoBgILACgJAgxAPwAMAAsACi0NCQYAKAYCBi0OBgktDgkFASgAA4BjAAYtDAYDIwAA18IqAQABBclvkzsTnekWPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAADbgSMAANvxJACADQAA244jAADbpy4AgAOABQEAgAUAAoAOLgKAC4AOIwAA2+woAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAA2+wjAADcRSgAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAADcRSgAgA0EAAMBAIAFgA2ADAEAgAyABIANAwCACAACgA4BAIANgA6ADwEAgAqADoAQDQCAEIAKgA4kAIAOAADcpS4BgBCAES4CgBGADwMAgBAAAoAQAwCADwACgA8jAADcdC4AgAyABiYlAACI7C0IAQMAAAECAS4KgJcAAy0IAQQAAAECAS4KgJUABC4IgGQAAiMAANzaDSgAAoCiAAUkAgAFAADc9CMAANzvLQ0EASYtDQQFAzCAoQACAAYPKAACgKEAByQCAAcAAN0VJQAA1F0nAggEHww4BggJJAIACQAA3SwlAADFxAAoAQIIADgIBgktDQkHHAwHBgAtDQMHBDgGBwgAOAUIBi0OBgQFKAAHgLMABS0OBQMBKAACgGMABS0MBQIjAADc2iUAAIjsASgAAYBjAAMtDQMCHAwCAwIcDAMBABwMAQICLQwCASYlAACI7C0IAQUnAgYEEQAQAQYBJwMFBAEAKAUCBicCBwQQADgHBgctDAYIDDgIBwkWDAkJJAIACQAA3d8uCoBkAAgAKAgCCCMAAN2+LQgBBgAAAQIBLQ4FBgw4AgMFJAIABQAA3l4jAADd/gEoAAOAjQAHDjgDBwgkAgAIAADeGCUAAIvxDDgCBwgkAgAIAADeNSMAAN4qLgiAjQAFIwAA3lUCOAIDBw44AwIIJAIACAAA3kwlAADUXS0MBwUjAADeVS0MBQQjAADeaS4IgGQABCMAAN5pBygABICOAAItCAEFAAABAgEtDgIFJwIIBAQGOAQICQQ4CQgKAjgECgcLKAAHgGQACCQCAAgAAN7KIwAA3qcBKAACgGMABw44AgcIJAIACAAA3sElAACL8S0OBwUjAADeyi0NBQcuCIBkAAIjAADe2Qw4AgcFJAIABQAA3vQjAADe6y0NBgEtDAQCJi0IAQgAAAECAS4KgGQACC4IgGQABSMAAN8ODSgABYCOAAkkAgAJAADffSMAAN8jLQ0GBS0NCAknAgoEEAw4AgoLJAIACwAA30IlAADFxC4EAAWAAygAgAQEABElAADHWy4IgAUACAAoCAIKADgKAgstDgkLASgAAoBjAAUtDggGLQwFAiMAAN7ZBSgAAoCOAAonAgwEAAsoAAyAjgALJAIACwAA37QHKAAKgI4ADgo4DgINJAIADQAA37QlAADUbwA4CgULDjgKCwwkAgAMAADfyyUAAIvxDDgLBAokAgAKAADf6CMAAN/dLgiAYQAJIwAA4C8AOAMLCg44AwoMJAIADAAA3/8lAACL8SgCAAwEAU0MOAoMDSQCAA0AAOAYJQAAxcQAKAECDAA4DAoNLQ0NCy0MCwkjAADgLy0NCAoZKAAKgJoACxwMCQoEADgLCgkOOAsJDCQCAAwAAOBXJQAAi/EtDgkIASgABYBjAAktDAkFIwAA3w4uABjKGMo=",
      "debug_symbols": "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",
      "brillig_names": ["public_dispatch"]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "AztecGateway7683"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claimable_orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "open_orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "order_status",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "used_nonces",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "filled_orders_block_numbers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_trigger_settlement_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_trigger_settlement_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::fill_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::fill_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "fill_deadline",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        },
                        {
                          "name": "order_data_type",
                          "type": {
                            "kind": "array",
                            "length": 32,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        },
                        {
                          "name": "order_data",
                          "type": {
                            "kind": "array",
                            "length": 301,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::open_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::open_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::get_filled_order_block_number_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_filled_order_block_number_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::get_order_status_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "status",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_check_order_status_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_check_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::claim_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::claim_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_check_order_commitment_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_check_order_commitment_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::fill_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::fill_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "order_data",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_assert_nonce_and_set_order_details_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_assert_nonce_and_set_order_details_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AztecGateway7683::get_config_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_config_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "status",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_update_order_status_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_update_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AztecGateway7683::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "fill_deadline",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        },
                        {
                          "name": "order_data_type",
                          "type": {
                            "kind": "array",
                            "length": 32,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        },
                        {
                          "name": "order_data",
                          "type": {
                            "kind": "array",
                            "length": 301,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::open_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::open_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "105": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "110": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "114": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "117": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "118": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "121": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\n    // Top-level unconstrained fns are contract entrypoints, but they're not explicitly designated in any way. They're\n    // the fallback case for a function that matches no other rules.\n    // TODO(#12743): improve this\n\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\n    // public, but which *are* contract entrypoints (i.e. they're not opting out via the #[test] or\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\n        !is_fn_private(f)\n            & !is_fn_public(f)\n            & !f.has_named_attribute(\"contract_library_method\")\n            & !f.has_named_attribute(\"test\")\n    });\n\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\n    // https://github.com/noir-lang/noir/issues/7714). We can't simply print a message since that'd otherwise break the\n    // output of utils such as `nargo test --list-tests`.\n    // // We don't expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr's\n    // // #[private] macro, possibly resulting in a non-standard interface).\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n    //     !f.is_unconstrained()\n    // }) {\n    //     let name = f.name();\n    //     warn(\n    //         f\"found private contract function '{name}' which does not have the #[private] attribute - make sure you know what you're doing!\",\n    //     );\n    // }\n\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n        f.is_unconstrained()\n    }) {\n        transform_top_level_unconstrained(f);\n    }\n}\n\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n"
    },
    "122": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{\n    stub_registry,\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\n};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    find_and_transform_top_level_unconstrained_fns(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The note discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_ciphertext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let note_discovery_call = create_note_discovery_call();\n    quote {\n        unconstrained fn sync_notes() {\n            // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n            // unconstrained execution context since it will not be available otherwise.\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n            $note_discovery_call\n        }\n    }\n}\n"
    },
    "123": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/notes/mod.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "124": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr",
      "source": "use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "125": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ.get_trait_impl(trait_constraint).expect(f\"Type does not implement trait\").methods().filter(\n        |m| m.name() == target_method,\n    )[0]\n        .as_typed_expr()\n}\n"
    },
    "136": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "139": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "142": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "143": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "144": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "145": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "146": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "147": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n    traits::{Deserialize, FromField},\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "151": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "152": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::{\n    abis::validation_requests::{\n        key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n    },\n    traits::Deserialize,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "153": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "156": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "159": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress,\n    point::{Point, POINT_LENGTH},\n    traits::Deserialize,\n};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(\n    address: AztecAddress,\n    ephPk: Point,\n) -> [Field; POINT_LENGTH] {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    let fields = get_shared_secret_oracle(address, ephPk);\n    Point::deserialize(fields)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "160": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "162": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "169": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "184": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "186": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "187": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "188": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "191": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "193": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "195": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "199": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "217": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "253": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "260": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "261": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "275": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "277": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "278": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "288": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "292": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "294": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "295": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "304": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "315": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "329": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "333": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "334": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "350": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "351": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "353": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "365": {
      "path": "/Users/eidoo/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "394": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    encrypted_logs::log_assembly_strategies::default_aes128,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        // TODO: we're abusing the note encoding scheme by computing the log for a fake note type with such a note type\n        // id that the recipient will realize that these are the private fields of a partial note. Ideally we'd not rely\n        // on this crude mechanism and we'd instead compute it as a proper event log. However, given the current state\n        // of the log library it's far easier to do it this way.\n        let encrypted_log = default_aes128::note::compute_log(\n            *context,\n            private_log_content,\n            storage_slot,\n            recipient,\n            sender,\n        );\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        // We abuse the fact that note type ids are 7 bits long to use the 8th bit indicate the log corresponds to a\n        // partial note. Ideally we'd use proper events with selectors, but those are not handled well at the moment.\n        UintNote::get_id() + 128\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "55": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/main.nr",
      "source": "mod config;\nmod types;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract AztecGateway7683 {\n    // context.chain_id() returns 1, which corresponds to the mainnet, making it unsuitable for our use case.\n    // Instead, we designate 999999 as the destination domain.\n    global LOCAL_DESTINATION_DOMAIN: u32 = 999999;\n\n    global UNKNOWN: u32 = 0;\n    global OPENED: u32 = 1;\n    global FILLED: u32 = 2;\n    global INITIATED_PRIVATELY: u32 = 3;\n\n    global SETTLE_ORDER_TYPE: [u8; 32] = [\n        25, 30, 167, 118, 189, 110, 12, 213, 106, 109, 68, 186, 74, 234, 47, 236, 70, 139, 74, 11,\n        76, 29, 136, 13, 64, 37, 146, 158, 235, 97, 93, 13,\n    ]; // sha256(\"SETTLE_ORDER_TYPE\")\n\n    use crate::{\n        config::Config,\n        types::{\n            events::Filled,\n            helpers::InternalRCOParams,\n            onchain_cross_chain_order::OnchainCrossChainOrder,\n            order_data::{\n                ORDER_DATA_LENGTH, ORDER_DATA_TYPE, OrderData, PRIVATE_ORDER, PUBLIC_ORDER,\n            },\n            resolved_cross_chain_order::{\n                FILL_INSTRUCTIONS_MAX_INSTRUCTIONS, FillInstruction, MAX_SPENT_MAX_OUTPUTS,\n                MIN_RECEIVED_MAX_OUTPUTS, Output, ResolvedCrossChainOrder,\n            },\n        },\n        utils::{u8_32_to_aztec_address, u8_32_to_u128},\n    };\n    use dep::aztec::{\n        macros::{functions::{initializer, internal, private, public, view}, storage::storage},\n        prelude::{AztecAddress, EthAddress, Map, PublicImmutable, PublicMutable},\n        protocol_types::{hash::sha256_to_field, traits::Packable},\n    };\n    use token::Token;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n        claimable_orders: Map<Field, PublicMutable<Field, Context>, Context>,\n        open_orders: Map<Field, PublicMutable<[u8; 32], Context>, Context>,\n        order_status: Map<Field, PublicMutable<u32, Context>, Context>,\n        used_nonces: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n        filled_orders_block_numbers: Map<Field, PublicMutable<Field, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(portal: EthAddress) {\n        storage.config.initialize(Config { portal });\n    }\n\n    #[public]\n    fn open(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, \"Invalid order data type\");\n\n        let data = _resolve(order, context.msg_sender(), context.timestamp());\n        let order_data = data.order_data;\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(order_data.sender_nonce);\n\n        assert(order_data.order_type == PUBLIC_ORDER, \"Not a public order\");\n        assert(order_data.origin_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order origin domain\");\n        assert(!storage.used_nonces.at(context.msg_sender()).at(nonce).read(), \"Invalid nonce\");\n\n        // We cannot store the entire order_data + ORDER_DATA_TYPE as it raises the following error:\n        // Reached the limit (63) on number of 'public data (contract storage) write' per tx 'storage_write_opcode(storage_slot, value).\n        // For this reason we store a commitment of it.\n        storage.open_orders.at(order_id).write(_get_open_order_commitment(order.order_data));\n        storage.order_status.at(order_id).write(OPENED);\n        storage.used_nonces.at(context.msg_sender()).at(nonce).write(true);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n\n            Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_in_public(\n                    context.msg_sender(),\n                    context.this_address(),\n                    u8_32_to_u128(min_received.amount),\n                    0,\n                )\n                .call(&mut context);\n        }\n\n        // TODO emit event Open(order_id, resolved_order);\n    }\n\n    #[private]\n    fn open_private(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, \"Invalid order data type\");\n\n        // NOTE: Force the sender to be zero in order to avoid creating a connection between the sender and the recipient.\n        let data = _resolve(order, AztecAddress::zero(), 0 as u64);\n        let order_data = data.order_data;\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(order_data.sender_nonce);\n\n        assert(order_data.order_type == PRIVATE_ORDER, \"Not a private order\");\n        assert(order_data.origin_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order origin domain\");\n        AztecGateway7683::at(context.this_address())\n            ._assert_nonce_and_set_order_details(order_id, order.order_data, nonce)\n            .enqueue(&mut context);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n\n            Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_in_private(\n                    context.msg_sender(),\n                    context.this_address(),\n                    u8_32_to_u128(min_received.amount),\n                    0,\n                )\n                .call(&mut context);\n        }\n\n        // TODO emit event Open(order_id, resolved_order);\n    }\n\n    #[private]\n    fn claim_private(\n        secret: [u8; 32],\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n\n        AztecGateway7683::at(context.this_address())\n            ._check_order_status(order_id, INITIATED_PRIVATELY)\n            .enqueue(&mut context);\n\n        // verify that a commitment exists for the given order.\n        AztecGateway7683::at(context.this_address())\n            ._check_order_commitment(order_id, origin_data_bytes, filler_data_bytes)\n            .enqueue(&mut context);\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        // if a commitment exists, the order is valid, allowing us to compare the recipient with hash(secret).\n        assert(sha256::digest(secret) == order_data.recipient, \"Invalid secret\");\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_to_private(context.msg_sender(), u8_32_to_u128(order_data.amount_out))\n            .call(&mut context);\n\n        AztecGateway7683::at(context.this_address())._update_order_status(order_id, FILLED).enqueue(\n            &mut context,\n        );\n\n        // TODO: store filled order\n\n        AztecGateway7683::at(context.this_address())\n            ._trigger_settlement(\n                order_id,\n                order_id_bytes,\n                filler_data_bytes, // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn fill(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        AztecGateway7683::at(context.this_address())._check_order_status(order_id, UNKNOWN).call(\n            &mut context,\n        );\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        // TODO: assert that order_data.data specifies that this order is a public one\n        assert(order_id_bytes == sha256::digest(origin_data_bytes), \"Invalid order id\");\n        assert(context.timestamp() as u32 <= order_data.fill_deadline, \"Order fill expired\");\n        assert(\n            order_data.destination_domain == LOCAL_DESTINATION_DOMAIN,\n            \"Invalid order destination domain\",\n        );\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_in_public(\n                context.msg_sender(),\n                u8_32_to_aztec_address(order_data.recipient),\n                u8_32_to_u128(order_data.amount_out),\n                Field::from_be_bytes(order_data.sender_nonce),\n            )\n            .call(&mut context);\n\n        storage.order_status.at(order_id).write(FILLED);\n        // TODO: store filled order\n\n        AztecGateway7683::at(context.this_address())\n            ._trigger_settlement(\n                order_id,\n                order_id_bytes,\n                filler_data_bytes, // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n            )\n            .call(&mut context);\n\n        context.emit_public_log(Filled {\n            order_id: order_id_bytes,\n            origin_data: origin_data_bytes,\n            filler_data: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[public]\n    fn fill_private(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        AztecGateway7683::at(context.this_address())._check_order_status(order_id, UNKNOWN).call(\n            &mut context,\n        );\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        // TODO: assert that order_data.data specifies that this order is a private one\n        assert(order_id_bytes == sha256::digest(origin_data_bytes), \"Invalid order id\");\n        assert(context.timestamp() as u32 <= order_data.fill_deadline, \"Order fill expired\");\n        assert(order_data.destination_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order domain\");\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_in_public(\n                context.msg_sender(),\n                context.this_address(),\n                u8_32_to_u128(order_data.amount_out),\n                0,\n            )\n            .call(&mut context);\n\n        storage.claimable_orders.at(order_id).write(sha256_to_field(_get_order_pre_image(\n            origin_data_bytes,\n            filler_data_bytes,\n        )));\n        storage.order_status.at(order_id).write(INITIATED_PRIVATELY);\n\n        context.emit_public_log(Filled {\n            order_id: order_id_bytes,\n            origin_data: origin_data_bytes,\n            filler_data: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[public]\n    #[view]\n    fn get_config() -> Config {\n        storage.config.read()\n    }\n\n    #[private]\n    #[view]\n    fn get_config_private() -> Config {\n        storage.config.read()\n    }\n\n    #[public]\n    #[view]\n    fn get_order_status(order_id_bytes: [u8; 32]) -> u32 {\n        storage.order_status.at(Field::from_be_bytes(order_id_bytes)).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_filled_order_block_number(order_id_bytes: [u8; 32]) -> Field {\n        storage.filled_orders_block_numbers.at(Field::from_be_bytes(order_id_bytes)).read()\n    }\n\n    #[internal]\n    #[public]\n    fn _assert_nonce_and_set_order_details(\n        order_id: Field,\n        order_data: [u8; ORDER_DATA_LENGTH],\n        nonce: Field,\n    ) {\n        assert(!storage.used_nonces.at(context.msg_sender()).at(nonce).read(), \"Invalid nonce\");\n        // We cannot store the entire order_data + ORDER_DATA_TYPE as it raises the following error:\n        // Reached the limit (63) on number of 'public data (contract storage) write' per tx 'storage_write_opcode(storage_slot, value).\n        // For this reason we store a commitment of it.\n        storage.open_orders.at(order_id).write(_get_open_order_commitment(order_data));\n        storage.order_status.at(order_id).write(OPENED);\n        storage.used_nonces.at(context.msg_sender()).at(nonce).write(true);\n    }\n\n    #[contract_library_method]\n    fn _get_open_order_commitment(order_data: [u8; ORDER_DATA_LENGTH]) -> [u8; 32] {\n        let mut data: [u8; ORDER_DATA_LENGTH + 32] = [0; ORDER_DATA_LENGTH + 32];\n        for i in 0..32 {\n            data[i] = ORDER_DATA_TYPE[i];\n        }\n        for i in 0..ORDER_DATA_LENGTH {\n            data[i + 32] = order_data[i];\n        }\n        sha256::digest(data)\n    }\n\n    #[public]\n    #[internal]\n    fn _check_order_status(order_id: Field, status: u32) {\n        assert(storage.order_status.at(order_id).read() == status, \"Invalid order status\");\n    }\n\n    #[public]\n    #[internal]\n    fn _check_order_commitment(\n        order_id: Field,\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_commitment = storage.claimable_orders.at(order_id).read();\n        assert(\n            order_commitment\n                == sha256_to_field(_get_order_pre_image(origin_data_bytes, filler_data_bytes)),\n            \"Invalid order\",\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _trigger_settlement(order_id: Field, order_id_bytes: [u8; 32], filler_data: [u8; 32]) {\n        storage.filled_orders_block_numbers.at(order_id).write(context.block_number());\n\n        let mut settlement_message_bytes: [u8; 96] = [0; 96];\n\n        for i in 0..32 {\n            settlement_message_bytes[i] = SETTLE_ORDER_TYPE[i]; // order_type\n            settlement_message_bytes[i + 32] = order_id_bytes[i]; // order_id_bytes\n            settlement_message_bytes[i + 64] = filler_data[i]; // recipient\n        }\n\n        let config = storage.config.read();\n        context.message_portal(config.portal, sha256_to_field(settlement_message_bytes));\n    }\n\n    #[contract_library_method]\n    fn _resolve(\n        order: OnchainCrossChainOrder,\n        sender: AztecAddress,\n        timestamp: u64,\n    ) -> InternalRCOParams {\n        let mut order_data = OrderData::decode(order.order_data);\n\n        assert(order_data.fill_deadline == order.fill_deadline, \"Invalid fill deadline\");\n        assert(u8_32_to_aztec_address(order_data.sender) == sender, \"Invalid order sender\");\n\n        let order_id_bytes = sha256::digest(order.order_data);\n        let order_id = Field::from_be_bytes(order_id_bytes);\n\n        let min_received_output = Output {\n            token: order_data.input_token,\n            recipient: [0; 32],\n            amount: order_data.amount_in,\n            chain_id: order_data.origin_domain,\n        };\n        let min_received: [Output; MIN_RECEIVED_MAX_OUTPUTS] =\n            [min_received_output; MIN_RECEIVED_MAX_OUTPUTS];\n\n        let max_spent_output = Output {\n            token: order_data.output_token,\n            recipient: order_data.recipient,\n            amount: order_data.amount_out,\n            chain_id: order_data.destination_domain,\n        };\n        let max_spent: [Output; MAX_SPENT_MAX_OUTPUTS] = [max_spent_output; MAX_SPENT_MAX_OUTPUTS];\n\n        let fill_instruction = FillInstruction {\n            destination_chain_id: order_data.destination_domain,\n            destination_settler: order_data.destination_settler,\n            origin_data: order.order_data,\n        };\n        let fill_instructions: [FillInstruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS] =\n            [fill_instruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS];\n\n        let resolved_order = ResolvedCrossChainOrder {\n            user: sender,\n            origin_chain_id: LOCAL_DESTINATION_DOMAIN,\n            open_dealine: timestamp as u32,\n            fill_deadline: order.fill_deadline,\n            order_id: order_id_bytes,\n            min_received,\n            max_spent,\n            fill_instructions,\n        };\n\n        InternalRCOParams { order_id, resolved_cross_chain_order: resolved_order, order_data }\n    }\n\n    #[contract_library_method]\n    fn _get_order_pre_image(\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) -> [u8; ORDER_DATA_LENGTH + 32] {\n        let mut pre_image: [u8; ORDER_DATA_LENGTH + 32] = [0; ORDER_DATA_LENGTH + 32];\n        for i in 0..ORDER_DATA_LENGTH {\n            pre_image[i] = origin_data_bytes[i];\n        }\n        for i in 0..32 {\n            pre_image[i + ORDER_DATA_LENGTH] = filler_data_bytes[i];\n        }\n        pre_image\n    }\n\n    #[public]\n    #[internal]\n    fn _update_order_status(order_id: Field, status: u32) {\n        storage.order_status.at(order_id).write(status);\n    }\n}\n"
    },
    "56": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/types/events.nr",
      "source": "use crate::types::order_data::ORDER_DATA_LENGTH;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n// #[event]\n#[derive(Serialize)]\npub struct Filled {\n    pub order_id: [u8; 32],\n    pub origin_data: [u8; ORDER_DATA_LENGTH],\n    pub filler_data: [u8; 32],\n}\n\n// 301 + 32 + 32 = 365      365 / 31 = 11.74 = 12\nimpl Packable<13> for Filled {\n    fn pack(self) -> [Field; 13] {\n        let mut result: [Field; 13] = [0; 13];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        let mut filler_data_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n            filler_data_31[i] = self.filler_data[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n        residual_bytes[10] = self.filler_data[31];\n\n        for i in 0..10 {\n            let mut partial: [u8; 31] = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < ORDER_DATA_LENGTH {\n                    partial[j] = self.origin_data[k];\n                }\n            }\n            result[i + 1] = Field::from_be_bytes(partial);\n\n            if i < 9 {\n                residual_bytes[i + 1] = self.origin_data[offset + 31];\n            }\n        }\n\n        result[0] = Field::from_be_bytes::<31>(order_id_31);\n        result[11] = Field::from_be_bytes::<31>(filler_data_31);\n        result[12] = Field::from_be_bytes::<31>(residual_bytes);\n        result\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], origin_data: [0; ORDER_DATA_LENGTH], filler_data: [0; 32] }\n    }\n}\n"
    },
    "59": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/types/order_data.nr",
      "source": "use crate::utils::u8_4_to_u32;\nuse dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n\npub global ORDER_DATA_LENGTH: u32 = 301;\npub global ORDER_DATA_TYPE: [u8; 32] = [\n    240, 12, 59, 246, 12, 115, 235, 151, 9, 127, 28, 152, 53, 83, 125, 160, 20, 224, 183, 85, 254,\n    148, 178, 93, 122, 200, 64, 29, 246, 103, 22, 160,\n];\n\npub global PUBLIC_ORDER: u8 = 0;\npub global PRIVATE_ORDER: u8 = 1;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OrderData {\n    pub sender: [u8; 32],\n    pub recipient: [u8; 32],\n    pub input_token: [u8; 32],\n    pub output_token: [u8; 32],\n    pub amount_in: [u8; 32],\n    pub amount_out: [u8; 32],\n    pub sender_nonce: [u8; 32],\n    pub origin_domain: u32,\n    pub destination_domain: u32,\n    pub destination_settler: [u8; 32],\n    pub fill_deadline: u32,\n    pub order_type: u8,\n    pub data: [u8; 32],\n}\n\nimpl OrderData {\n    pub fn decode(bytes: [u8; ORDER_DATA_LENGTH]) -> OrderData {\n        let sender = u8_order_data_length_to_u8_32(bytes, 0);\n        let recipient = u8_order_data_length_to_u8_32(bytes, 32);\n        let input_token = u8_order_data_length_to_u8_32(bytes, 64);\n        let output_token = u8_order_data_length_to_u8_32(bytes, 96);\n        let amount_in = u8_order_data_length_to_u8_32(bytes, 128);\n        let amount_out = u8_order_data_length_to_u8_32(bytes, 160);\n        let sender_nonce = u8_order_data_length_to_u8_32(bytes, 192);\n        let origin_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 224));\n        let destination_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 228));\n        let destination_settler = u8_order_data_length_to_u8_32(bytes, 232);\n        let fill_deadline = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 264));\n        let order_type = u8_order_data_length_to_u8(bytes, 268);\n        let data = u8_order_data_length_to_u8_32(bytes, 269);\n\n        OrderData {\n            sender,\n            recipient,\n            input_token,\n            output_token,\n            amount_in,\n            amount_out,\n            sender_nonce,\n            origin_domain,\n            destination_domain,\n            destination_settler,\n            fill_deadline,\n            order_type,\n            data,\n        }\n    }\n}\n\nfn u8_order_data_length_to_u8_32(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 32] {\n    let mut result = [0; 32];\n    for i in 0..32 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8_4(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 4] {\n    let mut result = [0; 4];\n    for i in 0..4 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> u8 {\n    bytes[start]\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/utils.nr",
      "source": "use dep::aztec::{prelude::AztecAddress, protocol_types::traits::FromField};\n\npub(crate) fn u8_32_to_u128(input: [u8; 32]) -> u128 {\n    let mut result = 0;\n    for i in 0..16 {\n        result = result + (input[31 - i] as u128) * (1 << (i * 8));\n    }\n    result\n}\n\npub(crate) fn u8_4_to_u32(bytes: [u8; 4]) -> u32 {\n    let field = Field::from_be_bytes(bytes);\n    field.assert_max_bit_size::<32>();\n    field as u32\n}\n\npub(crate) fn u8_32_to_aztec_address(bytes: [u8; 32]) -> AztecAddress {\n    AztecAddress::from_field(Field::from_be_bytes(bytes))\n}\n"
    },
    "63": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "64": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.set_public_teardown_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "71": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "72": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "73": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "74": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "76": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod private_logs;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size, encryption\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\n///\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\n/// along with its `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_notes<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing note discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "77": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "78": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\n    },\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = &mut 0;\n    whyle(\n        || *i < pending_partial_notes.len(),\n        || {\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\n\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n            if maybe_log.is_none() {\n                debug_log_format(\n                    \"Found no completion logs for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                *i += 1 as u32;\n                // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\n                // is somehow removed from the PXE DB.\n            } else {\n                debug_log_format(\n                    \"Completion log found for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                let log = maybe_log.unwrap();\n\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\n                // that we're getting the logs from the expected contract.\n                // TODO(#10273): improve how contract log siloing is handled\n                assert_eq(\n                    log.log_content.get(0),\n                    contract_address.to_field(),\n                    \"Got a public log emitted by a different contract\",\n                );\n\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n                // complete packed content.\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n                let complete_packed_note_content = array::append(\n                    pending_partial_note.packed_private_note_content,\n                    packed_public_note_content,\n                );\n\n                let discovered_notes = attempt_note_nonce_discovery(\n                    log.unique_note_hashes_in_tx,\n                    log.first_nullifier_in_tx,\n                    compute_note_hash_and_nullifier,\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.note_type_id,\n                    complete_packed_note_content,\n                );\n\n                debug_log_format(\n                    \"Discovered {0} notes for partial note with tag {1}\",\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n                );\n\n                array::for_each_in_bounded_vec(\n                    discovered_notes,\n                    |discovered_note: DiscoveredNoteInfo, _| {\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                        // temporary node connectivity issue - is simply throwing good enough here?\n                        assert(\n                            deliver_note(\n                                contract_address,\n                                pending_partial_note.storage_slot,\n                                discovered_note.nonce,\n                                complete_packed_note_content,\n                                discovered_note.note_hash,\n                                discovered_note.inner_nullifier,\n                                log.tx_hash,\n                                pending_partial_note.recipient,\n                            ),\n                            \"Failed to deliver note\",\n                        );\n                    },\n                );\n\n                // Because there is only a single log for a given tag, once we've processed the tagged log then we\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n                // being completed.\n                pending_partial_notes.remove(*i);\n\n                // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n                // shifts the elements to the left if the removed element is not the last element.\n            }\n        },\n    );\n}\n\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\n/// supports looping in unconstrained code.\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\n    if condition() {\n        body();\n        whyle(condition, body);\n    }\n}\n"
    },
    "79": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    capsules::CapsuleArray,\n    oracle::note_discovery::{deliver_note, sync_notes},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier,\n    MAX_NOTE_PACKED_LEN,\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\n    partial_notes::{\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\n    },\n};\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\n// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\n/// the note completion log tag).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\n/// which the notes would've been created (typically the same transaction in which the log was emitted), along with the\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let log_plaintext = decrypt_log(log, recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\n    // improved upon in the future to also handle events, etc.\n\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\n        destructure_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        attempt_note_discovery(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            storage_slot,\n            note_type_id,\n            log_payload,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            log_payload,\n            recipient,\n        );\n    } else {\n        // TODO(#11569): handle events\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id],\n        );\n    }\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\n        \"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\n    // distinguish private note logs and partial note logs.\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we'd be able to\n    // leverage enums and tagged unions to achieve this goal.\n    let combined_type_id = log_plaintext.get(1);\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\n\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, log_type_id, log_payload)\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note_content,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nunconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    recipient: AztecAddress,\n) {\n    // We store the information of the partial note we found so that we can later search for the public log that will\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\n    static_assert(\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\n        \"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\",\n    );\n\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag: log_payload.get(0),\n        storage_slot,\n        note_type_id,\n        packed_private_note_content: array::subbvec(log_payload, 1),\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n"
    },
    "80": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "86": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note/encryption.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle,\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse protocol_types::{address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, traits::ToField};\nuse std::aes128::aes128_encrypt;\n\n// contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48;\n\nglobal TAG_AND_EPH_PK_X_SIZE_IN_FIELDS: u32 = 2;\nglobal EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 = (\n    PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS\n)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES / 32;\n\n/// Computes an encrypted log using AES-128 encryption in CBC mode.\n///\n/// The resulting log has the following format:\n/// ```text\n/// [\n///   tag: Field,                    // Tag for note discovery, derived from sender/recipient\n///   epk_x: Field,                  // X coordinate of ephemeral public key\n///   log_bytes: [Field],            // Encrypted data converted from bytes to fields, containing:\n///     [\n///       epk_sign: u8,              // Sign bit of ephemeral public key Y coordinate\n///       header_ciphertext: [u8],   // AES encrypted header containing:\n///         [\n///           contract_address: [u8; 32],  // Contract address that emitted the note\n///           ciphertext_length: [u8; 2],  // Length of main ciphertext in bytes\n///           padding: [u8; 14]            // PKCS#7 padding to AES block size\n///         ],\n///       ciphertext: [u8],          // AES encrypted note data containing:\n///         [\n///           plaintext_bytes: [u8],       // The plaintext\n///           padding: [u8]                // PKCS#7 padding to AES block size\n///         ],\n///       padding: [u8]              // Random padding to make log_bytes multiple of 31\n///     ],\n///   padding: [Field]               // Random padding to PRIVATE_LOG_SIZE_IN_FIELDS\n/// ]\n/// ```\n///\n/// The encryption process:\n/// 1. Generate ephemeral key-pair and ECDH shared secret with recipient\n/// 2. Derive AES key and IV from shared secret using SHA-256\n/// 3. Encrypt header and note data separately using AES-128-CBC\n/// 4. Format into final log structure with padding\npub fn encrypt_log<let PT: u32>(\n    contract_address: AztecAddress,\n    plaintext: [Field; PT],\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n    // (This process is then reversed when processing the log in `do_process_log`)\n    let plaintext_bytes = fields_to_bytes(plaintext);\n\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    // (not to be confused with the tagging shared secret)\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + (PT * 32) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 = get_arr_of_size__log_bytes_padding__from_PT::<PT * 32>();\n    // Safety: this randomness won't be constrained to be random. It's in the\n    // interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PT * 32>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n    // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n    // should cover a full field.\n    let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // Safety: We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n        // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n        // TODO(#12749): Long term, this is not a good solution.\n\n        // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n        // contents publicly. It is therefore fine to trust the sender to provide random padding.\n        let field_bytes = unsafe { get_random_bytes::<31>() };\n        final_log[i] = Field::from_be_bytes::<31>(field_bytes);\n    }\n\n    final_log\n}\n\npub unconstrained fn decrypt_log(\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    recipient: AztecAddress,\n) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n    // let tag = log.get(0);\n    let eph_pk_x = log.get(1);\n\n    let log_ciphertext_fields = array::subbvec::<Field, PRIVATE_LOG_SIZE_IN_FIELDS, PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS>(\n        log,\n        TAG_AND_EPH_PK_X_SIZE_IN_FIELDS,\n    );\n\n    // Convert the ciphertext represented as fields to a byte representation (its original format)\n    let log_ciphertext = bytes_from_fields(log_ciphertext_fields);\n\n    // First byte of the ciphertext represents the ephemeral public key sign\n    let eph_pk_sign_bool = log_ciphertext.get(0) as bool;\n    // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n    let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n    // Derive shared secret and symmetric key\n    let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Extract the header ciphertext\n    let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n    let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), header_start);\n    // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n    // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n    // is fixed. But we do it anyway to not have to have duplicate oracles.\n    let header_ciphertext_bvec =\n        BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n    // Decrypt header\n    let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n    // Extract ciphertext length from header (2 bytes, big-endian)\n    let ciphertext_length =\n        ((header_plaintext.get(32) as u32) << 8) | (header_plaintext.get(33) as u32);\n\n    // Extract and decrypt main ciphertext\n    let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n    let ciphertext_with_padding: [u8; (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), ciphertext_start);\n    let ciphertext: BoundedVec<u8, (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n        BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n    // Decrypt main ciphertext and return it\n    let log_plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n    // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n    fields_from_bytes(log_plaintext_bytes)\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{decrypt_log, encrypt_log, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS};\n    use protocol_types::{address::AztecAddress, traits::{FromField, Serialize}};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn test_encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log =\n            BoundedVec::from_array(encrypt_log(contract_address, plaintext, recipient, sender));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret.serialize());\n\n        // Decrypt the log\n        let decrypted = decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n    }\n}\n"
    },
    "93": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
