{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "AztecGateway7683",
  "functions": [
    {
      "name": "settle",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["settle"]
    },
    {
      "name": "open",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "parameters": [
          {
            "name": "order",
            "type": {
              "kind": "struct",
              "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder",
              "fields": [
                {
                  "name": "fill_deadline",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                },
                {
                  "name": "order_data_type",
                  "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                },
                {
                  "name": "order_data",
                  "type": {
                    "kind": "array",
                    "length": 301,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIHYJwAABAMoAgAEBAFOJwIFBAAfGAAFAASAih0AgIqAigQdAICLgIsCHQCAjICMAh0AgI2AjQIdAICOgI4CHQCAj4CPAh0AgJCAkAIdAICRgJECHQCAkoCSAh0AgJOAkwIdAICUgJQCHQCAlYCVAh0AgJaAlgIdAICXgJcCHQCAmICYAh0AgJmAmQIdAICagJoCHQCAm4CbAh0AgJyAnAIdAICdgJ0CHQCAnoCeAh0AgJ+AnwIdAICggKACHQCAoYChAh0AgKKAogIdAICjgKMCHQCApICkAh0AgKWApQIdAICmgKYCHQCAp4CnAh0AgKiAqAIdAICpgKkCHQCAqoCqAh0AgKuAqwIdAICsgKwCHQCArYCtAh0AgK6ArgIdAICvgK8CHQCAsICwAh0AgLGAsQIdAICygLICHQCAs4CzAh0AgLSAtAIdAIC1gLUCHQCAtoC2Ah0AgLeAtwIdAIC4gLgCHQCAuYC5Ah0AgLqAugIdAIC7gLsCHQCAvIC8Ah0AgL2AvQIdAIC+gL4CHQCAv4C/Ah0AgMCAwAIdAIDBgMECHQCAwoDCAh0AgMOAwwIdAIDEgMQCHQCAxYDFAh0AgMaAxgIdAIDHgMcCHQCAyIDIAh0AgMmAyQIdAIDKgMoCHQCAy4DLAh0AgMyAzAIdAIDNgM0CHQCAzoDOAh0AgM+AzwIdAIDQgNACHQCA0YDRAh0AgNKA0gIdAIDTgNMCHQCA1IDUAh0AgNWA1QIdAIDWgNYCHQCA14DXAh0AgNiA2AIdAIDZgNkCHQCA2oDaAh0AgNuA2wIdAIDcgNwCHQCA3YDdAh0AgN6A3gIdAIDfgN8CHQCA4IDgAh0AgOGA4QIdAIDigOICHQCA44DjAh0AgOSA5AIdAIDlgOUCHQCA5oDmAh0AgOeA5wIdAIDogOgCHQCA6YDpAh0AgOqA6gIdAIDrgOsCHQCA7IDsAh0AgO2A7QIdAIDugO4CHQCA74DvAh0AgPCA8AIdAIDxgPECHQCA8oDyAh0AgPOA8wIdAID0gPQCHQCA9YD1Ah0AgPaA9gIdAID3gPcCHQCA+ID4Ah0AgPmA+QIdAID6gPoCHQCA+4D7Ah0AgPyA/AIdAID9gP0CHQCA/oD+Ah0AgP+A/wIdAIEAgQACHQCBAYEBAh0AgQKBAgIdAIEDgQMCHQCBBIEEAh0AgQWBBQIdAIEGgQYCHQCBB4EHAh0AgQiBCAIdAIEJgQkCHQCBCoEKAh0AgQuBCwIdAIEMgQwCHQCBDYENAh0AgQ6BDgIdAIEPgQ8CHQCBEIEQAh0AgRGBEQIdAIESgRICHQCBE4ETAh0AgRSBFAIdAIEVgRUCHQCBFoEWAh0AgReBFwIdAIEYgRgCHQCBGYEZAh0AgRqBGgIdAIEbgRsCHQCBHIEcAh0AgR2BHQIdAIEegR4CHQCBH4EfAh0AgSCBIAIdAIEhgSECHQCBIoEiAh0AgSOBIwIdAIEkgSQCHQCBJYElAh0AgSaBJgIdAIEngScCHQCBKIEoAh0AgSmBKQIdAIEqgSoCHQCBK4ErAh0AgSyBLAIdAIEtgS0CHQCBLoEuAh0AgS+BLwIdAIEwgTACHQCBMYExAh0AgTKBMgIdAIEzgTMCHQCBNIE0Ah0AgTWBNQIdAIE2gTYCHQCBN4E3Ah0AgTiBOAIdAIE5gTkCHQCBOoE6Ah0AgTuBOwIdAIE8gTwCHQCBPYE9Ah0AgT6BPgIdAIE/gT8CHQCBQIFAAh0AgUGBQQIdAIFCgUICHQCBQ4FDAh0AgUSBRAIdAIFFgUUCHQCBRoFGAh0AgUeBRwIdAIFIgUgCHQCBSYFJAh0AgUqBSgIdAIFLgUsCHQCBTIFMAh0AgU2BTQIdAIFOgU4CHQCBT4FPAh0AgVCBUAIdAIFRgVECHQCBUoFSAh0AgVOBUwIdAIFUgVQCHQCBVYFVAh0AgVaBVgIdAIFXgVcCHQCBWIFYAh0AgVmBWQIdAIFagVoCHQCBW4FbAh0AgVyBXAIdAIFdgV0CHQCBXoFeAh0AgV+BXwIdAIFggWACHQCBYYFhAh0AgWKBYgIdAIFjgWMCHQCBZIFkAh0AgWWBZQIdAIFmgWYCHQCBZ4FnAh0AgWiBaAIdAIFpgWkCHQCBaoFqAh0AgWuBawIdAIFsgWwCHQCBbYFtAh0AgW6BbgIdAIFvgW8CHQCBcIFwAh0AgXGBcQIdAIFygXICHQCBc4FzAh0AgXSBdAIdAIF1gXUCHQCBdoF2Ah0AgXeBdwIdAIF4gXgCHQCBeYF5Ah0AgXqBegIdAIF7gXsCHQCBfIF8Ah0AgX2BfQIdAIF+gX4CHQCBf4F/Ah0AgYCBgAIdAIGBgYECHQCBgoGCAh0AgYOBgwIdAIGEgYQCHQCBhYGFAh0AgYaBhgIdAIGHgYcCHQCBiIGIAh0AgYmBiQIdAIGKgYoCHQCBi4GLAh0AgYyBjAIdAIGNgY0CHQCBjoGOAh0AgY+BjwIdAIGQgZACHQCBkYGRAh0AgZKBkgIdAIGTgZMCHQCBlIGUAh0AgZWBlQIdAIGWgZYCHQCBl4GXAh0AgZiBmAIdAIGZgZkCHQCBmoGaAh0AgZuBmwIdAIGcgZwCHQCBnYGdAh0AgZ6BngIdAIGfgZ8CHQCBoIGgAh0AgaGBoQIdAIGigaICHQCBo4GjAh0AgaSBpAIdAIGlgaUCHQCBpoGmAh0AgaeBpwIdAIGogagCHQCBqYGpAh0AgaqBqgIdAIGrgasCHQCBrIGsAh0Aga2BrQIdAIGuga4CHQCBr4GvAh0AgbCBsAIdAIGxgbECHQCBsoGyAh0AgbOBswIdAIG0gbQCHQCBtYG1Ah0AgbaBtgIdAIG3gbcCHQCBuIG4Ah0AgbmBuQIdAIG6gboCHQCBu4G7Ah0AgbyBvAIdAIG9gb0CHQCBvoG+Ah0Agb+BvwIdAIHAgcACHQCBwYHBAh0AgcKBwgIdAIHDgcMCHQCBxIHEAh0AgcWBxQIdAIHGgcYCHQCBx4HHAh0AgciByAIdAIHJgckCHQCByoHKAh0AgcuBywIdAIHMgcwCHQCBzYHNAh0Agc6BzgIdAIHPgc8CHQCB0IHQAh0AgdGB0QIdAIHSgdICHQCB04HTAh0AgdSB1AIdAIHVgdUCHQCB1oHWAh0AgdeB1wIuCICKAAEoAgACBICLJwIFBCAtCAEEJwIGBCEAEAEGAScDBAQBACgEAgYuBAACgAMuBAAGgAQuBAAFgAUlAAAJ6y0MBAIoAgADBICrKAIABQQBLS0IAQQoAgAGBAEuABABBgEnAwQEAQAoBAIGLgQAA4ADLgQABoAELgQABYAFJQAACestDAQDJQAACjElAAAOxygCAAEEgdgnAgIEADsNAAEAAgEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAAAKMC4BgAiABi4CgAaACQEAgAgAAoAIAQCACQACgAkjAAAJ/yYoAIBDAgDwKACARAIADCgAgEUCADsoAIBGAgD2KACARwIAcygAgEgCAOsoAIBJAgCXKACASgIACSgAgEsCAH8oAIBMAgAcKACATQIAmCgAgE4CADUoAIBPAgBTKACAUAIAfSgAgFECAKAoAIBSAgAUKACAUwIA4CgAgFQCALcoAIBVAgBVKACAVgIA/igAgFcCAJQoAIBYAgCyKACAWQIAXSgAgFoCAHooAIBbAgDIKACAXAIAQCgAgF0CAB0oAIBeAgBnKACAXwIAFi4AAAGAYCgAgGEEACEBAAABgGEAASgBgGAEAAEBAIBgAAKAYS4AgGGAYi4CgEOAYgEAgGIAAoBiLgKARIBiAQCAYgACgGIuAoBFgGIBAIBiAAKAYi4CgEaAYgEAgGIAAoBiLgKARIBiAQCAYgACgGIuAoBHgGIBAIBiAAKAYi4CgEiAYgEAgGIAAoBiLgKASYBiAQCAYgACgGIuAoBKgGIBAIBiAAKAYi4CgEuAYgEAgGIAAoBiLgKATIBiAQCAYgACgGIuAoBNgGIBAIBiAAKAYi4CgE6AYgEAgGIAAoBiLgKAT4BiAQCAYgACgGIuAoBQgGIBAIBiAAKAYi4CgFGAYgEAgGIAAoBiLgKAUoBiAQCAYgACgGIuAoBTgGIBAIBiAAKAYi4CgFSAYgEAgGIAAoBiLgKAVYBiAQCAYgACgGIuAoBWgGIBAIBiAAKAYi4CgFeAYgEAgGIAAoBiLgKAWIBiAQCAYgACgGIuAoBZgGIBAIBiAAKAYi4CgFqAYgEAgGIAAoBiLgKAW4BiAQCAYgACgGIuAoBcgGIBAIBiAAKAYi4CgF2AYgEAgGIAAoBiLgKARoBiAQCAYgACgGIuAoBegGIBAIBiAAKAYi4CgF+AYgEAgGIAAoBiLgKAUYBiKACAYQIAACgAgGICAAIpAIBjBAAPQj8oAIBkBAABKACAZQQALCgAgGYEAS0pAIBnBGoJ5mcpAIBoBLtnroUpAIBpBDxu83IpAIBqBKVP9TopAIBrBFEOUn8pAIBsBJsFaIwpAIBtBB+D2aspAIBuBFvgzRkuAAABgG8oAIBwBAAJAQAAAYBwAAEoAYBvBAABAQCAbwACgHAuAIBwgHEuAoBngHEBAIBxAAKAcS4CgGiAcQEAgHEAAoBxLgKAaYBxAQCAcQACgHEuAoBqgHEBAIBxAAKAcS4CgGuAcQEAgHEAAoBxLgKAbIBxAQCAcQACgHEuAoBtgHEBAIBxAAKAcS4CgG6AcSgAgHAEAEAoAIBxBAAEKACAcgQAOCwAgHMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAoAIB0BAAQKACAdQQADigAgHYEAQAoAIB3BAADKACAeAEAACgAgHkEAAAoAIB6AAAAKACAewEAASgAgHwAAAEoAIB9BAACKACAfgIABCgAgH8CAAgoAICABAAIKACAgQIAECgAgIIEAB4oAICDBAAfKACAhAIAICgAgIUEACAoAICGAAB7KACAhwABACgAgIgEAU0rAICJAAAAAAAAAAACAAAAAAAAAAAmJQAAjN0tCAEFAAABAgEuCoB4AAUtCAEGAAABAgEuCoB6AAYtCAEHAAABAgEnAggAAi0OCAceAgAIAB4CAAkAMzgACAAJAAokAgAKAAAPGyUAAI0GLQgBCAAAAQIBLgqAewAILgiAeQAEIwAADzUNKAAEgIUACSQCAAkAAIybIwAAD0otDQgEJAIABAAAD1slAACNGB4CAAQBHgIACAYnAgoECy0IAAstDAMMLgiAeQANABAACgAlAACNKi0EAAAtDAwJLQ0JCgAoCgIKLQ4KCScCCwQMLQgADC0MAw0uCICFAA4AEAALACUAAI0qLQQAAC0MDQotDQoLACgLAgstDgsKJwIMBA0tCAANLQwDDi4IgHAADwAQAAwAJQAAjSotBAAALQwOCy0NCwwAKAwCDC0ODAsnAgwEYCcCDgQPLQgADy0MAxAtDAwRABAADgAlAACNKi0EAAAtDBANLQ0NDgAoDgIOLQ4ODScCDgSAJwIQBBEtCAARLQwDEi0MDhMAEAAQACUAAI0qLQQAAC0MEg8tDQ8QACgQAhAtDhAPJwIQBKAnAhIEEy0IABMtDAMULQwQFQAQABIAJQAAjSotBAAALQwUES0NERIAKBICEi0OEhEnAhIEwCcCFAQVLQgAFS0MAxYtDBIXABAAFAAlAACNKi0EAAAtDBYTLQ0TFAAoFAIULQ4UEycCFATgJwIWBBctCAAXLQwDGC0MFBkAEAAWACUAAI4hLQQAAC0MGBUnAhcEGC0IABgtDBUZABAAFwAlAACPFC0EAAAtDBkWJwIVBOQnAhgEGS0IABktDAMaLQwVGwAQABgAJQAAjiEtBAAALQwaFycCGQQaLQgAGi0MFxsAEAAZACUAAI8ULQQAAC0MGxgnAhcE6CcCGgQbLQgAGy0MAxwtDBcdABAAGgAlAACNKi0EAAAtDBwZLQ0ZGgAoGgIaLQ4aGSgCABoEAQgnAhwEHS0IAB0tDAMeLQwaHwAQABwAJQAAjiEtBAAALQweGycCHQQeLQgAHi0MGx8AEAAdACUAAI8ULQQAAC0MHxwoAgAbBAENADgDGx4tDR4dJwIfBCAtCAAgLQwDIS0MGyIAEAAfACUAAI0qLQQAAC0MIR4tDR4bACgbAhstDhseLQ0JGwAoGwIbLQ4bCS0NChsAKBsCGy0OGwotDQsbACgbAhstDhsLLQ0NGwAoGwIbLQ4bDS0NDxsAKBsCGy0OGw8tDREbACgbAhstDhsRLQ0TGwAoGwIbLQ4bEy0NGRsAKBsCGy0OGxktDR4bACgbAhstDhseLQ0JGwAoGwIbLQ4bCS0NChsAKBsCGy0OGwotDQsbACgbAhstDhsLLQ0NGwAoGwIbLQ4bDS0NDxsAKBsCGy0OGw8tDREbACgbAhstDhsRLQ0TGwAoGwIbLQ4bEy0NGRsAKBsCGy0OGxktDR4bACgbAhstDhseCjgcARskAgAbAAATFyUAAI/9JwIcBB8tCAAfLQwJIAAQABwAJQAAkA8tBAAALQwgGwo4GwQcJAIAHAAAE0glAACQzy4JgG8ABAAoBAIELgYABIBvLQgBBAAAAQIBLgqAbwAELgiAeQACIwAAE3MNKAACgHEAGyQCABsAAIwJIwAAE4gnAiAEIS0IACEtDAMiLgiAZgAjLgiAdgAkABAAIAAlAACQ4S0EAAAtDCIcLQwjHy0NHCAAKCACIC0OIBwHKAAfgHEAIA0oACCAdAAhJAIAIQAAE+ElAACTtAAoHAIiADgiICMtDSMhJwIiAoAnAiQEJS0IACUtDCEmLQwfJy0MIigAEAAkACUAAJPGLQQAAC0MJiMuBAAcgAMoAIAEBAARJQAAlUsuCIAFACEAKCECJAA4JCAlLQ4jJQ0oAB+AcgAcJAIAHAAAFJMjAAAUVi0NBBwtCAEEJwIfBAkAEAEfAScDBAQBACghAh8AKBwCIAAoBAIjQD8AIwAgAB8tDAQCLgiAeQAbIwAAFL4tDQQcASgAH4BkAAQOOB8EICQCACAAABSxJQAAldktDBwCLQwEGyMAABS+LQ0CHAAoHAIcLQ4cAicCHwQjLQgAIy0MISQtDBslLgiAZgAmABAAHwAlAACV6y0EAAAtDCQcLQ0cGwAoGwIbLQ4bHCcCHwQjLQgAIy0MHCQtDAIlABAAHwAlAACaKi0EAAAtDCQbLQ0bAgAoAgICLQ4CGycCHAQjLQgAIy0MGyQAEAAcACUAAJAPLQQAAC0MJAInAh8EIy0IACMtDBgkABAAHwAlAACb5C0EAAAtDCQcLQ0LGAAoGAIYLQ4YCy0NDxgAKBgCGC0OGA8nAh8EIy0IACMtDBYkABAAHwAlAACb5C0EAAAtDCQYLQ0LHwAoHwIfLQ4fCy0NDx8AKB8CHy0OHw8tDQsfACgfAh8tDh8LLQ0PHwAoHwIfLQ4fDy0NDR8AKB8CHy0OHw0tDQofACgfAh8tDh8KLQ0RHwAoHwIfLQ4fES0NDR8AKB8CHy0OHw0tDREfACgfAh8tDh8RLQ0KHwAoHwIfLQ4fCi0NDR8AKB8CHy0OHw0tDREfACgfAh8tDh8RLQ0KHwAoHwIfLQ4fCi0NGR8AKB8CHy0OHxktDQMfACgfAh8tDh8DLQ0ZHwAoHwIfLQ4fGS0NAx8AKB8CHy0OHwMtDRkfACgfAh8tDh8ZLQ0DHwAoHwIfLQ4fAy0NCR8AKB8CHy0OHwknAiAEIy0IACMuCIBjACQAEAAgACUAAJvkLQQAAC0MJB8cDAghBBwMISAFHAwgCAQnAiEEIy0IACMtDAgkABAAIQAlAACb5C0EAAAtDCQgJwIhBCMtCAAjLQwBJAAQACEAJQAAm+QtBAAALQwkCC0NGwEAKAECAS0OARstDQkBACgBAgEtDgEJLQ0bAQAoAQIBLQ4BGy0NCQEAKAECAS0OAQktDRsBACgBAgEtDgEbLQ0JAQAoAQIBLQ4BCS0NCgEAKAECAS0OAQotDQsBACgBAgEtDgELLQ0NAQAoAQIBLQ4BDS0NDwEAKAECAS0OAQ8tDREBACgBAgEtDgERLQ0TAQAoAQIBLQ4BEy0NGQEAKAECAS0OARktDR4BACgBAgEtDgEeLQ0bAQAoAQIBLQ4BGy0NCQEAKAECAS0OAQktDRsBACgBAgEtDgEbLQ0JAQAoAQIBLQ4BCS0NCgEAKAECAS0OAQotDQsBACgBAgEtDgELLQ0NAQAoAQIBLQ4BDS0NDwEAKAECAS0OAQ8tDREBACgBAgEtDgERLQ0TAQAoAQIBLQ4BEy0NGQEAKAECAS0OARktDR4BACgBAgEtDgEeLQ0JAQAoAQIBLQ4BCS0NGwEAKAECAS0OARsnAh4EIy0IACMtDBMkABAAHgAlAACQDy0EAAAtDCQBCygAHYBhABMLKAAdgGIAHhI4Ex4hJAIAIQAAGMclAACcfwsoABaAYwATJAIAEwAAGNwlAACckR4CABMBJwIWAAYtCAEeJwIhBAMAEAEhAScDHgQBACgeAiEtDCEjLQ4WIwAoIwIjLQ4TIy0IARMnAiEEBAAQASEBJwMTBAEAKBMCIS0MISMuCoB6ACMAKCMCIy4KgHoAIwAoIwIjLgqAegAjLQ0TIQAoIQIhLQ4hEy0IASEnAiMEBQAQASMBJwMhBAEAKCECIy0MIyQuCoB6ACQAKCQCJC4KgHoAJAAoJAIkLgqAegAkACgkAiQuCoCJACQtDRMjACgjAiMtDiMTLQ0hIwAoIwIjLQ4jIS0IASMAAAECAS0OEyMtCAETAAABAgEtDiETLQgBIQAAAQIBLgqAeQAhLQgBJAAAAQIBLgqAeAAkLgiAeQAEIwAAGfQNKAAEgH0AJSQCACUAAIutIwAAGgktDSQeCygAHoB4ACUkAgAlAAAaJicCJgQAPAkBJicCHgQlLQgAJS0MIyYtDBMnLQwhKC0MJCkAEAAeACUAAJyjLQQAAC0NIx4tDRMlLQ0hJi0OHiMtDiUTLQ4mIS4KgHsAJAEoACWAZAAeLQ0eEwsoABOAegAeCygAHoB4ACEkAgAhAAAalCUAAJ2xJwIlBCYtCAAmLQwFJy0MBigtDAcpLQwTKi4IgIYAKy0MASwAEAAlACUAAJ3DLQQAAC0MJx4tDCghLQwpIy0MKiQvDAAkABMcDBMlARwMJSQAHAwkEwELKAATgHgAJCQCACQAABr/JQAAoRUnAhMABC0IASQnAiUEAwAQASUBJwMkBAEAKCQCJS0MJSYtDhMmACgmAiYtDgImLQgBEycCJQQEABABJQEnAxMEAQAoEwIlLQwlJi4KgHoAJgAoJgImLgqAegAmACgmAiYuCoB6ACYtDRMlACglAiUtDiUTLQgBJScCJgQFABABJgEnAyUEAQAoJQImLQwmJy4KgHoAJwAoJwInLgqAegAnACgnAicuCoB6ACcAKCcCJy4KgIkAJy0NEyYAKCYCJi0OJhMtDSUmACgmAiYtDiYlLQgBJgAAAQIBLQ4TJi0IARMAAAECAS0OJRMtCAElAAABAgEuCoB5ACUtCAEnAAABAgEuCoB4ACcuCIB5AAQjAAAcEg0oAASAfQAeJAIAHgAAi1EjAAAcJy0NJx4LKAAegHgAISQCACEAABxEJwIjBAA8CQEjJwIeBCgtCAAoLQwmKS0MEyotDCUrLQwnLAAQAB4AJQAAnKMtBAAALQ0mHi0NEyEtDSUjLQ4eJi0OIRMtDiMlLgqAewAnASgAIYBkAB4tDR4TCygAE4B6AB4LKAAegHgAISQCACEAAByyJQAAnbEtCAEeKAIAIQQBTgAQASEBJwMeBAEAKB4CISgCACMEAU0AOCMhIy0MISQMOCQjJRYMJSUkAgAlAAAc/S4KgGEAJAAoJAIkIwAAHNwtCAEhAAABAgEtDh4hLgiAeQAEIwAAHRUNKAAEgIUAHiQCAB4AAIsBIwAAHSouCIB5AAQjAAAdNQ0oAASAZgAeJAIAHgAAipcjAAAdSi0NIR4uCYBvACEAKCECIS4GACGAby0IASEAAAECAS4KgG8AIScCIwQFLgiAeQAEIwAAHX4MOAQjJCQCACQAAIoFIwAAHZAoAgAlBAFAJwIoBCktCAApLQweKi4IgIgAKy0MJSwAEAAoACUAAKEnLQQAAC0MKiYtDCsnLQ0mHgAoHgIeLQ4eJgcoACeAcQAeDSgAHoB0ACUkAgAlAAAd7iUAAJO0ACgmAigAOCgeKS0NKSUnAikEKi0IACotDCUrLQwnLC0MIi0AEAApACUAAJPGLQQAAC0MKyguBAAmgAMoAIAEBAARJQAAlUsuCIAFACUAKCUCKQA4KR4qLQ4oKg0oACeAcgAeJAIAHgAAHpsjAAAeXi0NIR4tCAEhJwImBAkAEAEmAScDIQQBACglAiYAKB4CJwAoIQIoQD8AKAAnACYtDCEELgiAeQAkIwAAHsYtDSEeASgAJ4BkACEOOCchJiQCACYAAB65JQAAldktDB4ELQwhJCMAAB7GLQ0EIQAoIQIhLQ4hBCcCJgQnLQgAJy0MJSgtDCQpLgiAiAAqABAAJgAlAACV6y0EAAAtDCghLQ0hJAAoJAIkLQ4kIScCJQQmLQgAJi0MISctDAQoABAAJQAlAACaKi0EAAAtDCckLQgBBCcCIQQhABABIQEnAwQEAQAoBAIhJwIlBCAAOCUhJS0MISYMOCYlJxYMJyckAgAnAAAfcy4KgHoAJgAoJgImIwAAH1ItCAEhAAABAgEtDgQhLgiAeQAeIwAAH4sNKAAegIUABCQCAAQAAImzIwAAH6AtDSEeLgiAeQAEIwAAH68NKAAEgIUAISQCACEAAImEIwAAH8QnAhMABS0IAR4nAiEEAwAQASEBJwMeBAEAKB4CIS0MISQtDhMkACgkAiQtDgIkLQgBAicCEwQEABABEwEnAwIEAQAoAgITLQwTIS4KgHoAIQAoIQIhLgqAegAhACghAiEuCoB6ACEtDQITACgTAhMtDhMCLQgBEycCIQQFABABIQEnAxMEAQAoEwIhLQwhJC4KgHoAJAAoJAIkLgqAegAkACgkAiQuCoB6ACQAKCQCJC4KgIkAJC0NAiEAKCECIS0OIQItDRMhACghAiEtDiETLQgBIQAAAQIBLQ4CIS0IAQIAAAECAS0OEwItCAETAAABAgEuCoB5ABMtCAEkAAABAgEuCoB4ACQuCIB5AAQjAAAg1w0oAASAfQAlJAIAJQAAiSgjAAAg7C0NJB4LKAAegHgAJSQCACUAACEJJwImBAA8CQEmJwIeBCUtCAAlLQwhJi0MAictDBMoLQwkKQAQAB4AJQAAnKMtBAAALQ0hHi0NAiUtDRMmLQ4eIS0OJQItDiYTLgqAewAkASgAJYBkABMtDRMCCygAAoB6ABMLKAATgHgAHiQCAB4AACF3JQAAnbEwCIB8AAIeAgACAS0IARMnAh4EAwAQAR4BJwMTBAEAKBMCHi0MHiEtDhYhACghAiEtDgIhLQgBAicCFgQEABABFgEnAwIEAQAoAgIWLQwWHi4KgHoAHgAoHgIeLgqAegAeACgeAh4uCoB6AB4tDQIWACgWAhYtDhYCLQgBFicCHgQFABABHgEnAxYEAQAoFgIeLQweIS4KgHoAIQAoIQIhLgqAegAhACghAiEuCoB6ACEAKCECIS4KgIkAIS0NAh4AKB4CHi0OHgItDRYeACgeAh4tDh4WLQgBHgAAAQIBLQ4CHi0IAQIAAAECAS0OFgItCAEWAAABAgEuCoB5ABYtCAEhAAABAgEuCoB4ACEuCIB5AAQjAAAikA0oAASAfQAkJAIAJAAAiMwjAAAipS0NIRMLKAATgHgAJCQCACQAACLCJwIlBAA8CQElJwITBCQtCAAkLQweJS0MAiYtDBYnLQwhKAAQABMAJQAAnKMtBAAALQ0eEy0NAiQtDRYlLQ4THi0OJAItDiUWLgqAewAhASgAJIBkABMtDRMCCygAAoB6ABMLKAATgHgAFiQCABYAACMwJQAAnbEnAiQEJS0IACUtDAUmLQwGJy0MBygtDAIpLgiAhgAqLQwBKwAQACQAJQAAncMtBAAALQwmEy0MJxYtDCgeLQwpITAIgHwAIScCBQQAJwIHBAMAOAUHBi0IAQIAEAEGAScDAgQBACgCAgYtDgUGACgGAgYtDgUGJwIGBAMAOAIGBS0IAQUnAgYEAwAQAQYBJwMFBAEAKAUCBi0MBgcuCoBzAAcAKAcCBy4KgHMABy0NCwYAKAYCBi0OBgstDQ8GACgGAgYtDgYPLQ0LBgAoBgIGLQ4GCy0NDwYAKAYCBi0OBg8nAgcEJC0IACQtDAslABAABwAlAACQDy0EAAAtDCUGHgIABwEeAgAhAC0IASQAAAECAScCJQYALQ4lJCcCJQIfJwImBgEnAicCAS4IgGEABCMAACRmDSgABICBABMkAgATAACIICMAACR7LQ0kBC0NAhMAKBMCEy0OEwInAhYEAScCIgQDADgWIh4tCAETABABHgEnAxMEAQAoEwIeLQ4WHgAoHgIeLQ4WHicCHgQDADgTHhYtDBYeLQ4HHicCHgQkLQgAJC4IgHkAJS0MAiYuCIBkACctDBMoABAAHgAlAACj+i0EAAAtDCUHLQwmFi0NFgIAKAICAi0OAhYnAhMEAScCIgQDADgTIh4tCAECABABHgEnAwIEAQAoAgIeLQ4THgAoHgIeLQ4THicCHgQDADgCHhMtDBMeLQ4hHicCIQQkLQgAJC0MByUtDBYmLgiAZAAnLQwCKAAQACEAJQAAo/otBAAALQwlEy0MJh4tDR4CACgCAgItDgIeHAwEAgAAKBMCBC4EAB6AAygAgAQEAAElAACkyS4IgAUABy4IgAYAFi0OAhYtDQcCACgCAgItDgIHACgEAgIuBAAHgAMoAIAEBAABJQAApMkuCIAFABMuCIAGABYtDgEWLQ0TAQAoAQIBLQ4BEykCAAEAjJ5UcgAoAgIELgQAE4ADKACABAQAASUAAKZJLgiABQAHLgiABgAWLQ4BFi0NBwEAKAECAS0OAQctDQUBACgBAgEtDgEFACgFAgEAKAcCFi0NFhMnAh4EAgA4Fh4COfUAAQAGAAIAEyACAAEhAgACLQgBBQAoBQITLQ0TBycCFgQCADgTFgYiNIB5AAIABi0MAgcnAhYEAwA4BxYTABABEwEnAwUEAQAoBQIWLQ4HFgAoFgIWLQ4HFi0MBwQGKAQCBC0NBQIAKAICAi0OAgUkAgABAAAm9SMAACbZACgFAgYtDQYCJwIHBAIAOAYHATwNAQIjAAAm9S0NBQIAKAICAi0OAgULKAAEgHkAAiQCAAIAACcbJwIFBAA8CQEFASgACYBkAAQtDQQCHAwCBAABKAAJgH0ABS0NBQIcDAIFAAEoAAmAdwAGLQ0GAhwMAgYAASgACYBxAActDQcCHAwCBwAAOAkjEy0NEwIcDAITACcCAgQGADgJAh4tDR4WHAwWHgAnAhYEBwA4CRYiLQ0iIRwMISIAASgACYCAACQtDSQhHAwhJAAnAiEECQA4CSEmLQ0mJRwMJSYAJwIlBAoAOAklKC0NKCccDCcoACcCJwQLADgJJyotDSopHAwpKgAnAikEDAA4CSksLQ0sKxwMKywAJwIrBA0AOAkrLi0NLi0cDC0uAAEoAAmAdQAvLQ0vLRwMLS8AJwItBA8AOAktMS0NMTAcDDAxAAEoAAmAdAAyLQ0yMBwMMDIAJwIwBBEAOAkwNC0NNDMcDDM0ACcCMwQSADgJMzYtDTY1HAw1NgAnAjUEEwA4CTU4LQ04NxwMNzgAJwI3BBQAOAk3Oi0NOjkcDDk6ACcCOQQVADgJOTwtDTw7HAw7PAAnAjsEFgA4CTs+LQ0+PRwMPT4AJwI9BBcAOAk9QC0NQD8cDD9AACcCPwQYADgJP0ItDUJBHAxBQgAnAkEEGQA4CUFELQ1EQxwMQ0QAJwJDBBoAOAlDRi0NRkUcDEVGACcCRQQbADgJRUgtDUhHHAxHSAAnAkcEHAA4CUdKLQ1KSRwMSUoAJwJJBB0AOAlJTC0NTEscDEtMAAEoAAmAggBNLQ1NSxwMS00AASgACYCDAE4tDU5LHAxLTgABKAAJgIUATy0NT0scDEsJAAEoAB+AZABPLQ1PSxwMS08AASgAH4B9AFAtDVBLHAxLUAABKAAfgHcAUS0NUUscDEtRAAEoAB+AcQBSLQ1SSxwMSx8AASgAIIBkAFItDVJLHAxLUgABKAAggH0AUy0NU0scDEtTAAEoACCAdwBULQ1USxwMS1QAASgAIIBxAFUtDVVLHAxLIAABKAAIgGQAVS0NVUscDEtVAAEoAAiAfQBWLQ1WSxwMS1YAASgACIB3AFctDVdLHAxLVwABKAAIgHEAWC0NWEscDEsIAAEoABuAZABYLQ1YSxwMS1gAASgAG4B9AFktDVlLHAxLWQABKAAbgHcAWi0NWkscDEtaAAEoABuAcQBbLQ1bSxwMS1sAADgbI1wtDVxLHAxLXAAAOBsCXS0NXUscDEtdAAA4GxZeLQ1eSxwMS14AASgAG4CAAF8tDV9LHAxLXwAAOBshYC0NYEscDEtgAAA4GyVhLQ1hSxwMS2EAADgbJ2ItDWJLHAxLYgAAOBspYy0NY0scDEtjAAA4GytkLQ1kSxwMS2QAASgAG4B1AGUtDWVLHAxLZQAAOBstZi0NZkscDEtmAAEoABuAdABnLQ1nSxwMS2cAADgbMGgtDWhLHAxLaAAAOBszaS0NaUscDEtpAAA4GzVqLQ1qSxwMS2oAADgbN2stDWtLHAxLawAAOBs5bC0NbEscDEtsAAA4GzttLQ1tSxwMS20AADgbPW4tDW5LHAxLbgAAOBs/by0Nb0scDEtvAAA4G0FwLQ1wSxwMS3AAADgbQ3EtDXFLHAxLcQAAOBtFci0NckscDEtyAAA4G0dzLQ1zSxwMS3MAADgbSXQtDXRLHAxLdAABKAAbgIIAdS0NdUscDEt1AAEoABuAgwB2LQ12SxwMS3YAASgAG4CFAHctDXdLHAxLdwABKAALgGQAeS0NeXgcDHh5AAEoAAuAfQB6LQ16eBwMeHoAASgAC4B3AHstDXt4HAx4ewABKAALgHEAfC0NfHgcDHh8AAA4CyN9LQ19eBwMeH0AADgLAn4tDX54HAx4fgAAOAsWfy0Nf3gcDHh/AAEoAAuAgACALQ2AeBwMeIAAADgLIYEtDYF4HAx4gQAAOAslgi0NgngcDHiCAAA4CyeDLQ2DeBwMeIMAADgLKYQtDYR4HAx4hAAAOAsrhS0NhXgcDHiFAAEoAAuAdQCGLQ2GeBwMeIYAADgLLYctDYd4HAx4hwABKAALgHQAiC0NiHgcDHiIAAA4CzCJLQ2JeBwMeIkAADgLM4otDYp4HAx4igAAOAs1iy0Ni3gcDHiLAAA4CzeMLQ2MeBwMeIwAADgLOY0tDY14HAx4jQAAOAs7ji0NjngcDHiOAAA4Cz2PLQ2PeBwMeI8AADgLP5AtDZB4HAx4kAAAOAtBkS0NkXgcDHiRAAA4C0OSLQ2SeBwMeJIAADgLRZMtDZN4HAx4kwAAOAtHlC0NlHgcDHiUAAA4C0mVLQ2VeBwMeJUAASgAC4CCAJYtDZZ4HAx4lgABKAALgIMAly0Nl3gcDHiXAAEoAAuAhQCYLQ2YeBwMeAsAASgAD4BkAJgtDZh4HAx4mAABKAAPgH0AmS0NmXgcDHiZAAEoAA+AdwCaLQ2aeBwMeJoAASgAD4BxAJstDZt4HAx4mwAAOA8jnC0NnHgcDHicAAA4DwKdLQ2deBwMeJ0AADgPFp4tDZ54HAx4ngABKAAPgIAAny0Nn3gcDHifAAA4DyGgLQ2geBwMeKAAADgPJaEtDaF4HAx4oQAAOA8noi0NongcDHiiAAA4DymjLQ2jeBwMeKMAADgPK6QtDaR4HAx4pAABKAAPgHUApS0NpXgcDHilAAA4Dy2mLQ2meBwMeKYAASgAD4B0AKctDad4HAx4pwAAOA8wqC0NqHgcDHioAAA4DzOpLQ2peBwMeKkAADgPNaotDap4HAx4qgAAOA83qy0Nq3gcDHirAAA4DzmsLQ2seBwMeKwAADgPO60tDa14HAx4rQAAOA89ri0NrngcDHiuAAA4Dz+vLQ2veBwMeK8AADgPQbAtDbB4HAx4sAAAOA9DsS0NsXgcDHixAAA4D0WyLQ2yeBwMeLIAADgPR7MtDbN4HAx4swAAOA9JtC0NtHgcDHi0AAEoAA+AggC1LQ21eBwMeLUAASgAD4CDALYtDbZ4HAx4tgABKAAPgIUAty0Nt3gcDHgPAAEoABiAZAC3LQ23eBwMeLcAASgAGIB9ALgtDbh4HAx4uAABKAAYgHcAuS0NuXgcDHi5AAEoABiAcQC6LQ26eBwMeBgAASgADYBkALotDbp4HAx4ugABKAANgH0Auy0Nu3gcDHi7AAEoAA2AdwC8LQ28eBwMeLwAASgADYBxAL0tDb14HAx4vQAAOA0jvi0NvngcDHi+AAA4DQK/LQ2/eBwMeL8AADgNFsAtDcB4HAx4wAABKAANgIAAwS0NwXgcDHjBAAA4DSHCLQ3CeBwMeMIAADgNJcMtDcN4HAx4wwAAOA0nxC0NxHgcDHjEAAA4DSnFLQ3FeBwMeMUAADgNK8YtDcZ4HAx4xgABKAANgHUAxy0Nx3gcDHjHAAA4DS3ILQ3IeBwMeMgAASgADYB0AMktDcl4HAx4yQAAOA0wyi0NyngcDHjKAAA4DTPLLQ3LeBwMeMsAADgNNcwtDcx4HAx4zAAAOA03zS0NzXgcDHjNAAA4DTnOLQ3OeBwMeM4AADgNO88tDc94HAx4zwAAOA090C0N0HgcDHjQAAA4DT/RLQ3ReBwMeNEAADgNQdItDdJ4HAx40gAAOA1D0y0N03gcDHjTAAA4DUXULQ3UeBwMeNQAADgNR9UtDdV4HAx41QAAOA1J1i0N1ngcDHjWAAEoAA2AggDXLQ3XeBwMeNcAASgADYCDANgtDdh4HAx42AABKAANgIUA2S0N2XgcDHgNAAEoABGAZADZLQ3ZeBwMeNkAASgAEYB9ANotDdp4HAx42gABKAARgHcA2y0N23gcDHjbAAEoABGAcQDcLQ3ceBwMeNwAADgRI90tDd14HAx43QAAOBEC3i0N3ngcDHjeAAA4ERbfLQ3feBwMeN8AASgAEYCAAOAtDeB4HAx44AAAOBEh4S0N4XgcDHjhAAA4ESXiLQ3ieBwMeOIAADgRJ+MtDeN4HAx44wAAOBEp5C0N5HgcDHjkAAA4ESvlLQ3leBwMeOUAASgAEYB1AOYtDeZ4HAx45gAAOBEt5y0N53gcDHjnAAEoABGAdADoLQ3oeBwMeOgAADgRMOktDel4HAx46QAAOBEz6i0N6ngcDHjqAAA4ETXrLQ3reBwMeOsAADgRN+wtDex4HAx47AAAOBE57S0N7XgcDHjtAAA4ETvuLQ3ueBwMeO4AADgRPe8tDe94HAx47wAAOBE/8C0N8HgcDHjwAAA4EUHxLQ3xeBwMePEAADgRQ/ItDfJ4HAx48gAAOBFF8y0N83gcDHjzAAA4EUf0LQ30eBwMePQAADgRSfUtDfV4HAx49QABKAARgIIA9i0N9ngcDHj2AAEoABGAgwD3LQ33eBwMePcAASgAEYCFAPgtDfh4HAx4EQABKAAKgGQA+C0N+HgcDHj4AAEoAAqAfQD5LQ35eBwMePkAASgACoB3APotDfp4HAx4+gABKAAKgHEA+y0N+3gcDHj7AAA4CiP8LQ38eBwMePwAADgKAv0tDf14HAx4/QAAOAoW/i0N/ngcDHj+AAEoAAqAgAD/LQ3/eBwMeP8AATgACgAhAQAuDQEAAHgdDAB4AQAAATgACgAlAQEuDQEBAHgdDAB4AQEAATgACgAnAQIuDQECAHgdDAB4AQIAATgACgApAQMuDQEDAHgdDAB4AQMAATgACgArAQQuDQEEAHgdDAB4AQQAASgACoB1AQUuDQEFAHgdDAB4AQUAATgACgAtAQYuDQEGAHgdDAB4AQYAASgACoB0AQcuDQEHAHgdDAB4AQcAATgACgAwAQguDQEIAHgdDAB4AQgAATgACgAzAQkuDQEJAHgdDAB4AQkAATgACgA1AQouDQEKAHgdDAB4AQoAATgACgA3AQsuDQELAHgdDAB4AQsAATgACgA5AQwuDQEMAHgdDAB4AQwAATgACgA7AQ0uDQENAHgdDAB4AQ0AATgACgA9AQ4uDQEOAHgdDAB4AQ4AATgACgA/AQ8uDQEPAHgdDAB4AQ8AATgACgBBARAuDQEQAHgdDAB4ARAAATgACgBDAREuDQERAHgdDAB4AREAATgACgBFARIuDQESAHgdDAB4ARIAATgACgBHARMuDQETAHgdDAB4ARMAATgACgBJARQuDQEUAHgdDAB4ARQAASgACoCCARUuDQEVAHgdDAB4ARUAASgACoCDARYuDQEWAHgdDAB4ARYAASgACoCFARcuDQEXAHgcDHgKAAEoAByAZAEXLg0BFwB4HQwAeAEXAAEoAByAfQEYLg0BGAB4HQwAeAEYAAEoAByAdwEZLg0BGQB4HQwAeAEZAAEoAByAcQEaLg0BGgB4HAx4HAABKAAZgGQBGi4NARoAeB0MAHgBGgABKAAZgH0BGy4NARsAeB0MAHgBGwABKAAZgHcBHC4NARwAeB0MAHgBHAABKAAZgHEBHS4NAR0AeB0MAHgBHQABOAAZACMBHi4NAR4AeB0MAHgBHgABOAAZAAIBHy4NAR8AeB0MAHgBHwABOAAZABYBIC4NASAAeB0MAHgBIAABKAAZgIABIS4NASEAeB0MAHgBIQABOAAZACEBIi4NASIAeB0MAHgBIgABOAAZACUBIy4NASMAeB0MAHgBIwABOAAZACcBJC4NASQAeB0MAHgBJAABOAAZACkBJS4NASUAeB0MAHgBJQABOAAZACsBJi4NASYAeB0MAHgBJgABKAAZgHUBJy4NAScAeB0MAHgBJwABOAAZAC0BKC4NASgAeB0MAHgBKAABKAAZgHQBKS4NASkAeB0MAHgBKQABOAAZADABKi4NASoAeB0MAHgBKgABOAAZADMBKy4NASsAeB0MAHgBKwABOAAZADUBLC4NASwAeB0MAHgBLAABOAAZADcBLS4NAS0AeB0MAHgBLQABOAAZADkBLi4NAS4AeB0MAHgBLgABOAAZADsBLy4NAS8AeB0MAHgBLwABOAAZAD0BMC4NATAAeB0MAHgBMAABOAAZAD8BMS4NATEAeB0MAHgBMQABOAAZAEEBMi4NATIAeB0MAHgBMgABOAAZAEMBMy4NATMAeB0MAHgBMwABOAAZAEUBNC4NATQAeB0MAHgBNAABOAAZAEcBNS4NATUAeB0MAHgBNQABOAAZAEkBNi4NATYAeB0MAHgBNgABKAAZgIIBNy4NATcAeB0MAHgBNwABKAAZgIMBOC4NATgAeB0MAHgBOAABKAAZgIUBOS4NATkAeBwMeBkAASgAA4BkATkuDQE5AHgdDAB4ATkAASgAA4B9ATouDQE6AHgdDAB4AToAASgAA4B3ATsuDQE7AHgdDAB4ATsAASgAA4BxATwuDQE8AHgdDAB4ATwAATgAAwAjAT0uDQE9AHgcDHgjAAE4AAMAAgE9Lg0BPQB4HAx4AgABOAADABYBPS4NAT0AeBwMeBYAASgAA4CAAT0uDQE9AHgdDAB4AT0AATgAAwAhAT4uDQE+AHgcDHghAAE4AAMAJQE+Lg0BPgB4HQwAeAE+AAE4AAMAJwE/Lg0BPwB4HQwAeAE/AAE4AAMAKQFALg0BQAB4HQwAeAFAAAE4AAMAKwFBLg0BQQB4HQwAeAFBAAEoAAOAdQFCLg0BQgB4HQwAeAFCAAE4AAMALQFDLg0BQwB4HAx4LQABKAADgHQBQy4NAUMAeB0MAHgBQwABOAADADABRC4NAUQAeBwMeDAAATgAAwAzAUQuDQFEAHgcDHgzAAE4AAMANQFELg0BRAB4HAx4NQABOAADADcBRC4NAUQAeBwMeDcAATgAAwA5AUQuDQFEAHgcDHg5AAE4AAMAOwFELg0BRAB4HAx4OwABOAADAD0BRC4NAUQAeBwMeD0AATgAAwA/AUQuDQFEAHgcDHg/AAE4AAMAQQFELg0BRAB4HAx4QQABOAADAEMBRC4NAUQAeBwMeEMAATgAAwBFAUQuDQFEAHgcDHhFAAE4AAMARwFELg0BRAB4HAx4RwABOAADAEkBRC4NAUQAeBwMeEkAASgAA4CCAUQuDQFEAHgdDAB4AUQAASgAA4CDAUUuDQFFAHgdDAB4AUUAASgAA4CFAUYuDQFGAHgdDAB4AUYAJwJ4BCEBOAADAHgBSC4NAUgBRx0MAUcAeAAoAgFHBAAiATgAAwFHAUkuDQFJAUgdDAFIAUcAKAIBSAQAIwE4AAMBSAFKLg0BSgFJHQwBSQFIACgCAUkEACQBOAADAUkBSy4NAUsBSh0MAUoBSQAoAgFKBAAlATgAAwFKAUwuDQFMAUsdDAFLAUoAKAIBSwQAJgE4AAMBSwFNLg0BTQFMHQwBTAFLACgCAUwEACcBOAADAUwBTi4NAU4BTR0MAU0BTAAoAgFNBAAoATgAAwFNAU8uDQFPAU4dDAFOAU0AKAIBTgQAKQE4AAMBTgFQLg0BUAFPHQwBTwFOACgCAU8EACoBOAADAU8BUS4NAVEBUB0MAVABTwAoAgFQBAArATgAAwFQAVIuDQFSAVEdDAFRAVAAASgAA4BlAVIuDQFSAVEdDAFRAVIAKAIBUQQALQE4AAMBUQFULg0BVAFTHQwBUwFRACgCAVMEAC4BOAADAVMBVS4NAVUBVB0MAVQBUwAoAgFUBAAvATgAAwFUAVYuDQFWAVUdDAFVAVQAKAIBVQQAMAE4AAMBVQFXLg0BVwFWHQwBVgFVACgCAVYEADEBOAADAVYBWC4NAVgBVx0MAVcBVgAoAgFXBAAyATgAAwFXAVkuDQFZAVgdDAFYAVcAKAIBWAQAMwE4AAMBWAFaLg0BWgFZHQwBWQFYACgCAVkEADQBOAADAVkBWy4NAVsBWh0MAVoBWQAoAgFaBAA1ATgAAwFaAVwuDQFcAVsdDAFbAVoAKAIBWwQANgE4AAMBWwFdLg0BXQFcHQwBXAFbACgCAVwEADcBOAADAVwBXi4NAV4BXR0MAV0BXAABKAADgHIBXi4NAV4BXR0MAV0BXgAoAgFdBAA5ATgAAwFdAWAuDQFgAV8dDAFfAV0AKAIBXwQAOgE4AAMBXwFhLg0BYQFgHQwBYAFfACgCAWAEADsBOAADAWABYi4NAWIBYR0MAWEBYAAoAgFhBAA8ATgAAwFhAWMuDQFjAWIdDAFiAWEAKAIBYgQAPQE4AAMBYgFkLg0BZAFjHQwBYwFiACgCAWMEAD4BOAADAWMBZS4NAWUBZB0MAWQBYwAoAgFkBAA/ATgAAwFkAWYuDQFmAWUdDAFlAWQAASgAA4BwAWYuDQFmAWUdDAFlAWYAKAIBZQQAQQE4AAMBZQFoLg0BaAFnHQwBZwFlACgCAWcEAEIBOAADAWcBaS4NAWkBaB0MAWgBZwAoAgFoBABDATgAAwFoAWouDQFqAWkdDAFpAWgAKAIBaQQARAE4AAMBaQFrLg0BawFqHQwBagFpACgCAWoEAEUBOAADAWoBbC4NAWwBax0MAWsBagAoAgFrBABGATgAAwFrAW0uDQFtAWwdDAFsAWsAKAIBbAQARwE4AAMBbAFuLg0BbgFtHQwBbQFsACgCAW0EAEgBOAADAW0Bby4NAW8Bbh0MAW4BbQAoAgFuBABJATgAAwFuAXAuDQFwAW8dDAFvAW4AKAIBbwQASgE4AAMBbwFxLg0BcQFwHQwBcAFvACgCAXAEAEsBOAADAXABci4NAXIBcR0MAXEBcAAoAgFxBABMATgAAwFxAXMuDQFzAXIdDAFyAXEAKAIBcgQATQE4AAMBcgF0Lg0BdAFzHQwBcwFyACgCAXMEAE4BOAADAXMBdS4NAXUBdB0MAXQBcwAoAgF0BABPATgAAwF0AXYuDQF2AXUdDAF1AXQAKAIBdQQAUAE4AAMBdQF3Lg0BdwF2HQwBdgF1ACgCAXYEAFEBOAADAXYBeC4NAXgBdx0MAXcBdgAoAgF3BABSATgAAwF3AXkuDQF5AXgdDAF4AXcAKAIBeAQAUwE4AAMBeAF6Lg0BegF5HQwBeQF4ACgCAXkEAFQBOAADAXkBey4NAXsBeh0MAXoBeQAoAgF6BABVATgAAwF6AXwuDQF8AXsdDAF7AXoAKAIBewQAVgE4AAMBewF9Lg0BfQF8HQwBfAF7ACgCAXwEAFcBOAADAXwBfi4NAX4BfR0MAX0BfAAoAgF9BABYATgAAwF9AX8uDQF/AX4dDAF+AX0AKAIBfgQAWQE4AAMBfgGALg0BgAF/HQwBfwF+ACgCAX8EAFoBOAADAX8BgS4NAYEBgB0MAYABfwAoAgGABABbATgAAwGAAYIuDQGCAYEdDAGBAYAAKAIBgQQAXAE4AAMBgQGDLg0BgwGCHQwBggGBACgCAYIEAF0BOAADAYIBhC4NAYQBgx0MAYMBggAoAgGDBABeATgAAwGDAYUuDQGFAYQdDAGEAYMAKAIBhAQAXwE4AAMBhAGGLg0BhgGFHQwBhQGEAAE4AAMADAGGLg0BhgGFHQwBhQAMACgCAYUEAGEBOAADAYUBhy4NAYcBhh0MAYYBhQAoAgGGBABiATgAAwGGAYguDQGIAYcdDAGHAYYAKAIBhwQAYwE4AAMBhwGJLg0BiQGIHQwBiAGHACgCAYgEAGQBOAADAYgBii4NAYoBiR0MAYkBiAAoAgGJBABlATgAAwGJAYsuDQGLAYodDAGKAYkAKAIBigQAZgE4AAMBigGMLg0BjAGLHQwBiwGKACgCAYsEAGcBOAADAYsBjS4NAY0BjB0MAYwBiwAoAgGMBABoATgAAwGMAY4uDQGOAY0dDAGNAYwAKAIBjQQAaQE4AAMBjQGPLg0BjwGOHQwBjgGNACgCAY4EAGoBOAADAY4BkC4NAZABjx0MAY8BjgAoAgGPBABrATgAAwGPAZEuDQGRAZAdDAGQAY8AKAIBkAQAbAE4AAMBkAGSLg0BkgGRHQwBkQGQACgCAZEEAG0BOAADAZEBky4NAZMBkh0MAZIBkQAoAgGSBABuATgAAwGSAZQuDQGUAZMdDAGTAZIAKAIBkwQAbwE4AAMBkwGVLg0BlQGUHQwBlAGTACgCAZQEAHABOAADAZQBli4NAZYBlR0MAZUBlAAoAgGVBABxATgAAwGVAZcuDQGXAZYdDAGWAZUAKAIBlgQAcgE4AAMBlgGYLg0BmAGXHQwBlwGWACgCAZcEAHMBOAADAZcBmS4NAZkBmB0MAZgBlwAoAgGYBAB0ATgAAwGYAZouDQGaAZkdDAGZAZgAKAIBmQQAdQE4AAMBmQGbLg0BmwGaHQwBmgGZACgCAZoEAHYBOAADAZoBnC4NAZwBmx0MAZsBmgAoAgGbBAB3ATgAAwGbAZ0uDQGdAZwdDAGcAZsAKAIBnAQAeAE4AAMBnAGeLg0BngGdHQwBnQGcACgCAZ0EAHkBOAADAZ0Bny4NAZ8Bnh0MAZ4BnQAoAgGeBAB6ATgAAwGeAaAuDQGgAZ8dDAGfAZ4AKAIBnwQAewE4AAMBnwGhLg0BoQGgHQwBoAGfACgCAaAEAHwBOAADAaABoi4NAaIBoR0MAaEBoAAoAgGhBAB9ATgAAwGhAaMuDQGjAaIdDAGiAaEAKAIBogQAfgE4AAMBogGkLg0BpAGjHQwBowGiACgCAaMEAH8BOAADAaMBpS4NAaUBpB0MAaQBowABOAADAA4BpS4NAaUBpB0MAaQADgAoAgGkBACBATgAAwGkAaYuDQGmAaUdDAGlAaQAKAIBpQQAggE4AAMBpQGnLg0BpwGmHQwBpgGlACgCAaYEAIMBOAADAaYBqC4NAagBpx0MAacBpgAoAgGnBACEATgAAwGnAakuDQGpAagdDAGoAacAKAIBqAQAhQE4AAMBqAGqLg0BqgGpHQwBqQGoACgCAakEAIYBOAADAakBqy4NAasBqh0MAaoBqQAoAgGqBACHATgAAwGqAawuDQGsAasdDAGrAaoAKAIBqwQAiAE4AAMBqwGtLg0BrQGsHQwBrAGrACgCAawEAIkBOAADAawBri4NAa4BrR0MAa0BrAAoAgGtBACKATgAAwGtAa8uDQGvAa4dDAGuAa0AKAIBrgQAiwE4AAMBrgGwLg0BsAGvHQwBrwGuACgCAa8EAIwBOAADAa8BsS4NAbEBsB0MAbABrwAoAgGwBACNATgAAwGwAbIuDQGyAbEdDAGxAbAAKAIBsQQAjgE4AAMBsQGzLg0BswGyHQwBsgGxACgCAbIEAI8BOAADAbIBtC4NAbQBsx0MAbMBsgAoAgGzBACQATgAAwGzAbUuDQG1AbQdDAG0AbMAKAIBtAQAkQE4AAMBtAG2Lg0BtgG1HQwBtQG0ACgCAbUEAJIBOAADAbUBty4NAbcBth0MAbYBtQAoAgG2BACTATgAAwG2AbguDQG4AbcdDAG3AbYAKAIBtwQAlAE4AAMBtwG5Lg0BuQG4HQwBuAG3ACgCAbgEAJUBOAADAbgBui4NAboBuR0MAbkBuAAoAgG5BACWATgAAwG5AbsuDQG7AbodDAG6AbkAKAIBugQAlwE4AAMBugG8Lg0BvAG7HQwBuwG6ACgCAbsEAJgBOAADAbsBvS4NAb0BvB0MAbwBuwAoAgG8BACZATgAAwG8Ab4uDQG+Ab0dDAG9AbwAKAIBvQQAmgE4AAMBvQG/Lg0BvwG+HQwBvgG9ACgCAb4EAJsBOAADAb4BwC4NAcABvx0MAb8BvgAoAgG/BACcATgAAwG/AcEuDQHBAcAdDAHAAb8AKAIBwAQAnQE4AAMBwAHCLg0BwgHBHQwBwQHAACgCAcEEAJ4BOAADAcEBwy4NAcMBwh0MAcIBwQAoAgHCBACfATgAAwHCAcQuDQHEAcMdDAHDAcIAATgAAwAQAcQuDQHEAcMdDAHDABAAKAIBwwQAoQE4AAMBwwHFLg0BxQHEHQwBxAHDACgCAcQEAKIBOAADAcQBxi4NAcYBxR0MAcUBxAAoAgHFBACjATgAAwHFAccuDQHHAcYdDAHGAcUAKAIBxgQApAE4AAMBxgHILg0ByAHHHQwBxwHGACgCAccEAKUBOAADAccByS4NAckByB0MAcgBxwAoAgHIBACmATgAAwHIAcouDQHKAckdDAHJAcgAKAIByQQApwE4AAMByQHLLg0BywHKHQwBygHJACgCAcoEAKgBOAADAcoBzC4NAcwByx0MAcsBygAoAgHLBACpATgAAwHLAc0uDQHNAcwdDAHMAcsAKAIBzAQAqgE4AAMBzAHOLg0BzgHNHQwBzQHMACgCAc0EAKsBOAADAc0Bzy4NAc8Bzh0MAc4BzQAoAgHOBACsATgAAwHOAdAuDQHQAc8dDAHPAc4AKAIBzwQArQE4AAMBzwHRLg0B0QHQHQwB0AHPACgCAdAEAK4BOAADAdAB0i4NAdIB0R0MAdEB0AAoAgHRBACvATgAAwHRAdMuDQHTAdIdDAHSAdEAKAIB0gQAsAE4AAMB0gHULg0B1AHTHQwB0wHSACgCAdMEALEBOAADAdMB1S4NAdUB1B0MAdQB0wAoAgHUBACyATgAAwHUAdYuDQHWAdUdDAHVAdQAKAIB1QQAswE4AAMB1QHXLg0B1wHWHQwB1gHVACgCAdYEALQBOAADAdYB2C4NAdgB1x0MAdcB1gAoAgHXBAC1ATgAAwHXAdkuDQHZAdgdDAHYAdcAKAIB2AQAtgE4AAMB2AHaLg0B2gHZHQwB2QHYACgCAdkEALcBOAADAdkB2y4NAdsB2h0MAdoB2QAoAgHaBAC4ATgAAwHaAdwuDQHcAdsdDAHbAdoAKAIB2wQAuQE4AAMB2wHdLg0B3QHcHQwB3AHbACgCAdwEALoBOAADAdwB3i4NAd4B3R0MAd0B3AAoAgHdBAC7ATgAAwHdAd8uDQHfAd4dDAHeAd0AKAIB3gQAvAE4AAMB3gHgLg0B4AHfHQwB3wHeACgCAd8EAL0BOAADAd8B4S4NAeEB4B0MAeAB3wAoAgHgBAC+ATgAAwHgAeIuDQHiAeEdDAHhAeAAKAIB4QQAvwE4AAMB4QHjLg0B4wHiHQwB4gHhAAE4AAMAEgHjLg0B4wHiHQwB4gASACgCAeIEAMEBOAADAeIB5C4NAeQB4x0MAeMB4gAoAgHjBADCATgAAwHjAeUuDQHlAeQdDAHkAeMAKAIB5AQAwwE4AAMB5AHmLg0B5gHlHQwB5QHkACgCAeUEAMQBOAADAeUB5y4NAecB5h0MAeYB5QAoAgHmBADFATgAAwHmAeguDQHoAecdDAHnAeYAKAIB5wQAxgE4AAMB5wHpLg0B6QHoHQwB6AHnACgCAegEAMcBOAADAegB6i4NAeoB6R0MAekB6AAoAgHpBADIATgAAwHpAesuDQHrAeodDAHqAekAKAIB6gQAyQE4AAMB6gHsLg0B7AHrHQwB6wHqACgCAesEAMoBOAADAesB7S4NAe0B7B0MAewB6wAoAgHsBADLATgAAwHsAe4uDQHuAe0dDAHtAewAKAIB7QQAzAE4AAMB7QHvLg0B7wHuHQwB7gHtACgCAe4EAM0BOAADAe4B8C4NAfAB7x0MAe8B7gAoAgHvBADOATgAAwHvAfEuDQHxAfAdDAHwAe8AKAIB8AQAzwE4AAMB8AHyLg0B8gHxHQwB8QHwACgCAfEEANABOAADAfEB8y4NAfMB8h0MAfIB8QAoAgHyBADRATgAAwHyAfQuDQH0AfMdDAHzAfIAKAIB8wQA0gE4AAMB8wH1Lg0B9QH0HQwB9AHzACgCAfQEANMBOAADAfQB9i4NAfYB9R0MAfUB9AAoAgH1BADUATgAAwH1AfcuDQH3AfYdDAH2AfUAKAIB9gQA1QE4AAMB9gH4Lg0B+AH3HQwB9wH2ACgCAfcEANYBOAADAfcB+S4NAfkB+B0MAfgB9wAoAgH4BADXATgAAwH4AfouDQH6AfkdDAH5AfgAKAIB+QQA2AE4AAMB+QH7Lg0B+wH6HQwB+gH5ACgCAfoEANkBOAADAfoB/C4NAfwB+x0MAfsB+gAoAgH7BADaATgAAwH7Af0uDQH9AfwdDAH8AfsAKAIB/AQA2wE4AAMB/AH+Lg0B/gH9HQwB/QH8ACgCAf0EANwBOAADAf0B/y4NAf8B/h0MAf4B/QAoAgH+BADdATgAAwH+AgAuDQIAAf8dDAH/Af4AKAIB/wQA3gE4AAMB/wIBLg0CAQIAHQwCAAH/ACgCAgAEAN8BOAADAgACAi4NAgICAR0MAgECAAABOAADABQCAi4NAgICAR0MAgEAFAAoAgIBBADhATgAAwIBAgMuDQIDAgIdDAICAgEAKAICAgQA4gE4AAMCAgIELg0CBAIDHQwCAwICACgCAgMEAOMBOAADAgMCBS4NAgUCBB0MAgQCAwABOAADABUCBS4NAgUCBB0MAgQAFQAoAgIE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QwAoAgJEBAEnATgAAwJEAkYuDQJGAkUdDAJFAkQAKAICRQQBKAE4AAMCRQJHLg0CRwJGHQwCRgJFACgCAkYEASkBOAADAkYCSC4NAkgCRx0MAkcCRgAoAgJHBAEqATgAAwJHAkkuDQJJAkgdDAJIAkcAKAICSAQBKwE4AAMCSAJKLg0CSgJJHQwCSQJIACgCAkkEASwBOAADAkkCSy4NAksCSh0MAkoCSQABKAADgGYCSy4NAksCSh0MAkoAAwAuCAABAkooAgJLBAJmARAAAQJLAAEoAwJKBAABASgCSgACAksuDAJLAkwuDgAEAkwBKAJMAAICTC4OAAUCTAEoAkwAAgJMLg4ABgJMASgCTAACAkwuDgAHAkwBKAJMAAICTC4OABMCTAEoAkwAAgJMLg4AHgJMASgCTAACAkwuDgAiAkwBKAJMAAICTC4OACQCTAEoAkwAAgJMLg4AJgJMASgCTAACAkwuDgAoAkwBKAJMAAICTC4OACoCTAEoAkwAAgJMLg4ALAJMASgCTAACAkwuDgAuAkwBKAJMAAICTC4OAC8CTAEoAkwAAgJMLg4AMQJMASgCTAACAkwuDgAyAkwBKAJMAAICTC4OADQCTAEoAkwAAgJMLg4ANgJMASgCTAACAkwuDgA4AkwBKAJMAAICTC4OADoCTAEoAkwAAgJMLg4APAJMASgCTAACAkwuDgA+AkwBKAJMAAICTC4OAEACTAEoAkwAAgJMLg4AQgJMASgCTAACAkwuDgBEAkwBKAJMAAICTC4OAEYCTAEoAkwAAgJMLg4ASAJMASgCTAACAkwuDgBKAkwBKAJMAAICTC4OAEwCTAEoAkwAAgJMLg4ATQJMASgCTAACAkwuDgBOAkwBKAJMAAICTC4OAAkCTAEoAkwAAgJMLg4ATwJMASgCTAACAkwuDgBQAkwBKAJMAAICTC4OAFECTAEoAkwAAgJMLg4AHwJMASgCTAACAkwuDgBSAkwBKAJMAAICTC4OAFMCTAEoAkwAAgJMLg4AVAJMASgCTAACAkwuDgAgAkwBKAJMAAICTC4OAFUCTAEoAkwAAgJMLg4AVgJMASgCTAACAkwuDgBXAkwBKAJMAAICTC4OAAgCTAEoAkwAAgJMLg4AWAJMASgCTAACAkwuDgBZAkwBKAJMAAICTC4OAFoCTAEoAkwAAgJMLg4AWwJMASgCTAACAkwuDgBcAkwBKAJMAAICTC4OAF0CTAEoAkwAAgJMLg4AXgJMASgCTAACAkwuDgBfAkwBKAJMAAICTC4OAGACTAEoAkwAAgJMLg4AYQJMASgCTAACAkwuDgBiAkwBKAJMAAICTC4OAGMCTAEoAkwAAgJMLg4AZAJMASgCTAACAkwuDgBlAkwBKAJMAAICTC4OAGYCTAEoAkwAAgJMLg4AZwJMASgCTAACAkwuDgBoAkwBKAJMAAICTC4OAGkCTAEoAkwAAgJMLg4AagJMASgCTAACAkwuDgBrAkwBKAJMAAICTC4OAGwCTAEoAkwAAgJMLg4AbQJMASgCTAACAkwuDgBuAkwBKAJMAAICTC4OAG8CTAEoAkwAAgJMLg4AcAJMASgCTAACAkwuDgBxAkwBKAJMAAICTC4OAHICTAEoAkwAAgJMLg4AcwJMASgCTAACAkwuDgB0AkwBKAJMAAICTC4OAHUCTAEoAkwAAgJMLg4AdgJMASgCTAACAkwuDgB3AkwBKAJMAAICTC4OAHkCTAEoAkwAAgJMLg4AegJMASgCTAACAkwuDgB7AkwBKAJMAAICTC4OAHwCTAEoAkwAAgJMLg4AfQJMASgCTAACAkwuDgB+AkwBKAJMAAICTC4OAH8CTAEoAkwAAgJMLg4AgAJMASgCTAACAkwuDgCBAkwBKAJMAAICTC4OAIICTAEoAkwAAgJMLg4AgwJMASgCTAACAkwuDgCEAkwBKAJMAAICTC4OAIUCTAEoAkwAAgJMLg4AhgJMASgCTAACAkwuDgCHAkwBKAJMAAICTC4OAIgCTAEoAkwAAgJMLg4AiQJMASgCTAACAkwuDgCKAkwBKAJMAAICTC4OAIsCTAEoAkwAAgJMLg4AjAJMASgCTAACAkwuDgCNAkwBKAJMAAICTC4OAI4CTAEoAkwAAgJMLg4AjwJMASgCTAACAkwuDgCQAkwBKAJMAAICTC4OAJECTAEoAkwAAgJMLg4AkgJMASgCTAACAkwuDgCTAkwBKAJMAAICTC4OAJQCTAEoAkwAAgJMLg4AlQJMASgCTAACAkwuDgCWAkwBKAJMAAICTC4OAJcCTAEoAkwAAgJMLg4ACwJMASgCTAACAkwuDgCYAkwBKAJMAAICTC4OAJkCTAEoAkwAAgJMLg4AmgJMASgCTAACAkwuDgCbAkwBKAJMAAICTC4OAJwCTAEoAkwAAgJMLg4AnQJMASgCTAACAkwuDgCeAkwBKAJMAAICTC4OAJ8CTAEoAkwAAgJMLg4AoAJMASgCTAACAkwuDgChAkwBKAJMAAICTC4OAKICTAEoAkwAAgJMLg4AowJMASgCTAACAkwuDgCkAkwBKAJMAAICTC4OAKUCTAEoAkwAAgJMLg4ApgJMASgCTAACAkwuDgCnAkwBKAJMAAICTC4OAKgCTAEoAkwAAgJMLg4AqQJMASgCTAACAkwuDgCqAkwBKAJMAAICTC4OAKsCTAEoAkwAAgJMLg4ArAJMASgCTAACAkwuDgCtAkwBKAJMAAICTC4OAK4CTAEoAkwAAgJMLg4ArwJMASgCTAACAkwuDgCwAkwBKAJMAAICTC4OALECTAEoAkwAAgJMLg4AsgJMASgCTAACAkwuDgCzAkwBKAJMAAICTC4OALQCTAEoAkwAAgJMLg4AtQJMASgCTAACAkwuDgC2AkwBKAJMAAICTC4OAA8CTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4KgHoCTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4KgHoCTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4KgHoCTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4KgHoCTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4KgHoCTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4KgHoCTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4KgHoCTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4KgHoCTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4KgHoCTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4KgHoCTAEoAkwAAgJMLgqAegJMASgCTAACAkwuCoB6AkwBKAJMAAICTC4OALcCTAEoAkwAAgJMLg4AuAJMASgCTAACAkwuDgC5AkwBKAJMAAICTC4OABgCTAEoAkwAAgJMLg4AugJMASgCTAACAkwuDgC7AkwBKAJMAAICTC4OALwCTAEoAkwAAgJMLg4AvQJMASgCTAACAkwuDgC+AkwBKAJMAAICTC4OAL8CTAEoAkwAAgJMLg4AwAJMASgCTAACAkwuDgDBAkwBKAJMAAICTC4OAMICTAEoAkwAAgJMLg4AwwJMASgCTAACAkwuDgDEAkwBKAJMAAICTC4OAMUCTAEoAkwAAgJMLg4AxgJMASgCTAACAkwuDgDHAkwBKAJMAAICTC4OAMgCTAEoAkwAAgJMLg4AyQJMASgCTAACAkwuDgDKAkwBKAJMAAICTC4OAMsCTAEoAkwAAgJMLg4AzAJMASgCTAACAkwuDgDNAkwBKAJMAAICTC4OAM4CTAEoAkwAAgJMLg4AzwJMASgCTAACAkwuDgDQAkwBKAJMAAICTC4OANECTAEoAkwAAgJMLg4A0gJMASgCTAACAkwuDgDTAkwBKAJMAAICTC4OANQCTAEoAkwAAgJMLg4A1QJMASgCTAACAkwuDgDWAkwBKAJMAAICTC4OANcCTAEoAkwAAgJMLg4A2AJMASgCTAACAkwuDgANAkwBKAJMAAICTC4OANkCTAEoAkwAAgJMLg4A2gJMASgCTAACAkwuDgDbAkwBKAJMAAICTC4OANwCTAEoAkwAAgJMLg4A3QJMASgCTAACAkwuDgDeAkwBKAJMAAICTC4OAN8CTAEoAkwAAgJMLg4A4AJMASgCTAACAkwuDgDhAkwBKAJMAAICTC4OAOICTAEoAkwAAgJMLg4A4wJMASgCTAACAkwuDgDkAkwBKAJMAAICTC4OAOUCTAEoAkwAAgJMLg4A5gJMASgCTAACAkwuDgDnAkwBKAJMAAICTC4OAOgCTAEoAkwAAgJMLg4A6QJMASgCTAACAkwuDgDqAkwBKAJMAAICTC4OAOsCTAEoAkwAAgJMLg4A7AJMASgCTAACAkwuDgDtAkwBKAJMAAICTC4OAO4CTAEoAkwAAgJMLg4A7wJMASgCTAACAkwuDgDwAkwBKAJMAAICTC4OAPECTAEoAkwAAgJMLg4A8gJMASgCTAACAkwuDgDzAkwBKAJMAAICTC4OAPQCTAEoAkwAAgJMLg4A9QJMASgCTAACAkwuDgD2AkwBKAJMAAICTC4OAPcCTAEoAkwAAgJMLg4AEQJMASgCTAACAkwuDgD4AkwBKAJMAAICTC4OAPkCTAEoAkwAAgJMLg4A+gJMASgCTAACAkwuDgD7AkwBKAJMAAICTC4OAPwCTAEoAkwAAgJMLg4A/QJMASgCTAACAkwuDgD+AkwBKAJMAAICTC4OAP8CTAEoAkwAAgJMLg4BAAJMASgCTAACAkwuDgEBAkwBKAJMAAICTC4OAQICTAEoAkwAAgJMLg4BAwJMASgCTAACAkwuDgEEAkwBKAJMAAICTC4OAQUCTAEoAkwAAgJMLg4BBgJMASgCTAACAkwuDgEHAkwBKAJMAAICTC4OAQgCTAEoAkwAAgJMLg4BCQJMASgCTAACAkwuDgEKAkwBKAJMAAICTC4OAQsCTAEoAkwAAgJMLg4BDAJMASgCTAACAkwuDgENAkwBKAJMAAICTC4OAQ4CTAEoAkwAAgJMLg4BDwJMASgCTAACAkwuDgEQAkwBKAJMAAICTC4OARECTAEoAkwAAgJMLg4BEgJMASgCTAACAkwuDgETAkwBKAJMAAICTC4OARQCTAEoAkwAAgJMLg4BFQJMASgCTAACAkwuDgEWAkwBKAJMAAICTC4OAAoCTAEoAkwAAgJMLg4BFwJMASgCTAACAkwuDgEYAkwBKAJMAAICTC4OARkCTAEoAkwAAgJMLg4AHAJMASgCTAACAkwuDgEXAkwBKAJMAAICTC4OARgCTAEoAkwAAgJMLg4BGQJMASgCTAACAkwuDgAcAkwBKAJMAAICTC4OARoCTAEoAkwAAgJMLg4BGwJMASgCTAACAkwuDgEcAkwBKAJMAAICTC4OAR0CTAEoAkwAAgJMLg4BHgJMASgCTAACAkwuDgEfAkwBKAJMAAICTC4OASACTAEoAkwAAgJMLg4BIQJMASgCTAACAkwuDgEiAkwBKAJMAAICTC4OASMCTAEoAkwAAgJMLg4BJAJMASgCTAACAkwuDgElAkwBKAJMAAICTC4OASYCTAEoAkwAAgJMLg4BJwJMASgCTAACAkwuDgEoAkwBKAJMAAICTC4OASkCTAEoAkwAAgJMLg4BKgJMASgCTAACAkwuDgErAkwBKAJMAAICTC4OASwCTAEoAkwAAgJMLg4BLQJMASgCTAACAkwuDgEuAkwBKAJMAAICTC4OAS8CTAEoAkwAAgJMLg4BMAJMASgCTAACAkwuDgExAkwBKAJMAAICTC4OATICTAEoAkwAAgJMLg4BMwJMASgCTAACAkwuDgE0AkwBKAJMAAICTC4OATUCTAEoAkwAAgJMLg4BNgJMASgCTAACAkwuDgE3AkwBKAJMAAICTC4OATgCTAEoAkwAAgJMLg4AGQJMASgCTAACAkwuDgE5AkwBKAJMAAICTC4OAToCTAEoAkwAAgJMLg4BOwJMASgCTAACAkwuDgE8AkwBKAJMAAICTC4OACMCTAEoAkwAAgJMLg4AAgJMASgCTAACAkwuDgAWAkwBKAJMAAICTC4OAT0CTAEoAkwAAgJMLg4AIQJMASgCTAACAkwuDgE+AkwBKAJMAAICTC4OAT8CTAEoAkwAAgJMLg4BQAJMASgCTAACAkwuDgFBAkwBKAJMAAICTC4OAUICTAEoAkwAAgJMLg4ALQJMASgCTAACAkwuDgFDAkwBKAJMAAICTC4OADACTAEoAkwAAgJMLg4AMwJMASgCTAACAkwuDgA1AkwBKAJMAAICTC4OADcCTAEoAkwAAgJMLg4AOQJMASgCTAACAkwuDgA7AkwBKAJMAAICTC4OAD0CTAEoAkwAAgJMLg4APwJMASgCTAACAkwuDgBBAkwBKAJMAAICTC4OAEMCTAEoAkwAAgJMLg4ARQJMASgCTAACAkwuDgBHAkwBKAJMAAICTC4OAEkCTAEoAkwAAgJMLg4BRAJMASgCTAACAkwuDgFFAkwBKAJMAAICTC4OAUYCTAEoAkwAAgJMLg4AeAJMASgCTAACAkwuDgFHAkwBKAJMAAICTC4OAUgCTAEoAkwAAgJMLg4BSQJMASgCTAACAkwuDgFKAkwBKAJMAAICTC4OAUsCTAEoAkwAAgJMLg4BTAJMASgCTAACAkwuDgFNAkwBKAJMAAICTC4OAU4CTAEoAkwAAgJMLg4BTwJMASgCTAACAkwuDgFQAkwBKAJMAAICTC4OAVICTAEoAkwAAgJMLg4BUQJMASgCTAACAkwuDgFTAkwBKAJMAAICTC4OAVQCTAEoAkwAAgJMLg4BVQJMASgCTAACAkwuDgFWAkwBKAJMAAICTC4OAVcCTAEoAkwAAgJMLg4BWAJMASgCTAACAkwuDgFZAkwBKAJMAAICTC4OAVoCTAEoAkwAAgJMLg4BWwJMASgCTAACAkwuDgFcAkwBKAJMAAICTC4OAV4CTAEoAkwAAgJMLg4BXQJMASgCTAACAkwuDgFfAkwBKAJMAAICTC4OAWACTAEoAkwAAgJMLg4BYQJMASgCTAACAkwuDgFiAkwBKAJMAAICTC4OAWMCTAEoAkwAAgJMLg4BZAJMASgCTAACAkwuDgFmAkwBKAJMAAICTC4OAWUCTAEoAkwAAgJMLg4BZwJMASgCTAACAkwuDgFoAkwBKAJMAAICTC4OAWkCTAEoAkwAAgJMLg4BagJMASgCTAACAkwuDgFrAkwBKAJMAAICTC4OAWwCTAEoAkwAAgJMLg4BbQJMASgCTAACAkwuDgFuAkwBKAJMAAICTC4OAW8CTAEoAkwAAgJMLg4BcAJMASgCTAACAkwuDgFxAkwBKAJMAAICTC4OAXICTAEoAkwAAgJMLg4BcwJMASgCTAACAkwuDgF0AkwBKAJMAAICTC4OAXUCTAEoAkwAAgJMLg4BdgJMASgCTAACAkwuDgF3AkwBKAJMAAICTC4OAXgCTAEoAkwAAgJMLg4BeQJMASgCTAACAkwuDgF6AkwBKAJMAAICTC4OAXsCTAEoAkwAAgJMLg4BfAJMASgCTAACAkwuDgF9AkwBKAJMAAICTC4OAX4CTAEoAkwAAgJMLg4BfwJMASgCTAACAkwuDgGAAkwBKAJMAAICTC4OAYECTAEoAkwAAgJMLg4BggJMASgCTAACAkwuDgGDAkwBKAJMAAICTC4OAYQCTAEoAkwAAgJMLg4ADAJMASgCTAACAkwuDgGFAkwBKAJMAAICTC4OAYYCTAEoAkwAAgJMLg4BhwJMASgCTAACAkwuDgGIAkwBKAJMAAICTC4OAYkCTAEoAkwAAgJMLg4BigJMASgCTAACAkwuDgGLAkwBKAJMAAICTC4OAYwCTAEoAkwAAgJMLg4BjQJMASgCTAACAkwuDgGOAkwBKAJMAAICTC4OAY8CTAEoAkwAAgJMLg4BkAJMASgCTAACAkwuDgGRAkwBKAJMAAICTC4OAZICTAEoAkwAAgJMLg4BkwJMASgCTAACAkwuDgGUAkwBKAJMAAICTC4OAZUCTAEoAkwAAgJMLg4BlgJMASgCTAACAkwuDgGXAkwBKAJMAAICTC4OAZgCTAEoAkwAAgJMLg4BmQJMASgCTAACAkwuDgGaAkwBKAJMAAICTC4OAZsCTAEoAkwAAgJMLg4BnAJMASgCTAACAkwuDgGdAkwBKAJMAAICTC4OAZ4CTAEoAkwAAgJMLg4BnwJMASgCTAACAkwuDgGgAkwBKAJMAAICTC4OAaECTAEoAkwAAgJMLg4BogJMASgCTAACAkwuDgGjAkwBKAJMAAICTC4OAA4CTAEoAkwAAgJMLg4BpAJMASgCTAACAkwuDgGlAkwBKAJMAAICTC4OAaYCTAEoAkwAAgJMLg4BpwJMASgCTAACAkwuDgGoAkwBKAJMAAICTC4OAakCTAEoAkwAAgJMLg4BqgJMASgCTAACAkwuDgGrAkwBKAJMAAICTC4OAawCTAEoAkwAAgJMLg4BrQJMASgCTAACAkwuDgGuAkwBKAJMAAICTC4OAa8CTAEoAkwAAgJMLg4BsAJMASgCTAACAkwuDgGxAkwBKAJMAAICTC4OAbICTAEoAkwAAgJMLg4BswJMASgCTAACAkwuDgG0AkwBKAJMAAICTC4OAbUCTAEoAkwAAgJMLg4BtgJMASgCTAACAkwuDgG3AkwBKAJMAAICTC4OAbgCTAEoAkwAAgJMLg4BuQJMASgCTAACAkwuDgG6AkwBKAJMAAICTC4OAbsCTAEoAkwAAgJMLg4BvAJMASgCTAACAkwuDgG9AkwBKAJMAAICTC4OAb4CTAEoAkwAAgJMLg4BvwJMASgCTAACAkwuDgHAAkwBKAJMAAICTC4OAcECTAEoAkwAAgJMLg4BwgJMASgCTAACAkwuDgAQAkwBKAJMAAICTC4OAcMCTAEoAkwAAgJMLg4BxAJMASgCTAACAkwuDgHFAkwBKAJMAAICTC4OAcYCTAEoAkwAAgJMLg4BxwJMASgCTAACAkwuDgHIAkwBKAJMAAICTC4OAckCTAEoAkwAAgJMLg4BygJMASgCTAACAkwuDgHLAkwBKAJMAAICTC4OAcwCTAEoAkwAAgJMLg4BzQJMASgCTAACAkwuDgHOAkwBKAJMAAICTC4OAc8CTAEoAkwAAgJMLg4B0AJMASgCTAACAkwuDgHRAkwBKAJMAAICTC4OAdICTAEoAkwAAgJMLg4B0wJMASgCTAACAkwuDgHUAkwBKAJMAAICTC4OAdUCTAEoAkwAAgJMLg4B1gJMASgCTAACAkwuDgHXAkwBKAJMAAICTC4OAdgCTAEoAkwAAgJMLg4B2QJMASgCTAACAkwuDgHaAkwBKAJMAAICTC4OAdsCTAEoAkwAAgJMLg4B3AJMASgCTAACAkwuDgHdAkwBKAJMAAICTC4OAd4CTAEoAkwAAgJMLg4B3wJMASgCTAACAkwuDgHgAkwBKAJMAAICTC4OAeECTAEoAkwAAgJMLg4AEgJMASgCTAACAkwuDgHiAkwBKAJMAAICTC4OAeMCTAEoAkwAAgJMLg4B5AJMASgCTAACAkwuDgHlAkwBKAJMAAICTC4OAeYCTAEoAkwAAgJMLg4B5wJMASgCTAACAkwuDgHoAkwBKAJMAAICTC4OAekCTAEoAkwAAgJMLg4B6gJMASgCTAACAkwuDgHrAkwBKAJMAAICTC4OAewCTAEoAkwAAgJMLg4B7QJMASgCTAACAkwuDgHuAkwBKAJMAAICTC4OAe8CTAEoAkwAAgJMLg4B8AJMASgCTAACAkwuDgHxAkwBKAJMAAICTC4OAfICTAEoAkwAAgJMLg4B8wJMASgCTAACAkwuDgH0AkwBKAJMAAICTC4OAfUCTAEoAkwAAgJMLg4B9gJMASgCTAACAkwuDgH3AkwBKAJMAAICTC4OAfgCTAEoAkwAAgJMLg4B+QJMASgCTAACAkwuDgH6AkwBKAJMAAICTC4OAfsCTAEoAkwAAgJMLg4B/AJMASgCTAACAkwuDgH9AkwBKAJMAAICTC4OAf4CTAEoAkwAAgJMLg4B/wJMASgCTAACAkwuDgIAAkwBKAJMAAICTC4OABQCTAEoAkwAAgJMLg4CAQJMASgCTAACAkwuDgICAkwBKAJMAAICTC4OAgMCTAEoAkwAAgJMLg4AFQJMASgCTAACAkwuDgIEAkwBKAJMAAICTC4OAgUCTAEoAkwAAgJMLg4CBgJMASgCTAACAkwuDgAXAkwBKAJMAAICTC4OAgcCTAEoAkwAAgJMLg4CCAJMASgCTAACAkwuDgIJAkwBKAJMAAICTC4OAgoCTAEoAkwAAgJMLg4CCwJMASgCTAACAkwuDgIMAkwBKAJMAAICTC4OAg0CTAEoAkwAAgJMLg4CDgJMASgCTAACAkwuDgIPAkwBKAJMAAICTC4OAhACTAEoAkwAAgJMLg4CEQJMASgCTAACAkwuDgISAkwBKAJMAAICTC4OAhMCTAEoAkwAAgJMLg4CFAJMASgCTAACAkwuDgIVAkwBKAJMAAICTC4OAhYCTAEoAkwAAgJMLg4CFwJMASgCTAACAkwuDgIYAkwBKAJMAAICTC4OAhkCTAEoAkwAAgJMLg4CGgJMASgCTAACAkwuDgIbAkwBKAJMAAICTC4OAhwCTAEoAkwAAgJMLg4CHQJMASgCTAACAkwuDgIfAkwBKAJMAAICTC4OAh4CTAEoAkwAAgJMLg4CIAJMASgCTAACAkwuDgIhAkwBKAJMAAICTC4OAiICTAEoAkwAAgJMLg4CIwJMASgCTAACAkwuDgIkAkwBKAJMAAICTC4OAiUCTAEoAkwAAgJMLg4AGgJMASgCTAACAkwuDgImAkwBKAJMAAICTC4OAicCTAEoAkwAAgJMLg4CKAJMASgCTAACAkwuDgIpAkwBKAJMAAICTC4OAioCTAEoAkwAAgJMLg4AHQJMASgCTAACAkwuDgIrAkwBKAJMAAICTC4OAiwCTAEoAkwAAgJMLg4CLwJMASgCTAACAkwuDgIuAkwBKAJMAAICTC4OAjACTAEoAkwAAgJMLg4CMQJMASgCTAACAkwuDgIyAkwBKAJMAAICTC4OAjMCTAEoAkwAAgJMLg4CNAJMASgCTAACAkwuDgI1AkwBKAJMAAICTC4OAjYCTAEoAkwAAgJMLg4CNwJMASgCTAACAkwuDgI4AkwBKAJMAAICTC4OAjkCTAEoAkwAAgJMLg4COgJMASgCTAACAkwuDgI7AkwBKAJMAAICTC4OAjwCTAEoAkwAAgJMLg4CPQJMASgCTAACAkwuDgI+AkwBKAJMAAICTC4OAj8CTAEoAkwAAgJMLg4CQAJMASgCTAACAkwuDgJBAkwBKAJMAAICTC4OAkICTAEoAkwAAgJMLg4CQwJMASgCTAACAkwuDgJEAkwBKAJMAAICTC4OAkUCTAEoAkwAAgJMLg4CRgJMASgCTAACAkwuDgJHAkwBKAJMAAICTC4OAkgCTAEoAkwAAgJMLg4CSQJMASgCTAACAkwuDgADAkwtCAECKAIAAwQBVQAQAQMBJwMCBAEAKAICAygCAAQEAVQAOAQDBC0MAwUMOAUEBhYMBgYkAgAGAAB6li4KgGEABQAoBQIFIwAAenUtCAEDAAABAgEtDgIDKAIAAgQBVC4IgHkAASMAAHq1DDgBAgQkAgAEAACHwSMAAHrHLQgBBCgCAAUEARIAEAEFAScDBAQBACgEAgUoAgAGBAERADgGBQYtDAUHDDgHBggWDAgIJAIACAAAexIuCoBhAAcAKAcCByMAAHrxLQgBBQAAAQIBLQ4EBSgCAAQEAmUuCIB5AAEjAAB7MQ04AAECLQAGJAIABgAAh0sjAAB7Ri0NGwQAKAQCBC0OBBstDQMELQ0EAwAoAwIDLQ4DBC0NGwMAKAMCAy0OAxstDQQDACgDAgMtDgMELQ0bAwAoAwIDLQ4DGy0NBQMtDQMFACgFAgUtDgUDLQ0bBQAoBQIFLQ4FGy0NAwUAKAUCBS0OBQMtDRsFACgFAgUtDgUbLQ0EBQAoBQIFLQ4FBC0NGwUAKAUCBS0OBRstDQMFACgFAgUtDgUDLQgBBScCBgQOABABBgEnAwUEAQAoBQIGJwIHBA0AOAcGBy0MBggMOAgHCRYMCQkkAgAJAAB8MS4KgHoACAAoCAIIIwAAfBAtCAEGAAABAgEtDgUGLQgBBScCBwQgABABBwEnAwUEAQAoBQIHJwIIBB8AOAgHCC0MBwkMOAkIChYMCgokAgAKAAB8hS4KgGEACQAoCQIJIwAAfGQtCAEHAAABAgEtDgUHLQgBBScCCAQgABABCAEnAwUEAQAoBQIIJwIJBB8AOAkICS0MCAoMOAoJCxYMCwskAgALAAB82S4KgGEACgAoCgIKIwAAfLgtCAEIAAABAgEtDgUILgiAeQABIwAAfPENKAABgIMABSQCAAUAAIb+IwAAfQYtDQcFLgQABYADKACABAQAICUAAJVLLgiABQAJACgJAgoBKAAKgHkACy0OSwstDgkHLQgBBScCCQQgABABCQEnAwUEAQAoBQIJJwIKBB8AOAoJCi0MCQsMOAsKDBYMDAwkAgAMAAB9fi4KgGEACwAoCwILIwAAfV0uCIB5AAEjAAB9iQw4ASkJJAIACQAAhSkjAAB9my0NBgItDQgEKAIACAQCLi4IAAACLi4MAAQCLwAQAAgAJQAAp8MtBAAALgwCLwAFLgQAAoADKACABAQADiUAAJVLLgiABQAEACgEAggBKAAIgHkACS0OBQktDQcCKAIABwQCLi4IAAACLi4MAAICLwAQAAcAJQAAp8MtBAAALgwCLwAFLgQABIADKACABAQADiUAAJVLLgiABQACACgCAgcAOAcpCC0OBQgtDgIGLQgBBCcCBQQOABABBQEnAwQEAQAoBAIFJwIGBA0AOAYFBi0MBQcMOAcGCBYMCAgkAgAIAAB+jy4KgHoABwAoBwIHIwAAfm4tCAEFAAABAgEtDgQFLgiAeQABIwAAfqcMOAErBCQCAAQAAITcIwAAfrktDQUCJwIGBA0GKAYCBCcCCAQDADgGCActCAEFABABBwEnAwUEAQAoBQIHLQ4GBwAoBwIHLQ4GBycCCAQDADgFCAcAKAICCC4EAAiAAy4EAAeABC4EAAaABSUAAAnrACgFAgctDQcGJwIIBAIAOAcIAjcNAAIABi0IAQInAgUEDAAQAQUBJwMCBAEAKAICBScCBgQLADgGBQYtDAUHDDgHBggWDAgIJAIACAAAf3cuCoB6AAcAKAcCByMAAH9WLQgBBQAAAQIBLQ4CBS0IAQInAgYEIAAQAQYBJwMCBAEAKAICBicCBwQfADgHBgctDAYIDDgIBwkWDAkJJAIACQAAf8suCoBhAAgAKAgCCCMAAH+qLQgBBgAAAQIBLQ4CBi0IAQInAgcEIAAQAQcBJwMCBAEAKAICBycCCAQfADgIBwgtDAcJDDgJCAoWDAoKJAIACgAAgB8uCoBhAAkAKAkCCSMAAH/+LQgBBwAAAQIBLQ4CBy4IgHkAASMAAIA3DSgAAYCDAAIkAgACAACEjyMAAIBMLQ0GAi4EAAKAAygAgAQEACAlAACVSy4IgAUABAAoBAIIASgACIB5AAktDksJLQ4EBi0IAQInAgQEIAAQAQQBJwMCBAEAKAICBCcCCAQfADgIBAgtDAQJDDgJCAoWDAoKJAIACgAAgMQuCoBhAAkAKAkCCSMAAICjLgiAeQABIwAAgM8MOAElBCQCAAQAAIK0IwAAgOEtDQUCLQ0HAycCBwQoLQgAKC0MAykAEAAHACUAAKfDLQQAAC0MKQQuBAACgAMoAIAEBAAMJQAAlUsuCIAFAAMAKAMCBwEoAAeAeQAILQ4ECC0NBgInAgYEKC0IACgtDAIpABAABgAlAACnwy0EAAAtDCkELgQAA4ADKACABAQADCUAAJVLLgiABQACACgCAgYAOAYlBy0OBActDgIFLQgBAycCBAQMABABBAEnAwMEAQAoAwIEJwIFBAsAOAUEBS0MBAYMOAYFBxYMBwckAgAHAACBxS4KgHoABgAoBgIGIwAAgaQtCAEEAAABAgEtDgMELgiAeQABIwAAgd0MOAEnAyQCAAMAAIJnIwAAge8tDQQBJwIEBAsGKAQCAicCBgQDADgEBgUtCAEDABABBQEnAwMEAQAoAwIFLQ4EBQAoBQIFLQ4EBScCBgQDADgDBgUAKAECBi4EAAaAAy4EAAWABC4EAASABSUAAAnrACgDAgUtDQUEJwIGBAIAOAUGATcNAAEABCYAKAICBQA4BQEGLQ0GAy0NBAUuBAAFgAMoAIAEBAAMJQAAlUsuCIAFAAYAKAYCBwA4BwEILQ4DCC0OBgQBKAABgGQAAy0MAwEjAACB3S0NAggAKAgCCC0OCAItCAEIAAABAgEtDgIIBTCAhQABAAkuCIB5AAQjAACC4Q0oAASAgwAKJAIACgAAhAQjAACC9i0NBQQBKAABgGQACi0NCAsoAgAMBAIuLggAAAIuLgwACwIvABAADAAlAACogy0EAAAuDAIvAAgMOAonCyQCAAsAAIM/JQAAk7QuBAAEgAMoAIAEBAAMJQAAlUsuCIAFAAsAKAsCDAA4DAoNLQ4IDS0OCwUBKAAJgIMABA44CQQIJAIACAAAg4MlAACV2Q04AAQCLQAIJAIACAAAg5gjAACD+y0NBgkkAgAIAACDqSUAAJO0ACgDAgsAOAsEDC0NDAgNKAAKgIMABCQCAAQAAIPMJQAAk7QuBAAJgAMoAIAEBAAgJQAAlUsuCIAFAAQAKAQCCwA4CwoMLQ4IDC0OBAYjAACD+y0MCgEjAACAzwA4CQQKDjgJCgskAgALAACEGyUAAJXZDTgACgItAAskAgALAACEMCMAAIR+LQ0IDCQCAAsAAIRBJQAAk7QAKAMCDQA4DQoOLQ0OCy4EAAyAAygAgAQEACAlAACVSy4IgAUACgAoCgINADgNBA4tDgsOLQ4KCCMAAIR+ASgABIBkAAotDAoEIwAAguEtDQcCACgbAggAOAgBCS0NCQQuBAACgAMoAIAEBAAgJQAAlUsuCIAFAAgAKAgCCQA4CQEKLQ4ECi0OCAcBKAABgGQAAi0MAgEjAACANwAoAgIGADgGAQctDQcELQ0FBi4EAAaAAygAgAQEAA4lAACVSy4IgAUABwAoBwIIADgIAQktDgQJLQ4HBQEoAAGAZAAELQwEASMAAH6nLQ0FCgAoCgIKLQ4KBS0IAQoAAAECAS0OBQoFMICFAAEACy4IgHkACSMAAIVWDSgACYCDAAwkAgAMAACGdiMAAIVrLQ0GCQEoAAGAZAAMLQ0KDSgCAA4EAi4uCAAAAi4uDAANAi8AEAAOACUAAKiDLQQAAC4MAi8ACgw4DCsNJAIADQAAhbQlAACTtC4EAAmAAygAgAQEAA4lAACVSy4IgAUADQAoDQIOADgODA8tDgoPLQ4NBgEoAAuAgwAJDjgLCQokAgAKAACF+CUAAJXZDDgJAgokAgAKAACGCiMAAIZtLQ0HCyQCAAoAAIYbJQAAk7QAKAQCDQA4DQkOLQ0OCg0oAAyAgwAJJAIACQAAhj4lAACTtC4EAAuAAygAgAQEACAlAACVSy4IgAUACQAoCQINADgNDA4tDgoOLQ4JByMAAIZtLQwMASMAAH2JADgLCQwOOAsMDSQCAA0AAIaNJQAAldkMOAwCDSQCAA0AAIafIwAAhu0tDQoOJAIADQAAhrAlAACTtAAoBAIPADgPDBAtDRANLgQADoADKACABAQAICUAAJVLLgiABQAMACgMAg8AOA8JEC0ODRAtDgwKIwAAhu0BKAAJgGQADC0MDAkjAACFVi0NCAUAKBsCCgA4CgELLQ0LCS4EAAWAAygAgAQEACAlAACVSy4IgAUACgAoCgILADgLAQwtDgkMLQ4KCAEoAAGAZAAFLQwFASMAAHzxLQ0FBgA4AQIHDDgHBAgkAgAIAACHZiUAAJO0ASgCSgACAAkAOAkHCi0NCggcDAgJAhwMCQcAHAwHCAIuBAAGgAMoAIAEBAESJQAAlUsuCIAFAAcAKAcCCQA4CQEKLQ4ICi0OBwUBKAABgGQABi0MBgEjAAB7MS0NAwQBKAJKAAIABgA4BgEHLQ0HBRwMBQcCHAwHBgAcDAYFAi4EAASAAygAgAQEAVUlAACVSy4IgAUABgAoBgIHADgHAQgtDgUILQ4GAwEoAAGAZAAELQwEASMAAHq1LQ0kEwI4JQQWHAwWHgQNKAAegIUAFiQCABYAAIhDJQAAk7QAKA8CKAA4KB4pLQ0pFhwMFh4GBSgABIB/ABYYOCYWKAw4FiIpJAIAKQAAiHUlAACpQwQ4HigWJwIqBgAKOCooKSQCACkAAIijBjgWKCwKOCweKyQCACsAAIijJQAAqVUAOBMWHg44Ex4oJAIAKAAAiLolAACV2S0OHiQAOAQnEy0MEwQjAAAkZiQCACQAAIjZIwAAiRcAKBMCJQA4JQQmLQ0mJCcCJQQmLQgAJi0MHictDAIoLQwWKS0MISotDCQrABAAJQAlAACpZy0EAAAjAACJFwEoAASAZAAkLQwkBCMAACKQJAIAJQAAiTUjAACJcwAoHgImADgmBCctDSclJwImBCctCAAnLQwhKC0MAiktDBMqLQwkKy0MJSwAEAAmACUAAKlnLQQAACMAAIlzASgABIBkACUtDCUEIwAAINccDAQhAAA4EyEkACgeAiUAOCUEJi0NJiEwDAAhACQBKAAEgGQAIS0MIQQjAAAfrwAoJAIlADglHiYtDSYEHAwEJQAtDSEELgQABIADKACABAQAISUAAJVLLgiABQAmACgmAicAOCceKC0OJSgtDiYhASgAHoBkAAQtDAQeIwAAH4sFMIBwAAQAJCcCJwQoLQgAKC0MHikuCICIACotDCQrABAAJwAlAAChJy0EAAAtDCklLQwqJi0NJSQAKCQCJC0OJCUtDSEkLQgBJycCKAQJABABKAEnAycEAQAoJQIoACgkAikAKCcCKkA/ACoAKQAoLQ0nJAAoJAIkLQ4kJy0OJyEBKAAEgGQAJC0MJAQjAAAdfi0NIR4BKAAEgIUAIwAoAwIlADglBCYtDSYkDSgAI4CIACUkAgAlAACKxiUAAJO0LgQAHoADKACABAQBTiUAAJVLLgiABQAlACglAiYAOCYjJy0OJCctDiUhASgABIBkAB4tDB4EIwAAHTUtDSEeASCAYAACACQAOCQEJS0NJSMuBAAegAMoAIAEBAFOJQAAlUsuCIAFACQAKCQCJQA4JQQmLQ4jJgEoAASAZAAeLQ4kIS0MHgQjAAAdFSQCAB4AAIteIwAAi5wAKCQCIQA4IQQjLQ0jHicCIQQoLQgAKC0MJiktDBMqLQwlKy0MJywtDB4tABAAIQAlAACpZy0EAAAjAACLnAEoAASAZAAeLQweBCMAABwSJAIAJQAAi7ojAACL+AAoHgImADgmBCctDSclJwImBCctCAAnLQwjKC0MEyktDCEqLQwkKy0MJSwAEAAmACUAAKlnLQQAACMAAIv4ASgABIBkACUtDCUEIwAAGfQFMIBwAAIAGycCIAQhLQgAIS0MAyIuCIBmACMtDBskABAAIAAlAACQ4S0EAAAtDCIcLQwjHy0NHBsAKBsCGy0OGxwtDQQbLQgBICcCIQQJABABIQEnAyAEAQAoHAIhACgbAiIAKCACI0A/ACMAIgAhLQ0gGwAoGwIbLQ4bIC0OIAQBKAACgGQAGy0MGwIjAAATcy0NCAkAKAICCwA4CwQMLQ0MCgEggGAAAgAMADgMBA0tDQ0LCjgKCwwEOAkMCi0OCggBKAAEgGQACS0MCQQjAAAPNSgAgAQEeAANAAAAgASAAyQAgAMAAI0FKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQW35IldMXaK3zwBAQImJQAAjN0tCAEEJwIFBCEAEAEFAScDBAQBACgEAgUnAgYEIAA4BgUGLQwFBww4BwYIFgwICCQCAAgAAI12LgqAYQAHACgHAgcjAACNVS0IAQUAAAECAS0OBAUuCIB5AAMjAACNjg0oAAOAhQAEJAIABAAAjagjAACNoy0NBQEmLQ0FBAA4AgMGDjgCBgckAgAHAACNwyUAAJXZDSgABoBmAAckAgAHAACN2CUAAJO0ACgBAggAOAgGCS0NCQcuBAAEgAMoAIAEBAAhJQAAlUsuCIAFAAYAKAYCCAA4CAMJLQ4HCQEoAAOAZAAELQ4GBS0MBAMjAACNjiUAAIzdLQgBBCcCBQQFABABBQEnAwQEAQAoBAIFLQwFBi4KgGEABgAoBgIGLgqAYQAGACgGAgYuCoBhAAYAKAYCBi4KgGEABi0IAQUAAAECAS0OBAUuCIB5AAMjAACOgQ0oAAOAcQAEJAIABAAAjpsjAACOli0NBQEmLQ0FBAA4AgMGDjgCBgckAgAHAACOtiUAAJXZDSgABoBmAAckAgAHAACOyyUAAJO0ACgBAggAOAgGCS0NCQcuBAAEgAMoAIAEBAAFJQAAlUsuCIAFAAYAKAYCCAA4CAMJLQ4HCQEoAAOAZAAELQ4GBS0MBAMjAACOgSUAAIzdLQgBAwAAAQIBLgqAfAADLQgBBAAAAQIBLgqAegAELgiAeQACIwAAj0INKAACgHEABSQCAAUAAI+FIwAAj1ctDQQBHAwBAgApAgADAP////8OOAIDBCQCAAQAAI97JQAAqpAcDAECBC0MAgEmLQ0EBQMwgHcAAgAGDygAAoB3AAckAgAHAACPpiUAAKqiDSgABoBxAAckAgAHAACPuyUAAJO0ACgBAggAOAgGCS0NCQccDAcGAC0NAwcEOAYHCAA4BQgGLQ4GBAUoAAeAhwAFLQ4FAwEoAAKAZAAFLQwFAiMAAI9CKgEAAQUq4YsU1OpBWjwBAQImJQAAjN0tCAEDAAABAgEuCoB8AAMtCAEEAAABAgEuCoB6AAQuCIB5AAIjAACQPQ0oAAKAhQAFJAIABQAAkFcjAACQUi0NBAEmLQ0EBQMwgIMAAgAGDygAAoCDAAckAgAHAACQeCUAAKqiDSgABoCFAAckAgAHAACQjSUAAJO0ACgBAggAOAgGCS0NCQccDAcGAC0NAwcEOAYHCAA4BQgGLQ4GBAUoAAeAhwAFLQ4FAwEoAAKAZAAFLQwFAiMAAJA9KgEAAQWQfkcGuXRGPzwBAQImJQAAjN0tCAEFJwIGBBEAEAEGAScDBQQBACgFAgYnAgcEEAA4BwYHLQwGCAw4CAcJFgwJCSQCAAkAAJEtLgqAeQAIACgIAggjAACRDC0IAQYAAAECAS0OBQYMOAIDBSQCAAUAAJGsIwAAkUwBKAADgHAABw44AwcIJAIACAAAkWYlAACV2Qw4AgcIJAIACAAAkYMjAACReC4IgHAABSMAAJGjAjgCAwcOOAMCCCQCAAgAAJGaJQAAqqItDAcFIwAAkaMtDAUEIwAAkbcuCIB5AAQjAACRtwcoAASAcQACLQgBBQAAAQIBLQ4CBScCCAQEBjgECAkEOAkICgI4BAoHCygAB4B5AAgkAgAIAACSGCMAAJH1ASgAAoBkAAcOOAIHCCQCAAgAAJIPJQAAldktDgcFIwAAkhgtDQUHLgiAeQACIwAAkicMOAIHBSQCAAUAAJJCIwAAkjktDQYBLQwEAiYtCAEIAAABAgEuCoB5AAgFKAACgHEACScCCwQACygAC4BxAAokAgAKAACSiAcoAAmAcQANCjgNAgwkAgAMAACSiCUAAKlVLgiAeQAFIwAAkpMNKAAFgHEACiQCAAoAAJMAIwAAkqgtDQYFLQ0ICQ0oAAKAdAAIJAIACAAAksUlAACTtC4EAAWAAygAgAQEABElAACVSy4IgAUACAAoCAIKADgKAgstDgkLASgAAoBkAAUtDggGLQwFAiMAAJInADgJBQsOOAkLDCQCAAwAAJMXJQAAldkMOAsEDCQCAAwAAJM0IwAAkykuCIBhAAojAACTdwA4AwsMDjgDDA0kAgANAACTSyUAAJXZDSgADIBmAAskAgALAACTYCUAAJO0ACgBAg0AOA0MDi0NDgstDAsKIwAAk3ctDQgLGSgAC4B/AAwcDAoLBAA4DAsKDjgMCg0kAgANAACTnyUAAJXZLQ4KCAEoAAWAZAAKLQwKBSMAAJKTKgEAAQXFa8RaDhAAAjwBAQImJQAAjN0nAgYEBAY4AgYHBDgHBggCOAIIBQMwgHEABQACDygABYBxAAYkAgAGAACT/CUAAKqiHAwCBwIcDAcGBBwMBgICBTCAfwACAAYnAggCAAo4CAIHJAIABwAAlD8GOAYCCgsoAAqAfwAJJAIACQAAlD8lAACpVRo4AQYHDSgAAoB+AAEkAgABAACUZCMAAJRZLgiAeQAEIwAAlIcYOAcGAQ0oAAaAhAACJAIAAgAAlH4lAACpQy0MAQQjAACUhxwMAwIEAzCAdwAFAAMPKAAFgHcABiQCAAYAAJSpJQAAqqIcDAMGAhwMBgUEHAwFAwINKAADgH4ABSQCAAUAAJTYIwAAlM0uCIB5AAEjAACVLwUwgH8AAwAFJwIHAgAKOAcDBiQCAAYAAJUMBjgFAwkLKAAJgH8ACCQCAAgAAJUMJQAAqVUYOAIFAw0oAAWAhAACJAIAAgAAlSYlAACpQy0MAwEjAACVLwA4BAECDjgEAgMkAgADAACVRiUAAJXZLQwCASYuAYADgAYLAIAGAAKAByQAgAcAAJVmIwAAlXEuAIADgAUjAACV2C4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAJXELgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAJWTKAGABQQAAQMAgAYAAoAGIwAAldgmKgEAAQVFp8pxGUHkFTwBAQImJQAAjN0tCAEEAAABAgEtDgEELQgBBQAAAQIBLQ4CBS0NAQYAKAYCBi0OBgEnAgcEBAY4AgcIBDgIBwkCOAIJBgsoAAaAeQAHJAIABwAAl10jAACWQAcoAAKAcQAIAzCAcQAGAAkPKAAGgHEACiQCAAoAAJZlJQAAqqINKAAIgHQABiQCAAYAAJZ6JQAAk7QAKAECCgA4CggLLQ0LBhwMCQsCHAwLCgQcDAoLAgUwgH8ACwAKJwINAgAKOA0LDCQCAAwAAJbLBjgKCw8LKAAPgH8ADiQCAA4AAJbLJQAAqVUaOAYKDA0oAAuAfgAGJAIABgAAlvAjAACW5S4IgHkAByMAAJcTGDgMCgYNKAAKgIQACyQCAAsAAJcKJQAAqUMtDAYHIwAAlxMuBAABgAMoAIAEBAARJQAAlUsuCIAFAAYAKAYCCgA4CggLLQ4HCy0OBgQAOAIJBg44AgYHJAIABwAAl1QlAACV2S0OBgUjAACXXS0NBQYHKAAGgHEABS0MBQIjAACXcg0oAAKAdQAFJAIABQAAmdQjAACXhwUwgIAAAwAFJwIHBAAKOAcDBiQCAAYAAJe7BjgFAwkLKAAJgIAACCQCAAgAAJe7JQAAqVUcDAUDACcCBgEALQgBBScCBwQJABABBwEnAwUEAQAoBQIHJwIIBAhDA7AAA4B2AAgABgAHLgiAeQACIwAAl/oNKAACgH0AAyQCAAMAAJglIwAAmA8tDQQCLQ0BAwIoAwIDLQ4DAS0MAgEmBSgAAoBxAAMtDQQGATCAdQACAAcNKAADgIAACCQCAAgAAJhOJQAAk7QAKAUCCQA4CQMKLQ0KCAEoAAOAZAAJDjgDCQokAgAKAACYdiUAAJXZDSgACYCAAAokAgAKAACYiyUAAJO0ACgFAgsAOAsJDC0NDAoBKAADgH0ACQ44AwkLJAIACwAAmLMlAACV2Q0oAAmAgAALJAIACwAAmMglAACTtAAoBQIMADgMCQ0tDQ0LASgAA4B3AAkOOAMJDCQCAAwAAJjwJQAAldkNKAAJgIAAAyQCAAMAAJkFJQAAk7QAKAUCDAA4DAkNLQ0NAxwMCAkEGSgACYB/AAgcDAoJBAA4CAkKDjgICgwkAgAMAACZPCUAAJXZGSgACoB/AAgcDAsJBAA4CAkKDjgICgskAgALAACZYCUAAJXZGSgACoB/AAgcDAMJBAA4CAkDDjgIAwokAgAKAACZhCUAAJXZDSgAB4B0AAgkAgAIAACZmSUAAJO0LgQABoADKACABAQAESUAAJVLLgiABQAIACgIAgkAOAkHCi0OAwotDggEASgAAoBkAAMtDAMCIwAAl/otDQQFDSgAAoB0AAYkAgAGAACZ7SUAAJO0LgQABYADKACABAQAESUAAJVLLgiABQAGACgGAgcAOAcCCC4KgHkACAEoAAKAZAAFLQ4GBC0MBQIjAACXciUAAIzdLQgBBAAAAQIBLQgBBScCBgQhABABBgEnAwUEAQAoBQIGJwIHBCAAOAcGBy0MBggMOAgHCRYMCQkkAgAJAACafy4KgGEACAAoCAIIIwAAml4tCAEGAAABAgEtDgUGLQgBBScCBwQJABABBwEnAwUEAQAoAQIHACgCAggAKAUCCUA/AAkACAAHLQ0FAQAoAQIBLQ4BBS0OBQQuCIB5AAMjAACa0g0oAAOAgAABJAIAAQAAmuwjAACa5y0NBgEmLQ0EAgAoAgIHADgHAwgtDQgFHAwFAgAnAgcBAC0IAQUnAggEBQAQAQgBJwMFBAEAKAUCCCcCCQQEQwOwAAKAdgAJAAcACAUwgHEAAwACLgiAeQABIwAAm0UNKAABgHEAByQCAAcAAJtrIwAAm1oBKAADgGQAAS0MAQMjAACa0i0NBgcAOAIBCA44AggJJAIACQAAm4YlAACV2QAoBQIKADgKAQstDQsJDSgACICFAAokAgAKAACbqSUAAJO0LgQAB4ADKACABAQAISUAAJVLLgiABQAKACgKAgsAOAsIDC0OCQwtDgoGASgAAYBkAActDAcBIwAAm0UlAACM3ScCAgIYGjgBAgMcDAMEAhwMBAIEHAwCAwIbKAABgIEAAhwMAgUCHAwFBAQcDAQCAhsoAAGAfwAEHAwEBgIcDAYFBBwMBQQCHAwBBgIcDAYFBBwMBQECLQgBBScCBgQFABABBgEnAwUEAQAoBQIGLQwGBy0OAwcAKAcCBy0OAgcAKAcCBy0OBAcAKAcCBy0OAQctDAUBJioBAAEFUCX8dzBk45U8AQECJioBAAEFW021Co+HABM8AQECJiUAAIzdLgiAeQAFIwAAnLMNKAAFgHcABiQCAAYAAJ0eIwAAnMgtDQEFLQ0CBi0NAwctDQQILQgBCScCCgQFABABCgEnAwkEAQAoBgIKJwILBAQAKAkCDD8PAAoADC0NCQYAKAYCBi0OBgktDgUBLQ4JAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWAZAAGJAIABwAAnTwjAACdqC0NAQctDQIILQ0DCS0NBAoAKAgCDAA4DAUNLQ0NCwAoBwINADgNBQ4tDQ4MADgLDA0uBAAIgAMoAIAEBAAFJQAAlUsuCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAACdqC0MBgUjAACcsyoBAAEFAtxuJ4B2Ep08AQECJiUAAIzdLQgBCCcCCQQDABABCQEnAwgEAQAoCAIJLQwJCi0OBAoAKAoCCi0OBgotCAEEJwIGBAQAEAEGAScDBAQBACgEAgYtDAYJLgqAegAJACgJAgkuCoB6AAkAKAkCCS4KgHoACS0NBAYAKAYCBi0OBgQtCAEGJwIJBAUAEAEJAScDBgQBACgGAgktDAkKLgqAegAKACgKAgouCoB6AAoAKAoCCi4KgHoACgAoCgIKLgqAiQAKLQ0ECQAoCQIJLQ4JBC0NBgkAKAkCCS0OCQYtCAEJAAABAgEtDgQJLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS4KgHkABi0IAQoAAAECAS4KgHgACi4IgHkAByMAAJ7WDSgAB4B9AAskAgALAACguSMAAJ7rLQ0KDQsoAA2AeAAOJAIADgAAnwgnAg8EADwJAQ8nAg0EDi0IAA4tDAkPLQwEEC0MBhEtDAoSABAADQAlAACcoy0EAAAtDQkNLQ0EDi0NBg8tDg0JLQ4OBC0ODwYuCoB7AAoBKAAOgGQABi0NBgQnAgYAcQo4BQYJCygABIB6AAYkAgAJAACgfiMAAJ94JwIJAHMKOAUJCiQCAAoAAKBUIwAAn48nAgkAdQo4BQkKJAIACgAAoCojAACfpicCCQB4CjgFCQokAgAKAACgACMAAJ+9CygABYCGAAkkAgAJAACf1icCCgQAPAkBCgsoAAaAeAAFJAIABQAAn+slAACdsS0MAQctDAIILQwDCy0MBAwjAACgqAsoAAaAeAAFJAIABQAAoBUlAACdsS0MAQctDAIILQwDCy0MBAwjAACgqAsoAAaAeAAFJAIABQAAoD8lAACdsS0MAQctDAIILQwDCy0MBAwjAACgqAsoAAaAeAAFJAIABQAAoGklAACdsS0MAQctDAIILQwDCy0MBAwjAACgqAsoAAaAeAAFJAIABQAAoJMlAACdsS0MAQctDAIILQwDCy0MBAwjAACgqC0MBwEtDAgCLQwLAy0MDAQmJAIACwAAoMYjAAChBAAoCAIMADgMBw0tDQ0LJwIMBA0tCAANLQwJDi0MBA8tDAYQLQwKES0MCxIAEAAMACUAAKlnLQQAACMAAKEEASgAB4BkAAstDAsHIwAAntYqAQABBQ/0kvy25IIAPAEBAiYlAACM3S0IAQUnAgYEEQAQAQYBJwMFBAEAKAUCBicCBwQQADgHBgctDAYIDDgIBwkWDAkJJAIACQAAoXMuCoB5AAgAKAgCCCMAAKFSLQgBBgAAAQIBLQ4FBgw4AgMFJAIABQAAofIjAAChkgEoAAOAcAAHDjgDBwgkAgAIAAChrCUAAJXZDDgCBwgkAgAIAAChySMAAKG+LgiAcAAFIwAAoekCOAIDBw44AwIIJAIACAAAoeAlAACqoi0MBwUjAACh6S0MBQQjAACh/S4IgHkABCMAAKH9BygABIBxAAItCAEFAAABAgEtDgIFJwIIBAQGOAQICQQ4CQgKAjgECgcLKAAHgHkACCQCAAgAAKJeIwAAojsBKAACgGQABw44AgcIJAIACAAAolUlAACV2S0OBwUjAACiXi0NBQcuCIB5AAIjAACibQw4AgcFJAIABQAAoogjAACify0NBgEtDAQCJi0IAQgAAAECAS4KgHkACAUoAAKAcQAJJwILBAALKAALgHEACiQCAAoAAKLOBygACYBxAA0KOA0CDCQCAAwAAKLOJQAAqVUuCIB5AAUjAACi2Q0oAAWAcQAKJAIACgAAo0YjAACi7i0NBgUtDQgJDSgAAoB0AAgkAgAIAACjCyUAAJO0LgQABYADKACABAQAESUAAJVLLgiABQAIACgIAgoAOAoCCy0OCQsBKAACgGQABS0OCAYtDAUCIwAAom0AOAkFCw44CQsMJAIADAAAo10lAACV2Qw4CwQMJAIADAAAo3ojAACjby4IgGEACiMAAKO9ADgDCwwOOAMMDSQCAA0AAKORJQAAldkNKAAMgIgACyQCAAsAAKOmJQAAk7QAKAECDQA4DQwOLQ0OCy0MCwojAACjvS0NCAsZKAALgH8ADBwMCgsEADgMCwoOOAwKDSQCAA0AAKPlJQAAldktDgoIASgABYBkAAotDAoFIwAAotklAACM3S0IAQYAAAECAS0OAQYtCAEBAAABAgEtDgIBLQ0EAgAoAgICLQ4CBC4IgHkABSMAAKQxDDgFAwIkAgACAACkVCMAAKRDLQ0GAi0NAQMtDAIBLQwDAiYkAgACAACkYSUAAJO0JwIIBAMAOAQIBwA4BwUILQ0IAi0NBgctDQEIACgHAgkuBAAIgAMoAIAEBAABJQAApMkuCIAFAAouCIAGAAstDgILLQ0KAgAoAgICLQ4CCi0OCQYtDgoBASgABYBkAAItDAIFIwAApDEuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAAClGCMAAKWIJACADQAApSUjAAClPi4AgAOABQEAgAUAAoAOLgKAC4AOIwAApYMoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAApYMjAACl3CgAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAACl3CgAgA0EAAMBAIAFgA2ADAsAgAOABYANJACADQAApkABAIAKgAiADy4AgAqAEC4AgAyAEQsAgBCAD4ASJACAEgAApkAuAYAQgA4uAoAOgBEBAIAQAAKAEAEAgBEAAoARIwAApg8BAIAMgAiABiYuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAACmmCMAAKcIJACADQAApqUjAACmvi4AgAOABQEAgAUAAoAOLgKAC4AOIwAApwMoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAApwMjAACnXCgAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAACnXCgAgA0EAAMBAIAFgA2ADAEAgAyABIANAwCACAACgA4BAIANgA6ADwEAgAqADoAQDQCAEIAKgA4kAIAOAACnvC4BgBCAES4CgBGADwMAgBAAAoAQAwCADwACgA8jAACniy4AgAyABiYlAACM3S0IAQMAAAECAS4KgHwAAy0IAQQAAAECAS4KgHoABC4IgHkAAiMAAKfxDSgAAoCDAAUkAgAFAACoCyMAAKgGLQ0EASYtDQQFAzCAggACAAYPKAACgIIAByQCAAcAAKgsJQAAqqINKAAGgIMAByQCAAcAAKhBJQAAk7QAKAECCAA4CAYJLQ0JBxwMBwYALQ0DBwQ4BgcIADgFCAYtDgYEBSgAB4CHAAUtDgUDASgAAoBkAAUtDAUCIwAAp/ElAACM3S0IAQMAAAECAS4KgHwAAy0IAQQAAAECAS4KgHoABC4IgHkAAiMAAKixDSgAAoCDAAUkAgAFAACoyyMAAKjGLQ0EASYtDQQFAzCAggACAAYPKAACgIIAByQCAAcAAKjsJQAAqqINKAAGgIMAByQCAAcAAKkBJQAAk7QAKAECCAA4CAYJLQ0JBxwMBwYALQ0DBwQ4BgcIADgFCAYtDgYEBSgAB4CHAAUtDgUDASgAAoBkAAUtDAUCIwAAqLEqAQABBclvkzsTnekWPAEBAiYqAQABBWRhiKjGz5TLPAEBAiYlAACM3S0NAwYtDQQHCygAB4B4AAgkAgAIAACpjScCCQQAPAkBCQsoAAaAdwAHJAIABwAAqhwjAACpoi0NAQYtDQIHLQ0DCC0NBAkNKAAIgHcACiQCAAoAAKnHJQAAk7QuBAAGgAMoAIAEBAAEJQAAlUsuCIAFAAoAKAoCCwA4CwgMLQ4FDAEoAAiAZAAFDjgIBQYkAgAGAACqByUAAJXZLQ4KAS0OBwItDgUDLQ4JBCMAAKqPJwIGBActCAAHLQwBCC0MAgktDAMKLQwECwAQAAYAJQAAnKMtBAAALQ0BBi0NAgctDQQILgQABoADKACABAQABCUAAJVLLgiABQAJACgJAgoBKAAKgHkACy0OBQstDgkBLQ4HAi4KgGQAAy0OCAQjAACqjyYqAQABBVoC5Bu1HqmfPAEBAiYqAQABBSiGkrBH3P1DPAEBAiY=",
      "debug_symbols": "7b3djiS9cbV7L++xDvgbP76VDxuGbOszBAiSIcsb2DB075s9M5VV8xaz2cPKfDq7Kn1gt+SKWYyVkUFyZQT5v7/9x5/+7X/+81///Nf/+7f//u1f/s///vaXv/37H//x57/9tf2n//3nH377t7//+S9/+fN//uvtf/1bePtfWc2+Wfz3f/3xr2//xX//449//8dv/6Jq+off/vTX//jtXyxGbf/G//3zX/7027/EkP/5//yhmXmaM9MZMwt5zmwOLaY5sykmLc2hpTnf8hxalp5ZzKmGH3YxZ6s/Gf7h/vchpcvPQ0k3vw6dXxeR+OPXRTQsvxbr/NhqqBcPaoq3P/7mQInbOOB++XmMjjqw0ROotjwBGz2BWPUSFlFyft8Br37x1iWXOwdq2dqBmH524BuMJAam+/oliZeHmKReQWrsYKSilyG1P6/B1Oy+QWjcH0J2h/D8MER0vURWdLu+Gt8RPJYNEFwuPw5J7hDsFxG+WSWZscr9p67pQkHS7O97UyyXS96xmzS7knc0LXnH9Pevrfczf9KSl/FIeH88kurlx5KkDMbj4TJ485TuxlNW+FmyZxtPHj1tSdeAkiqDn4dSrzmz/D7CvcjRRlTD4UZUjjYiORxHUo82Ij0cR3q4OFI72ogsHW5EerQROT+LxLgsQGMN9yOSY42ohBAON6JytBHFw3EU69FGlA7HUTpcHCU72ohyOtyI9Ggj+oS9SNRFl0jR7kckRxvRJ+xFRiMqRxuRHI6jT9iLDEakh+NIDxdHn7AXGYzoE/YioxHp0Ub0CXuRptQuI7rR/JYRycFGFMPROGofCA43Ij/aiGI+3IjsaCNKh+Mo6dFGlA/39ufDvf0lHG5EBR9RjpcPTe0JlfsR+dFGVA/HUbWjjUjS4UYkRxuRxsON6HAcWTjciA739tvh3n7PhxsRvz7Ktvy63NRE/BhRCulwIzocRzEebkT1cCPyo43oE77UjEZ0OI5yPtyIDvf2l8O9/Z/wpWYwok/4UlPqdUTeGVE92ojkcBxJOdyI7Ggj0nS4EenRRmSH48jkaCPyw739fri33/1gI8qBXx/VpQA/Vi33I7KjjSgejqOoRxtRiocbUT3aiHI43IiOx5EfbUTlE97+aydo1Xo/IjvaiGo63IjkaCOSeLgRHY6jT6hjG42o4COS64hE7lds6kcbkR2Oo0/4UjMYkafDjUgONqLyCXVsoxEdjqNP6KkZjegT3v5r54Hc/tuXEfnRRvQJdWyjEenRRvQJPTWjER2Oo0/4UjMaEb+DlOsxM1ru+o7KJ3ypGY3oeBz50UYk+XAj0qON6BO+1IxGdDiOLB5uRId7++1wb/8nfKkZjYjfQaot62y7r0Con9BTMxjRJ+xFRiMqhxvR4eIopcONSI82onw4jrIcbUSf0FOjy2l6bUT5fkT1cCPyo42o5sONyI42IjkcR5+wFxmM6BN6aux6SKnZT53i9z9OFi7JK1ks98O3Lz18y197+Hw4e1iW+35/WE39hM8zoxHJwUYkn3Dk2WhE5XAj8qONKB6Oo0/YEg1GlI729ks63Nv/CccMjEZUDzeiw7395XBvfznc218P9/bXo62PRA739svh3n493PpID/f26+He/k/YSo1GdLi33w/39h9ud6SH2x3p4XZHerjdkcajvf0aj/b26+F2R3q43ZHmw739h9sd6eF2R1oO9/Yfbneke++OvoMIALL3HuY7SCVAHADZe/PwHcQAECNCeO9V+zcQJ0LYgRC2vZfL30EKAQKEsO29Tv0OAoSwpUiAAPOJZSKEMxHCGZhPrBAhXIgQJpZERiyJTIgQJpZEts2SSJeTAFxvrhm+gGyzJBqAbLNaGYFs8Z6oXEEsDG6RrXq5RFbCzb9s38ezSf3FluORQ43HN1kubTmeeqzxxIPxs0nVxZbjsa3HE39/O3PxTbpcRyCb1CEMQbZ4/W25Ozq6h/L+z6VcfixyvS0g9y+Tt+s19dEHPy7ZLwc2l3JzwU6WH6FR0gv5qq/j6yaV3l/F1xd6rvJC7+smZ90cxNfqlx1MkSC/97Vuc6PwMXytMV++KdR4c8H01df6Qr4+TwwPfY3PM+eMfX2h55pe6H3NL5SH8ys91xd6X8sL5eEn2tPVstRi1BLDva81vpCvz6PBDH2VJ5pzNF7+5aq5dny11/FVnyiGR75ucgrsV/H1idYSapdBVwvx3ld/puc68vV1nmsMT7RGVAmLr6l0fH2mOWfg6zNpMENfn2jtP/I1PdHaf+jrE+kSQ1+fac4Z+LpJNeNX8fWFnusz6U1DX59pzilx2edUvff1iWoIhr4+lQYz8vWZ5teBr/pM66aRr8+kNw18tRd6rvZE76tXvfjqdq+tpfBEMTzyNT7PnCNh0Zuk7cs7vpYX8vV51v5DX9MLPdcn2qsPfX2ivfrY1xd6ruWFnqs8z169OeiLr+m+hiA90T5Hmsiy+Hoz6KuvT/S+jnx9ou/qQ1/9eXobRr7mZ1r7D319nRjOz7T2H/mankcflrj8WlINHV+fp4Zg6Gt+pjw88vV59Kahr+WZ5pyRry/0XJ+oLnzs6ws91yf6Jjn2tbyQry+0ltAXWiPqE+lNafl2JcnutbVsT7RGHPr6RHPOyFd/ojln6OsTzTlDX59Ilxj4WsLrPNfyRL0NQ1/jznPOdxABQPau5v8OskXZkKfr+fAu9Q5kk/MShiCFADEAZJNS6SEI4ckmx+AOQR5/GVMI4XI2Yvu72B3IBjcDfACkEiAOgGxwDO4HQAhPNrj86wMgCoA4EcIOvIx1g3PQUogSF5Ao6R6kECAOgMQtQjjlvIA003sQA0A2uGfqAyACgORIgBCelECAFAKECOFKvIxVARAhQliIEFYihJUI4U2WRCMQI0LYiBB2Yj5xIIQlBAKkEiBACAuxJBJiSSTEkkiIJZEQSyLJRAhnIoSJJZEQSyKpRAgTSyIhlkQiRAgTSyIhlkRb3Cc/BiGWREIsicSJECaWREosiba4Qf0DIMB8osSSaIury8cgxJJIiSXRFneGfwCkEiBECBcihIklkRJLIq1ECBNLIiWWRCpECBNLIiWWRFtcqf0BEGI+IZZEW1ypPQQxYkm0xZXaKaay/DomS/cgDoBssSQagxCeJOKZJMKTTDyTvEFaiTkt70nM2e9ANrhV8QMghCd1E09ivIKU+7RSFQDZYrUyBqkAyBYCzhgE8cQBkC0EnJjFF5Byc6D6AmIAiCcCRPYH8RAJEMKTGAiQQoAAIbzFLdEfAFEAJBMhnIkQLkQIFyKEiwMglQjhSoSwJAKECGElQnibJdEIhAhhYknkxJLIiSWRA0siCcCSSLa4evkDIA6AAEuiBmIASEoEiAIgmQjhTIQwsCRqIEQIFyKEgSVRAyFCWIgQFmI+USKElQhhJeYTI0LYiBB2Yj755SXRm1X85Y9U363qlJXPWP3yd6HvVjZj9csT/3erKeZ/eWr+bjXFfJ5i/pdnw+9WU8zXKeZ/eQL6ZiVTzMsU8zr1fukU8zrFvE29XzbFvE8xP5XZ0lRmS6FMWc28X2kqs6U4w3yaymxpKrOlPMX8VGZLU5ktlSnmpzJbmspsqU4xP5XZ0lRmSzLF/FRmSyuZzZbrBpLneme1ktlGVjpjtZLZRlYyYZVDnLKqU1bdp5xDulzKmEORO6t+jmpDiIvVzXFCF6v+8TjNXb9a2Z1VP9sMrWzGqp83cpRLyUZOKdxZ9U+DHVr5jFX/1M6c4+Up5/Y/7281iuXy48fFyrVep3tElNXlzCOrN8/0+wlRbTx9L5KnZTxxcLxVDIvLse0Glh9/O33h/td2Oc4i+vUB5lS+j6effz5xPHas8fRz5ieO52D8+MH48WPxU0I62HjkWOOJ8WDjqfR46vW4ofTTeO5/q76Ujqr79V/+dhbh/aD1siYp+TrktznyftWTlvkwpZv5sPvjuly6UW+OR2o//U6gnwQ+RGAqJ4GPEXhG4GME5jMCHyTwjMDHCCz5JPAxAs8IfIzAeubAxwjsXw1zEvhxAs+dyGMEajwJHBFoFwG63jQiLgSeEfgYgXbmwAcJPGfhEYGy/FZ+/ul3Au0k8CEC/dyJPEjgGYEPEVjDGYEPEnhG4GMExnQS+BiBZwQ+RmA6c+CDBJ564GMEnt9EHiSwnHvhBwk81ZjHCKynHthj5QyrDivn14suK+ck2GPlXN13WNFzyd5jRU9W7lmxc2busSInK/es+Dkz91g5Z+YeK6fqcc+KnB8UuqycM3OHlVP677Jyrvg7rKQzVnqsnHmlw0p50fVKvbIicsfKi5Z8arn8Nmmd//F3Cl9zyfcrFEaxSz971HBXdCcvqlFsSaGdL/KjFL7oPn9TCl9zkv0lCtUvLQTR4v2M/KIKwoYU6ovKDZtSeM7Ij1IYX/MTw6YUnouahyk8p5NHKXzR4zE2pfCMwkcpzOei5mEKz0XNoxSWc1HzMIXnouZhCs/p5FEK6zmdPEzhOZ08SqGcUTik0Jf756OXewpf9MyRTSncYEaOZheIVOqAwlr9Mvrq9ebXQTq/bpLwhcObV+jtX/42+i3OC/680Xv80qP3Lzx6C2U4+rvb75uVz1jFPGWlM1YpTlnVKaspNvIUVp7CKlNPuUxh1amnXKeeskw9ZZli/gM1HjWO3vNlKozt2+n1bdTer7UuH1pVwvU9794AoNku85uWlN7/cZvgdTmPOpbgtz//5uwHpsOtndWrsym8P/7rbQfVrmPP5UdO+8ABWAce/FdmfrV8Il4Hn+/erNXDet6z8tUz5d+1WvkiJ8v7kMVt06Xyuye/e5RjjSeFg42nHms8+WD85IPxUw7Gz8rK5/PGY8caz8pq7fPGo/R4nuv8WZd4EvgYgXIS+BCBekbggwSeEfgYgXZG4IME1pPAhwj0MwIfJPDMgY8QqGHlCsCTwA8TeO5EHiMw5pPAEYHv3EPQCDwj8DEC05kDHyTwnIUfOf1TAy8XPxuB507kMQLLGYEPEnhG4GME1jMCHySwnAQ+RKCcEfgggWcOfIzA85vIowSeO5HHCLRzL/wggaca8xiBfuqBPVbOsLpnJZ5fL7qsnJNgh5V4ru57rJxL9h4rfrJyz0o6Z+YeK3aycs9KPmfmHivnzNxhpZyqR4+Vc2busXLOzB1WTum/x8qp53dZOWOlx8qZVzqs2IuuV967CUPTi5Z8bncThqb4mku+7Q7QbxS+ZsbaksJ0vsiPUvii+/xNKXzNSXa7wwE1vaiCsCmFryk3bErhOSM/SmF9zU8Mm1J4LmoepfBFD8fYlMJzUfMohS9aDLopheei5mEKz0XNoxTauah5mMJzUfMohS961simFJ7TycMUntPJgxTmcEbhY9c4aH7RM0c2pXCDGXn2PgOxdB19/z4DlcuBFarXYbwdbf1t9FucF/x5o8/5K49+C7H+E0ffFzZ0KaTIWn0w+vYV6DKgt79/Oqf9G8hKL/zGIAqASCJACE+U8GRlt70tiBUCxACQlV7BjUGA6Cori7ptQVaqbjYGARJkSYQniXgmGUj1pWziidgV5Oa+kAuIbvGe3NxJot9m89+B+BZpJapeQez3d/hoDVuk+pSuntyuUbo/l3K5MEVEr/uD7uUqfl37hOiDH5eWIy/7gxLtp19/99Vex9eYX8hXfx1f0ws91/RC7+sm26CD+FqXC6eKBLn3VZ7nubY8e7lMskYr975qfR1f7XlieOxreSFfX+h99Rd6rv46z1XC86ybxr6+0HONz7N/Hfsqr+NreqK1RAmLryWGjq9PNOcMfX2evfrQ1/xEc47G5Zrj9jnt3tcSX8jXJ4rhka+bfDn9Ir7KE60l1C7DaNvy2PH1mZ7rwFd9oeeqT7RGbDuZxdfUWSPaM805I1+fSEcc+vpM8+vAV3+mNeLI12eac973VZ/ou/rY1xd6rvF15hyNzzTnlOVWv/ZR7t7X9EzPdeTrE+nDI1+fSoMZ+fpM66aBr6W8kK8v9FzrE72vXpfLoN3u9ab2YF/I1+eZc9r31cswJMZODNvzrP3Hvj7P2n/oq7/Qc32ivfrIV3uivfrY1xd6rk9UGzL0NT/PXr056IuvKXR8fZ71sMSii6+S730tT/S+jnytT/S+jnyV56lvGvr6TGv/ka/PtPYf+vpCucmfRx+W64kSkmpnfvXnqSEY+erhmfLwyNfyQr4+05wz8DW+0HN9ol7foa9PVBc+9vWF3tf8TGvEka8vtJZ4ohr4sa9PpDel5duVfDt48Pe+PlFv/tjXJ5pzhr4+0Zwz8vWJehvGvj6RLjHy9Yl6G8a+PtFaYuSrDS/01VgGvpZwqbWJJV0x3s73vP91+zJ4OaHGgl0VsO7wky3EpCZlX4df0o/hl689fP/Sw/evzb5/ZfYthK/Mfhv+12Y/fm32o33p4af8tYevX3r4uX7p4Y9PSz/28OVLD79+bfbr1459+crr/fZvHZt9L5cftz/L/fD90K9uDvnCfg7F74YfI//qZlmGX+394ateL3nRm+tVvm91La59Dllue8l6czVMf/S/dkONXQYfb27feLuh5vt49FjjWfus8GnjkWONpx6Mn3owfuRg/Eg92Hj8WONZawv7tPEYPZ5D3CCWFlk5pZzf/3FdqgdrsduffiPQ0kngYwTqSeBDBPoZgQ8SeEbgQwSmcEbggwTKSeBDBMYzAh8k8MyBjxG4dnfPSeBHCTx3Io8RmMtJ4IhAWw6osXRP4BmBjxFYzhz4IIHnLDwiUJbfys8//UYgLxc/G4HnTuQxAuWMwAcJPCPwMQL1jMAHCawngQ8RaGcEPkjgmQMfI/D8JvIogedO5CECczj3wg8SeKoxjxEYTz2wx8oZVh1Wzq8XXVbOSbDDSj5X9z1WziV7h5USTlY6rJwzc48VP1m5Z6WeM3OPlXNm7rAip+rRY+WcmTus6Dkz91g5pf8OK6ee32XljJUOK37mlXtWSnjR9Uq9siJyx8qLlnxqufy2fWqe//E3CvNrLvl+hcIoVi7+abgruisvqlFsSuH5Ij9K4Yvu8zel8DUn2V+iUP3SQhAt3s/IL6ogbErha8oNW1L4otrEphSWk8JHKTwXNY9S+KKHY2xK4bmoeZTCFy0G3ZTCc1HzIIU1nIuahyksJ4WPUnguah6l8EXPGtmUwnM6eZTCdE4nD1N4RuGQQs+Lf17uKXzRM0c2pXCDGfl6oV+8vfaoT2GtfvmnxdJ19O1B9EiUy4EVqtczZ95Ojv42+i3OC/680dfylUe/hVj/iaMfChsWRhd+7XiuuWW/jN48vP/jGIvVJYe1eeX259+c1f7XvbYeX5wVe9/ZYvny9atYSe+PqCFeTpW3enMF2TKeftKxpMt4yoj8DY8hritC4eeNR481Hj8YP34sfiQcix9ZOdDz08YTw8HGUw82HqfH81yHD8pKA+lJ4IcJtJPAhwjMZwQ+SOAZgY8RWM4IfJBAPQl8iMB6RuCDBJ458DECpZwEPkbguRN5jECtJ4EjAt87hFr0jMDHCLQzBz5I4DkLP3T0m/By8bMReO5EHiJQwxmBDxJ4RuBjBMYzAh8kUE4CHyIwnRH4IIFnDnyMwPObyKMEnjuRxwgs5174QQJPNeYxAuupB/ZYOcOqw8r59aLLyjkJdljRc3XfY+VcsndYWTlA89VZOWfmDiseTlY6rJwzc4+Vc2a+Z8XCqXr0WDln5g4r8ZyZe6yc0n+HlVPP77JyxkqHlXzmlQ4r5UXXK+8eg24vWvK54THopq+55Nvw9GR7UY1iUwrPF/lRCl90n78pha85yW54MpS/qIKwKYWvKTdsSeGLahObUvianxg2pfBc1DxK4YsejrEpheei5lEKX7QYdFMKz0XNoxSWc1HzMIXnouZhCs9FzaMUvuhZI5tSeE4nj1Io53TyMIVnFD54hre/6Jkjm1K4wYw8e5h19Xrz6+5h1uLLcdA3r9Dbv/xt9FucF/x5o/f6dUfvYQux/hNHPxY2tNyO/ptVzFNWOmOV4pRVnbLyGas8xUaewipTWGXqKdcprDr1lGXqKcvUU5Yp5j9Q43Fz0v2XvjCgOdulqIR0yVMlxoGztV58lXDD5g+A/iFVWwLs7YHv7UH/Q/p2ALE/c20JsLcHcW8P+lPWhgD9ot4tAWRngH6p6ZYAQw9yGiXemOKyCf1piSW9zUKO4XJ9SY43F8307zrJ9bKzsKz2+1Tacv7XHn790sOvX5v9+rXZl6/NvpQvPXz92uzr1479lYJmt4tV2wzk3+8y4kpT8sBqpWl3ZFWmrGzCKq2oJCMrnbGKccpKZqxSmLIqU1Y+Y5VX1sh5eY2ChcH6TC8bUQn59+uzlG1ngJL2BpCdAWrcG2BvD9Zm8u0A+nNtXGSNEusg2294RWEbT18/iMvJ0SWFOBiPLFdQFtEwGk+oy3hSvBuP9vlJqS7jqQOZOYXLw0q3V1teAGxnAMt7A+zsQY4bACxyYUvndwB9TfjXAMrlhUk3N81dAMrOgkkuOwsmuaa9AR4XTJLE5SGI3ui8Qb9jSAQwAD8U8GO8DXgcwwKAAfjhgB8b6N5jDN8do2ygfo8xbH+MCPixgQw+xEiP5xJZVqNSrytM9x8AsjNADnsD7O1B2duDsrcHdW8Pat0ZQPb2QMreALYzgKa9AfYOU9s72QGrjQKsNorv70cNAcAoAMb+q6YaAT8i4EfKAMb+q7+aE4Cx/+qvFsCPsv+OuO69/qh7rz9q9Z0BJO8NoDsD6N4e6N4eWNobYG8PPO4NsPeL5ju/aBLy3gA7L/QlPh6m0cJyXJFFu4fYOVAlpb0B9n4Keec3QfaWHWRv2UHq3g+57u3B3rKDyN5RJHvnU91ZOBHb+xnsPSuv3Py7JcDOyU5D2RvgcQ8sLlfQWza/hfilH38bzwZz7Lbj0WONZ/xdYvMyxFAuH6hzqHfNOZrD4UZUjzaicrinVuxoI6r5cCPyo41IDhfZcjiO9HBxpId718aCy5GL2dW+dA+Wevzaw/+EJLQc2pLjzSK2304coi6Ha4QUyu8dsBC+ugNf/gn4F3dg/OHx6A589SeQeAfScnRQvi18XnFAoiwOSNY7BzK/TslheQJ5NAu0QZsvDmjM9w4o/wSWk2maA3XkgLotDli5a2KwT9iVbeyAfHEHPqEfemMH6hd3QL76E9D01R346mnUvvoTsK/+BPyrPwH/4k/AwxdfSnj44ksJj198IvNP2FJu7IAfyIFvI0r5cCOyo43oE05Uup47mMtwGxrT0uMeYw53WrZ/wh5iYwfKV3fAv7gD8tWfwN7fvL6DKACy92biO8gWi518vXgylptzxy8gXnYHiSGEhKAogdI/KamU5SiSUtLo7Grz5TD49rdcjznJIV5gHIFZWXxsDmMIzEqz79YwK7W3m8NUBKYyIdA/43pzGEkIjDIhsFI+uzkMk2yM8caYZOPMe+OIN2sHW28Og2SBGBMDw3iTGG8SMnuuHX69OQyS02Jh3pvCZAFmLRAr4w2zFojCZAFlvFHGG2OygDE5zRlvHPEmhcDAIPubFBlvIuQNMq2tnLa8PQzjTWa8yci0lpglx9oBzJvDMO+NMFlAGG8Y+SEx8kNi5IdkyMomMWuBxKwFcogMDOMNsxbIzFogJ8abBHmDZIHMrAUyIz/kwnjDyA+ZkR8yIz9kYbxh5IfMyA+ZkR+yMd4w8kNmlhyZWXIUZslRGPmhMEuOwiw5CrPkKIz8UJglR2GWHIVZchRGfijMkqMwS47CLDkK88WjMEuOwiw5CrPkKMwXj8IsOQqz5CjMkqMyXzwqs+SozJKjRsgbZFqrzJKjMkuOyiw5KvPFozJLjsp88ajMF4/KfPGowoQAsxaozFqgGhMCxiQbR5KNhMTAIEsOYfoIhJk9hekjEKaPQJg+AmH6CITpIxBmJy1MH4EwO2lhPuQL8yFfmA/5wnzIF2aLK8wWd+2Q7s1hkAytEUk2awdZbw6DZOi1Q7A3h2FCoCQGBkk2ymwK106L3hpGmGTDbApVmQzNCMTKbAqVaY9Tpj3OmE2hMcqtMcqtMZtCS0iGtowkG2M2hcYUjllBko0xm0KTyMAwyUYZb5RJNsa8NwZ5w7w3jHJrjnjjTA+7M1tcj0gWcKaiy5ktrjNbXGc+rzpT0eXMWsCZii5ndGhnKrqc0aGdqehyZsPuzIbdmQ27MxVd7kzqdGIieDsLjIFRBAY5z+bt8AcEBlHV35pxERhkLfDWS4LAFOa9KYw3lXlvKvPeCOONMO+NMllAGW8Q+eFN6UJgnPHGmdSJyA9vSY2BQVJnRL6wt/9hvEGO0GswyEQQM+MNUgYXY4kMDONNDQwMMhFEYbwRJnUKMxEo440yqdOYicAYb5xJnY5MBAkpiW8wSOpMSEl8g2G8QT6sNBhkIkg5MzDMe1OY94ZZC6RaGBhk9kzChAAjPyRGfkjGhAAzSSekdjBm5KCZBoNkaOZsuwaDhEBmNuyZ2bDnzIQAUi8QmUPnGgzjTWWSTWXeG2G8YSZp5tC5yBw6F7Mx8w1SLxAzI95npMA/FqZeoDDifWHqBQpTL1CYtUBh6gUKcv9Ng2G8QdoVGgyygCrMhr0wG/bCbNgLI94XYVKnMhMBsxYoTL1AYeoFikPeIO9NDch7U5m1QGVU9crUDlZmLVCRdoUGg7w3lVkLVEZ+qIz8UJm1QGXkh8rID8yhc5E5dC4yh87Faow3jPxQnZkIkNN5oiAH0DYYZCIQ5lOExMLAIBOBJMYb5Ai9KEy9gDBdEcLUCwhy1lAUpitCKpM6kUMZGgzjjTKpU5mJgOmKEKb6QYyZCJgPK8J8WFHmw4oytYOKnJwUlakdVGYtoEy7gjK1g8p8ilBGflBGflCmdVGZSVqZ2kFVJgSYAn9lageV2bAbs2E3ZsNuTLOfMfUCxtQLMOcORmPqBYypFzCm2c+YSdqYegGrkDfIfGNMvYAx4r0xBf7G1AsYI94bUy9gTL2AM2sBD4WBQbKAM+K9M+0Kjhx13GAYb5gNuzMbdmfEe2fOF3DkkroGw2QBpl7AmXoBZ2oHnakXcKZegDl3sMEw8w1SO5gCshZoMIbAIPJDg2G8QeSHBqMITGa8QeSHFBD5ocEw3iDyQ4OpCIww3giTOoWZCJTxRpnUacxEYIw3zqRO5KyhFJGzhhoMkjojUi/QYBhvkHqBBoNMBDEz3iAHNzcYZCKIhfEGObg5ReRQhgbDeCNM6hRmIlDGG2VSpzETgTFZwJn3BqkdTMy5gykh7QoNBpk9E/IposEgySYx8kMqTAgwk3RCagdTqkwIIAX+DYZJNsyGPTEb9sRs2JMzIYDUC6SM1As0GCQEMnK+QINBkk1mtrg5IRk6M1vcXJgQYFT1jHxhbzBMCCBf2BsMk2yU8UaZZGPMe2OMN8wknZEC/7YhiAwMMt8UZotbmC/szIGADQZ5bwqzxWUOBGw7XOa9YdYCzIGADYbJAswXduZAwAaDLKAKs2EvzIa9MBv2wnxhL8wX9sJ8Ya/MWqAiBf6pIgX+DYbxhlHVK1LgnyqzFmAOBGwwzHvDrAWYAwEbDPPeMGsB5kDA9sGDyQLMWoA5ELDBMLMnsxZgDgRMwsgPwnxhZw4EbDDIRCBMtR1zIGCDQSYCYT5FMAcCJimZgWG8QQ4EbDDIRCBMtR1zIGASZSYCptqOORCwwTATgTPeOJM6mdZFDYWBQVKnMq2LynxYUebDijIfVhS59qDBMO8NUzuozFpAkcOBkzK1g8p8ilBGflBGflBjQoCZpJWpHTTkON0Gg2RoY2oHjdmwG7NhN2bDbpkJAaZewJh6AWNqB5kDAZMx9QImkDfMe8PUC5gy3jD1AsbUCxgj3jMHAjYY5L1xRrxnDgRsMMh748xagDkQMDlym0+DYbxh2hUcuc0nObNhd2bD7syG3Rnx3pVJncpMBMxawJl6AWfqBRypHcwBqRdoMILAIGuBzBwImANSO9hgGG+QdoUGw7w3hfGmMO9NZbJAZbxB5IcGUxEYZbxRJnUi8kMOxnhjTOp0ZiJATufJzIGADQaZCGJkvEEOBMwxRQaG8QY5ELDBIBNBLIw3SL1Ag0EmglgZbyqTOpFDGRoM440yqVOZicAYb4xJnc5MBMiHlZyQDysNBpkIElI72GCQ9yYhtYM5MWuBhLQrNBhk9kyFCQFGfkiM/JCECQFmkk7KJBtjQsCYDO1MsmE27JnZsGdmw56RZr8Gg2TojNQLZObcwZyReoGGwrw3hfGGmaRzZbJAZbxB6gUaDLLkyIx4n5V5b4x5b5gtbmY+5JeAhEBh5G7mQMBckFN72zyQGRhkkmaO0MuFUW6Zs+0aDJMFlAloZrfGnAaXCyNCVmYbxRzTliujDjLnp+XKqIOV2XhU5hNeZWQ75sSxXJlynsp89KrGBDTzNaoyBTDM4VkNBkmdwhTDCvP9RpgqVWFqOZhzoBoMkjqF+bAizIcVYQouhSlLYI40ysKIKcJ88VCmXUEZMUWZTxHM6TxZGTFFmWo7LUxAM2IKc2xOZo7NycqIKcoUjjHn2TQYJHUy59lkQ657bzBI6mQOmmmfbxIDg6ROQ06Jz1aZgGbEFGO+ezJnpmRjxBRjlurGiCmGHAuanVmqM6eMZEdOHGswyHzjjJjiyFFgDQaZb5wRUxw57brBMJHGLNWd+e7pzHdPR5bqJSDfPRuMIzDIUr0wZz+UgHz3bDCGwCDfPQtzWkL715iARr57lqBMFjAmoI1JnchSvUTku2dhOvJLRJbqJSLfPRsMkjqZHvYSCxPQyHfPEpGleonCBDTy3bMw7dglGhPQzqRO5LtnSYiYUhLy3bPBIFkgIWJKSch3z5KQ754Nhglo5LtnSch3zwbDBDQippRkTBZwJqAZMSUj3z1LRr57NhgkdTJNsiUj3z0L071aMvLds+TKBDQjpjD9noXp9yyZEVOyMVkAuWmp/XORgUGyQEHOHWz/RmJgkCxQkDOIS2HElFIDA8MENCOmFGWygDIBzYgpBTlav8VzYGCQ1FmR0+BKRU6GbTBI6qzIMW2lFiagGTGlIrfHlSpMQDNiSlUmCxgT0IyYUpEzU4og53UWYcQUQc5MKYKc3V2EEVOEWaoLI6YIU5kizFJdGDFFmMoUYZbqwogpwlSmKLNUV0ZMUaYyRZmlujJiijKVKUy/Z2H6PQvT79lgmBBAisiLKpPTlAkBpkRRGc1GkW6iYkyJojGajTE7AmN2BExbaYNhIq0wkcZ8XjXkFMUGwwQ083nVkG6iBsMENPN51ZluIuby+gaDpE5nuok8RwYGSZ3Mde/Fmc+rztSqOyPeO/N51ZladWcqIZ0R75m20srcXF6ZttIakFtJakDOF6jMleI1IF9xGwwTAsiOoAZkR9BgmBAQJtkg3wgaDBMCxiQbZzI0M9/EgCSbiGw8GgwSAhHZeDQYJENHZr6JyMajwSAZOjLzTURasBoMkqGZq5FrNCbZGJOhmfkmIp8iKnOZcE3MfJOQTxE1IZ1eNSFCV2Vu+a2pMJGGXCBYkzABzWw8mOt3GwzzejITQXIm0piJICN9BDUjxUk1MwpURvoIamZ2BJnZEWRmR5CRPoKahSFNmYBWJgsgd6/W7AxpyLE5lbl7tRakj6Ayd6/WglQN1YJUDVXm7tXK3L1ambtXK3P3amXuXq1FGdKMCWhjsgBSNVSZu1drZcSUilQNVebu1crcvVqZu1crc/dqZe5ebTAMaYyYwty92mCQtUBFOr0qc/dqFaTTqzJ3r1ZhPq8K0ulVmbtXK3P3amXuXq3M3auVuXu1JWiGNGUCmqmzEeRQhsrcvdpgkIBW5rsnc/dqZe5erczdq5W5e7UyvbgNhiGNkbuZu1cbDLIWYO5ercrI3WpMFmAqIZm7Vytz92pl7l6tzN2r1ZjKFKZJtjJ3r1ZjKlOYu1erMXK3MZUpzN2rDYYhjZG7nemNcuTYnMo0yVZHziBuMEgW8MyQxsjdTJNsg0GygAtDGiN3O1M76EzTkiO1g03tDgyMIDDIeTbCdK8K070qTPeqBOR27AbDkFaZgBYmCyBnELdvXgxpxgS0M1kAOYNYmLZSiYjc3WCQLBBTRWAQubvBIFkgIrWDwvR7CtPvKUy/p0RlsoAxpBkT0IiYIgmpHWwwCGkJkbslIbWDkpDawQbDkFaYgEZqBxsMshZIwpCmTEArkwWQRkxJSO2gZETubjBIFmAaMSUnhjRE7paM1A4K04jZYBjSKhPQwmQBpBGzwTCkGRPQzmQBpBFTClI7KIWRuwtSOyhMI6YURkwpjNxdkNpBYRoxpTBiSmHk7qJMFkAaMRsMQxojd1ekdlCYRswGw5DGyN0VqR0UphFTKiOmVEburkjtoDCNmFIZMaUycjfTiCnVkbWAMGKKMHI304gpgtQONhiGNEbuZhoxRZDawQbDkMbI3UwjZoNB1gLCiCnMpajCNGKKMrWDyogpzKWowjRiijK1g8qIKcrI3UwjpihTO6iMmKKM3M00YooytYPKiCnGyN1MI6Ywt5WKMWKKMXI304gpxtQOMreVijFyN9OIKcxtpcLcVirMbaViTO0gc1tpg0FIc0buZm4rbZu1wMAwpDFytzO1g87UDjojpjgjdztTO+hM7aAjYooy14g2GEVgkNpBDYjcrUwjpgakdlBDYUhD5G5lGjGbBslkAWVIUyagjckCzqROpHZQIyJ3K9OI2WAcgUkMaYjcrRE5d7DBIGuBWBnShAloYbIAUjuo0RjSnAlo5NxBTUjtoDI3YipzI6YyN2IqcyNmg2FIK0xAI+cONhhkLcDciNk+sDMBbUwWQGoHNSG1g5oRubvBIFkgI7WDmhkxJSNyd4NBskBGagc1M2JKrkxAC5MFkNrBBsOQZkxAO5MFkNpBLYyYUhi5uyDnDjYYZC1QGDGlMHJ3Qc4d1ILUDmphxJTCyN1FmSyA1A5qYcSUwsjdNSBZoCK1gw2GIY2RuytyZ3GDQdYClRFTKiN3V+TO4gaDrAUqI6ZURu6uxmQBpHZQhRFThJG7BbnEQQWpHVRhxBRh5G5BLnFQQWoHGwxDGiN3izJZAKkdVGHEFGHkbkUucWgwyFpAGTFFGblbmdpBZWoHlRFTlJG7lakdVKZ2UBkxRRm5W5naQWVqB5URU4yRu42pHTSmdtAYMcUYuduY2kFjageNEVOMkbuNqR00pnbQGDHFGLnbmNpBZ2oHnZG7mUZMdaZ20JnaQWfkbqYRU52pHXSmdtAZuZtpxGyLzsDAMKQhcrcxjZgNxhCYyJCGyN0NxhEYpHbQQmFIq0xAI+cOth1uQWCUIU2ZgDYmCyC1gw0GIS0icrdF5NzBJtkEBoYhDZG7LSLnDjYYZC0QK0OaMAEtTBZAagctGkOaMwGNnDtoKSBrgYSIKQ0GCeiEnDtoCakdbDAMaYUJaOTcwfbBIzAwDGnKBLQxWQCpHbTEiCkZkbsbDJIFMlI7aJkRUzIidzcYJAtkpHbQMiOm5MoEtDBZAKkdbDAMacYENHLuoBWkdrDBIKQVRu4uyCUODQZZCxRGTCmM3F2QSxysILWDVhgxpTByd1EmCyC1g1YYMaUwcndFLnGwitQONhiGNEbursglDlaR2sEGw5DGyN0VucShwSBrgcqIKZWRu6sxWQCpHTRhxBRh5G5BagdNkNpBE0ZMEUbuFqR20ASpHWwwDGmM3C3KZAGkdrDBMKQxcrcytYPK1A4qI6YoI3crUzuoTO2gMmKKMnK3MrWDytQOKiOmKCN3K1M7qEztoDFyN9OIacbUDhpTO2iM3M00YpoxtYPG1A4aI3czjZgNBkmdxtQOGiN3M42YDQZZC3hASHNG7nbk3EFzpnbQmdpBZ+RuR84dbD9A1gLO1A46I3e7MlmAqR10pnbQEbnbA3LuYINxBCYypCFytwfk3MEGowhMYUirTEAj5w56QGoHPShDmjEBbUwWQGoHPSJiSoNBAjoi5w62DUFkYBjSELnbI3LuYINB1gKxMqQJE9DKZAGkdrBtpBnSnAlo5NxBT0jtoCdETPGEyN0NBskCCakd9FQY0goT0Mi5g56Q2sEGw5CmTEAbkwWQ2kFPjJiSEbnbM3KJQ4NB1gKZEVMyInc3GCQLZKR20DMjpmRhAlqYLIDUDnpmxJRsTEAjlzi0j1GRgUFIK4zcXZBLHBoMshYojJhSGLm7IJc4NBhkLVAYMaUwcndRJgsgtYNeGDGlMnJ3RWoHvSK1g14ZMaUycndFage9IrWDDYYhjZG7qzBZAKkd9MqIKZWRu6szWQCpHWz/HUKaMHK3ILWDLkjtoAsjpggjdwtSO+iC1A66MGKKMHK3KJMFkNrBBoNMa0wjpitTO6hM7aAycjfTiOnK1A4qUzuojNzNNGI2GCR1KlM7qIzczTRiujK1g8rUDhojdxty7qAbUztoTO2gMXK3IecOujG1g8bUDhojd5swWYCpHTSmdtAYuducyQJM7aAztYPOyN2OnDvoztQOOlM76Izc7ci5g+5M7aAztYPOyN2uTBZgagedEVOckLtTCMS5gw2GqB18g2FII+TuBkOcO/gGYwhMYUirTEAT5w42GKJ2sMEoQ5oxAW1MFiBqB1PLnJGBQQI6RiQLRKJ28A2GIS0jAR0LkgViDQwMQ5owAa1MFlBkLRCNIc2ZgHYkC6SArAVSREhLKTIwSBZIRO1ggykMaYUJ6IpkgSSJgWFIUyagjckCHhgYhLQckIDOMTIwyFogM2JKzpmBQbJALshaIDNiShYmoIXJAkTtYINhxJRsTEA7kgVKSAwMQlph5O6SkCxQcmBgGNIYubvUyMAga4HCiCmFkbuLMlnAkLVAYcSUysjdNSBZoBK1gw2GEVMqI3fXjGSBWhIDw5DGyN1VmCyggYFBpjWkEbPBOJMFHCFNGLkbacR8g0GygCSGNEbuRhox32CQ1CmVIY2Ru5FGzAajyFpAGLlbGDFFHMkCytQOKiN3KyOmaEKygDK1g8rI3cqIKVoTA8OQxsjdyogpaoGBQaY1ZWoHjRFTLCCkWUSmNWNqB40RUywzpBUmoJnaQWPEFBOGNGUCmhFTjKkdNEdI8xAYGCQLOFM76IkhLSEB7YyY4kztoBeGtMoENCOmOFM76MqQxsjdztQOMo2YMYSCwCByd4MxBAapHYwhM6QhcneDEQQGqR2MQRjShAloZbIAUjvYYBjSELk7RqR2MDKNmDFGhjRE7o4RqR2MTCNmjIUhrTIBjdQORqYRM0ZlSDMmoI3JAkjtYEyImNJgkIBOSO1gZBoxGwxDGiJ3t1ktMTDIWiBVhjRhAlqZLIA0YsZkDGnOBDRSOxiZRsyYGTElI3J3g0GyANOIGTMjpuTCBDRSOxiZRswGw5CmTEAbkwWQ2sGYGTGlMHJ3Qc4djEwjZiyMmFIYubsg5w5GphEzFkbuLkjtYCzCZAFlSGPk7mJMFkBqByPTiNlgkICuyLmDTVFNDAxDGiN3V+TcwViR2sHINGLGysjdVZksgNQOti8RDGmM3F2Rcwcj04gZBakdjMLI3YKcOxiZRswohSGNkbsFOXcwMo2YURi5WxgxhWnEjOIMaYzcrYyYwjRiNhiGNEbuVkZMYRoxozK1g8rI3crUDjKNmFGZ2kFl5G6mETMqcu5gNKZ20BgxxRi525BzB6MxtYPGiCnGyN2GnDvYYJAsYIyYYozcbcpkAaZ20BgxxRm525FzB6MztYPOiCnOyN2OnDsYnakddEZMcUbudmGyACOmOFM76Izc7c5kAURMebvaD4FB5O63y4kQGERMebteAYFB5O63A6IRGERMeTvikoFhAlqZLICIKW+nmSAwSKv8Wz82AoPUDr51lCEwSKv8W008A4OsBWJhSKtMQCO1g28fPhEYZUgzJqCNyQJI7eDbspOBQQI6IbWDb//DwDCkIXJ3SkjtYEpI7WCDYUgTJqCVyQJI7WBKxpDmTEAjtYMpI7WDKTNiSkbk7gaDZIGM1A6mzIgpuTABjdQOpozUDjYYhjRlAtqYLIDUDjYYhLTCyN0FqR1sMMhaoDBiSmHk7oLUDqaC1A4mphEzFUbuLsJkAaR2MDGNmA2GCWikdrBtPRMDg5BWGbm7IrWDqSK1g4lpxEyVkbsrUjvYYJC1ANOI2ZQhJqCVyQJI7WBiGjGTMHK3ILWDSZDawcQ0YjYYJKAFqR1MgtQOJqYRs8nQTEALkwWQ2sEGg0xrYkwWcCYLMGIK04jZvqskBgbJAsrI3cqIKUwjZlKmdlAZMUUZMYVpxEzK1A4qI6YoI6YwjZjJmNpBphEzMY2YiWnETMbUDjKNmIlpxExMI2aDYQKaEVOYRszENGImY2oHmUbMxDRiJqYRMzlTO8g0YiamETMxjZjJmdpBphEzMY2YiWnETM7UDjKNmIlpxExMI2aDIQI6M42YmWnEzEwjZg6ImJKZRszMNGJmphEzh8oEtDCkCRPQypBmTEAbQxoid2emETNHpHYwM42YmWnEzEwjZoNBApppxMxMI2ZmGjFzFCaglSHNmIA2hjRE7s5MI2ZmGjEz04iZEyJ3Z6YRMzONmJlpxMypMgFdGdKECWhlSFMmoI0hzZmAZsSUjMjdmWnEzEwjZmYaMXNG5O7MNGJmphEzM42YOQsT0IyYwjRiZqYRM2dnApoRUwojdzONmA0GCWimETMzjZiZacTMhZG7mUbMzDRiZqYRMxdG7mYaMTPTiJmZRsxcGbmbacTMTCNmZhoxc2XkbqYRMzONmJlpxGwwTEAzYgrTiJmZRsxcGbmbacTMTCNmZhoxszByN9OImZlGzMw0YmZh5G6mETMzjZiZacTMwsjdwogpwsjdTCNmg0ECWhkxRRm5m2nEzEwjZmYaMbMycjfTiJmVkbuZRswGwwQ0I6YoI3czjZhZGbmbacTMxsjdTCNmNkbuZhoxGwwS0EwjZjZG7mYaMbMxcjfTiJmNkbuZRsxsjNzNNGI2GCSgmUbM7IzczTRiZmfkbqYRMzsjdzONmNkZuZtpxGwwTEAzYoozcjfTiFkCIncXphGzBETuLkwjZgmI3F2YRswGwwR0ZUgTJqCFIU2ZgDaGNGcCGhFTSkTk7sI0YjYYJKCZRswSEbm7MI2YJRYmoCtDmjABLQxpygS0MaQZE9CImFISIncXphGzJETuLkwjZkmI3F2YRsySChPQlSGtMgEtDGnKBLQypBkT0IiYUjIidxemEbNkRO4uTCNmg0ECmmnELLkwAc2IKbkyAc2IKVmZgGbElGxMQDNiSmbk7sKIKYWRu5lGzPZvIAHNNGKWwsjdTCNmKYzczTRiNhgmoBkxpTByN9OIWQojdzONmKUycjfTiFkqI3czjZgNBglophGzJWgmoBkxpTJyN9OIWSojdzONmKUycjfTiNlgkIBmGjGLMHI304hZhJG7mUbMIozczTRiFmHkbqYRs8EwAc2IKcLI3UwjZlFG7mYaMYsycjfTiFmUkbuZRswGwwQ0I6YoI3czjZhFGbmbacQsysjdTCNmMUbuZhoxGwwS0EwjZhMHMwPDkMbI3UwjZjFG7mYaMYsxcjfTiNlgmIBmxBRn5G6mEbM4I3czjZjFGbmbacQszsjdTCNmg2ECmhFTnJG7mUbM4ozczTRi1oDI3ZVpxKwBkbsr04jZYByByQxphQnowpBWmYAWhjRlAloZ0owJaGdIQ+TuyjRi1ojI3ZVpxKwRkbsr04hZIyJ3V6YRs8bKBLQwpAkT0MqQZkxAG0MaIndXphGzJkTurkwjZk2I3F2ZRswGgwQ004hZU2UCujKkCRPQypBmTEAbQxoid9fMiCkZkbsr04hZMyJ3V6YRs2ZE7q5MI2bNlQloRkzJwgQ0I6ZkZQKaEVMyI3czjZi1MHI304hZCyN3M42YtTByN9OI2WCYgGbElMLI3UwjZi2M3M00YtbCyN1MI2atjNzNNGI2GCSgmUbMWhm5m2nErJWRu5lGzFoZuZtpxKyVkbuZRswGwwQ0I6YII3czjZjttUECmmnErMLI3UwjZhVG7mYaMRsME9CMmCKM3M00YlZh5G6mEbMqI3czjZhVGbmbacRsMEhAM42YVRm5m2nEbItOJqAZMUUZuZtpxKzKyN1MI2aDQQKaacRsu6jMwDCkMXI304hZjZG7mUbMaozczTRiNhgmoBkxxRi5m2nEbJINEtBMI2Z1Ru5mGjGrM3I304jZYJCAZhoxmwbJBDQjpjgjdzONmNUZuZtpxKyOyN3CNGI2GEdgIkMaIncL04jZPngoAlMY0ioT0JUhTZiAVoY0ZQLaGNKcCWhETJGIyN3CNGJKRORuYRoxJSJytzCNmA2GCejKkCZMQAtDmjIBbQxpzgQ0IqZIQuRuYRoxGwwS0EwjpiRE7hamEVNSYQK6MqQJE9DCkKZMQBtDmjEBzYgpGZG7hWnElIzI3cI0YkpG5G5hGjElFyagGTElVyagGTElKxPQjJiSjQloRkwpjNzNNGJKYeRuphGzwSABzTRiSmHkbqYRUwojdzONmFIYuZtpxJTCyN1MI2aDQQKaacSUysjdTCOmVEbuZhoxpTJyN9OIKZWRu5lGzAbDBDQjplRG7mYaMaUycjfTiCnCyN1MI6YII3czjZgNBglophFThJG7mUZMEUbuZhoxRRi5m2nEFGHkbqYRs8EgAc00YooycjfTiNneTiSgmUZMUUbuZhoxRRm5m2nEbDBMQDNiijJyN9OIKcbI3UwjphgjdzONmGKM3M00YjYYJqAZMcUYuZtpxGxrWyagGTHFGLmbacQUZ+RuphGzwSABzTRiijNyN9OIKc7I3UwjpjgjdzONmOKM3M00YjYYJqARMUUDIncr04jZlCFFYBJDGiJ3K9OIqaEwAV0Z0ioT0MKQpkxAK0OaMQGNiCkaEblbmUZMjYjcrUwjZoNBApppxNRYmIAuDGmVCWhhSFMmoJUhzZiAdoY0RO5WphFTEyJ3K9OIqQmRu5VpxNSEyN3KNGJqqkxAC0OaMAGtDGnGBLQxpCFytzKNmJoRuVuZRkzNiNytTCNmg0ECmmnE1FyZgGbElCxMQDNiSjYmoBkxJTNyN9OI2WCQgGYaMbUwcndhxJTCyN1MI6YWRu5mGjG1MHI304jZYJiAZsSUwsjdTCOmVkbuZhoxtTJyN9OIqZWRu5lGzAbDBDQjplRG7mYaMbUycjfTiKmVkbuZRkwVRu5mGjEbDBLQTCOmCiN3M42YKozczTRiqjByN9OIqcLI3UwjZoNhApoRU5SRu5lGTFVG7mYaMVUZuZtpxFRl5G6mEbPBMAHNiCnKyN1MI6YqI3czjZhqjNzNNGKqMXI304jZYJCAZhox1Ri5m2nEVGPkbqYRs6U0JqAZMcUYuZtpxGwwSEAzjZjqjNzNNGKqM3I304ipzsjdTCOmOiN3M42YDYYJaEZMcUbuZhox1RG525hGzLYhiAwMQxoidxvTiNlgHIEpDGmVCejKkCZMQCtDmjEBbQxpiNxtTCNmg0ECmmnEtIjI3cY0YlpE5G5jGjGbnMYEdGVIEyaglSFNmYA2hjRnAhoRUywhcrcxjZiWELnbmEZMS4jcbUwjZoNhAroypAkT0MKQpkxAG0OaMwHNiCkZkbuNacRsMEhAM42YlhG525hGTMuFCWhGTMnCBDQjpmRlApoRU7IxAc2IKYWRu5lGTCuM3M00Ylph5G6mEdMKI3czjZgNhgloRkwpjNzNNGJaYeRuphHTKiN3M42YVhm5m2nEbDBIQDONmFYZuZtpxLTKyN1MI6ZVRu5mGjGtMnI304jZYJCAZhoxTRi5m2nENGHkbqYR04SRu5lGTBNG7mYaMRsME9CMmCKM3M00YpowcjfTiGnKyN1MI6YpI3czjZgNBglophHTlJG7mUZMU0buZhoxTRm5m2nENGXkbqYRs8EgAc00YpoxcjfTiGnGyN1MI6YZI3czjZhmjNzNNGI2GCagGTHFGLmbacQ0Z+RuphHTnJG7mUbMFmhIQDONmA2GCWhGTHFG7mYaMc0ZuZtpxGyZkwloREzxgMjdzjRiNhhHYBJDGiJ3O9OI6aEwAV0Z0oQJaGFIUyagjSHNmIBGxBSPiNztTCOmR0TudqYRs+07IgPDkFaYgK4MaZUJaGFIUyaglSHNmIBGxBRPiNztTCNmEzmQgGYaMRsMEtBMI6anwgR0YUirTEALQ5oyAa0MacYEtDOkIXK3M42YnhG525lGTM+I3O1MI6ZnRO52phGzfSJgApoRU7IwAc2IKdmYgGbElMzI3UwjZvvmFRkYhjRG7mYaMRsMEtBMI6YXRu5mGjG9MHI304jphZG7mUbM9oEdCWimEbPBIAHNNGJ6ZeRuphHTKyN3M42YXhm5m2nEbP9/JqAZMaUycjfTiOmVkbuZRsz23yEBzTRiujByN9OI6cLI3UwjZoNhApoRU4SRu5lGTBdG7mYaMV0YuZtpxHRl5G6mEbPBIAHNNGK6MnI304jpysjdTCOmKyN3M42YrozczTRiNhgmoBkxxRi5m2nEdGPkbqYR042Ru5lGTDdG7mYaMRsME9CMmGKM3M00YroxcjfTiOnOyN1MI6Y7I3czjZgNBglophHTnZG7mUZMd0buZhox3Rm5m2nEdGfkbqYRs8EAAZ0D0ojZYAi5+w2GIY2QuxtMZkgj5O43GIa0ygS0MKQJE9DKkGZMQBtDmiMBjTRitv8TIwPDkJaQgEYaMd9gkIBGGjHb/6lMQFeGNGECWhnSjAloY0hzJKCRRsw3GCSgkUbMBpMyA8OQlpGARhoxG0xlAroypAkT0MqQpkxAG0OaMwHNiCk5IAGdGTElp8jAMKRlJKAzI6bkwgQ0I6ZkYQKaEVOyMgHNiCnZmYBmxJTCyN2FEVMKI3cXRkwpjNxdGDGlMHJ3YcSUwsjdhRFTCiN3F0ZMKYzcXRgxpTJyd2XElMrI3ZURUyojd1dGTKmM3F0ZMaUycndlxJTKyN2VEVMqI3dXRkwRRu4WRkwRRu4WRkwRRu4WRkwRRu4WRkwRRu4WRkwRRu4WRkwRRu4WRkwRRu5WRkxRRu5WRkxRRu5WRkxRRu5WRkxRRu5WRkxRRu5WRkxRRu5WRkxRRu42RkwxRu42RkwxRu42RkwxRu42RkwxRu42RkwxRu42RkwxRu42RkwxRu52RkxxRu52RkxxRu52RkxxRu52RkxxRu52RkxxRu52RkxxRu52RkxxRu5mGjFjQOTuyDRixoDI3ZFpxIwBkbsj04jZYJiArgxpwgS0MKQpE9DGkOZMQCNiSoyI3B2ZRsyGggQ004gZIyJ3R6YRM8bCBHRlSBMmoIUhTZmANoY0YwIaEVNiQuTuyDRixoTI3ZFpxIwJkbsj04gZU2ECujKkVSaghSFNmYBWhjRjAhoRU2JG5O641oiZtSwwOb0PUyTEy48l3Pw4/cBYWadvi2H7Y6zk/20xAD8y4EcJAEYFMHx/jFoADCCuRPbH0ARgADnRAD8MeB6+f24vcYt8lcOCkfM9Rt7AD81++bGW0MGo+2OUBGDo/hgV8KMCfkgBMHx/DM0Ahu2PYUBceQAwZHeMtZs+t8UA/IgBwNg/t691e/4ahtiCofEeY4t1otpl11kslHsMSQCG7o+hEcCoAIbvj2EFwABi14HY9f1jV0IEMPaPXdkkt48wCoCxf+zKFvrVEAOI3QzEbgZitwCxW4DYLUDsViB2KxC7AsTuFjrcCEN/NXZ/mJU5M58yszxnplNmv7w0+GEmM2YawpxZnTObegAa85yZTZml/gMosoRy2/6/H/cpxMseLIV0vwfTJPtjrBUAbIoB+FEAPwrgRwX8qIAfEgCMCmD4/hhr5cVbYqzVFm+KYftjOOCH7/88LCQAY4v3XOKCIfffyywGAKPuj5EAPxLgRwb8yIAfBfBjZb+6LYbvj1Hz/hgSAQzdH0MTgAH4YcDzMGD+8A3e87jUdLQ/exgFwPDdMTwUAAPwIwJ+RMCPBPiRbH+MnAEM3R+j1P0xttifDzFkfwwB/BDgeej+88fqyQm/hJGWvVrMd7UQKWyxV4tFFgwJ9xhb7NWiL340kA6G7I+RMoBh+2PkAmD4/hhF98fYJO+OMDZ4z5PXBcN7GL4/hhQAA/BDAT8U8MMAPwzwYwvtdYhhu2PELbTXEcYWc+0QQ/bHSHF/jC32Bqlec7vcr6/iFrld/PJNOGmsHYwN3sH2YeCCYSHfY0jeAkMXjNJ5HlusqYcYsj+GJQBD98dwwA/f/3mkLfKuXnNJp1aoYdj+GFt8jxphbPE9aogh+2NsUV8yxPD9McoWeVfygiG1g7FFLpFlHvR4Pw+mWvbH2KL2Y4gh+2NoBDAAPwx4Hlt8K7LlBIn2z3Xmj03mwRGG746RQ9kfY4v9xxCj7o+RAD8S8DzW9MSSFozbKaGHYUuZ9O0bKNb5adbl6Jas6bqNyCX/GE9OBxuPHms85WD8lIPxUw/GTz0YP3IwftbWS581nrW11aeNpx5rPGv1up82Hj/WeNZqej5tPMfip4RjxU8Jx1r/lMTyY+Hy2/andsZT2Hzo4XJEUfbYHc+m+fCmOr2N5ztCDbsj7O6D7O6D7O+D742gZXeE3X2w3X0w2xvB8+4IujNCDWl3hN19iLv7EPeOpZr2fh9qDrsjbJBbNSwI+f0519UuaxK3m/KjZTglHGs45VjD8UMNpx6LnZWFSF06BEuL9veHk3O4/Dg3+fifv5cw60pZ2bYYvj+GAn4o4IcBfhjghwN+rJSVbYkhK1vubTF0f4yVzzqbYqyUlW2LIftjZMCPDDyPEgCMLd7zGheMmjoYtj9GzQAG4IcAfgjghwJ+KODHSrnithi6P4ZHAMN3x1g7vmpTjBgADMIP4HmkAmBs8Z77FcM7GDkBGLo/RgH8KIAfFfCjAn4I4IfI/hgaAYy6P4ZlAMP3x9hkfz7C2N8PCxnA2H/+sLSBH2X5cS7pvpzXttirlbx8824fezsYG3BVbPGjhvuyS6tlfwyJAIbsj6EJwND9MawCGL4/hm/wntflu0H7s4ehu2N4SAAG4EcE/IiAHwnwIwF+bKG9DjFkf4wttNchhu2PscVcO8Tw/TG22Bu0z9ULRr1fX/kWud1tOaI8hNrBePwdLMGX79nB79rRcwhxC4xL23CJWToYsj/GBjrcGKMAGL4/RgL82ECHG2JsoMOVsOSSBlc6GLY/Rqn7Y9QAYMj+GBIBDN8fY4NvXiXWvLwftXYwdAuM5ccpxHuMDb55jTFkfwwPAEbdHSOGAGAUAGODvHs9TrHB3c8fcYv5fISxQZ3MGEP2x9hirh1i6P4YBfCjAM9jrflmOQWlwdn7GBu2Y7XxlIONx481HjkYP3IwfvRg/OjB+LGD8bPW7PRZ41lrjfq08eihxpNWaqE+bTwxHmw8cqzxpIPxkw4WP/lY659UWH4G7ehvRefoeAbt6G8FuFuO574Z8K30b3eE3X2w3X2w3X3wuDuC7IyQQ9wdYXcfYtgdoe6O4HsjpLI7wu4+5N19KLvHUtn9fahpd4QNcutmLcV59QSzzxqOHGo4Go81nGOxY+zy0fKyvLaS7pePGZYbhuPxg/EDyw1my3LfLN6Pp4R4qO1HCXqs8cRysPH4scYDyw3D8cByw3g8R+PnYPFTjiV/FNm9RLRhFADD98fQDGDo/hiWAIwNypsl2gVD0n2pUt2ijVqubbtS78tQ6xZHfWhZMPS+ZDevnUf2Sxi23ALa1mQdrjYoFxxibNG2a3l55ibawfD9MWrdH2OL1q4hhuyPoYAfCjwPA/ww4Hls0VI7xNjiHUzpmkvuS0Rli9w+wtii7WqIoftjbNG2O8Sw/TEy4EcGnkfZIJd4vC7c79uoG4bvj7FF29UIY4ujJYYYGzxzv+ZEl84zN9sfw7fgarmpuoT72+iyblCmPcbYoq0k2IJxfwRA1k3arkYYhB++P0bS/TEywNUW7a7vtz42DNkfo2YAw/bH2EL3GWL4/hgK+KHA8/AtNJnrBxbx+3fQNmjbHWMAfmzQgjPG2CB2NV61pVvh+IKxRU4cYpT9MbY4Sm2IscE6UWtZMPReF7Ut1rtDDMCPLXSfgS66yZE+I4wtjjofYvj+GBu0cI4wfIu9wRCD8GP/5+HR9sfY4vju949raxhbHEe1tIO/fae7x9jkSLgRBuDHFuv294+2y5scUzPC2ORIuAHGFvPHEEP3x9jiW+oQA/DDgeexxRz1PkYJkb0dd1D/1sajxxpPOhg/ib09eFAfWMK2d4M9Wp/TxiPHGk/JBxuPHWs8W9zetel4/FjjkYPxIweLH03HGs/a7dyynAJSLL0/npSW4sb2p9zP2Ws165ti2O4Yce0G0U0xZH+MtRb4TTHq4xg5Xb4HpXxfj1biWvvZL2FIXDAk32PUDfwoSw1iKhI7GBu8gzVfFtlv92/eY6y1QW+JoRvEVS3LM6+qHQzbH8PK/hgrx75ti1F3x0ghABj7P48UAT8i8DxSBjC2eAdzuuaSeo+xRW4fYZQIYMj+GDUBGLo/hgB+CPA8dINcIumycH+7KrSDYftjWN4fwyOAscEzl2tOFL1/5jkWAGODZ67LVatJ4/0aLifZHyNv8Mx16R1KKqGDIftjFMCPUvfHqHl/DAG42iK3i5dr7HbeQU0Ahu+PscUeZ4SxxR5niFF3xyghABj7P4+SNojd9lAXLSOEDobuj5EBP0oAMLbQltJVW0p2jyEZwND9MRTgyjZ45kWWd7Dc9023f6Duj+GAH75BvhroonWLvDvE0P0xYgIwbH+MLbSlIQbgRwaexxZ7gxFG3YCruPT8p9jZO9ctNJkoecFQ72Do/hgK+KEb7D+u1y80uPs1Q7UEYPj+GFvMHwMM2WL+GGLU/TEi4EcEnscWc9QIY6VmOuvSOtW2D+9jFJWlD1E1djD8cYxrj3n78z6XyErN9LYYgB8r3w02xViZo34NIyxX/lnuxNWKpr8tRgUwfGOM+72BWAEwAD98Az90KdZqcPda+Fo//rYYuj9GTACG7Y+xssfZFgPwIwPPY+Uby6YYdYPnIfmiw7U/cwdjg/dDZGlykI5eolL3x9hijhpilG0xPHUwfH8MA/zYYo66fhNucJ3n4XV3DAsJwND9MWIGMGx/jAT4kYDnsVIHsCnGSv9ISst5vKn6YM+ZLsvEdLv7sB8IK9VXv4QgSzH17X5zQdC9EWR3H1bmpi0RbG+ElXqoX0Ko19KY1EGwvRF8dx9ct0SwcIfgYYNo9UVav+1euCDEDaJ1OUA5uXYQ6t4IaXcfku2NkLeI1qVoyK2DYHsjlN19KLv7UGVvhJX6sC0RdvdhZW+0JYI/jlD8PQQruyPs7sMWM9B7CDVsMQMNEGRvhH5uzbasdrOVAUIMyxfRGONVWYmSer+uy6ebcF035LeT/+9+q14ujqr79V9Opp1f5+UCqnLTJ/h2U9o9Kfm6ms83p1G0H/+gxU5aOrSUM1q6tOhr0hKXSoic5J6W/p74pEVOWjq09O8oOmkpJy09Wl50gh7QomfK7dJyptweLf3rcE5azmjp0dL/yPjqtMT+XaFZF4isN+N5lT1R7B+xd9JyRkuXFn9NWga5pV//e9JiJy0dWlb0lpenRU5aOrTIi07QI1rOlNul5Uy5PVr6l4WftJzR0qOlf8T/q9OycrJjFpWFltsDpLq0lHAp5YolXWuIovZ+bWG5X8BCvX4V756erLY0AqrpTz/+MXw/9vCX+0z6w48HZ385y7/96Z3hH5z9wfDT12a/X/x3nOEvZxWr3dzN1/1xbNvKuqTWepOoFm/zwR/Wqrffh18jPnzNy/Atvz/85LocqOk3Byvkki7jl689fvni/Pe71w45fis/jf/+1+KXH+vNJapXX/udCkfxNYe4XE4fblaBN+Mvxx5/vo6/9GLNDs7/cPz6tcffv4X+C43fvvT42w+++Pi/OP/xa8d/jodeK43Hv1KXrnG5aU5Hle9Rr3Xy7e8yuFBJlsuXRG7uSOqO3+0iCcQQffDjIgszReznf/q7s/1j4r6os/naimvWc1ZeyNkaXsnZ8kLOyis9WXmpJ+sv5Ky+0pNd+yz1lM5aeiVnX2lR4a809axUHT+psy809ZTwRFs8DcvhpHrzPfzGWX0hZ+MTTT1jZ1/pyaZXerLplZ5sfqUnm1/pyZYnWkGNnX2iFdTQ2WcS3MbOPtHmfeisvFI21i3e2Viuzn4rhr3+/DuKbbHdiJauKDe7mgXFt/iUE/2KkkLtoAiAUkNEUCqBEjOBkhDG0iZPX/Umkv0eZZMF4RjFCZRSCJRNPvaNUSqBIogvgjwXMQLFtnguYek1aH9r6KBs8b4Ev5krY75HcQVQJCQEZYtsGa6l4Q3xfnUhm0heYxQnUFIhUHJAUCqBUhBfCvJcKhLJOqwPFLcByvOdgyGWT1p6tJzR0qNlXKT9nLS8308qrict97RoiCctPVrqSUuPFj9p6dASX3SCHtFyptweLelMuV1a5KSlQ0s+o6VHSwknLR1aVjqU0/L1IOdhh9fz7Ym0f332y9NiZ7R0aSmvScsgt6x8ZXh1WvrXJp606EnLPS22ore8PC0vOkGPaDlTbo+WeKbcLi120tKhJZ3R0qNlpZTr1Wnp14qn9kXgYqYyOo7VbTl1LLqHAYufd8bIyvXxX9TZQWvhyk32z+qsvJCzfdXrWZ19pSdrr/Rk+8WiT+qsv9KT9fJKztrrOOvhhRYVHl5o6vEYX8nZF5p6PD7RFm/UR+l99eNZnX2iqWfobH6lJ5tf6cmWV3qy5ZWebH2lJytPtIIaO/tEK6ihs88kuI2dLa/k7Ctl4/4xkkmWrsYktY6c1eU8fLd4/fEFwh+GSCFcP5zdNjN/g5AQyv4Q+3vR/6b/ixBxKewLqd5B9Avvt4WQ3SH6LdIPPAu5gegEeArlEuAp6v1wtniH/ObLsNxBlLA/RNkbIq4s6ktevkfffryui5lOmfUbtsdmc2gyhyZzaDqHpnNoFufMZMps5bPI0MxmzFYuWR2b+ZRZnEOLc76lqfctrQgNpS5JudyedHAxqyuULJUp7c+OmZQpNFkZ5LI8SsX13kzznNkc2tobMDDzOGfmM2Y56JRZXElBy0lwzcw6ZjpllubQVhYjg5jMOc2ZTb0BeWXmHZnVMGdWp8xkDk3mfNO5B7AydbSoW9YwOXXMypyZz5iVUObM5tDiHNrKjDMyS3Noac63tYX3wKyEOTOZMqtxzkynzGQOTeZ8W1kYSi3dPcMPs7pSMSCy7B5Ee2Y6hbbyFVvsanZTXns1kymzNIe29gYMzHKZMitpymxlxhmarbymalez+2XoylGLY7NJNJ+KSa1TZjb3BphOmXmeM7MZMwl5zmzKN4lTD0BW7tG0y6aj3Bb+W7fwvy3TFyU23ZzlFu2Coftj9N/kjTHsYYwcfcHIKdxj1ARg6P4YK/fG/RJGyVeMUu4xVq5++hWMtr5bMMqNwnrF6KbDkpYuk9tz03sYdWm8aF8A7v597S+Ct/v3+1r6hv++7fvv9zeu2/37/TNVmtJy+fc13v77341W7uPdMri1PB7ceTkBpf1t98GtNe+PIRHA8P0xtkhoIwxL+2OsXA64LcYWsRtuMOQOw0IAMAg/fFsMv38eFguAscHiSK6LihLuFxVr7bu/hFFHGLY/Rk67L1ysBACj7I/RP4FnvFq3/pnAHzDs7xI/Yuh9w9Fi2UOeNbRJw1RXDAfLEu+Lf+Pn6H357wOIdW2og1nIJU8aapw19EnDtSAfGvZPeB4aauhPnx8xXH0c7050GmKYNZxG9A8YesfHVGYN197H92c2DXktVuvI0CYNS5p6kTXUMGtYJg37n6WarnR5Gu3P6y7tUtPX7GzKLvbT8QfsJvHiJF6cxEuTeGkSr7/c+YCdztn1t+cfsPM5u/4MNbbrC/sfsJvFm/RPy6RdP160XKaYtqsOHbv+7XUtn18+r7S0J/d2KyVMH7DzObt+CcfYrl/D0SZzf9+uv4RqqVwXO409O5mzk0k88Sm73M+77b9f+Lw9pudq1/+w+QG7OmeXwqRdPz5zXs43ylV7dj5nlyfx8iReGePdXLx5tZOV52BXO7eOneZJO5uz61exje08TtmV/hpdS1rirOTcsVuJ66FdfxGqVi/7XjXp2fWXki3N24In3rOTObuVPDi26+fra2W3SurEdVmJz6FdvzXqA3Y2Z7cSn0O7/vr6A3Y+ZbdSvzK2669btS5lF1q9k19WbvdU9bzEdW/9Uvvfe8d2/W+4Y7v+evADdpPj1Ln3vfZljrHdSnwO7Vby59hOp+xW7p38gN0kXoyTdnPPQfr7sZ/ev168rNRxjO3KJF4Nk3Yr+Xo5oVLbp7aOna3kibDwqbH07HzOzufwdCU+x3Y6Z7eynhjareTrsd3K/Od6tasdu5X1y9huEm9lHdI+qy92teffSnze5uv483vb+XJSrC6yWbFePKus5Pco784LOjmf6Mp8MrabxFuZT4Z2K/PJ2K5O2Vm/PDum9r3g8gRzCJ2Vy8pHvA9ZTmPWacy6hnm9tHrFcuVTzQcsV77VfMTSZy1XvtbksEy87W/pWvqspU9j+hpmkhvLYb5JbV95+X1qc/Do929XkV9+X29Lr5aReX8+OsLI+j1dhxjZYTlb+aR8gJH12+QPMTI76shWvvMfYGQrhQTAyJaPv22nHnoj24qzpS/5bWSjs03a6m9ZULe/Y2cOcLNPGtlojeorxTafPjILIR52ZH7UkaW1p7lIdDHHlEZI2ev1997Rcm2t0uJXkUoMS74psdQOUhYKqRQKqSYMSTdCkhskix0kSRgS5pNu5dN1l9CQxr8fzSgWQ/mkkYne5CDtjCymw45MjzqydFjOVtfunz+yetSRlXzUka2u3T9/ZPJJIxutqaLEw47Mjzoy1aOOzFeeZkxX1THW0LOUScsU4rSlT1rmvkZqqVwegCW5a6FoZjZl1t9Fjs10xqz0+RybyZRZv25+bFbmzHzKbGXjJzUvS1ypHXm6WdqsZZ7GzNOYZQ3zevTr26EWHcv+AVBRroeGRGlfaDuWK5sA0XQdrRbpWPavzPqQpc1arqSpsWVdSVMfsfRZy5Ul+Qcs09pTMbladsr6mqXOWuZpzBUR462NdrFsG5SOZYnTltOYdS0Sbt6y329LCfG5jcyPOrK1/HKAkR2WM9WjjszSUUfm4bAjs4OObOUkKGJk73+yaiPbirONP1mZlPBJIxtt4WSltOYAI6v5qCOTeNSR6drTrDdrKulZWpy2tFlLz9OWPmm5ckTVhyynMWOetlyZ0y3rNdI67Uumayv6D1hOY66IyB+wXMuPH7BceSp+nV3EpXQs1/LL2FJXRutXYfbt+ISO5YpgpnE5Aqz93WmXbJY+aWkrEf8Ry2nMlbj9gOVK3H7AcuXjykcsbdZyRUHReC271GihZ7mGeY0hjT4qexBflh7iN5eYxN6PR7qX1XzAMenxxiTpgGM6IE96QJ70gDzZ8XhauRI7alrOA3j7u1Mk4yvrB01LJ0n7u5cTPcdpyzprubLy+IjlyuyY8jX3p5I7lms5bWwpawzJzWh7Kw8Xn7Vce2PGllZnLVd0Gc3L/V7t75R6lnXO0tcOkfqIZVmxLDeWtXYsV8p7PmKps5apzlqurbA+YGmzliu6+wcsV3T3tum+tZSepcxayjSmrD2Vq+rV/vaOpeZpS5u1NJm1XNsBfcDSJy1j0FnL1fdTbyw99Cx11jJNY6aVp1Ju5uz2cbtjmcu0pc9aFp21XCn4/YClhGlLm7Vcez9LuLUsPUubtbRpTFub7e06Z5dc/znSKnNcfl+6s2ZcOe3x15GWE3na33X4HWGoonpaWwn88siuhf8ldw4vaEh1Bw66SDFgSJhPK3U6eyDZRkjXA0lL9rRBrGbZaGR+5aCETmZIJW7PwQqSUEgV86k6hbRSO/HLSCVey4x/f8TWXKzqRhm/5BsOOo06DUl34KCLZAlDwnzyCiHlmZn2h6XNWkaZtUyT+lSz1FnLtZX5Byx91rLUWcsapi3nMaf9lDxraZNfAH2llDy+HUW+YIbQUQjy2np5aFnW3rIPWK580W0C3Y1lZ3VfYpy2tFnLtbrtD1j6rOXK+/kRy2nMMv1U6jRD/aNpJC0XekuboHp2dc5u5Q0zudbMtL9Lz7JMW/qspU9j+ixmDWXachozTmOuvNUfsFx5qz9iqbOWK9+TPmC5skv6iKXMWtZpzDrtp4Rpy5UY0uUkxPZ3jT1Lm7Vc0eA+YjmNadOYNo3p05g+iykrX4o/YLmiSX3Esk5b+qzlykz/Via1WFrsrBZl7S3zG0zPPcy1t2yMufaWWbliWs09S5+11GnMtbfsJ8tOD5vL2ltmS31D+1tHe9Utayd8rSL2U8e0snv43DHp4ca0chztJ4/pgDzFA/IUD8jTSs2Ete8k19zfuWDD1yqbzfya+73TB+Nr9cnj+UZNZzFXvuv/7GfuWsqkpYU4bemzlms7oKaaXS1L6Vn6rGWaxlz5bvUByyyzlmV6tGsRP4xbm15hrdXyfsRSZy3XdiMfsLRZS5vGtGk/V3PCyNLXLpFLl8R80y1VFyObMFq7Pm6ZAm4O2Lka2YRRXkFa7h2z0jHqI5ktM1S9N+orCWLXG6vyvVFfRBgZrSAtZ7Lf7E0Wo5WbuK4XjaWeUf9agqXKpAn190b9DcnIaAXpEkaaO5Sv3LaQby7x6Rj5hNHKPQtLo5TWznNaudzmHaP20WDtBrP3jWzCKM4gxRmkNIPU1xEHRjnOGMmEUQkzRnXGaCaMavl1o7hyS8eSLPWmMa+li+9GffZ8qTZ3lXujPnsjozJjZBNGde1m2+vlvTeVq1czmTJbqV8ems2h6RyazqHZHJrNofncc/MptLVD0YZmdc7Mp8xW2qCHZjplltKvZ5DUr6D2dFmv3u5bFqN+pn//vU7993qAVGeG19eQR0ZlxmgiwaX+ZmhkNIPUL9XypQnAb1rsrkY6YeQzSD6avTpGOUzEXu7riQOjWGaMfMKo36A0MMphxmgKacankmeMZp5TnYmItdnq2qgXby7xim9C5/2vr+e23Z7alsoFQ3bHKGvz4KYYgB8R8CMCfvQvl94YowAYvj/Gygmgv4axnCiTbqu43jp97pdCvnxc1Z/mlrd6rLtfX7vPSv5p6r//aUqLvpdSzu//uC73qNdid4mpZD1JuSOlpJOUe1LOSLknpZ6R0iHljJR7UiSepNyTckbKPSl65pQOKXaSckeKnSvaDin+kqTY5dv47YUCCyn+mpEyIOU1c8q7pNTwkrOPLL+VnDukyEnKHSnxJVe0I1LOSLknJZ2R0iHljJR7UnI4Sbkn5YyUe1LKmVM6pLyknjIg5TU12hEpL7n3GZAiL7lLHpHyAnrKd0/1BR7/D09f4O3/7qm9QPL/4ekLrBK/e+ovsPT74Wl9GU9fZZaRUF7G01eZZSS+yiwj8QV2mN89fQXR8oenrzLLyCvIiz88fZXV4NrVr8/o6cu8p/I882m9eir3jSHyPCU8uvQLJq3zP/5By9MsM36Flih2vT4k3BdnyPPsB7ekRcNLvkRjWp5m/7UpLc+zWfslWtSXo9MtSoeW10y5I1qeZxu4LS2vORMNaXkaGXNTWp6n9XJbWs6U26Pledovt6XljJYeLfWcoLu0nBN0l5Zzgu7R8jyVT9vScqbcHi16ptwuLWfK7dFirxktfr2ox0uPlteciUa0rHSqxuVE5phubrp8o+WHnU3ZWfhlvHunavXrIdM3t37Htzv/7h/Ecoy13tziGjX+GNHKeUtDT1a0h6Hdyr5iaLdSVz+0W7k9YWxX5+wmI8pXzjob2809B49l0s4OFsG+0tr2iSPK5WgjknC4ER0ujvRgcRRDSEcbUTxYHMVwtHwUQznY2x9DPVwcHS0fxWCHe/v9aHEUD5eP4vM0FuZ02demfHMlyY+dSozPo5kNPX2ZZ/o8Z6/l5RKe5rR0PH0aaXPk6fPoT0NPn0aAHHr6NOLZyNPnOblt6OmrZKQUXiUjpec5OG3k6fOchjbyND1Nw83I0/6eWCQv+yW5v13zza5M2vmcnU7i6SSeTeLZJJ5P4rlN2eWQJ+10zq5/Gd/Yrl+b/AE7mbPLk3h50r8SJu368aLlknRENXTs+m1nGq43p4YsHbv+F60P2NU5u37T2Afs+u+DL5eP9+1KvzVAQ7neXaud51BWrogb203i5Tpnt3L3bQ4Lnzn1eFGds7M4aSdzdr5ygWle5tVctWdXp+xqCJN2k3hxjCepY7d2haxd7W5vErra+ZxdPy+N7fpfCz5gp3N2/etGtaQlzspN1+7VbiWuh3YrtydbXaRmk47dygEjLc3fXPDsHbt+B9gH7HTObuVS5OvBayqpE9eyEp9jO5mzW4nPod1KfA7t+uvrD9jVOTudfA4r94jXpdFQq3fyi67kJfXlfnTrrV+0XwnyATubs+uvB8d2eXKcee5915U7tYd2K/E5ttM5u/6XoQ/Y2ZydTuLppH82+Rz6+7Gf3r9evKzU6H3AbhIvypxdWsnXizKiop351upKngjXT62x9OzqnJ1M4q3E59BuJT6HdivribGdz9n5yvy3FDg3u9qz8yk7D3N4vrIO0brE2W0d7tVuJT5v83X8+b3tKHfF6lJcUKwXz55W8nuUd+cFn5xPfGU+GdqVSbyV+WRsp3N2EufsVg6XKWU5IKHc7Kea/Hix0zm7lVuOx3YyY5dCf5/5Abs6aedzdjFP2tmc3Uq7tcSLztO2JNf8UOSH2UonpSyy2duKvWNWp8xWikpGg1ypCR2ZrRQBDM3m0HwOzafQ4sprMDQrc2Y287jjyjswNPMps5UK9JFZjnNmOmVW5igpc2hzb3cTg6bMVspJh2ZlzmwqJn3tZojkl4Xi29/XnX20i6FMGq7dAjs2XCmOyNe3NeQU7g3XejXHhjJpuFaxkku+Gpbye8McVhpgQlthL4Yl1Y6hTyKmtaGqXA2tg5jjrKFPGq6d/jA0XAvyoeHKK/wBQ5s01NXHEW4MpWNok4Y2i2j6AUPv+Ohp1nDtfZTr+1jC3fuY41q1Ua4jQ5k0XOlJGb7IcWXBOzZMadJwpTVklJCboU0a1jxr6FMJOa8Wqo8NbdJwrRB1lJBX68VGz3G1/GqIGOtcskqzc0eanTvS7NyR1oJ8aDg7d6TZuSNJnUvIScOs4TSiz2XylfKpjxja3BSQVpdkdWRoc4Y5TCbkPDt35NnVY17r+SjXp2HXr7o/igObmUyZ2UqfXV00nfY9rmNmU2Yri4aBWVlrfR+ZrXXoLy990zjuzVY2621ft8hcqYO2cpj/0KzMmdmU2cpZdiOzOudbnRvkygKhXnXGelM3dTXzKbOVF2dktqLgDc10ymxlmT40m0KrK+9bXQT+psrljplPma1kypHZyhp7aKZTZnmOkn4J4NhsjsmVTUC+nnHT/L83W9kCDM10ymxFcxqa1TkznzLTOUp07gHYHJrNPQCfewA+9wBWblLLS5FazHafgmRl7h6ZrRymPjTTKbOVPdfQzKbMVu7QGZmVqbl7pfhubDY15Uv9ZbR/tv/0//7x73/+47/95U//3Wze/p//89d//8ef//bXH//xH//ff13+P//29z//5S9//s9//a+//+3f//Qf//P3P/3rX/7272//v9/Cj//1f+Rt1yLZQxvQ22N92/201fHb8Np/0hjqH7R9Rmj/uX77zxL/oG233v7zty1CbV+3/9D+l739F28vmLb58A/tf6U20jba/x8=",
      "brillig_names": ["open"]
    },
    {
      "name": "fill",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8412360910299423372": {
            "error_kind": "string",
            "string": "Invalid order destination domain"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "5Z3ZjiTHsabfhde88NUWvcrBQNDCIxAgSIGiBhgIeveJ6qrwiO5wK8uydvPyzLwRssX46zPz1Xz/zw9//+mv//7Hn3/+9X9/+9cPf/qf//zwy29/+8sfP//26/av//z3xx/++vvPv/zy8z/+fP6/fwgv/5Nz4S+Kf/3zL7++/B//+uMvv//xw58QCX/84adf//7DnyhG3P7G//78y08//CmG/N//8+Mmq9kmI5MMik1mo6HNN7SlJNloZPONbTTGnizmVMObLm4m1a+EP16/Dyntn4eSTl+HztcFIL59XQBD+xqo8zHVUHcPaornj18cKCGNcYB5/zxGnurAoByo1HKAtByIFfdiESHn9x3gyru3DLlcHIh1tAMxfe3AF0zKczDd6kcBoNWjcMhqfFXlbFKhRVWiSQUWVTWxajWpus0sbbnaVDWfVc4Vs983bc1oavYgvm8P5L2wwcl05jcAOwPQ2wP09qDfh44EkDOAvT1gZw9qv4cdCUBnQIzeAHAGJG8PUvUGODcVNTs3drUEb4C7B955UL+/sUPio7/PVwQkfwS6IzD6I6o7goI/YoIX7I4YEARQLG0kn4nPiA99/GoPLmUPDAgxxtqj9ucpxPft2b6NeIw0yzEwhdeRJuhRyQhInQHhCZCUZ0BwAiTPyPg8I+PLDE/KDE/qDE/qjNIFM+oJzKjx+vTFCMgMT2hGntCM0sUz6glPqPEYwgzIiCKcqTRIOU2c7pCYJkBSmAGpMyD9Gp+O2en89ex0bxWh7FPH22rLsSRS6ytCmIsYiiB3REn+CH8vhDmJoQh/L8A/LwDcERj8EdUfMaABibGtWsYaLggq/ghyR3DyR7h7QSH7I/y9iMkfAe6IFPwR1R8xogHBto8hRbogRkQgGoLcESMiEA3h78WICERD+HsB/nkxIgJRECMiEA1R/REDGpDUpsBjIrwgRkQgGsLfC87+CPRGcIj+CHBHRH8vYvVHuBdaTtkfQe6IPKC/yHFfVo25lisC3RHF34sC7oga/BHFH8HuCPD3Asgdgf6FFv0LLUV/xID+Yhv37ohy2lC+Izj4IyZ4wc6IEkZMs2gIdEeMmGbREP5epOiPqP4I/0I7YppFQwzoL0o9EHxFlOyP8PeiJn8EuCMg+COqOwL9vcDij/AvtORfaAndETygv6i5LdtXLFcEeCNiiP6I6o9gd0TM/ghyRyR/LxK6I/KIQnuc3q5YrwhwR5Tgjyj+CHZHVH8vRqwlKYgRa0lwIADSFYHuCPT3YsQ0i4Kg4I8o/gh2R7C/FyN2s7yPSGFEoT22NwDkKwLdESPWkjREdUeM2M2iISZ4we6IPCBUg+OGFyzhiiB3RPH3oqA7okZ/RHVHjJhm0RATvGB3BPoXWvQvtCOmWTTEgFANqfXddJ0KTiN2s2gI8kbkERGIhnDPixyDP6K6I5K/F6n4I0YUWgwH4hKB5BERiIZAd0SJ/ghwR1R/L0ZEIBpiQN9Nx913RF9tE71+nCjslShRvEwk5hGbb0fag3ExewYUCQ4thODLuYCSR0zFaIjijyB3xIiDRRoCvRElJH8EuCNi8EcUfwS7I0asN2kI/0Kb/Qtt9i+0xb/QluqP8C+01b/QVvf+ooB/oQX/QjsiItIQ/oUW/Qutf5BT/IOc4h/kFP8gp4boj3AvtNU/yKn+QU6N7oW2+gc51T/Iqdm/0PoHOfXDQc6rqphUbFF9OLp4VaFF9eEY4FUFFhWaUv7Dne+rypTyZEr5D/d6X1RsSnm2pDx8uLt5VVWTypLyEItJZUl5SMmkstQvyKaUz6aUN7VsYGrZoJhS3tSySRdE5rb8QSXQRSUsNJd29o22SO+iEhZ2j9MoVM59yq4ii0pYG1VUwq7ymvdJXaqgPAgCZU85gOOIcu6/c0PHCzqnJ4D6H28ThHvqbpNH9NXXr8bj/RqPwszknRhPd2x8vOeUj/dc5oWjfGsYfzzBtYUdcDVeWK9cwvga8z5M2Uag5Wq8sBfrToxfuNjoxi/cVKrG4z2nPN1zmad7bm34nlOe77nM8x23NrRySLzN9DXjt/X4jvFwx8bHhYeBuvErN5XY7lWvmOvVeGEy/z6MzysXG9V4vmPjy8qd1Ba87MbT6S2Bw/ilU14xvt5zyteVw4NtkNqMT53wAJZuKjXj7znlceXATDV+5cBMM37pMaxq/NJNpWb80p2UYvzSY1jV+DtuKnnpMSyW2KLKih3jl055xfi1h4GK8Wnpdl4zfukeVjF+7TGsZvw9p3xZucxz3W9er0zXATjDysVGNX7hphJCG8NCjJ1iAwsHZqrxKy+o6cbfc8qvPBjRjb/nlF95MKIbf78pX0NaeDCyWczN+BQ6xi8c20BsD7NAPFnRjF95p5Nu/MplXjO+LLxBTjV+6cBMNf6ei83SgZlq/MLzNhDb15Bqp52nhZd1dOOXbm0U41fe/K8bv3RT+b7x0jX4d2L80oGZYvzKO5104++5zMelwwPF+JW3aenG33F4EPPKY9jUJlrh/D7nYfzK4YFmfFm5qVSNX7mpVI1fuanUjF95g5xu/D2n/Mob5HTjhaaybYTVjUdqT2ghdcbJUbjdaSwD/BnCJdUfYUTG9twY07FV9Mu9JjUJNyh8jMD7Qfy0TeZeCPRBwhdVAotKWOOH0M7Gw+m4ar9ipJpb+YVj40+3sBOH/UEp4tNlym/5l4Rl+7M9CS9elGhSmVhVZ9V6VYFFJRzvVFTCnlRN1W9lMOxNGSFcVcJhPEUl1FJN1a8XVPalHiJWLi2quFc8CKfK8Fr4svAI8EAAOgOEMfxAADgDkrcHwps0AwH9QIlLuxCFIb4PKNSe3StUktKkVjya+FP88NakZmHBjdv1JxxS/R6HhUWxcQDh6ZqBAHQGCK8DDwR4eyDs6hoI6NbLLVzIDYD8PiC1/iMFvgLYGdBfKBsJcPZAuOr6Y4C0D2ZSugL6U1YfA5R9c8QWEFwB0AfwbhXH8u3NV7X040dVVU0qtqhqMalMrP5gWVUJsU2uR7yvNRBtcAehXLJWCGsHArw9IG8PhJvOxgGEddGBAGcPpBuBBwKqM0C4DXggoHgD2BmQvt+DBG0TXgI8ouoY8I3B/ow8wY88wQ8hgB/LIH9GneBHneAHpAkM9GdgnMAAfwZN8IPqBMb3tyWQ26J3PQaJzK8ALt4A8gVsvZU3wNuD6O1B9PYgZW+Atwc5eQPAGVCCN8C7mBbnxg4mRBswIdoAmOAHTPAD0wSGf9QENMEPmuAHxwkM/+gPQ5jA8I/+ME7wY0DwoTOce2/0jj8woTMgR29AdQYUbw+Ktwc1eAPcPXCOoBC8Kxp4VzT0LqboHOhLd41/BBCpbRqLdNqO1hDeBZW9qxo75wKF7A1w7jTJe9qBUvAGuHvgnQfZuxRl5/aUSvIGeOeBd69M4F0PwLuxQ+9M9u40ibzzwLvLpAFLAUjt0SSK+YoYMFevIHhAt6ki0B0Roz8C3BHJ34tU/RHfXy/ouPSCMvEZ8aGPv9gzoEsfaw+tZY8aMHBEbfgSU9wZ2+9yfA7hDYITIDXOgNQZEJ4AUecOhkBmZDzOyHickfE4I+Nphic8I0/Yv3RBCHkGhCZA4gxP4ow8SXEGpM6A8ASIus1yCGREEc7UJkJjOT3hvUMKTIDUMgPCEyDCSYcU9msBOH19ArgD2f5IY8Qj3o+Q3hjkz8AJfvR3Joxl9PdBDmZUf0Z/vWAwY4Yf7M6IYUDZPW5K+qrpfWH0jg7w/qfh/FBJfHna+vI1QrtwAo+Vp4jx1foY79p6vmfrE96z9cJRyNRe0eFclXtEUuTaLhLZfn97WcUGgQmQkmdAaAKkzvCkzvBEOE09FoJhBqTMgPAECM0oXRxnQNAfkkKaAZnhSYwzIBOaeuG6qI9Btv55H5Vtv1O8QGBAPUlbXNkgMdQLhMoISAoHpKYrRGjqSzkg5fb4OZwupvlyU9zla7dL6kpuy1qlnLZgvV28BonL87jKz+JqDvV5XH2eXI1PU1ezNAC6Q1cr7+PJAgGurtaHydUa835Co0YqV1chPo+rD1OAVVel4eQjuvo8dZWeJ1fpiXL1YaIl1dXHGdnorj7MeFVztUizS4/o6uOEECU0V0sMV1fj43Q2qqsPMzTXXX2czgbbdfwvZ5yvrkprmg/oan6cAqy5Kq2QPqKrjxNCYHtDulKIV1frA+Wq5urz5Co8TmCIbTGrnrerHK4+UGejuIqPM2OouvpA/arm6gMFhoqr9ECdjebqA3U2iqv8PLnKT9PZCHfM36erJbZwv2LH1QfKVcXVx1k11119oH5VcTU9ULSkuJofZ3JUdfWJcvVx6iq3h3BfTmFfXYXHKcCqqw/T2bycuNv/coydAgwPE+6rruLDhPu6q8+Tq48zNNddfZ5cfZyhue7q0+QqpIcZmr+c3m2uptBx9WFiYDju6IJ4esS+uZofp66qrj5OXdVcLQ+zb0l19YHCfdXV5ynADxTuq64+zDwwHFdCbF1op1+lh9kgoLv6QC2w4io/zNyS7uoDdTbvuyo8rfSYrj5QuK+4+ji7vHVXn6euxgcKDBVX09OEEPg4G9pVV/PjzC2ltjwFX9AXVx8nMNRcLY/T2aiuPk5no7r6OJ2N5urjHFPQXX2eXH2cYwq6q76dzReG890Tr4w6gTFgN9Bxq1mMELRiEVpQFM45/XrDNo5YGx9qD61lz4i5mI/Zk9sVtiV07KGl7KGQF7Nnev1qe823KZ6rPTEvZg+tZc+I6P1j9lBbled4tafOTh/Cvf3hWK/2jAgjPmQPwx5GMOarPRgWs6d8nj2UOvbwWvZM79+53arOX8WKuz2z6xfX+p49nBezB5eyh0cclfqQPTG05wG2n9SxCGanEJd3DbrhiYmi3FQcS9hrTSynNxFeHiPodBkh77dAU6iHRd3R2xbh7x0eEof3P46xtP15MdYE589fne2XzwytFGWi28dIvRdHWJh9H8uY4Icw3zyWUScw2J8hTG2OZUzwQ5jMG8sYUHY/7V0VhnrP1mO+Z+sp3rX1oFlfgtbz301Hy/1OsBxhTgHF2QJw3EiNikVUQ3vBuZ4efWj29Budkva2imsI79vDx9U+W0n81mUMQqw5FAHuCGHzy1BE/W4E5DbtWb99BB1DCt4Abw+ytwf9N0lHAtgZULw9KN4eCMHWQAA5A4TpvYEAdAagtwcIzgDybirIu6KRd0Vj74rGzh5Ir5h+BBCpvYsV6fSWSUOQOyImfwS4I5K/FwndEdnfi+yfFzW6I9A/odA/u8k/oai6I9jfC3YvtClEf4R7XqQBgywNUb4/oba5jP1jivnSsaYa/BHVH8HuCMj+CHJHoL8XAxpzDUH+9YL8C+2AsJ+Oc8OUic+ID338xZ4Bo4Sx9tBS9uSgBkJYo9LgxxSxzRuf599fV6M3CE6AxDgDUmdAeAIk5RmQGRmfZ2R8npHxeUbGlxme1Bl5UmeULphRT/QgaQAEZ3iCM/KEZpQumlFPaEaN5zIDMqIIZ2pDx21VPH0LKfpS6QBILDMgPAHy4T7+VYUWVU4mFVhUJZhU1aRii6qaUr6SRSWs1x2b+GMIRRlT1HbiqJ5OHNX0RgBvgvDUzkiCuw/k7gO5+8DuPrC3D1W4v2ckoboT2JsgbJoeSBB6n5EE8iZkdx+yez6U5E4YUadrex/n3Me9EWpwJ1RvArj7AO4+oLsP6O4DufsgbK4ZSWBvAmdnAoToTkBvQkzuBHcfkns+JO/+AfKIOt2OBVTuEIo7gb0Jxd2H4u5DdfehuvsA7j4AeRMwuxPQm0DVmzBkPP0+AZwJGKI7wTsfpNtfRxIG1GnI7bqs09aKRiBvwogRu0Jw9yG7+5DdfSjuPhR3H2pyJ6A3AaI7gb0JI8bT7xNGjKcVgr8P7vnA3v0DjZgzPt2MBelCGDHKwrSvWW6LoFfCgFSi0HYonp642gkjZkMVwoCIbEuJnRCuhBFtq0Jgb8KIMdD7hBFzlQqhehMouxMG9KJU9zP9hNc6zdWdMKC0UrvDkQp9S+BQvAkjRigKAb0JKbkTyJswYvygENx9KO75MKKP40bgfKnTPGLFTyFUbwK4+wDuPqC7D+juA7n7MGLFTyGwN2HEit97BAojZhIVAnoTRqz4vU8Y0j+0+yGJ4UKoA1rvmNtTwjGXcGGMaPtiiW2DazndRNwYZQij+VEqXRnszxixlqIy0J9BaQJjgh8jVm1URh3BCHjUj0s9jyFOYJA/I+YJDPZnpOLPyGkCY0T/UbBdNlgQL4wypP+gdrNiTfnKqBMY7M+oeQKD/BkwwQ9AfwYOaXeBjvpBVwb4M8b05wqD/Rlc3BkphAmM6s+IE/wYsVci1tLuy68lXRk0hAGNQVc/RuyXUBnoz8hxAgP8GWWCH0NiBo0xok2sOR/149JHpVr8GUPmADQG+jMwTWCQP4PyBMYEP3hCfkj7Kmu765zOo5buJBzttZzjMc3Xvek8Y7vpPOMposybZS/mZCm8+Cxz6lLmxLVSJ66VOmmt1ElrpU5eK3WkHVCfZQ4vZY60M/aTzBGuOfo0c3Apc6SLKT7LnLVSB9cqO7hWvMNzU2db59vN2ZbKLuaUMLcZ5PZO35YQHXPi0GbwtIf19TWXDUDOgOTtQfL2IHt7kNEZUJI3wNuD6u1BBWcARG9AdQZg8AZ4e0DeHpB3KWLvesDOrWkNA1pTPB63ze93sO8/ZrZZQytZE9NS1uBK1qSl0ibNDRO3EV+LWk9LYHuYWCfPJajmrJU6k+cSiFpMTxQ75uBKQ4xa81LmQFjLnLqUOZPnElRzYClzaK3UobXKDi01tQHB+WQRQQzuhOpOYG9Cyu4E8iaM2AvL7eF7Br4Q6ogTLdxqD1/2gsCQvQexVbq4/b4yRuzNiafHw/nKGHFCSmWM2HsQ29GZmL7e29n5OCRuO0G330eUGV9HBDBkq8Jgk3A1kzDk6Sadji+FfJqQaCbhcibFtJxJieebVPJhUikXk0YcHP6gSdtySfvbJdWrScXVpFcG+zMA/Rlj+rvj63i5q21jkD9jxJ1FGoPDBAa4M2jIOTWNMcGPGCYwRrQlqbT+OJXL+S4acoZMYww5g9yuq4oZr2k14r5blcH+jBE33WmMEa/IaIwRd0moDPJnDNlHfYpjMqYrg/wZPMGPIaON9xk85FyUwoh5AmNInr97LwMPOYOsMIacJ9IY/ndYDLlHSWWgP6NO8GPCnSKMvuMow2iTcf6UU0Y4TKLLaJMJljOJy2ImbasQaT2TcDmTYl3OpJTXM+kzGoFwMgkuJuW8nknrpVJJn2sSX8tSweVMqnG+SXDMO5cQriZ9Qh9X3zcJ4nomzW+9358K5zFXnQ02CZczaUi8FFI9qvW3l+dtDHZnbM75M4asimmMEUVka7Ta15cLr7b5BfJnDOnvFMaQ9TeNMaRhi21oF3O6MIZcXqExZvgxZGHwvQ0kHLH6MyhNYKA/Y8ikq8Ygd0YKeQLDPz9SBH/GkEep3nmaZSOMeAypxTDY8WFE36EQ3H0YMZIB3O/GhMvy7EZAb8KIS48VAnsThjxK9S5hyKNU7xP8fXDPhxF9kUIYUB+wtDoN324Y4jxiIlchuPsQB7RL7z2stRHQmzBiYVEhsDchV29CCe4Efx/c82HEhcbvE4StKCW13f41aEEfhTbnQ/HYuc/8hij+CPpuRKLYDuQkOBDbuPuVIWx2GcuY4IewE38sA9wZRdgsOZZRxzJOUziNEcMExgQ/0gQ/0gw/2J+RywTGBD/KBD8K+TNqnsBAfwakCYwJfuAEP3BCuaIJ9YMntLv8/e0u5D1mhZq/DeBqCN6A4g0gZ0BM3gBvD5K3BwmdAdnbgwzOgOJd0Yp3RSvexXRAMKAAvIspRG+Ad39A31/RlDmDSuCOGN01d4aolas7A0KYwCgTGP7TKxDzBIZ/CA4pTWBM8CNP8CNP8KPECQzwZ9QJftQJfkCYwKgTGP7TRIBlAmOCHxOG8zBhOA/sXz8wpAkM50AavcfcGJ3He5iCN8B5vIfZ24Ps7gE7A7zH3Og95sbqXdGqd0UD72LqPeZG8C6mmL0B3v2BcB4ltU1NnGtR5gxiOrbIwmFNIuyZQ/vJpvOmsrzpXu2hyfYgtc0kpwNyuz3S5UKfZk8sa9kjDKo/zx6cbU87QYwMV3tyWsyexdJHmASYYQ+FTvkpsJY9wpkrT3v283J02mZ/2FNn29POC3ftgbCYPbPbZ2qbISlf+1PCtJg9sJY9NLv8UDvGwqFTfojWsodhKXs4lMXs4bXsibiWPamuZU+eXt+PFxRC7NhT17KnLJY+pXyePZ3+ncv0+n68SxWv8SHX6enTTmr07eG17IG8lj0j4o0Ax811pyv3hfmWkvb5Fjg9ytJ/BI2OUziRlY8L4G5GAfr6T7+6So/japtD21ylq6ucn8dVfBJXYwghPpGvT5Sv8YnyNcLz+JqeKF9HDKzuxld+Hl/zs4QSL74+UZ9T0hP5+kR9Tn2cAR2G/S8XzKXna3kiXx+nz1F9hSfKV3iifMUnyld8onylJ8pXfpy4Sff1ceImzdf4QHNruq+PM1bXfX2edjgmob7C8XT5actt/0RIimF39uV3PX/+SpGWrD9Gac+pb79r7FBoBKXWg4IdX0qeQpnii7DDfzAFwhTKlBTDIbmfziU5dSg8g0Iwg8JxCgUnUFJIUyhTfIlxCqXOoOQR+RLavRHb7xQ7lBH1JdR4ULBDKXEKZYovdUTLHzIclEIdCsygQJ5CoRkUaVZlMIVnUGiKLzQlXzhNoGRhfBPaa6K8TUVpFGyM06dvo4os3LfyIQK0SOzcsjQCeROSuw/CS8QjCexNEDa3fojQHopL52enG4G9CdXdh0ojCRSuBBhQWrn15qdjbo2AA0pr2wicGDsE8CaQuw/E3gQeUVqpEahDYGdCCcWd4O6DcExlIEE4mDyS4O6DcDhkIEE47vEhQuF3CdWbUN19GNEDvU8Y0QMpBPQm9PsHqnGfRacKSvy9zUTt3WhkOkVMO6J+N2KbqWgR/jbrfUH0b6sai5jgBQ9AxDZMCaeXbN8Qwv3TYxH+XvQHW9+RF6fgr1fA03G/6jZHfjWHBtQhPsxJcEGk7I9Ad0QRSl9b5tIRn3UyarO+v3S0ivXKlkfhtud7sR7iXVtf79l6vOu0x7tOewp3bf19pz3fs/Wc79r6e+6tINxziwn92/Puxfp4zy0mxJUjZG1rHUgDofuwPq3cYurW33Xa57tO+3zXaV/uOu3LXad9XbmvVa2Hlfta3fqVRye69SuPTlTr8Z7bHOxvn3jZzdQWQl52NjVlbEIyCvtLTbcIuS/MkZswp3AVYrYKySjsr7C87Ic5DpbkUi5C6t+W8rJgfeR6OS0jNGH/6pEbiEkytd0L/LIxokPM2Sgs0Spko1Aq5Kqw//rvDUIMVqGYHeEkhKuQglVoJvINQu74yMUqlOojHPWxhGt95CCV1aoJySiMyVaROQWrsBiF/d3kwHvPgeFoNtK2FPaq6r86pqpMrP7egbzNiL/J8tYcNV23J0Te20GKqYPo31Odt9RriApnxJsMTTLKJll/b4AuqwZZFG6f02VokkUbLdp8S8Ek628kz7FFWTmm8n5BpFxbScxIV0Z/G/lgBrozYkgTGBP8iBP86Id9YxlCkR/LqBMY3K+63DqDWJXO4MtR0GOwEcqV0n/CbDhlii8lT6HQDEqd4kt/jJpT2Td351RZo0A8Yn3I2KH0W68cmi9Zqy3bX6YjEsWYr5T+noec2jzCRqkaBfkIIrcBXIdSZ1D6g5zhlDKFwjMoPMOX1F9nHU2JcQplii9pii9pii95ii95RguTSphCmVIrhR55MEXokWXKmwxNsv6MnCrrn2bOJbTxXlG72piozVDHHK7DQ+E083AKzaD0N10Np8zwJfcb21Ryu/monBZHat1l1STr35eky2y0YqMVG63aaNVIY5Osf52oLiOTrH/wVZVRssnQJGMbjU2+lWCqbyUKtDbNu/3kqywLSdJWE7afHVlJJloRjGwdUCrng7+7rEabzEaTaoAmY5MM0SSjapKx0ARROmTUkVWLrIZgkxVLmawx2GSmGlBTssnIJOuvF+syG63YfKu2DBC6DsjtUgbI6SrrLzrpMjTJyEYjG41tNKHHUWQQkk1m8g36hzZ1mamUQH9hV5exSSaEoarMRis234TAEGq7BA5qvcr604cJoB31BOzJqo0mGEmHjPNVxsUmM9FQqgGKLCaTLAWbjEwyoceB9kLiJisdGZlkxUYraCmTWLNJBsEmqyZZf+lBl4FJRjYa2XxjUwaQMIdN+6CjxFMZ6c/IKRslN0b1ZwiryWMZ8N0MZadmpBwmMKo/o3+i/2OM97eKRurvo/0QQ9mMtjG6zWFpd8iWUt9n1La2W5mvf78fBI/7+/0Lkwf+fXD9+8L79gP/fjdMKW07ZbneUxg5snvh5vT9hVvZ3Bs5xwkM9mf0Y5axjBENmsaAMIFB/gwcUXbf3e29McifQRP8IBzL4E5+cJrAGBAcvb9tPkk7gD/EqBoD/BkxeAcuG4P8GSn5M/oL7ADtONv28+ii94Nkmw5suv4Y8QadkUdGHhl5bOSxjRf7CxY36KpRxzZdf81C1/XjtBt0ZNNlIy8b/SvJqOuXFyx77ACIoaPrLxViiPvcGm79REfXX7u4QYc2XX+aRtf1lwu36VJ+V5f6Yw4MBZsOO/mQUjHqjLyMNl2/3cXc7ofEnHrp0t9Jpev6sd0NOrLp+jHYNidcm65iT4cmXQ7JqDPyos6D1NFlIR/o0DF1dCUadWDT9c/s3qBjm64/TsOSWjkrOXd0QrnWdMIemW02ep8URYKerh/Lbs08NR5wT1eMOrbp+pvnEGLLB0idcl2E8qnryKYTyqeqE8qnquvH1zfo0KZDYz7041asbc0NK3falyq0S8f5W6Re/FL7m790XX8h4gYd2XTZaGex1ffan2vTdUL51HVs0/WXCHVd/6aEG3RWntE/suUD9MdjX9W/XnmBUG26aORFsumS0F63J3QRsNPfQhXaibbze1s9Lj0d2nRg5AnlU9dVm06IJ1Sd0F7rOqH/awcqN1296lCIX3SdkSfEIdhOC28/O/6hUD7P7XX8ut52ps0KtWdMtt+98oxZaN/bIdB+v4DG/gSF/kTXGXlCf6Lr2KaDbNKRcNXLNq5rk8Q5hNRTklUZzcxoZiaJ2QJzSdkvqTcp2arsRzG3KPv9xPZ163hfzvx0lWhVgpkJEjPBSam2Ny/Ve/9+qwpR+77W4xR4Pa+7H5YJF0stYJlwc9UKli2bZv3dZ0tYRotaxv3IYwXL+nMzS1jGn2VZW/6uEDrrFtJ1Zx+3rB1Ke7FMu1Bzi/5aQL39jp0+QLjjbIJlWozK/adnlrCMV7UMcVXLWMrNNkUXt1WCpJEy1+N77s3lCntNPkza5q5be7PNR19HeVsIWGaRYppFSmEaqQ4iwYlEsUPKYRppmk9llE/HKGEj6d9rPcq2RJg+yTLAUxuEHcsoLGtZXdUyXjbNxNj9sy2LIa9qWYzLWsarWpbKJ1mmxFRZuFxyBcsyrmpZqataVoXc3KYpDstq6CihmJVmpjTSUJVZeM41lT0DKMHlfN0mA5NMeMBUlVWbjE0yLDYZmWRky4D+mrIqEwZ+UHMLcaF2pqezcJ/PDUphu9JNSjMzSszjkXao1FPmfsAMx4nxuC3sdrqmIgwCANNh7baG1lOSVSlMGN2gFJqpW5RsVQrN1A1KISS/QclSrhAcys62vixc+3ODUrj55yalkCsU2qQmUIw9JVuV0cyMUkk41bJvh6UzJp+z8Iz7CpZJ7csCli2bZqWualkNy1pGq1oGsKplGD/LsveXrDbLRqXZ4CWrDIE+yTJtCCdctbWCZSkuaxmvalmRcrOeYiroKtmqFKNrVQnRrESrEpNZaWaS2U8poqeMR0nrHF/aRvXBrLQyUZhEvkVJVmUUcoWP3gUYSkcptS+6MgvW8jExC4ydvlPYrPly3Vvr2zB2jktmFEr8DUqhxN+iNDOFcnuDUii3tyjJqCRhBuUGpTCDgvHYdomRQk8pMY8yhJG1bQ9bNd8LK3A86kfsfazNe0lvnH6uTXU9m3JY0KYF06ksmE5lwXSqC6ZTf34/br1mm+Hdfnc2yZAQP2BqJ0leLhzttYnMRqX0/uwtSrIqhcgDUz7a/lRyRym1aTcopRSCk7W9yIMzWpVSjdGVNZuVQq7k0CJmzKkz0mbh9fNblGamFGHlclLWTl1hYXvPLcpqVXI2K8mmLEGKsHSlMO9+i1KoK9uS50kJHWUqZqWZmaVcOWa9tt/cUQrPvd+iBKuyFrOSrUppBKQrsVqVYv3Ek5JDT1mtSjYzhXfft4nWo88u6dqvFOEt4ZuUaFXGalUKG35vUZJVmcGqlOpnCWdl6SnBqqxmZpV6ezr67JLrf7W5yhzb96XXa5YIYRCp3ciz/a7qOoI6i7pZRoMsOzb+lwy9soHZIQ36JJpFomk+Cft0PEgwiHTcNFsyf/8WvJJCGWQZH2lQQumReHwa9EmxTCNN8ynhLJKwd+LDpK3NOEg5DyirZVCLX/IpDToHdTZSdUiDLqmGaaRpPkGeRjL0Sq9KBKuSillpnJ8qyTonVrIUmd+gRKsyZrOSrMpkZiaznzlalcW4AliEreQRQ2j97/a7M0OQpXj5BiVZlUJ8CszhpEw9JVuVBFaltG/7BiUalUWon7cozcxozZWSrClU+lfTQGqvuUIi7Oj6O1Ju0PXLLMGxZ2b73Yl/ilDDblGiVQlmJpiZaGaimUlmplCrb1AKtfoWZTUqq7CedIuSrUph1HOL0sxMZj+TtX5Ke7sJ202I2+8ae0qwKoU5uFuUZmY1M6uZCWYmmJnCSvEtSrIqhTmmW5RoVApP4Eai49oIotiJFkGqZXxicu4xpVqmM6VaRuVgUs09JVqVxcyUatlXys4ZtgJSLaO2v2H7jdpYdeTeiSLtiP1Um4TRw+faVNezCRdMJ1wwnWjBdKIF00nYM0Gc4tH2dx7YKNLOZiI+2n7unIMp0v5kvb/BWq1MYV3/az9zTymcsb1FaWZKIyBdKY2AOB9ljEvpKdGqZDNTWLfSlRSKVRmTWYnGckvmCEvay3uLslqV0mjkBiVYldXMrGY/xTZBU3I/banss1RfRZEl7yq2qEoxqciiEi4S0VRoUQnXiGgqU8r3oyZNJZ1uOt7ihtMelQJfZDVIx4yOHYFbtNuRoUkmbDbSjBRGbppM2Aaoymy0YqMVG02YmFVlYJIJAx4tu4UxiSaTDkVrMjLJyFYDhPVLTca2JGETLdpqdwymlIxCsKLKwCRLpjJZU5/WTo+m84rNS124fIvcJlKQTydJvqy9XL4+dpqW0wxuCp1PU2p9eUqnTSLdj2t7M7EWOn/66qYQij2cm/Up3CzPkZvlOXKzPkduCucaHs1NeI7chOeom0Ls+XBuPkcUJEww3p+btE+lnq+QPNx8lNx8301+lLqpuPkgLe3xGid8/ekXNyE+SKFV3EwPEh5obj5HoX2UYbXm5nPk5qMMqzU3y1O4+SjDas3N56ib8CDBnubmc0RB+CADMc1NfAo36S7r5pvtd9l8vtrOd9nDvdle7th2ulvbpXtk78P2u2xOX22P99tG4n1Ozbzafp/zLW+2328bicJtbXdhe77jNjLfcRtZ7nJU8Gb7HccE9Y7Tvd5xeYeF25njjrmUT0doDtsXLu+a7SvPPqi2LxyLabbTwrGYanu5Y9vvuK7yHddVXrhvUmyncL/pLr05che2rzxPoNq+8FyqavvC41XN9nS/cSSlO24j8x3X1ZW3dGi2r7xPQ7X9ntN94TYS23nYhNX+8aujdeEG9SOOxtOb8Riue0tp5V0VYx19kKKrOooLj1PHOrrwoPZDjm7DxN1Rip1Wlx6lMVIdXTgUHOroygcXxjq6cLAz1tFH6V4UR3nl7SNjHX2S7oXjs+RofJLuhdOjdC983HfMpefoo7S6mqP9YRpA3hnbz+tVX1W4cErX9a+cukFn5JGRR0YeG3ls5bFFByEUo45suv5GP12XklGHNl028rLRvxKNun55wXYnESCGjq6/MQRDew8RN1c6uv5tBTfowKbrL4rfoOvXB243ofZ1sf8EDoZ26h+3JOjoUjbqjLwMNl2/3cXcXpbEnHrp0p8L0XX9+xBu0KFN1x/44vFGIOaKPR2YdClEo87Iizqvc9E6CM/KYaZDx9TRlWDUVZuuPy9+g45suv4DLi+vq+66bx/Pe9UJ5VrT5dBPT6r7BQ1I0NVxnwfUeMAdXX/sdYOObLr+hnI8jnchpE65zkL51HVo0wnlU9UJ5VPV9ePrG3Rg06ExH/pxK9Y2VY6VO+1LEdol5NzKdS9+Kf0NHTfo2Kbrx4O6LhvtLLb6XvpXRes6oXzqOrLp+te/36Bjmw6NPDT6R8Z86I/Hvqp/vfJSQzHqjLyINl0S2mto9QE6j8iC8KzSNkZp6Ymx9HRg04GRJ5RPVSeUT1UnxBOqTmivdZ3Q/7WJv013fUQVQIhfdJ2RJ8Qh2N74xPPc16ETyue5vY5f19vOpJn6KDII1/Nsfxze7RfA2J8IF8jcoDPyhP5E15FNB8mmEzbPB2wZGM7x/64ii4qzSWVhSYepNZWJJdymralMrGRiCVs5FZWwiVJTVYtK2DioqUysamJVG4stKjCVXjCVKDSVKDSVKDKVKOHSTEXFplxmUy6zJZelx4Y0lSWXKWaTypLLZGqjKFlymUxtFJnaKDK1UVRMuVxMJaqacrmaShSYchlMJQpNuYymEkWmXCZTiSJTLrOpRJniKDbFURwsucymOIqjJZelnRiaypLLnINJVUwqS4niYsrlYipR1ZTL1VSiwJTLYCpRaMplNJUoNOWyaazHprEem8Z6zIZcxhCSSQUWVYwmVbWoUjCpiknFFlXOJhVZVMWUy8WUy9WUy8IIMR6bAlPAi0o4FhLbjHCMmC8qYZwSqVkYuXyriv1ZSIUVhXFKPF7H3Zblryq2qKKJJcyliCnf2UAYwz5zn2M9Vmhj6G03fP+JRxR2tXyiPbiWPf1V60+0Z7H0KYulT1ksfYT2+dPsATK0/FEYnyoqKiYVG1QprFUOhd1fn2dPXKscprhY+qTF0ictlj7CzMCn2SPMA7wfVSZhrlJRCQ8cKyphRK+p0KISVkY0lYlFJr/IkvJZmp1LHNvwJp12q0V6E0qDX10IRqG0lJCPZ7BDTqEjBKNQWlBQhdJs2Fa7DmEpV6FwAUIo8RhtllSvQmHkqBNRMhXhEFKHKK3EqUJpyloTFmluRxeiUSjN1ahCYdB3g1DMjnASwlWYs1VoJZZ0g5A7PhY0CqWpmK3aHLUjhI5QKqtVEUqTxrqw2ipywWwVok3I0vJiOXKDjmDi7bTjtjiebTKhS6zlmHZKV5mQnppMSE1VRiYZSUECHCHcJUkoCOtqJbUOsaTUkaFJJnTcqqzaZGySJZtv2WakdFNZadldTwfBDhmYZNK1VZqMTLL+5nJdxiYZ2mjSLUFtx+LLab2rTHpBV5FJF7toMrbIpBlzVWZKkiism6syU0pGYQ08Hwflc73WtygMdVVZscnIJBPCG1UGJlm1JUm1ZQDYaGDLALBlANoyQJhJze3U3VYgrk2QcMhWl7FJJoyBFFkS1uxUWTXJhH2CqszUd0vzg6rM1OWnbKNV4ajPHvMilKuo37txW2hlhKuoXx41ERhE/c2xmqgYov9NRhZZDtkms9GijRZttGSjJRstF5vMRis236QJAkUmTQ9osmqTsUkmHPZ8twXJ/R6U0z7dz6Uj6o9936/XwuScQmKDecJsniYCgygaGjhh6k8RJQupv0mLaS8RX9141URsEGULKWu9V09UDGWv9CeiFFE1dHnCtJ4mQoMIk0VkIZHFJ7KUcrLkE3+wRPx3+9f//cvvP//lr7/89K9N8fIf//3r3/74+bdf3/75x//75/5f/vr7z7/88vM//vzP33/7209///fvP/35l9/+9vLffghv//M/qcT047aomTdzXkx5+ecW4m3/eqkUCbcJ3W3hrWz/fkmSbVWHf9wWjl6+/tJ8RK7wY2SIL/9H/PIFlJcvYLN0s/b/Aw==",
      "brillig_names": ["fill"]
    },
    {
      "name": "_assert_nonce_and_set_order_details",
      "is_unconstrained": true,
      "custom_attributes": ["internal", "public"],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "order_data",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "11094545764365153162": {
            "error_kind": "string",
            "string": "Function _assert_nonce_and_set_order_details can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_assert_nonce_and_set_order_details"]
    },
    {
      "name": "open_private",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "order",
            "type": {
              "kind": "struct",
              "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder",
              "fields": [
                {
                  "name": "fill_deadline",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                },
                {
                  "name": "order_data_type",
                  "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                },
                {
                  "name": "order_data",
                  "type": {
                    "kind": "array",
                    "length": 301,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+ydBXRU2ba1g7vTNDTQaOOSikCCu7u7BBLc3d3d3d3d3WmgG3d3d/d/1bvpdzenT1cDmXv/meORMebrtXdurffV3OvMSkhSJ4Tbfz4+xnRzGxjtP3UIUajA/4YUJbbs/fVftQ5j87+LZLMXxWYvms1eDJu9OKJclr1ENv+7xDZ7SWz2ktrspbTZS2WzV1gU3rJXxGavqM1eMZu94jZ7JWz2StrslbLZK22zV8Zmr6zNXjmbvfI2exVs9ira7FWy2atss1fFZq+qzV41m73qNns1bPZq2uzVstmrbbPnZ7NXx2avrs2ev81egM1ePZu9+jZ7DWz2GtrsNbLZa2yz18Rmr6nNXjObveY2ey1s9lra7LWy2Wtts9fGZq+tzV47m732NnsdbPY62ux1stnrbLPXxWavq81eN5u97jZ7PWz2etrs9bLZ622z18dmr6/NXj+bvf42ewNs9gba7A2y2RtsszfEZm+ozd4wm73hNnsjbPZG2uyNstkbbbM3xmZvrM3eOJu98TZ7E2z2JtrsTbLZm2yzN8Vmb6rN3jSbvek2ezNs9mba7M2y2ZttszfHZm+uzd48m735NnsLbPYW2uwtstlbbLO3xGZvqc3eMpu95TZ7K2z2VtrsrbLZW22zt8Zmb63N3jqbvfU2exts9jba7G2y2dtss7fFZm+rzd42m73tNns7bPZ22uztstnbbbO3x2Zvr83ePpu9/TZ7v9vsHbDZO2izd8hm7w+bvT9t9g7b7B2x2Ttqs3fMZu+4zd4Jm72TNnunbPZO2+ydsdk7a7N3zmbvvM3eBZu9izZ7l2z2LtvsXbHZu2qzd81m77rN3g2bvZs2e7ds9m7b7N2x2btrs3fPZu++zd4Dm72HNnuPbPYe2+w9sdl7arP3zGbvuc3eC5u9lzZ7r2z2XtvsvbHZe2uz985m773N3gebvY82e59s9j7b7Dn/j3UvhM1eSJu9UDZ7oW32wtjshbXZC2ezF95mL4LNXkSbvUg2e5Ft9qLY7EW12YtmsxfdZi+GzV5Mm71YNnuxbfZ+stmLY7P3s81eXJu9eDZ7v9jsxbfZS2Czl9Bm71ebvUQ2e4lt9pLY7CW12Utms5fcZu83m70UNnspbfZS2eylttlLY7OX1mYvnc1eepu9DDZ7GW323G32HDZ7HjZ7njZ7XjZ73jZ7mWz2Mtvs+djs+drsZbHZy2qzl81mL7vNXg6bvZw2e7ls9nLb7OWx2ctrs5fPZi+/zV4Bm72CNnuFbPYK2+wVsdkrarNXzGavuM1eCZu9kjZ7pWz2StvslbHZK2uzV85mr7zNXgWbvYo2e5Vs9irb7FWx2atqs1fNZq+6zV4Nm72aNnu1bPZq2+z52ezVsdmra7Pnb7MXYLNXz2avvs1eA5u9hjZ7jWz2GtvsNbHZa2qz18xmr7nNXgubvZY2e61s9lrb7LUJ3FM/QgT+N1fgfz3dM3l5+Wf28Hd4Omq7e/j6+Xi7e3n7ZfJx+Di8fbzrevh4evr7ePlk9vXzzezu6/Dy9HcEePt6Brj/56NI6P/2cg/Sh0cdnZxFv5fT4RVg3XKyyY9+3EIrrE4fPgXWqdz+W6dW6qKB/5u/HldMiuKiEqKSof+7/9dHKIsH7kH7cKQB9ioWGnc2pWAz5O6u07+0wF7Fgf6VJvEvHbBXCaB/ZYD+2WVDKSUbSit1GaUuacmGslKUE5UXVTCQDemBvcoCz6YiyWxnAPYqB/SvEol/GYG9ygP9q6w5GyoqGVBJqSsrdQVLNlSRoqqomqi6gWxwB/aqAjybGiSz7QD2qgr0ryaJfx7AXtWA/tXSnA01lAyoqdS1lLq6JRtqS+EnqiOqayAbPIG9agPPxp9ktr2AvfyA/gWQ+OcN7FUH6F89zdngr2RAgFLXU+q6lmyoL0UDUUNRIwPZkAnYqz7wbBqTzHZmYK8GQP+akPjnA+zVEOhfU83Z0FjJgCZK3VSpG1myoZkUzUUtRC0NZIMvsFcz4Nm0IpntLMBezYH+tSbxLyuwVwugf200Z0MrJQNaK3UbpW5pyYa2UrQTtRd1MJAN2YC92gLPpiPJbGcH9moH9K8TiX85gL3aA/3rrDkbOioZ0EmpOyt1B0s2dJGiq6ibqLuBbMgJ7NUFeDY9SGY7F7BXV6B/PUn8yw3s1Q3oXy/N2dBDyYCeSt1LqbtbsqG3FH1EfUX9DGRDHmCv3sCz6U8y23mBvfoA/RtA4l8+YK++QP8Gas6G/koGDFDqgUrdz5INg6QYLBoiGmogG/IDew0Cns0wktkuAOw1GOjfcBL/CgJ7DQH6N0JzNgxTMmC4Uo9Q6qGWbBgpxSjRaNEYA9lQCNhrJPBsxpLMdmFgr1FA/8aR+FcE2Gs00L/xmrNhrJIB45R6vFKPsWTDBCkmiiaJJhvIhqLAXhOAZzOFZLaLAXtNBPo3lcS/4sBek4D+TdOcDVOUDJiq1NOUerIlG6ZLMUM0UzTLQDaUAPaaDjyb2SSzXRLYawbQvzkk/pUC9poJ9G+u5myYrWTAHKWeq9SzLNkwT4r5ogWihQayoTSw1zzg2Swime0ywF7zgf4tJvGvLLDXAqB/SzRnwyIlAxYr9RKlXmjJhqVSLBMtF60wkA3lgL2WAs9mJclslwf2Wgb0bxWJfxWAvZYD/VutORtWKhmwSqlXK/UKSzaskWKtaJ1ovYFsqAjstQZ4NhtIZrsSsNdaoH8bSfyrDOy1DujfJs3ZsEHJgI1KvUmp11uyYbMUW0RbRdsMZEMVYK/NwLPZTjLbVYG9tgD920HiXzVgr61A/3ZqzobtSgbsUOqdSr3Nkg27pNgt2iPaayAbqgN77QKezT6S2a4B7LUb6N9+Ev9qAnvtAfr3u+Zs2KdkwH6l/l2p91qy4YAUB0WHRH8YyIZawF4HgGfzJ8ls1wb2Ogj07zCJf37AXoeA/h3RnA1/KhlwWKmPKPUflmw4KsUx0XHRCQPZUAfY6yjwbE6SzHZdYK9jQP9OkfjnD+x1HOjfac3ZcFLJgFNKfVqpT1iy4YwUZ0XnROcNZEMAsNcZ4NlcIJntesBeZ4H+XSTxrz6w1zmgf5c0Z8MFJQMuKvUlpT5vyYbLUlwRXRVdM5ANDYC9LgPP5jrJbDcE9roC9O8GiX+NgL2uAv27qTkbrisZcEOpbyr1NUs23JLituiO6K6BbGgM7HULeDb3SGa7CbDXbaB/90n8awrsdQfo3wPN2XBPyYD7Sv1Aqe9asuGhFI9Ej0VPDGRDM2Cvh8CzeUoy282BvR4B/XtG4l8LYK/HQP+ea86Gp0oGPFPq50r9xJINL6R4KXolem0gG1oCe70Ans0bktluBez1EujfWxL/WgN7vQL6905zNrxRMuCtUr9T6teWbHgvxQfRR+e+gWxoA+z1Hng2n0lmuy2w1wegf25hOPxrB+z1EehfiDB6s+GzkgHOs/qrDqHUnyzZEFI+F0oUWhQmjP5saA/sFTIM7mzCksx2B2CvUED/wpH41xHYKzTQv/CasyGskgHhlDq8UocJ82U2RJB1RFEkUWQD2dAJ2CsC8GyikMx2Z2CviED/opL41wXYKxLQv2iasyGKkgFRlTqaUke2ZEN0WccQxRTFMpANXYG9ogPPJjbJbHcD9ooB9O8nEv+6A3vFBPoXR3M2xFYy4CeljqPUsSzZ8LOs44riiX4xkA09gL1+Bp5NfJLZ7gnsFRfoXwIS/3oBe8UD+pdQczbEVzIggVInVOpfLNnwq6wTiRKLkhjIht7AXr8CzyYpyWz3AfZKBPQvGYl/fYG9EgP9S645G5IqGZBMqZMrdRJLNvwm6xSilKJUBrKhH7DXb8CzSU0y2/2BvVIA/UtD4t8AYK+UQP/Sas6G1EoGpFHqtEqdypIN6WSdXpRBlNFANgwE9koHPBt3ktkeBOyVHuifg8S/wcBeGYD+eWjOBnclAxxK7aHUGS3Z4ClrL5G3KJOBbBgC7OUJPJvMJLM9FNjLC+ifD4l/w4C9vIH++WrOhsxKBvgota9SZ7JkQxZZZxVlE2U3kA3Dgb2yAM8mB8lsjwD2ygr0LyeJfyOBvbIB/culORtyKBmQU6lzKXV2SzbklnUeUV5RPgPZMArYKzfwbPKTzPZoYK88QP8KkPg3BtgrL9C/gpqzIb+SAQWUuqBS57NkQyFZFxYVERU1kA1jgb0KAc+mGMlsjwP2Kgz0rziJf+OBvYoA/SuhORuKKRlQXKlLKHVRSzaUlHUpUWlRGQPZMAHYqyTwbMqSzPZEYK9SQP/Kkfg3CdirNNC/8pqzoaySAeWUurxSl7FkQwVZVxRVElU2kA2Tgb0qAM+mCslsTwH2qgj0ryqJf1OBvSoB/aumORuqKBlQVamrKXVlSzZUl3UNUU1RLQPZMA3YqzrwbGqTzPZ0YK8aQP/8SPybAexVE+hfHc3ZUFvJAD+lrqPUtSzZUFfW/qIAUT0D2TAT2Ksu8Gzqk8z2LGAvf6B/DUj8mw3sFQD0r6HmbKivZEADpW6o1PUs2dBI1o1FTURNDWTDHGCvRsCzaUYy23OBvRoD/WtO4t88YK8mQP9aaM6GZkoGNFfqFkrd1JINLWXdStRa1MZANswH9moJPJu2JLO9ANirFdC/diT+LQT2ag30r73mbGirZEA7pW6v1G0s2dBB1h1FnUSdDWTDImCvDsCz6UIy24uBvToC/etK4t8SYK9OQP+6ac6GLkoGdFXqbkrd2ZIN3WXdQ9RT1MtANiwF9uoOPJveJLO9DNirB9C/PiT+LQf26gn0r6/mbOitZEAfpe6r1L0s2dBP1v1FA0QDDWTDCmCvfsCzGUQy2yuBvfoD/RtM4t8qYK8BQP+GaM6GQUoGDFbqIUo90JINQ2U9TDRcNMJANqwG9hoKPJuRJLO9BthrGNC/UST+rQX2Gg70b7TmbBipZMAopR6t1CMs2TBG1mNF40TjDWTDOmCvMcCzmUAy2+uBvcYC/ZtI4t8GYK9xQP8mac6GCUoGTFTqSUo93pINk2U9RTRVNM1ANmwE9poMPJvpJLO9CdhrCtC/GST+bQb2mgr0b6bmbJiuZMAMpZ6p1NMs2TBL1rNFc0RzDWTDFmCvWcCzmUcy21uBvWYD/ZtP4t82YK85QP8WaM6GeUoGzFfqBUo915INC2W9SLRYtMRANmwH9loIPJulJLO9A9hrEdC/ZST+7QT2Wgz0b7nmbFiqZMAypV6u1Ess2bBC1itFq0SrDWTDLmCvFcCzWUMy27uBvVYC/VtL4t8eYK9VQP/Wac6GNUoGrFXqdUq92pIN62W9QbRRtMlANuwF9loPPJvNJLO9D9hrA9C/LST+7Qf22gj0b6vmbNisZMAWpd6q1Jss2bBN1ttFO0Q7DWTD78Be24Bns4tktg8Ae20H+rebxL+DwF47gP7t0ZwNu5QM2K3Ue5R6pyUb9sp6n2i/6HcD2XAI2Gsv8GwOkMz2H8Be+4D+HSTx709gr/1A/w5pzoYDSgYcVOpDSv27JRv+kPWfosOiIway4TDyOgGezVGS2T6CvE6A/h0j8e8ocpaB/h3XnA1HlQw4ptTHlfqIJRtOyPqk6JTotIFsOAbsdQJ4NmdIZvs4sNdJoH9nSfw7Aex1CujfOc3ZcEbJgLNKfU6pT1uy4bysL4guii4ZyIaTwF7ngWdzmWS2TwF7XQD6d4XEv9PAXheB/l3VnA2XlQy4otRXlfqSJRuuyfq66IbopoFsOAPsdQ14NrdIZvsssNd1oH+3Sfw7B+x1A+jfHc3ZcEvJgNtKfUepb1qy4a6s74nuix4YyIbzwF53gWfzkGS2LwB73QP694jEv4vAXveB/j3WnA0PlQx4pNSPlfqBJRueyPqp6JnouYFsuATs9QR4Ni9IZvsysNdToH8vSfy7Auz1DOjfK83Z8ELJgJdK/Uqpn1uy4bWs34jeit4ZyIarwF6vgWfznmS2rwF7vQH694HEv+vAXm+B/n3UnA3vlQz4oNQflfqdJRs+yfqzyC2sfD6s/my4Aez1CXg2IcNyzPZNYK/PQP9Ckfh3C9jLLSzOv9Bh9WaDc77/yoBQSh1aqUOE/TIbwsg6rCicKLyBbLgN7BUGeDYRSGb7DrBXWKB/EUn8uwvsFQ7oXyTN2RBByYCISh1JqcNbsiGyrKOIooqiGciGe8BekYFnE51ktu8De0UB+heDxL8HwF5Rgf7F1JwN0ZUMiKHUMZU6miUbYsk6tugnURwD2fAQ2CsW8Gx+JpntR8BesYH+xSXx7zGw109A/+JpzoaflQyIq9TxlDqOJRt+kXV8UQJRQgPZ8ATY6xfg2fxKMttPgb3iA/1LROLfM2CvBED/EmvOhl+VDEik1ImVOqElG5LIOqkomSi5gWx4DuyVBHg2v5HM9gtgr6RA/1KQ+PcS2CsZ0L+UmrPhNyUDUih1SqVObsmGVLJOLUojSmsgG14Be6UCnk06ktl+DeyVGuhfehL/3gB7pQH6l0FzNqRTMiC9UmdQ6rSWbMgoa3eRQ+RhIBveAntlBJ6NJ8lsvwP2cgf650Xi33tgLwfQP2/N2eCpZICXUnsrtYclGzLJOrPIR+RrIBs+AHtlAp5NFpLZ/gjslRnoX1YS/z4Be/kA/cumORuyKBmQVamzKbWvJRuyyzqHKKeTzUA2fAb2yg48m9wks+08RFSvHED/8pD4FwLoX06gf3k1Z0NuJQPyKHVepc5lyYZ8ss4vKiAqaCAbQgLPJh/wbAqRzHYooH/5gf4VJvEvNNC/AkD/imjOhkJKBhRW6iJKXdCSDUVlXUxUXFTCQDaEAZ5NUeDZlCSZ7bBA/4oB/StF4l84oH/Fgf6V1pwNJZUMKKXUpZW6hCUbysi6rKicqLyBbAgPPJsywLOpQDLbEYD+lQX6V5HEv4hA/8oB/aukORsqKBlQUakrKXV5SzZUlnUVUVVRNQPZEAl4NpWBZ1OdZLYjA/2rAvSvBol/UYD+VQX6V1NzNlRXMqCGUtdU6mqWbKgl69oiP1EdA9kQFXg2tYBnU5dktqMB/asN9M+fxL/oQP/8gP4FaM6GukoG+Ct1gFLXsWRDPVnXFzUQNTSQDTGAZ1MPeDaNSGY7JtC/+kD/GpP4FwvoXwOgf000Z0MjJQMaK3UTpW5oyYamsm4mai5qYSAbYgPPpinwbFqSzPZPQP+aAf1rReJfHKB/zYH+tdacDS2VDGil1K2VuoUlG9rIuq2onai9gWz4GXg2bYBn04FktuMC/WsL9K8jiX/xgP61A/rXSXM2dFAyoKNSd1Lq9pZs6CzrLqKuom4GsuEX4Nl0Bp5Nd5LZjg/0rwvQvx4k/iUA+tcV6F9PzdnQXcmAHkrdU6m7WbKhl6x7i/qI+hrIhoTAs+kFPJt+JLP9K9C/3kD/+pP4lwjoXx+gfwM0Z0M/JQP6K/UApe5ryYaBsh4kGiwaYiAbEgPPZiDwbIaSzHYSoH+DgP4NI/EvKdC/wUD/hmvOhqFKBgxT6uFKPcSSDSNkPVI0SjTaQDYkA57NCODZjCGZ7eRA/0YC/RtL4t9vQP9GAf0bpzkbxigZMFapxyn1aEs2jJf1BNFE0SQD2ZACeDbjgWczmWS2UwL9mwD0bwqJf6mA/k0E+jdVczZMVjJgilJPVepJlmyYJuvpohmimQayITXwbKYBz2YWyWynAfo3HejfbBL/0gL9mwH0b47mbJilZMBspZ6j1DMt2TBX1vNE80ULDGRDOuDZzAWezUKS2U4P9G8e0L9FJP5lAPo3H+jfYs3ZsFDJgEVKvVipF1iyYYmsl4qWiZYbyIaMwLNZAjybFSSz7Q70bynQv5Uk/jmA/i0D+rdKczasUDJgpVKvUurllmxYLes1orWidQaywQN4NquBZ7OeZLY9gf6tAfq3gcQ/L6B/a4H+bdScDeuVDNig1BuVep0lGzbJerNoi2irgWzwBp7NJuDZbCOZ7UxA/zYD/dtO4l9moH9bgP7t0JwN25QM2K7UO5R6qyUbdsp6l2i3aI+BbPABns1O4NnsJZltX6B/u4D+7SPxLwvQv91A//Zrzoa9SgbsU+r9Sr3Hkg2/y/qA6KDokIFsyAo8m9+BZ/MHyWxnA/p3AOjfnyT+ZQf6dxDo32HN2fCHkgF/KvVhpT5kyYYjsj4qOiY6biAbcgDP5gjwbE6QzHZOoH9Hgf6dJPEvF9C/Y0D/TmnOhhNKBpxU6lNKfdySDadlfUZ0VnTOQDbkBp7NaeDZnCeZ7TxA/84A/btA4l9eoH9ngf5d1JwN55UMuKDUF5X6nCUbLsn6suiK6KqBbMgHPJtLwLO5RjLb+YH+XQb6d53EvwJA/64A/buhORuuKRlwXalvKPVVSzbclPUt0W3RHQPZUBB4NjeBZ3OXZLYLAf27BfTvHol/hYH+3Qb6d19zNtxVMuCeUt9X6juWbHgg64eiR6LHBrKhCPBsHgDP5gnJbBcF+vcQ6N9TEv+KAf17BPTvmeZseKJkwFOlfqbUjy3Z8FzWL0QvRa8MZENx4Nk8B57Na5LZLgH07wXQvzck/pUE+vcS6N9bzdnwWsmAN0r9VqlfWbLhnazfiz6IPhrIhlLAs3kHPJtPJLNdGujfe6B/n0n8KwP07wPQP7dwerPhk5IBn5Xa+f/3r/qjJRtCyOdCikKJQofTnw1lgWcTIhzubMKE45jtckD/QgL9C0viX3mgf6GA/oXTnA1hlAwIq9ThlDp0uC+zIbysI4giiiIZyIYKwLMJDzybyCSzXRHoXwSgf1FI/KsE9C8i0L+omrMhspIBUZQ6qlJHsmRDNFlHF8UQxTSQDZWBZxMNeDaxSGa7CtC/6ED/YpP4VxXoXwygfz9pzoZYSgbEVuqflDqmJRviyPpnUVxRPAPZUA14NnGAZ/MLyWxXB/r3M9C/+CT+1QD6FxfoXwLN2fCLkgHxlTqBUsezZENCWf8qSiRKbCAbagLPJiHwbJKQzHYtoH+/Av1LSuJfbaB/iYD+JdOcDUmUDEiq1MmUOrElG5LL+jdRClFKA9ngBzyb5MCzSUUy23WA/v0G9C81iX91gf6lAPqXRnM2pFIyILVSp1HqlJZsSCvrdKL0ogwGssEfeDZpgWeTkWS2A4D+pQP6507iXz2gf+mB/jk0Z0NGJQPcldqh1Bks2eAha0+Rl8jbQDbUB56NB/BsMpHMdgOgf55A/zKT+NcQ6J8X0D8fzdmQScmAzErto9TelmzwlXUWUVZRNgPZ0Ah4Nr7As8lOMtuNgf5lAfqXg8S/JkD/sgL9y6k5G7IrGZBDqXMqdTZLNuSSdW5RHlFeA9nQFHg2uYBnk49ktpsB/csN9C8/iX/Ngf7lAfpXQHM25FMyIL9SF1DqvJZsKCjrQqLCoiIGsqEF8GwKAs+mKMlstwT6VwjoXzES/1oB/SsM9K+45mwoqmRAMaUurtRFLNlQQtYlRaVEpQ1kQ2vg2ZQAnk0ZktluA/SvJNC/sppnu4wyw2WVupRSl7bMdjlZlxdVEFW0me2Q4LNJ6YbzsxLOT+fb7v/PHDr/6+ybWLMPlYBzVVmTD5UDfQht8UD9CAH2JYSbnoxxw3LWtusNNyO1W9CHxD/A+eFw6ORMA+MM8NbJmRbGWSeTTs50ME53P52c6UnOPQOM08dfJ2dGGKdD63y6wzgz1dbJ6cDNp49OTg/cfHro5PSEcfprvd69cPPpq5PTG8ZZp45Ozkwwztpa8zMzjNPHSyenD24+tX5d5wvj9K+rkzMLjNNDq59ZYZxeWl83s8E4a2vNpewwTndPnZw5YJyZtF5HOXHzGaCTMxduPrXmfG4Yp09mnZx5YJyeWr9eygvjrKM15/PBOP21zmd+GKfef2coAOP01fq6WRB37lr9LOSm5+vPMChOx3/+kxrzg5z/6ZYmBMg/6ZY2BO4s1JvRB/UHAVU0/YAOfa7pgeeaAXiuyJt/uwPPtSr4B4d//YCnqs0PutBnXRp41mWAZ418Y7JywLOupumsq33FDzWD/IeMbjhPq2nKssTW+Xa4B+mj8JfPOUjdilj9C0K3on8/i+/uVszN5iy+s1txN9tz/a5uJdz+YUa+o1tJt3+ct2/uVsrNxex+Y7fSbi6vg2/qVsbtX66pb+hW1u1fr8+v7lbu33t9dbfyX9PrK7tV+LpeX9Wt4tf2+opulb6+1792q/wtvf6lW5Vv6+WyW9Vv7eWiW7Vv7/WP3ap/T69/6Fbj+3rZdqv5vb1sutX6/l5/61Y7KL0s3fyC1uuLbnWC2kvpVjfovf63mz+iV2C3AEyv/+lWD9XL+Qe1uF7uzl9O++vrXLfAOv1f/2Ci7LkB+QsD+XUxFiFgLErAWIyAsTgBYwkCxpIEjKUIGEsTMJZxC/6MZd2CP2M5t+DPWN4t+DNWcAv+jBXdgj9jJbfgz1jZLfgzVnEL/oxV3YI/YzW34M9Y3S34M9ZwC/6MNd2CP2MtAsbabsGf0c8t+DPWcQv+jHXdgj+jv1vwZwxwC/6M9QgYkf82qYuxAQFjQwLGRgSMjQkYmxAwNiVgbEbA2JyAsQUBY0sCxlYEjK0JGNsQMLYlYGxHwNiegLEDAWNHAsZOBIydCRi7EDB2JWDsRsDYnYCxBwFjTwLGXgSMvQkY+xAw9iVg7EfA2J+AcQAB40ACxkEEjIMJGIcQMA4lYBxGwDicgHEEAeNIAsZRBIyjCRjHEDCOJWAcR8A4noBxAgHjRALGSQSMkwkYpxAwTiVgnEbAOJ2AcQYB40wCxlkEjLMJGOcQMM4lYJxHwDifgHEBAeNCAsZFBIyLCRiXEDAuJWBcRsC4nIBxBQHjSgLGVQSMqwkY1xAwriVgXEfAuJ6AcQMB40YCxk0EjJsJGLcQMG4lYNxGwLidgHEHAeNOAsZdBIy7CRj3EDDuJWDcR8C4n4DxdwLGAwSMBwkYDxEw/kHA+CcB42ECxiMEjEcJGI8RMB4nYDxBwHiSgPEUAeNpAsYzBIxnCRjPETCeJ2C8QMB4kYDxEgHjZQLGKwSMVwkYrxEwXidgvEHAeJOA8RYB420CxjsEjHcJGO8RMN4nYHxAwPiQgPERAeNjAsYnBIxPCRifETA+J2B8QcD4koDxFQHjawLGNwSMbwkY3xEwvidg/EDA+JGA8RMB42cCRmfD4M4YgoAxJAFjKALG0ASMYQgYwxIwhiNgDE/AGIGAMSIBYyQCxsgEjFEIGKMSMEYjYIxOwBiDgDEmAWMsAsbYBIw/ETDGIWD8mYAxLgFjPALGXwgY4xMwJiBgTEjA+CsBYyICxsQEjEkIGJMSMCYjYExOwPgbAWMKAsaUBIypCBhTEzCmIWBMS8CYjoAxPQFjBgLGjASM7gSMDgJGDwJGTwJGLwJGbwLGTASMmQkYfQgYfQkYsxAwZiVgzEbAmJ2AMQcBY04CxlwEjLkJGPMQMOYlYMxHwJifgLEAAWNBAsZCBIyFCRiLEDAWJWAsRsBYnICxBAFjSQLGUgSMpQkYyxAwliVgLEfAWJ6AsQIBY0UCxkoEjJUJGKsQMFYlYKxGwFidgLEGAWNNAsZaBIy1CRj9CBjrEDDWJWD0J2AMIGCsR8BYn4CxAQFjQwLGRgSMjQkYmxAwNiVgbEbA2JyAsQUBY0sCxlYEjK0JGNtoYFQ/IL0dHnW19ZaPkIq30QPr6uHc3GqIaopqiWqL/ER1RHVF/qIAUT1RfVEDUUNRI1HjcP/p0SRcYNNQgf91Nk1s2aths1fTZq+WzV5tmz0/m706Nnt1bfb8bfYCbPbq2ezVt9lrYLPX0Gavkc1eY5u9JoF76kco5DA43N0Lu+EuriJKL0/3TF5e/pk9/B2ejtruHr5+Pt7uXt5+mXwcPg5vH++6Hj6env4+Xj6Zff18M7v7Orw8/R0B3r6eAYHNmobDDbzqaVMbT0OCPVXZg+pDM00+NNM9W85fKgD2agb0tLkmT5sbmK3mQB9aaPKhhYHZKgbs1QLoaUtNnrbUPVvOHz4EUx+0zZFcT8WB/pVww/nXStMctTKQUa2Ac9Rakw+tDWRUSWCv1kBP22jytI2B2WoD9KGtJh/aGpitUsBebYGettPkaTsDr381gqkP2uZIrqfSQP/KuOH8a69pjtobyKj2wDnqoMmHDgYyqiywVwegpx01edrRwGx1BPrQSZMPnQzMVjlgr05ATztr8rSzgde/msHUB21zJNdTeaB/Fdxw/nXRNEddDGRUF+AcddXkQ1cDGVUR2Ksr0NNumjztZmC2ugF96K7Jh+4GZqsSsFd3oKc9NHnaw8DrX61g6oO2OZLrqTLQvypuOP96apqjngYyqidwjnpp8qGXgYyqCuzVC+hpb02e9jYwW72BPvTR5EMfA7NVDdirD9DTvpo87Wvg9a92MPVB2xzJ9VQd6F8NN5x//TTNUT8DGdUPOEf9NfnQ30BG1QT26g/0dIAmTwcYmK0BQB8GavJhoIHZqgXsNRDo6SBNng4y8PrnF0x90DZHcj3VRvrnhvNvsKY5GmwgowYD52iIJh+GGMioOsBeQ4CeDtXk6VADszUU6MMwTT4MMzBbdYG9hgE9Ha7J0+EGXv/qBFMftM2RXE/+QP8C3HD+jdA0RyMMZNQI4ByN1OTDSAMZVQ/YayTQ01GaPB1lYLZGAX0YrcmH0QZmqz6w12igp2M0eTrGwOtf3WDqg7Y5kuupAdC/hm44/8ZqmqOxBjJqLHCOxmnyYZyBjGoE7DUO6Ol4TZ6ONzBb44E+TNDkwwQDs9UY2GsC0NOJmjydaOD1zz+Y+qBtjuR6agL0r6kbzr9JmuZokoGMmgSco8mafJhsIKOaAXtNBno6RZOnUwzM1hSgD1M1+TDVwGw1B/aaCvR0miZPpxl4/QsIpj5omyO5nloA/WvphvNvuqY5mm4go6YD52iGJh9mGMioVsBeM4CeztTk6UwDszUT6MMsTT7MMjBbrYG9ZgE9na3J09kGXv/qBVMftM2R8/0kgP61dcP5N0fTHM0xkFFzgHM0V5MPcw1kVDtgr7lAT+dp8nSegdmaB/RhviYf5huYrfbAXvOBni7Q5OkCA69/9YOpD9rmSK6nDkD/Orrh/FuoaY4WGsiohcA5WqTJh0UGMqoTsNcioKeLNXm62MBsLQb6sESTD0sMzFZnYK8lQE+XavJ0qYHXvwbB1Adtc+R8rxKgf13dcP4t0zRHywxk1DLgHC3X5MNyAxnVDdhrOdDTFZo8XWFgtlYAfVipyYeVBmarO7DXSqCnqzR5usrA61/DYOqDtjmS66kH0L+ebjj/Vmuao9UGMmo1cI7WaPJhjYGM6gXstQbo6VpNnq41MFtrgT6s0+TDOgOz1RvYax3Q0/WaPF1v4PWvUTD1QdscyfXUB+hfXzecfxs0zdEGAxm1AThHGzX5sNFARvUD9toI9HSTJk83GZitTUAfNmvyYbOB2eoP7LUZ6OkWTZ5uMfD61ziY+qA+5xCW5xxUzq0Azky13X39M2XKrJNzG4DTzy9T5tr+Pt46ObcDOD3rZPIP8MzsoZNzB4CztrdXQIC3Z22dnDsBnN4Od39vj8wBOjl3ATh9/dy9M/n41NHJuRvA6Qjw8azrW9tPJ+cexLn7+bvXqevwdbLFcvv7PWnVe9Gq96BV7z2r3nNWvdeseo9Z9d6y6j1l1XvJqveQVe8dq94zVr1XrHqPWPXesFuVeptSb1fqHUq9U6l3KfVupd4TWO+V/+4T7Rf9LjogOig6JPpDFNrtv/en/evM04dwc3M1B+5B+3AA70+r7abSRQgYixIwFiNgLE7AWIKAsSQBYykCxtIEjGUIGMsSMJYjYCxPwFiBgLEiAWMlAsbKBIxVCBirEjBWI2CsTsBYg4CxJgFjLQLG2gSMfgSMdQgY6xIw+hMwBhAw1iNgrE/A2ICAsSEBYyMCxsYEjE0IGJsSMDYjYGxOwNiCgLElAWMrAsbWBIxtCBjbEjC2I2BsT8DYgYCxIwFjJwLGzgSMXQgYuxIwdiNg7E7A2IOAsScBYy8Cxt4EjH0IGPsSMPYjYOxPwDiAgHEgAeMgAsbBBIxDCBiHEjAOI2AcTsA4goBxJAHjKALG0QSMYwgYxxIwjiNgHE/AOIGAcSIB4yQCxskEjFMIGKcSME4jYJxOwDiDgHEmAeMsAsbZBIxzCBjnEjDOI2CcT8C4gIBxIQHjIgLGxQSMSwgYlxIwLiNgXE7AuIKAcSUB4yoCxtUEjGsIGNcSMK4jYFxPwLiBgHEjAeMmAsbNBIxbCBi3EjBuI2DcTsC4g4BxJwHjLgLG3QSMewgY9xIw7iNg3E/A+DsB4wECxoMEjIcIGP8gYPyTgPEwAeMRAsajBIzHCBiPEzCeIGA8ScB4ioDxNAHjGQLGswSM5wgYzxMwXiBgvEjAeImA8TIB4xUCxqsEjNcIGK8TMN4gYLxJwHiLgPE2AeMdAsa7BIz3CBjvEzA+IGB8SMD4iIDxMQHjEwLGpwSMzwgYnxMwviBgfEnA+IqA8TUB4xsCxrcEjO8IGN8TMH4gYPxIwPiJgPEzAaOzYXBnDEHAGJKAMRQBY2gCxjAEjGEJGMMRMIYnYIxAwBiRgDESAWNkAsYoBIxRCRijETBGJ2CMQcAYk4AxFgFjbALGnwgY4xAw/kzAGJeAMR4B4y8EjPEJGBMQMCYkYPyVgDERAWNiAsYkBIxJCRiTETAmJ2D8jYAxBQFjSgLGVASMqQkY0xAwpiVgTEfAmJ6AMQMBY0YCRncCRgcBowcBoycBoxcBozcBYyYCxswEjD4EjL4EjFkIGLMSMGYjYMxOwJiDgDEnAWMuAsbcBIx5CBjzEjDmI2DMT8BYgICxIAFjIQLGwgSMRQgYixIwFiNgLE7AWIKAsSQBYykCxtIEjGUIGMsSMJYjYCxPwFiBgLEiAWMlAsbKBIxVCBirEjBWI2CsTsBYg4CxJgFjLQLG2gSMfgSMdQgY6xIw+hMwBhAw1iNgrE/A2ICAsSEBYyMCxsYEjE0IGJsSMDYjYGxOwNiCgLElAWMrAsbWBIxtNDCqH5DeDo+62nq7e7mHVLyNHlj/Gc7N7bDoiOio6JjouOiE6KTolOi06IzorOic6LzoguhiuP/0uBQusGmowP86mya27B222Ttis3fUZu+Yzd5xm70TNnsnbfZO2eydttk7Y7N31mbvnM3eeZu9CzZ7F232LgXuqR+hkMPgcHcf4Ia7uAYqvTzdM3l5+Wf28Hd4Omq7e/j6+Xi7e3n7ZfJx+Di8fbzrevh4evr7ePlk9vXzzezu6/Dy9HcEePt6BgQ2uxwOd6Gqnl628TQk2FOVPag+XNHkwxXdsyVODAL2ugL09KomT68amK2rQB+uafLhmoHZGgzsdQ3o6XVNnl7XPVviw5/B1AdtcyTX0xCgf0PdcP7d0DRHNwxk1A3gHN3U5MNNAxk1DNjrJtDTW5o8vWVgtm4BfbityYfbBmZrOLDXbaCndzR5esfA69/hYOqDtjmS62kE0L+Rbjj/7mqao7sGMuoucI7uafLhnoGMGgXsdQ/o6X1Nnt43MFv3gT480OTDAwOzNRrY6wHQ04eaPH1o4PXvSDD1QdscyfU0BujfWDecf480zdEjAxn1CDhHjzX58NhARo0D9noM9PSJJk+fGJitJ0Afnmry4amB2RoP7PUU6OkzTZ4+M/D6dzSY+qBtjuR6mgD0b6Ibzr/nmubouYGMeg6coxeafHhhIKMmAXu9AHr6UpOnLw3M1kugD680+fDKwGxNBvZ6BfT0tSZPXxt4/TsWTH3QNkdyPU0B+jfVDeffG01z9MZARr0BztFbTT68NZBR04C93gI9fafJ03cGZusd0If3mnx4b2C2pgN7vQd6+kGTpx8MvP4dD6Y+aJsjuZ5mAP2b6Ybz76OmOfpoIKM+AufokyYfPhnIqFnAXp+Ann7W5OlnA7P1GeiDW3g9Pjj7JtY8W7OBvVQfguppCE2ehgiv//XvRLjg6YO2OZLraQ7Qv7luOP9CapqjkOH1Z1RI4PUUSpMPoQxk1Dxgr1BAT0Nr8jS0gdkKDfQhjCYfwhiYrfnAXmGAnobV5GlYA69/J8MFTx+0zZFcTwuA/i10w/kXTtMchTOQUeGA11N4TT6EN5BRi4C9wgM9jaDJ0wgGZisC0IeImnyIaGC2FgN7RQR6GkmTp5EMvP6dChc8fdA2R3I9LQH6t9QN519kTXMU2UBGRQZeT1E0+RDFQEYtA/aKAvQ0qiZPoxqYrahAH6Jp8iGagdlaDuwVDehpdE2eRjfw+nc6XPD0QdscyfW0AujfSjecfzE0zVEMAxkVA3g9xdTkQ0wDGbUK2Csm0NNYmjyNZWC2YgF9iK3Jh9gGZms1sFdsoKc/afL0JwOvf2fCBU8ftM2RXE9rgP6tdcP5F0fTHMUxkFFxgNfTz5p8+NlARq0D9voZ6GlcTZ7GNTBbcYE+xNPkQzwDs7Ue2Cse0NNfNHn6i4HXv7PhgqcP2uZIrqcNQP82uuH8i69pjuIbyKj4wOspgSYfEhjIqE3AXgmAnibU5GlCA7OVEOjDr5p8+NXAbG0G9voV6GkiTZ4mMvD6dy5c8PRB2xzJ9bQF6N9WN5x/iTXNUWIDGZUYeD0l0eRDEgMZtQ3YKwnQ06SaPE1qYLaSAn1IpsmHZAZmazuwVzKgp8k1eZrcwOvf+XDB0wdtcyTX0w6gfzvdcP79pmmOfjOQUb8Br6cUmnxIYSCjdgF7pQB6mlKTpykNzFZKoA+pNPmQysBs7Qb2SgX0NLUmT1MbeP27EC54+qBtjuR62gP0b68bzr80muYojYGMSgO8ntJq8iGtgYzaB+yVFuhpOk2epjMwW+mAPqTX5EN6A7O1H9grPdDTDJo8zWDg9e9iuODrQyy3v99TUb2XonoPRfXeieo9E9V7Jar3SFTvjajeE1G9F6J6D0T13ofqPQ/Vex2q9zhU7224V6n3KfV+pf5dqQ8o9UGlPqTUfwTWGcVzd5FD5CHyFHmJvEWZRKHd/nt/RbfAOn0Ity8+QoBnqrAb/usgNGMRAsaiBIzFCBiLEzCWIGAsScBYioCxNAFjGQLGsgSM5QgYyxMwViBgrEjAWImAsTIBYxUCxqoEjNUIGKsTMNYgYKxJwFiLgLE2AaMfAWMdAsa6BIz+BIwBBIz1CBjrEzA2IGBsSMDYiICxMQFjEwLGpgSMzQgYmxMwtiBgbEnA2IqAsTUBYxsCxrYEjO0IGNsTMHYgYOxIwNiJgLEzAWMXAsauBIzdCBi7EzD2IGDsScDYi4CxNwFjHwLGvgSM/QgY+xMwDiBgHEjAOIiAcTAB4xACxqEEjMMIGIcTMI4gYBxJwDiKgHE0AeMYAsaxBIzjCBjHEzBOIGCcSMA4iYBxMgHjFALGqQSM0wgYpxMwziBgnEnAOIuAcTYB4xwCxrkEjPMIGOcTMC4gYFxIwLiIgHExAeMSAsalBIzLCBiXEzCuIGBcScC4ioBxNQHjGgLGtQSM6wgY1xMwbiBg3EjAuImAcTMB4xYCxq0EjNsIGLcTMO4gYNxJwLiLgHE3AeMeAsa9BIz7CBj3EzD+TsB4gIDxIAHjIQLGPwgY/yRgPEzAeISA8SgB4zECxuMEjCcIGE8SMJ4iYDxNwHiGgPEsAeM5AsbzBIwXCBgvEjBeImC8TMB4hYDxKgHjNQLG6wSMNwgYbxIw3iJgvE3AeIeA8S4B4z0CxvsEjA8IGB8SMD4iYHxMwPiEgPEpAeMzAsbnBIwvCBhfEjC+ImB8TcD4hoDxLQHjOwLG9wSMHwgYPxIwfiJg/EzA6GwY3BlDEDCGJGAMRcAYmoAxDAFjWALGcASM4QkYIxAwRiRgjETAGJmAMQoBY1QCxmgEjNEJGGMQMMYkYIxFwBibgPEnAsY4BIw/EzDGJWCMR8D4CwFjfALGBASMCQkYfyVgTETAmJiAMQkBY1ICxmQEjMkJGH8jYExBwJiSgDEVAWNqAsY0BIxpCRjTETCmJ2DMQMCYkYDRnYDRQcDoQcDoScDoRcDoTcCYiYAxMwGjDwGjLwFjFgLGrASM2QgYsxMw5iBgzEnAmIuAMTcBYx4CxrwEjPkIGPMTMBYgYCxIwFiIgLEwAWMRAsaiBIzFCBiLEzCWIGAsScBYioCxNAFjGQLGsgSM5QgYyxMwViBgrEjAWImAsTIBYxUCxqoEjNUIGKsTMNYgYKxJwFiLgLE2AaMfAWMdAsa6BIz+BIwBBIz1CBjrEzA2IGBsSMDYiICxMQFjEwLGpgSMzQgYmxMwtiBgbEnA2IqAsTUBYxsNjOoHpLfDo6623u4+7iEVb6MH1pnDu7n5iHxFWURZRdlE2UU5RDlFuUS5RXlEeUX5RPlFBcL/p0fB8IFNQwX+19k0sWXPx2bP12Yvi81eVpu9bDZ72W32ctjs5bTZy2Wzl9tmL4/NXl6bvXw2e/lt9grY7BUM3FM/QrkBh8Hh7g68geIXNzr0dM/k5eWf2cPf4emo7e7h6+fj7e7l7ZfJx+Hj8Pbxruvh4+np7+Plk9nXzzezu6/Dy9PfEeDt6xkQ2KxQeNyFqnpayMbTkGBPVfag+lBYkw+Fdc+WO/Smko7CQE+LaPK0iIHZKgL0oagmH4oamC3gzUAdRYGeFtPkaTHds+X8o4Zg6oO2OZLrCXjD1i9urBpU/4prmqPiBjKqOHCOSmjyoYSBjALexNZRAuhpSU2eljQwWyWBPpTS5EMpA7N1BNirFNDT0po8LW3g9c8nmPqgbY7kegLeIPqLGzkH1b8ymuaojIGMKgOco7KafChrIKOAN812lAV6Wk6Tp+UMzFY5oA/lNflQ3sBsAW927igP9LSCJk8rGHj98w2mPmibI7megDek/+LG8UH1r6KmOapoIKMqAueokiYfKhnIqNPAXpWAnlbW5GllA7NVGehDFU0+VDEwW2eAvaoAPa2qydOqBl7/sgRTH7TNkVxPZ4H+nXPD+VdN0xxVM5BR1YBzVF2TD9UNZNR5YK/qQE9raPK0hoHZqgH0oaYmH2oamK0LwF41gZ7W0uRpLQOvf1mDqQ/a5kiup4tA/y654fyrrWmOahvIqNrAOfLT5IOfgYy6DOzlB/S0jiZP6xiYrTpAH+pq8qGugdm6AuxVF+ipvyZP/Q28/mULpj5omyO5nq4C/bvmhvMvQNMcBRjIqADgHNXT5EM9Axl1HdirHtDT+po8rW9gtuoDfWigyYcGBmbrBrBXA6CnDTV52tDA61/2YOqDtjmS6+km0L9bbjj/Gmmao0YGMqoRcI4aa/KhsYGMug3s1RjoaRNNnjYxMFtNgD401eRDUwOzdQfYqynQ02aaPG1m4PUvRzD1QdscyfV0F+jfPTecf801zVFzAxnVHDhHLTT50MJARt0H9moB9LSlJk9bGpitlkAfWmnyoZWB2XoA7NUK6GlrTZ62NvD6lzOY+qBtjuR6egj075Ebzr82muaojYGMagOco7aafGhrIKMeA3u1BXraTpOn7QzMVjugD+01+dDewGw9AfZqD/S0gyZPOxh4/csVTH3QNkdyPT0F+vfMDedfR01z1NFARnUEzlEnTT50MpBRz4G9OgE97azJ084GZqsz0IcumnzoYmC2XgB7dQF62lWTp10NvP7lDqY+aJsjuZ5eAv175Ybzr5umOepmIKO6AeeouyYfuhvIqNfAXt2BnvbQ5GkPA7PVA+hDT00+9DQwW2+AvXoCPe2lydNeBl7/8gRTH7TNkVxPb4H+vXPD+ddb0xz1NpBRvYFz1EeTD30MZNR7YK8+QE/7avK0r4HZ6gv0oZ8mH/oZmK0PwF79gJ721+RpfwOvf3mDqQ/a5kiup49A/z654fwboGmOBhjIqAHAORqoyYeBBjLqM7DXQKCngzR5OsjAbA0C+jBYkw+DDcyW8/8RqtdgoKdDNHk6xMDrX75g6oO2OZLrKQRwjkKGwPk3VNMcDTWQUUOBczRMkw/DDGRUKOBsDQN6OlyTp8MNzNZwoA8jNPkwwsBshQbO1gigpyM1eTrSwOtf/mDqg7Y5kuspDHCOwgJf/0ZpmqNRBjJqFHCORmvyYbSBjAoHnK3RQE/HaPJ0jIHZGgP0YawmH8YamK3wwNkaC/R0nCZPxxl4/SsQjH2I5fb3eyqq91JU76Go3jtRvWeieq9E9R6J6r0R1XsiqvdCVO+BqN77UL3noXqvQ/Ueh+q9DTMqtbtSO5TaQ6k9ldpLqb2VOlNgPV7+O0E0UTRJNFk0RTRVNE0U2u2/91d0C6zTh3D74iMEeKYKu+G/DkIzFiFgLErAWIyAsTgBYwkCxpIEjKUIGEsTMJYhYCxLwFiOgLE8AWMFAsaKBIyVCBgrEzBWIWCsSsBYjYCxOgFjDQLGmgSMtQgYaxMw+hEw1iFgrEvA6E/AGEDAWI+AsT4BYwMCxoYEjI0IGBsTMDYhYGxKwNiMgLE5AWMLAsaWBIytCBhbEzC2IWBsS8DYjoCxPQFjBwLGjgSMnQgYOxMwdiFg7ErA2I2AsTsBYw8Cxp4EjL0IGHsTMPYhYOxLwNiPgLE/AeMAAsaBBIyDCBgHEzAOIWAcSsA4jIBxOAHjCALGkQSMowgYRxMwjiFgHEvAOI6AcTwB4wQCxokEjJMIGCcTME4hYJxKwDiNgHE6AeMMAsaZBIyzCBhnEzDOIWCcS8A4j4BxPgHjAgLGhQSMiwgYFxMwLiFgXErAuIyAcTkB4woCxpUEjKsIGFcTMK4hYFxLwLiOgHE9AeMGAsaNBIybCBg3EzBuIWDcSsC4jYBxOwHjDgLGnQSMuwgYdxMw7iFg3EvAuI+AcT8B4+8EjAcIGA8SMB4iYPyDgPFPAsbDBIxHCBiPEjAeI2A8TsB4goDxJAHjKQLG0wSMZwgYzxIwniNgPE/AeIGA8SIB4yUCxssEjFcIGK8SMF4jYLxOwHiDgPEmAeMtAsbbBIx3CBjvEjDeI2C8T8D4gIDxIQHjIwLGxwSMTwgYnxIwPiNgfE7A+IKA8SUB4ysCxtcEjG8IGN8SML4jYHxPwPiBgPEjAeMnAsbPBIzOhsGdMQQBY0gCxlAEjKEJGMMQMIYlYAxHwBiegDECAWNEAsZIBIyRCRijEDBGJWCMRsAYnYAxBgFjTALGWASMsQkYfyJgjEPA+DMBY1wCxngEjL8QMMYnYExAwJiQgPFXAsZEBIyJCRiTEDAmJWBMRsCYnIDxNwLGFASMKQkYUxEwpiZgTEPAmJaAMR0BY3oCxgwEjBkJGN0JGB0EjB4EjJ4EjF4EjN4EjJkIGDMTMPoQMPoSMGYhYMxKwJiNgDE7AWMOAsacBIy5CBhzEzDmIWDMS8CYj4AxPwFjAQLGggSMhQgYCxMwFiFgLErAWIyAsTgBYwkCxpIEjKUIGEsTMJYhYCxLwFiOgLE8AWMFAsaKBIyVCBgrEzBWIWCsSsBYjYCxOgFjDQLGmgSMtQgYaxMw+hEw1iFgrEvA6E/AGEDAWI+AsT4BYwMCxoYEjI0IGBsTMDYhYGxKwNiMgLE5AWMLAsaWBIytCBhbEzC20cCofkB6OzzqauvtXsc9pOJt9MB6eng3txmimaJZotmiOaK5onmi+aIFooWiRaLFoiWipaJl4f/TY3n4wKahAv/rbJrYsjfDZm+mzd4sm73ZNntzbPbm2uzNs9mbb7O3wGZvoc3eIpu9xTZ7S2z2ltrsLbPZWx64p36EQg6Dw90d+AZCX7zRj6d7Ji8v/8we/g5PR213D18/H293L2+/TD4OH4e3j3ddDx9PT38fL5/Mvn6+md19HV6e/o4Ab1/PgMBmK8LjLlTV0xU2noYEe6qyB9WHlZp8WKl7trBvquRYCfR0lSZPVxmYrVVAH1Zr8mG1gdkCvhmWYzXQ0zWaPF2je7bEh+nB1AdtcyTXE/ANy754Y7Gg+rdW0xytNZBRa4FztE6TD+sMZBTwTdwc64Certfk6XoDs7Ue6MMGTT5sMDBbwDffc2wAerpRk6cbDbz+zQimPmibI7megG+Q+MUbGQbVv02a5miTgYzaBJyjzZp82Gwgo4BvGunYDPR0iyZPtxiYrS1AH7Zq8mGrgdkCvtmnYyvQ022aPN1m4PVvZjD1QdscyfUEfEPWL944Naj+bdc0R9sNZNR24Bzt0OTDDgMZBXyTWscOoKc7NXm608Bs7QT6sEuTD7sMzBbwzYUdu4Ce7tbk6W4Dr3+zgqkP2uZIrifgG0B/8UbNQfVvj6Y52mMgo/YA52ivJh/2Gsgo4JtiO/YCPd2nydN9BmZrH9CH/Zp82G9gtoBvZu7YD/T0d02e/m7g9W92MPVB2xzJ9QR8w/kv3hg+qP4d0DRHBwxk1AHgHB3U5MNBAxkFfBN+x0Ggp4c0eXrIwGwdAvrwhyYf/jAwW4mBs/UH0NM/NXn6p4HXvznB1AdtcyTXE/AGF1/ciCKo/h3WNEeHDWTUYeAcHdHkwxEDGQW86YfjCNDTo5o8PWpgto4CfTimyYdjBmYLeLMWxzGgp8c1eXrcwOvf3GDqg7Y5kusJeEOdL258E1T/TmiaoxMGMuoEcI5OavLhpIGMAt5kyHES6OkpTZ6eMjBbp4A+nNbkw2kDswW8OZTjNNDTM5o8PWPg9W9eMPVB2xzJ9QS8gdcXN9oKqn9nNc3RWQMZdRY4R+c0+XDOQEYBb2rmOAf09LwmT88bmK3zQB8uaPLhgoHZAt6MznEB6OlFTZ5eNPD6Nz+Y+qBtjuR6At4w8Isb+wXVv0ua5uiSgYy6BJyjy5p8uGwgo4A3UXRcBnp6RZOnVwzM1hWgD1c1+XDVwGwBb37puAr09JomT68ZeP1bEEx90DZHcj0Bb1D6xY1Eg+rfdU1zdN1ARl0HztENTT7cMJBRwJu2Om4APb2pydObBmbrJtCHW5p8uGVgtoA323XcAnp6W5Ontw28/i0Mpj5omyO5noA3RP7ixsVB9e+Opjm6YyCj7gDn6K4mH+4ayCjgTaIdd4Ge3tPk6T0Ds3UP6MN9TT7cNzBbwJt7O+4DPX2gydMHBl7/FgVTH7TNkVxPwBuwf3Gj9KD691DTHD00kFEPgXP0SJMPjwxkFPCm9I5HQE8fa/L0sYHZegz04YkmH54YmK1swNl6AvT0qSZPnxp4/VscTH3QNkdyPWUHzlEO4OvfM01z9MxARj0DztFzTT48N5BROYGz9Rzo6QtNnr4wMFsvgD681OTDSwOzlQs4Wy+Bnr7S5OkrA69/S4KpD9rmSK6n3MA5ygN8/XutaY5eG8io18A5eqPJhzcGMiovcLbeAD19q8nTtwZm6y3Qh3eafHhnYLbyAWfrHdDT95o8fW/g9W9pMPVB2xzJ9ZQfOEcFgK9/HzTN0QcDGfUBOEcfNfnw0UBGFQTO1kegp580efrJwGx9AvrwWZMPnw3MViHgbH0GeuoWQY+nzr6Jdc6W+LAsGPsQy+3v91RU76Wo3kNRvXeies9E9V6J6j0S1XsjqvdEVO+FqN4DUb33oXrPQ/Veh+o9DtV7G45X6glKPVGpJyn1ZKWeotRTlXraX7V4HlIUShRaFEYUVhROFN655/bf+yu6BdbpQ7h98RECPFOF3fBfB6EZixAwFiVgLEbAWJyAsQQBY0kCxlIEjKUJGMsQMJYlYCxHwFiegLECAWNFAsZKBIyVCRirEDBWJWCsRsBYnYCxBgFjTQLGWgSMtQkY/QgY6xAw1iVg9CdgDCBgrEfAWJ+AsQEBY0MCxkYEjI0JGJsQMDYlYGxGwNicgLEFAWNLAsZWBIytCRjbEDC2JWBsR8DYnoCxAwFjRwLGTgSMnQkYuxAwdiVg7EbA2J2AsQcBY08Cxl4EjL0JGPsQMPYlYOxHwNifgHEAAeNAAsZBBIyDCRiHEDAOJWAcRsA4nIBxBAHjSALGUQSMowkYxxAwjiVgHEfAOJ6AcQIB40QCxkkEjJMJGKcQME4lYJxGwDidgHEGAeNMAsZZBIyzCRjnEDDOJWCcR8A4n4BxAQHjQgLGRQSMiwkYlxAwLiVgXEbAuJyAcQUB40oCxlUEjKsJGNcQMK4lYFxHwLiegHEDAeNGAsZNBIybCRi3EDBuJWDcRsC4nYBxBwHjTgLGXQSMuwkY9xAw7iVg3EfAuJ+A8XcCxgMEjAcJGA8RMP5BwPgnAeNhAsYjBIxHCRiPETAeJ2A8QcB4koDxFAHjaQLGMwSMZwkYzxEwnidgvEDAeJGA8RIB42UCxisEjFcJGK8RMF4nYLxBwHiTgPEWAeNtAsY7BIx3CRjvETDeJ2B8QMD4kIDxEQHjYwLGJwSMTwkYnxEwPidgfEHA+JKA8RUB42sCxjcEjG8JGN8RML4nYPxAwPiRgPETAeNnAkZnw+DOGIKAMSQBYygCxtAEjGEIGMMSMIYjYAxPwBiBgDEiAWMkAsbIBIxRCBijEjBGI2CMTsAYg4AxJgFjLALG2ASMPxEwxiFg/JmAMS4BYzwCxl8IGOMTMCYgYExIwPgrAWMiAsbEBIxJCBiTEjAmI2BMTsD4GwFjCgLGlASMqQgYUxMwpiFgTEvAmI6AMT0BYwYCxowEjO4EjA4CRg8CRk8CRi8CRm8CxkwEjJkJGH0IGH0JGLMQMGYlYMxGwJidgDEHAWNOAsZcBIy5CRjzEDDmJWDMR8CYn4CxAAFjQQLGQgSMhQkYixAwFiVgLEbAWJyAsQQBY0kCxlIEjKUJGMsQMJYlYCxHwFiegLECAWNFAsZKBIyVCRirEDBWJWCsRsBYnYCxBgFjTQLGWgSMtQkY/QgY6xAw1iVg9CdgDCBgrEfAWJ+AsQEBY0MCxkYEjI0JGJsQMDYlYGxGwNicgLEFAWNLAsZWBIytCRjbaGBUPyC9HR519fV2dw+peBs9sI4Qwc0toiiSKLIoiiiqKJoouiiGKKYolii26CdRHNHPorgR/tMjXoTApqEC/+tsmtiyF9FmL5LNXmSbvSg2e1Ft9qLZ7EW32YthsxfTZi+WzV5sm714gXvqRyjw4QF/4P3FD6Y93TN5efln9vB3eDpqu3v4+vl4u3t5+2Xycfg4vH2863r4eHr6+3j5ZPb1883s7uvw8vR3BHj7egYENvslAu7CUj39xcbTkGBPVfag+hBfkw/xdc8W9pcAHPGBnibQ5GkCA7OVAOhDQk0+JDQwW8Bf3nAkBHr6qyZPf9U9W843fwumPmibI7megL9g88UvwgTVv0Sa5iiRgYxKBJyjxJp8SGwgo4C/dORIDPQ0iSZPkxiYrSRAH5Jq8iGpgdkC/rKYIynQ02SaPE1m4PUvYjD1QdscyfUE/IW+L37xLqj+Jdc0R8kNZFRy4Bz9psmH3wxkFPCXHB2/AT1NocnTFAZmKwXQh5SafEhpYLaAv5zqSAn0NJUmT1MZeP2LFEx90DZHcj0Bf4H4i1/0Dap/qTXNUWoDGZUaOEdpNPmQxkBGAX+p2pEG6GlaTZ6mNTBbaYE+pNPkQzoDswX8ZXhHOqCn6TV5mt7A61/kYOqDtjmS6wn4Bwtf/GFBUP3LoGmOMhjIqAzAOcqoyYeMBjIK+EccjoxAT901eepuYLbcgT44NPngMDBbwD++cTiAnnpo8tTDwOtflGDqg7Y5kusJ+AdSX/whU1D989Q0R54GMsoTOEdemnzwMpBRwD8ac3gBPfXW5Km3gdnyBvqQSZMPmQzMVi3gbGUCeppZk6eZDbz+RQ2mPmibI7megH+Q+cUfTgbVPx9Nc+RjIKN8gHPkq8kHXwMZBfwjVYcv0NMsmjzNYmC2sgB9yKrJh6wGZgv4x8WOrEBPs2nyNJuB179owdQHbXMk1xPwD8C/+EPtoPqXXdMcZTeQUdmBc5RDkw85DGQU8I/iHTmAnubU5GlOA7OVE+hDLk0+5DIwW8A3M3DkAnqaW5OnuQ28/kUPpj5omyO5noBvOPHFG0ME1b88muYoj4GMygOco7yafMhrIKOAb8LhyAv0NJ8mT/MZmK18QB/ya/Ihv4HZAr55iiM/0NMCmjwtYOD1L0Yw9UHbHMn1BHyDmy/eiCao/hXUNEcFDWRUQeAcFdLkQyEDGQV80x9HIaCnhTV5WtjAbBUG+lBEkw9FDMxWc+BsFQF6WlSTp0UNvP7FDKY+aJsjuZ6Ab6j1xRtfBdW/YprmqJiBjCoGnKPimnwobiCjgG8y5igO9LSEJk9LGJitEkAfSmryoaSB2QK+OZyjJNDTUpo8LWXg9S9WMPVB03N2/ja1exvga1ZpTWdf2kCulAaefRlNPpQxcA3EDqY+hJYe4ZXnq36E0OiBexA/bHCD3tvxn/+oXpSN8J//lovg9uWbKDo/Ed4CgH4xQgyN/3+mxlEWOIDlNB0keuBYOH8i4YxDwvkzCWfcH0FuLMjLBwZ5BWuQlw8McnXP+T+Ka4EKzuFeHhjuFYL7V9iBh4t8zhU1fWVZ0cBXlhWBPlSC+ODjbvWhUqAPoQOf/1/XkvNz0S3+oMMqgoZ5RjNGJGCMRMAYmYAxCgFjVALGaASM0QkYYxAwxiRgjEXAWEnjF+4/+urti+vt4a+tt8Oj7l8zq35tV1nmroqoqqiaqLqohqimqJaotshPVEdUV+QvChDVE9W3fsNWOfCLSXWvis1eVZu9ajZ71W32atjs1bTZq2WzV9tmz89mr47NXl2bvXo2e/WVL6hNfddfN7h/1x/4raHqRYPA7/obWofI+Qnrdx7wvyWEfIcf4PzmzNEA+F1eQ5J/HmPh9CfhDCD958ZKhMHTKDB4GluDp1Fg8Kh7jQ2EUSVgGDUChlHjH0Np7N/AmwQOZVPrUDax+Tfwpgb+DRwzlP/p1QQ4lE2D/2+Z/OevDIDPuZmmfwNv9v/hS9VGwf8Vw129xaXzo3ngxdnCenE2D7wQ1b0WEfT/9kEj0CuGvGY4mgMHtYWmw4X/mQaO09EC6F9LTRd6y8ALXf1AB15LoA+tNPnQyoAPrYA+tNbkQ2vdPoC+xdbhg6vnHFRO4A80HZVJnjPwB6SOKiTPGfgDV0dVkucM/AGuoxrJcwb+QNhRneQ5A3/A7KhB8pyBP7B21CR5zsAfgDtqkTxn4A/UHbVJnjPwB/QOP5LnDPyBv6NO8P4HJ8dfRT3g19ttNH3fofYF+/DXh6M+8OzboP6dJZOvr/qcQ4DnvR34vGIFMkZQfr4dUakjKXVkpY6i1FGVOppSR1fqGEodU6ljKbX6c/d2/1CrP4evr9QhlDqk+rN6pQ6t1GGUOqxSh1Pq8IF1e/lvB1FHUSdRZ1EXUVdRtwj/+UdV578XhnL7+wf6H1XbM/yjqru7l7bejv/M7V/ehg6su4svPUQ9Rb2s/3jb3eYnKz1s9nra7PWK8Pd/5A2DNeuLQw1qQHQH/oNxD+CPK3sCf8rUC/zjSlMXb4cfF6/txdtbfOkj6ivqZ714e9tclH1s9vra7PUzcPF2AF68vYEXbx/gxdsXePH2I714O/64eG0v3v7iywDRQNEg68Xb3+aiHGCzN9Bmb5CBi7cj8OLtD7x4BwAv3oHAi3cQ6cXb6cfFa3vxDhZfhoiGioZZL97BNhflEJu9oTZ7wwxcvJ2AF+9g4MU7BHjxDgVevMNIL97OPy5e24t3uPgyQjRSNMp68Q63uShH2OyNtNkbZeDi7Qy8eIcDL94RwIt3JPDiHUV68Xb5cfHaXryjxZcxorGicdaLd7TNRTnGZm+szd44AxdvF+DFOxp48Y4BXrxjgRfvONKLt+uPi9f24h0vvkwQTRRNsl68420uygk2exNt9iYZuHi7Ai/e8cCLdwLw4p0IvHgnkV683X5cvLYX72TxZYpoqmia9eKdbHNRTrHZm2qzN83AxdsNePFOBl68U4AX71TgxTsNfPGa+uOZquGC+cVr85dt0yP8578zrBfVdJuLxfk/0v2XbaqJQR2k6cALb8aPoTT2N8AzA4dylnUonZ+w/g3wrAj6/wYYM5T/ScqZwKGcRTqUMxm+zLH8meHswKGcYx3K2RH+/meGcyLo/zPDmcAvBWYDh3LOj6Q0NpRzA4dynnUo59oM5TwDQ4lKSudQzgUO5TzSoZxLmJTzA4dygXUo59sM5QIDQzkXmJTzgUO54EdSGhvKhYFDucg6lAtthnIRWVIuBA7lItKhrEL43ffiwKFcYh3KxTbffS8x8N13FeB334uBQ7nkx1Aa++57aeBQLrMO5VKb776XGfjuuwrwu++lwKFcRjqUSwm/plweOJQrrEO53Oble4WBl++lwK8plwOHcsWPpDQ2lCsDh3KVdShX2gzlKgNDWQX4NeVK4FCuIh3KlYRJuTpwKNdYh3K1zVCuMTCUK4FJuRo4lGt+JKWxoVwbOJTrrEO51mYo15El5VrgUK4jHcpUbsF8KG2++14fOJQbrEO53ua77w0GvvtWTQzqd9/rgUO54cdQGvvue2PgUG6yDuVGm+++Nxn47hszlP/57nsjcCg3kQ7lRsKvKTcHDuUW61Butnn53mLg5Xsj8GvKzcCh3PIjKY0N5dbAodxmHcqtNkO5zcBQopLSOZRbgUO5jXQotxIm5fbAodxhHcrtNkO5w8BQbgUm5XbgUO74kZTGhnJn4FDusg7lTpuh3EWWlDuBQ7kLPJQR3f47gDqHsnwInAcq7+4IGoGdzUNa+gYVfjfuAB17gIOly0MnYwiwh3v+D18E/wmVAH+Vd6/Oi2Av8CL4C34v8CLYR3AR7ANeBH95uA/8taeOi3RfBPz7s+4JxrPjpuk6BP0swN2vbh0PV5xB9WA/7Gw8/HRy/g7gDPCu7e0v/x9UziT25+5w/86P7lbO7+7k7t7jy15B6OTurr7tZtA6ubu7eNvNb+7c+596fQdjH/te3/Vs+9r1+k7fvuKdDr+6c/9/6/UNjANc9/qmZzvQVa9v9O0b3lzuXzsP/tpeX8E45Ot6fdWzHfo1vb7St+94P69/7Dz8W3u5YBzxbb1cPtuR39LrX3wLwlso/a3z6O/tZcM45vt62T7bsd/T6x98A7xrzf92Hh/UXgrjhKD1+uLZTgxKL4tvwDcKcUxG9RLGKZhe//NspyJ6Bfo2Dfg1/QHw91h/faC/nj343bnh+ber1MkW0+2/b2ziXDu/rv8UWP+u1AeU+mBg/dfjDsn6D9GfosMR/rv/1wf6X2wLA3sdAs7QEU0zhPavCLDXH0D/jpL4VxTY60+gf8eA/tllwxElA44q9TGlPmzJhuOyPiE6KTplIBuKAXsdB57NaZLZLg7sdQLo3xkS/0oAe50E+ndWczacVjLgjFKfVepTlmw4J+vzoguiiwayoSSw1zng2Vwime1SwF7ngf5dJvGvNLDXBaB/VzRnwyUlAy4r9RWlvmjJhquyvia6LrphIBvKAHtdBZ7NTZLZLgvsdQ3o3y0S/8oBe10H+ndbczbcVDLgllLfVuoblmy4I+u7onui+wayoTyw1x3g2Twgme0KwF53gf49JPGvIrDXPaB/jzRnwwMlAx4q9SOlvm/JhseyfiJ6KnpmIBsqAXs9Bp7Nc5LZrgzs9QTo3wsS/6oAez0F+vdSczY8VzLghVK/VOpnlmx4JevXojeitwayoSqw1yvg2bwjme1qwF6vgf69J/GvOrDXG6B/HzRnwzslA94r9QelfmvJho/OteizyPlb4rqzoQaw10fg2YSIyDHbNYG9PgH9C0niXy1gr89A/0JF1JsNzvn+KwNCKnUopXaL+GU2hJZ1GFFYUTgD2VAb2Ct0RNzZhCeZbT9grzBA/yKQ+FcH2Css0L+ImrMhvJIBEZQ6olKHs2RDJFlHFkURRTWQDXWBvSIBzyYayWz7A3tFBvoXncS/AGCvKED/YmjOhmhKBkRX6hhKHdWSDTFlHUsUW/STgWyoB+wVE3g2cUhmuz6wVyygfz+T+NcA2Cs20L+4mrMhjpIBPyt1XKX+yZIN8WT9iyi+KIGBbGgI7BUPeDYJSWa7EbDXL0D/fiXxrzGwV3ygf4k0Z0NCJQN+VepESp3Akg2JZZ1ElFSUzEA2NAH2Sgw8m+Qks90U2CsJ0L/fSPxrBuyVFOhfCs3ZkFzJgN+UOoVSJ7NkQ0pZpxKlFqUxkA3Ngb1SAs8mLclstwD2SgX0Lx2Jfy2BvVID/UuvORvSKhmQTqnTK3UaSzZkkHVGkbvIYSAbWgF7ZQCejQfJbLcG9soI9M+TxL82wF7uQP+8NGeDh5IBnkrtpdQOSzZ4yzqTKLPIx0A2tAX28gaejS/JbLcD9soE9C8LiX/tgb0yA/3LqjkbfJUMyKLUWZXax5IN2WSdXZRDlNNANnQA9soGPJtcJLPdEdgrO9C/3CT+dQL2ygH0L4/mbMilZEBupc6j1Dkt2ZBX1vlE+UUFDGRDZ2CvvMCzKUgy212AvfIB/StE4l9XYK/8QP8Ka86GgkoGFFLqwkpdwJINRWRdVFRMVNxANnQD9ioCPJsSJLPdHdirKNC/kiT+9QD2Kgb0r5TmbCihZEBJpS6l1MUt2VBa1mVEZUXlDGRDT2Cv0sCzKU8y272AvcoA/atA4l9vYK+yQP8qas6G8koGVFDqikpdzpINlWRdWVRFVNVANvQB9qoEPJtqJLPdF9irMtC/6iT+9QP2qgL0r4bmbKimZEB1pa6h1FUt2VBT1rVEtUV+BrKhP7BXTeDZ1CGZ7QHAXrWA/tUl8W8gsFdtoH/+mrOhjpIBdZXaX6n9LNkQIOt6ovqiBgayYRCwVwDwbBqSzPZgYK96QP8akfg3BNirPtC/xpqzoaGSAY2UurFSN7BkQxNZNxU1EzU3kA1Dgb2aAM+mBclsDwP2agr0ryWJf8OBvZoB/WulORtaKBnQUqlbKXVzSza0lnUbUVtROwPZMALYqzXwbNqTzPZIYK82QP86kPg3CtirLdC/jpqzob2SAR2UuqNSt7NkQydZdxZ1EXU1kA2jgb06Ac+mG8lsjwH26gz0rzuJf2OBvboA/euhORu6KRnQXal7KHVXSzb0lHUvUW9RHwPZMA7YqyfwbPqSzPZ4YK9eQP/6kfg3AdirN9C//pqzoa+SAf2Uur9S97FkwwBZDxQNEg02kA0Tgb0GAM9mCMlsTwL2Ggj0byiJf5OBvQYB/RumORuGKBkwVKmHKfVgSzYMl/UI0UjRKAPZMAXYazjwbEaTzPZUYK8RQP/GkPg3DdhrJNC/sZqzYbSSAWOUeqxSj7JkwzhZjxdNEE00kA3Tgb3GAc9mEslszwD2Gg/0bzKJfzOBvSYA/ZuiORsmKRkwWamnKPVESzZMlfU00XTRDAPZMAvYayrwbGaSzPZsYK9pQP9mkfg3B9hrOtC/2ZqzYaaSAbOUerZSz7BkwxxZzxXNE803kA1zkecMPJsFJLM9D3kWQP8Wkvg3H3kWQP8Wac6GBUoGLFTqRUo935INi2W9RLRUtMxANiwA9loMPJvlJLO9ENhrCdC/FST+LQL2Wgr0b6XmbFiuZMAKpV6p1Mss2bBK1qtFa0RrDWTDYmCvVcCzWUcy20uAvVYD/VtP4t9SYK81QP82aM6GdUoGrFfqDUq91pING2W9SbRZtMVANiwD9toIPJutJLO9HNhrE9C/bST+rQD22gz0b7vmbNiqZMA2pd6u1Fss2bBD1jtFu0S7DWTDSmCvHcCz2UMy26uAvXYC/dtL4t9qYK9dQP/2ac6GPUoG7FXqfUq925IN+2X9u+iA6KCBbFgD7LUfeDaHSGZ7LbDX70D//iDxbx2w1wGgf39qzoZDSgb8odR/KvVBSzYclvUR0VHRMQPZsB7Y6zDwbI6TzPYGYK8jQP9OkPi3EdjrKNC/k5qz4biSASeU+qRSH7NkwylZnxadEZ01kA2bgL1OAc/mHMlsbwb2Og307zyJf1uAvc4A/bugORvOKRlwXqkvKPVZSzZclPUl0WXRFQPZsBXY6yLwbK6SzPY2YK9LQP+ukfi3HdjrMtC/65qz4aqSAdeU+rpSX7Fkww1Z3xTdEt02kA07gL1uAM/mDsls7wT2ugn07y6Jf7uAvW4B/bunORvuKBlwV6nvKfVtSzbcl/UD0UPRIwPZsBvY6z7wbB6TzPYeYK8HQP+ekPi3F9jrIdC/p5qz4bGSAU+U+qlSP7JkwzNZPxe9EL00kA37gL2eAc/mFcls7wf2eg707zWJf78De70A+vdGcza8UjLgtVK/UeqXlmx4K+t3oveiDway4QCw11vg2Xwkme2DwF7vgP59IvHvELDXe6B/nzVnw0clAz4p9Wel/mDJBrdIsi8KKQoVSX82/AHs5WRHnU3oSByz/SewVwigf2FI/DsM7BUS6F/YSHqzwTnff2VAGKUOq9ShIn2ZDeFkHV4UQRTRQDYcAfYKBzybSCSzfRTYKzzQv8gk/h0D9ooA9C+K5myIpGRAZKWOotQRLdkQVdbRRNFFMQxkw3Fgr6jAs4lJMtsngL2iAf2LReLfSWCv6ED/YmvOhphKBsRS6thKHcOSDT/JOo7oZ1FcA9lwCtjrJ+DZxCOZ7dPAXnGA/v1C4t8ZYK+fgf7F15wN8ZQM+EWp4yt1XEs2JJB1QtGvokQGsuEssFcC4NkkJpntc8BeCYH+JSHx7zyw169A/5JqzobESgYkUeqkSp3Ikg3JZJ1c9JsohYFsuADslQx4NilJZvsisFdyoH+pSPy7BOz1G9C/1JqzIaWSAamUOrVSp7BkQxpZpxWlE6U3kA2Xgb3SAM8mA8lsXwH2Sgv0LyOJf1eBvdIB/XPXnA0ZlAzIqNTuSp3ekg0OWXuIPEVeBrLhGrCXA3g23iSzfR3YywPoXyYS/24Ae3kC/cusORu8lQzIpNSZldrLkg0+svYVZRFlNZANN4G9fIBnk41ktm8Be/kC/ctO4t9tYK8sQP9yaM6GbEoGZFfqHEqd1ZINOZ1MotyiPAay4Q6wV07g2eQlme27wF65gP7lI/HvHrBXbqB/+TVnQ14lA/IpdX6lzmPJhgKyLigqJCpsIBvuA3sVAJ5NEZLZfgDsVRDoX1ES/x4CexUC+ldMczYUUTKgqFIXU+rClmwoLusSopKiUgay4RGwV3Hg2ZQmme3HwF4lgP6VIfHvCbBXSaB/ZTVnQ2klA8oodVmlLmXJhnKyLi+qIKpoIBueAnuVA55NJZLZfgbsVR7oX2US/54De1UA+ldFczZUUjKgslJXUeqKlmyoKutqouqiGgay4QWwV1Xg2dQkme2XwF7VgP7VIvHvFbBXdaB/tTVnQ00lA2opdW2lrmHJBj9Z1xHVFfkbyIbXwF5+wLMJIJntN8BedYD+1SPx7y2wV12gf/U1Z0OAkgH1lLq+UvtbsqGBrBuKGokaG8iGd8BeDYBn04Rktt8DezUE+teUxL8PwF6NgP4105wNTZQMaKrUzZS6sSUbmsu6hailqJWBbPgI7NUceDatSWb7E7BXC6B/bUj8+wzs1RLoX1vN2dBayYA2St1WqVtZsqGdrNuLOog6GsgGJwSqVzvg2XQime0QQP/aA/3rTOJfSKB/HYD+ddGcDZ2UDOis1F2UuqMlG7rKupuou6iHgWwIBTybrsCz6Uky26GB/nUD+teLxL8wQP+6A/3rrTkbeioZ0Eupeyt1D0s29JF1X1E/UX8D2RAWeDZ9gGczgGS2wwH96wv0byCJf+GB/vUD+jdIczYMUDJgoFIPUur+lmwYLOshoqGiYQayIQLwbAYDz2Y4yWxHBPo3BOjfCBL/IgH9Gwr0b6TmbBiuZMAIpR6p1MMs2TBK1qNFY0RjDWRDZODZjAKezTiS2Y4C9G800L/xJP5FBfo3BujfBM3ZME7JgPFKPUGpx1qyYaKsJ4kmi6YYyIZowLOZCDybqSSzHR3o3ySgf9NI/IsB9G8y0L/pmrNhqpIB05R6ulJPsWTDDFnPFM0SzTaQDTGBZzMDeDZzSGY7FtC/mUD/5pL4Fxvo3yygf/M0Z8McJQPmKvU8pZ5tyYb5sl4gWihaZCAbfgKezXzg2Swmme04QP8WAP1bQuLfz0D/FgL9W6o5GxYrGbBEqZcq9SJLNiyT9XLRCtFKA9kQF3g2y4Bns4pktuMB/VsO9G81iX+/AP1bAfRvjeZsWKVkwGqlXqPUKy3ZsFbW60TrRRsMZEN84NmsBZ7NRpLZTgD0bx3Qv00k/iUE+rce6N9mzdmwUcmATUq9Wak3WLJhi6y3iraJthvIhl+BZ7MFeDY7SGY7EdC/rUD/dpL4lxjo3zagf7s0Z8MOJQN2KvUupd5uyYbdst4j2ivaZyAbkgDPZjfwbPaTzHZSoH97gP79TuJfMqB/e4H+HdCcDfuVDPhdqQ8o9T5LNhyU9SHRH6I/DWRDcuDZHASezWGS2f4N6N8hoH9HSPxLAfTvD6B/RzVnw2ElA44o9VGl/tOSDcdkfVx0QnTSQDakBJ7NMeDZnCKZ7VRA/44D/TtN4l9qoH8ngP6d0ZwNp5QMOK3UZ5T6pCUbzsr6nOi86IKBbEgDPJuzwLO5SDLbaYH+nQP6d4nEv3RA/84D/busORsuKhlwSakvK/UFSzZckfVV0TXRdQPZkB54NleAZ3ODZLYzAP27CvTvJol/GYH+XQP6d0tzNtxQMuCmUt9S6uuWbLgt6zuiu6J7BrLBHXg2t4Fnc59kth1A/+4A/XtA4p8H0L+7QP8eas6G+0oGPFDqh0p9z5INj2T9WPRE9NRANngCz+YR8Gyekcy2F9C/x0D/npP45w307wnQvxeas+GZkgHPlfqFUj+1ZMNLWb8SvRa9MZANmYBn8xJ4Nm9JZjsz0L9XQP/ekfjnA/TvNdC/95qz4a2SAe+U+r1Sv7FkwwdZf3TuiT4byAZf4Nl8AJ6NW2SO2c4C9O8j0L8QJP5lBfr3CehfyMh6s8E5339lQAilDqnUny3ZEEo+F1oURhQ2sv5syAY8m1CRcWcTjmS2swP9Cw30LzyJfzmA/oUB+hdBczaEUzIgvFJHUOqwkb/MhoiyjiSKLIpiIBtyAs8mIvBsopLMdi6gf5GA/kUj8S830L/IQP+ia86GqEoGRFPq6EodxZINMWQdUxRLFNtANuQBnk0M4Nn8RDLbeYH+xQT6F4fEv3xA/2IB/ftZczb8pGRAHKX+WaljW7IhrqzjiX4RxTeQDfmBZxMXeDYJSGa7ANC/eED/EpL4VxDo3y9A/37VnA0JlAxIqNS/KnV8SzYkknViURJRUgPZUAh4NomAZ5OMZLYLA/1LDPQvOYl/RYD+JQH695vmbEimZEBypf5NqZNasiGFrFOKUolSG8iGosCzSQE8mzQks10M6F9KoH9pSfwrDvQvFdC/dJqzIY2SAWmVOp1Sp7ZkQ3pZZxBlFLkbyIYSwLNJDzwbB8lslwT6lwHonweJf6WA/mUE+uepORscSgZ4KLWnUrtbssFL1t6iTKLMBrKhNPBsvIBn40My22WA/nkD/fMl8a8s0L9MQP+yaM4GHyUDfJU6i1JntmRDVllnE2UX5TCQDeWAZ5MVeDY5SWa7PNC/bED/cpH4VwHoX3agf7k1Z0NOJQNyKXVupc5hyYY8ss4ryifKbyAbKgLPJg/wbAqQzHYloH95gf4VJPGvMtC/fED/CmnOhgJKBhRU6kJKnd+SDYVlXURUVFTMQDZUAZ5NYeDZFCeZ7apA/4oA/StB4l81oH9Fgf6V1JwNxZUMKKHUJZW6mCUbSsm6tKiMqKyBbKgOPJtSwLMpRzLbNYD+lQb6V57Ev5pA/8oA/augORvKKRlQXqkrKHVZSzZUlHUlUWVRFQPZUAt4NhWBZ1OVZLZrA/2rBPSvGol/fkD/KgP9q645G6oqGVBNqasrdRVLNtSQdU1RLVFtA9lQB3g2NYBn40cy23WB/tUE+leHxD9/oH+1gP7V1ZwNfkoG1FHqukpd25IN/rIOENUT1TeQDQHAs/EHnk0DktmuB/QvAOhfQxL/6gP9qwf0r5HmbGigZEBDpW6k1PUt2dBY1k1ETUXNDGRDA+DZNAaeTXOS2W4I9K8J0L8WJP41AvrXFOhfS83Z0FzJgBZK3VKpm1myoZWsW4vaiNoayIbGwLNpBTybdiSz3QToX2ugf+1J/GsK9K8N0L8OmrOhnZIB7ZW6g1K3tWRDR1l3EnUWdTGQDc2AZ9MReDZdSWa7OdC/TkD/upH41wLoX2egf901Z0NXJQO6KXV3pe5iyYYesu4p6iXqbSAbWgLPpgfwbPqQzHYroH89gf71JfGvNdC/XkD/+mnOhj5KBvRV6n5K3duSDf1lPUA0UDTIQDa0AZ5Nf+DZDNY02xG/xz/HP3/qO+5D/o/dvuue3P/Q7TvvT23b7bvvp2zTLQj3Fv5bt8RBmV1LtyDeF/aLbkG+R6rSTb1faFCvqfUx9VxTcazXlCNovSN86V+QukW0nkUQukX6+7l+d7fIdjPynd2i2M/bd3WL+k+z+x3dov3zdfDN3aK7uqa+sVsM19fnN3WL+W/X+jd0i/XvufHV3WJ/TQZ9Zbefvi7PvqpbnK/Nxq/o9vPX5+y/dov7LZn9L93ifVv+u+z2S9C/Pvvf/pD7Gwd2A93r93+6pQC+xn3U9BoXNvC/kN7yrJH3k0XeW3UA8Gv4Ibiv4R3Ar10cyBmx+75vsPL93RClHqjUgyzf9w2V9TDRcNGIwO/7nArl9t/v+ew+ckHm0fN/nsf//B8N/z8CvGt7+8uUuCkewdiF/kAE/DWPZizsFvwZixAwFiVgLEbAWJyAsQQBY0kCxlIEjKUJGMsQMJYlYCxHwFiegLECAWNFAsZKBIyVCRirEDBWJWCsRsBYnYCxBgFjTQLGWgSMtQkY/QgY6xAw1iVg9CdgDCBgrEfAWJ+AsQEBY0MCxkYEjI0JGJsQMDYlYGxGwNicgLEFAWNLAsZWBIytCRjbEDC2JWBsR8DYnoCxAwFjRwLGTgSMnQkYuxAwdiVg7EbA2J2AsQcBY08Cxl4EjL0JGPsQMPYlYOxHwNifgHEAAeNAAsZBBIyDCRiHEDAOJWAcRsA4nIBxBAHjSALGUQSMowkYxxAwjiVgHEfAOJ6AcQIB40QCxkkEjJMJGKcQME4lYJxGwDidgHEGAeNMAsZZBIyzCRjnEDDOJWCcR8A4n4BxAQHjQgLGRQSMiwkYlxAwLiVgXEbAuJyAcQUB40oCxlUEjKsJGNcQMK4lYFxHwLiegHEDAeNGAsZNBIybCRi3EDBuJWDcRsC4nYBxBwHjTgLGXQSMuwkY9xAw7iVg3EfAuJ+A8XcCxgMEjAcJGA8RMP5BwPgnAeNhAsYjBIxHCRiPETAeJ2A8QcB4koDxFAHjaQLGMwSMZwkYzxEwnidgvEDAeJGA8RIB42UCxisEjFcJGK8RMF4nYLxBwHiTgPEWAeNtAsY7BIx3CRjvETDeJ2B8QMD4kIDxEQHjYwLGJwSMTwkYnxEwPidgfEHA+JKA8RUB42sCxjcEjG8JGN8RML4nYPxAwPiRgPETAeNnAkZnw+DOGIKAMSQBYygCxtAEjGEIGMMSMIYjYAxPwBiBgDEiAWMkAsbIBIxRCBijEjBGI2CMTsAYg4AxJgFjLALG2ASMPxEwxiFg/JmAMS4BYzwCxl8IGOMTMCYgYExIwPgrAWMiAsbEBIxJCBiTEjAmI2BMTsD4GwFjCgLGlASMqQgYUxMwpiFgTEvAmI6AMT0BYwYCxowEjO4EjA4CRg8CRk8CRi8CRm8CxkwEjJkJGH0IGH0JGLMQMGYlYMxGwJidgDEHAWNOAsZcBIy5CRjzEDDmJWDMR8CYn4CxAAFjQQLGQgSMhQkYixAwFiVgLEbAWJyAsQQBY0kCxlIEjKUJGMsQMJYlYCxHwFiegLECAWNFAsZKBIyVCRirEDBWJWCsRsBYnYCxBgFjTQLGWgSMtQkY/QgY6xAw1iVg9CdgDCBgrEfAWJ+AsQEBY0MCxkYEjI0JGJsQMDYlYGxGwNicgLEFAWNLAsZWBIytCRjbaGBMbGV0uAfpw/KeLkHq9rf3XglCN5v3SPnubrbvZfKd3f7hPUe+q9s/vjfId3Rz8R4e39zN5XttfGO3f3lPjG/q9q/vXfEN3b7iPSa+uttXvRfEV3b7yvds+KpuX/3eCl/R7RveA+Ffu33TexX8S7dvfE8Bl92++W//XXT7jr/R/8du3/W39P/Q7Tv/5t2223f/bbpNtyD8DfnfuiUOyuuupVsQ/yb7i25B/ttppRvgb5z/txvkb5EDu4H+Zvh/usH+tle6Af8GV8vfyjo/0F9/Do2sh/N/P0KCgSuH+28vT/dMXl7+mT38HZ6O2u4evn4+3u5e3n6ZfBw+Dm8f77oePp6e/j5ePpl9/Xwzu/s6vDz9HQHevp4Bgc1G4p688+/q3EIFHpCzb2L5b2hF1g/0QYZw+789cPAfxIfj4AzlpvkCDoUElpQF3unpizsyBTUMRgEHUw0DZ9/u+jz9n1dB4B2+HKoPQfV0tCZPR+v0NPCrFOCd3RyjgZ6O0eTpGH2e/u9XkcA7+jnGAD0dq8nTsbo8Vb7KB97J0TEW6Ok4TZ6O0+PpF9+FXQN6Og7o6XhNno7X4anlu+SrQE/HAz2doMnTCYGeOr/4D+/232+E1A/0F4NX3PR+Mfidvf/2ry+qFxMj/+e/kyIHGvKXgZOUg/nrA/rFqMWwbxwkd8sgOSYCh3ISyXdJEzVxBvGc/zZwV4DPeQLwnCdrCp/J/x/CR8ctztWP7+ztMnymBIbPVGv4TDUQPqphQQ2fKcChnEoSPlOCY/jY/NwCeGE4JgPPeZqm8Jn2/yF8Lrnxhc/0wPCZYQ2fGQbCRzUsqOEzHTiUM0jCZ3rwCx/bH8ACLwzHNOA5z9QUPjP/P4TPRTe+8JkVGD6zreEz20D4qIYFNXxmAYdyNkn4zApu4fMPv0kCvDAcM4HnPEdT+Mz5/xA+F9z4wmduYPjMs4bPPAPhoxoW1PCZCxzKeSThMzd4hc8//koc8MJwzAGe83xN4TP//0P4nHfjC58FgeGz0Bo+Cw2Ej2pYUMNnAXAoF5KEz4LgFD4ufrcXeGE45gPPeZGm8Fn0/yF8zrnxhc/iwPBZYg2fJQbCRzUsqOGzGDiUS0jCZ3HwCR+Xf6QAvDAci4DnvFRT+CyN/PdfXwj5rZ7+yx+RnHXD+bBMkw/L/j+E8Fk3vhBeHhjCK6whvMJACAdhkP4WwsuBF+cKkhBeHhx/6mfDCQw7xzLgOa/UFD4rbULYevZBZV/1/ezeduwx3f77xxnOdRFZfFK4/6pDKLWT4ZPyuNWyXiNaK1oX+e9/7IGeK+D5OVYD52q9pusyLNK/4PtXXo41wLPYAJyR9TFxvT7GxGaP9fpdH/m/1+kGpV6r1Oss1+9GWW8SbRZtifzfP9gKo1y7dh+5MM/DeZOuv2UG+jUT2EvbO2GEIGBcqSHjElsZf7xbx79+/Hi3jm/7+PFuHd/W7ce7dXxbtx/v1vFt3X68W8e3dUsclK+zf7xbR5C6/Xi3jm/7cFM+0F9/btTxPbbzmw/nN9lh3P7+kdj6BIL4xekAN9wXpwPdcF+cDnLDfXE62A33xekQN9wXp0PdcF+cDnPDfXE63A33xekIN9wXpyPdcF+cjnL71wv3q7uN/vdeX91tzNf0+spuY7+u11d1G/e1vb6i2/iv7/Wv3SZ8S69/6Tbx23q57DbpW3u56Db523v9Y7cp39PrH7pN/b5ett2mfW8vm27Tv7/X37rNCEovS7eZQev1RbdZQe2ldJsd9F7/220Ooldgt7mYXv/TbR6ql/PXv9w0fNGnfAS1d93Mnp7eXn511J4UX/hq4BxJwol81zD1Nyu2Bv5mxTbrb1Zsjfzfbyb++vjmX9H5lye1FfgTtO3An6CpPmy38QF9uNsMDWFQPd4B4PT1qeudSf4/6eTc+b2cHj6ZrVt2P7XcH+G/P53cofykspeyv9PyU8tdst4t2iPaa+C3DnpGwPXaBbxO95H8NlAPoH+7gf7tJ/GvO9C/PUD/fgf/NpU1G/YpebBfqX9X6r2WbDgg64OiQ6I/DGRDP+DZHACezZ8ks90X6N9BoH+HSfzrA/TvENC/I5qz4U8lAw4r9RGl/sOSDUdlfUx0XHTCQDb0Bp7NUeDZnCSZ7UFA/44B/TtF4t9AoH/Hgf6d1pwNJ5UMOKXUp5X6hCUbzsj6rOic6LyBbBgAPJszwLO5QDLb/YH+nQX6d5HEv2FA/84B/bukORsuKBlwUakvKfV5SzZclvUV0VXRNQPZMBR4NpeBZ3OdZLaHAP27AvTvBol/g4H+XQX6d1NzNlxXMuCGUt9U6muWbLgl69uiO6K7BrJhFPBsbgHP5h7JbI8E+ncb6N99Ev9GAP27A/TvgeZsuKdkwH2lfqDUdy3Z8FDWj0SPRU8MZMNw4Nk8BJ7NU5LZHgf07xHQv2ck/o0F+vcY6N9zzdnwVMmAZ0r9XKmfWLLhhaxfil6JXhvIhjHAs3kBPJs3JLM9GujfS6B/b0n8mwT07xXQv3eas+GNkgFvlfqdUr+2ZMN7WX8QfXTuG8iGicCzeQ88m88ksz0B6N8HoH9uUTj8Gw/07yPQvxBR9GbDZyUDnGf1v++4otSfLNkQUj4XShRaFCaK/myYBjybkFFwZxOWZLanAv0LBfQvHIl/U4D+hQb6F15zNoRVMiCcUodX6jBRvsyGCLKOKIokimwgGyYDzyYC8GyikMx2YWCviED/opL4VwTYKxLQv2iasyGKkgFRlTqaUke2ZEN0WccQxRTFMpANRYG9ogPPJjbJbBcD9ooB9O8nEv+KA3vFBPoXR3M2xFYy4CeljqPUsSzZ8LOs44riiX4xkA0lgL1+Bp5NfJLZLgnsFRfoXwIS/0oBe8UD+pdQczbEVzIggVInVOpfLNnwq6wTiRKLkhjIhtLAXr8CzyYpyWyXAfZKBPQvGYl/ZYG9EgP9S645G5IqGZBMqZMrdRJLNvwm6xSilKJUBrKhHLDXb8CzSU0y2+WBvVIA/UtD4l8FYK+UQP/Sas6G1EoGpFHqtEqdypIN6WSdXpRBlNFANlQE9koHPBt3ktmuBOyVHuifg8S/ysBeGYD+eWjOBnclAxxK7aHUGS3Z4ClrL5G3KJOBbKgC7OUJPJvMJLNdFdjLC+ifD4l/1YC9vIH++WrOhsxKBvgota9SZ7JkQxZZZxVlE2U3kA3Vgb2yAM8mB8ls1wD2ygr0LyeJfzWBvbIB/culORtyKBmQU6lzKXV2SzbklnUeUV5RPgPZUAvYKzfwbPKTzHZtYK88QP8KkPjnB+yVF+hfQc3ZkF/JgAJKXVCp81myoZCsC4uKiIoayIY6wF6FgGdTjGS26wJ7FQb6V5zEP39gryJA/0pozoZiSgYUV+oSSl3Ukg0lZV1KVFpUxkA2BAB7lQSeTVmS2a4H7FUK6F85Ev/qA3uVBvpXXnM2lFUyoJxSl1fqMpZsqCDriqJKoso22RASfDYVgX5WwfkZoPM5VwI+56qw5+zlYTdDFZRZqaLUVZW6smWGqsm6uqiGqKaBGaoG9LMWzE/PADs/aym+VVfqGkpd0+JnbVn7ieqI6hp4vV4P/DuGOsCz8decl7WVM/BTan+lrms5mwBZ1xPVFzUwcDZbgGcTADybhiRfC+wA+lcP6F8jEv92Af2rD/SvseZsaKhkQCOlbqzUDSzZ0ETWTUXNRM0NZEMv4Nk0AZ5NC5LZRt7XoCnQv5Yk/iHva9AM6F8rzdnQQsmAlkrdSqmbW7KhtazbiNqK2hnIBuQ9E1oDz6Y9yWwj72vQBuhfBxL/kPc1aAv0r6PmbGivZEAHpe6o1O0s2dBJ1p1FXURdDWQD8p4JnYBn041ktpH3NegM9K87iX/I+xp0AfrXQ3M2dFMyoLtS91DqrpZs6CnrXqLeoj4GsgF5z4SewLPpSzLbyPsa9AL614/EP+R9DXoD/euvORv6KhnQT6n7K3UfSzYMkPVA0SDRYAPZgLxnwgDg2QwhmW3kfQ0GAv0bSuIf8r4Gg4D+DdOcDUOUDBiq1MOUerAlG4bLeoRopGiUgWxA3jNhOPBsRpPMNvK+BiOA/o0h8Q95X4ORQP/Gas6G0UoGjFHqsUo9ypIN42Q9XjRBNNFANiDvmTAOeDaTSGYbeV+D8UD/JpP4h7yvwQSgf1M0Z8MkJQMmK/UUpZ5oyYapsp4mmi6aYSAbkPdMmAo8m5kks428r8E0oH+zSPxD3tdgOtC/2ZqzYaaSAbOUerZSz7BkwxxZzxXNE803kA3IeybMAZ7NApLZRt7XYC7Qv4Uk/iHvazAP6N8izdmwQMmAhUq9SKnnW7JhsayXiJaKlhnIBuQ9ExYDz2Y5yWwj72uwBOjfChL/kPc1WAr0b6XmbFiuZMAKpV6p1Mss2bBK1qtFa0RrDWQD8p4Jq4Bns45ktpH3NVgN9G89y8+Agb3WAP3boDkb1ikZsF6pNyj1Wks2bJT1JtFm0RYTv98A7LUReDZbWX53B9hrE9C/bST+DQb22gz0b7vmbNiqZMA2pd6u1Fss2bBD1jtFu0S7DWTDEGCvHcCz2cPy+w3AXjuB/u0l8W8YsNcuoH/7NGfDHiUD9ir1PqXebcmG/bL+XXRAdNBANgwH9toPPJtDJLM9Atjrd6B/f7D8fgOw1wGgf39qzoZDSgb8odR/KvVBSzYclvUR0VHRMQPZMArY6zDwbI6z/AwO2OsI0L8TLD8DBvY6CvTvpOZsOK5kwAmlPqnUxyzZcErWp0VnRGdN/H4DsNcp4NmcY/ndHWCv00D/zpP4Nx7Y6wzQvwuas+GckgHnlfqCUp+1ZMNFWV8SXRZdMZANE4C9LgLP5irL7zcAe10C+neNxL9JwF6Xgf5d15wNV5UMuKbU15X6iiUbbsj6puiW6LaBbJgM7HUDeDZ3SGZ7CrDXTaB/d1l+vwHY6xbQv3uas+GOkgF3lfqeUt+2ZMN9WT8QPRQ9MpAN04C97gPP5jHJbE8H9noA9O8JiX8zgL0eAv17qjkbHisZ8ESpnyr1I0s2PJP1c9EL0UsD2TAT2OsZ8Gxekcz2LGCv50D/XpP4NxvY6wXQvzeas+GVkgGvlfqNUr+0ZMNbWb8TvRd9MJANc4C93gLP5iPJbM8F9noH9O8TiX/zgL3eA/37rDkbPioZ8EmpPyv1B0s2uEWVfVFIUaio+rNhPrCXkx11NqGjcsz278BeIYD+hSHx7wCwV0igf2Gj6s0G53z/lQFhlDqsUoeK+mU2hJN1eFEEUUQD2XAQ2Csc8Gwikcz2IWCv8ED/IpP49wewVwSgf1E0Z0MkJQMiK3UUpY5oyYaoso4mii6KYSAb/gT2igo8m5gks30Y2Csa0L9YJP4dAfaKDvQvtuZsiKlkQCyljq3UMSzZ8JOs44h+FsU1kA1Hgb1+Ap5NPJLZPgbsFQfo3y8k/h0H9voZ6F98zdkQT8mAX5Q6vlLHtWRDAlknFP0qSmQgG04AeyUAnk1iktk+CeyVEOhfEhL/TgF7/Qr0L6nmbEisZEASpU6q1Iks2ZBM1slFv4lSGMiG08BeyYBnk5Jkts8AeyUH+peKxL+zwF6/Af1LrTkbUioZkEqpUyt1Cks2pJF1WlE6UXoD2XAO2CsN8GwykMz2eWCvtED/MpL4dwHYKx3QP3fN2ZBByYCMSu2u1Okt2eCQtYfIU+RlIBsuAns5gGfjTTLbl4C9PID+ZSLx7zKwlyfQv8yas8FbyYBMSp1Zqb0s2eAja19RFlFWA9lwBdjLB3g22Uhm+yqwly/Qv+wk/l0D9soC9C+H5mzIpmRAdqXOodRZLdmQ08kkyi3KYyAbrgN75QSeTV6S2b4B7JUL6F8+Ev9uAnvlBvqXX3M25FUyIJ9S51fqPJZsKCDrgqJCosIGsuEWsFcB4NkUIZnt28BeBYH+FSXx7w6wVyGgf8U0Z0MRJQOKKnUxpS5syYbisi4hKikqFZgNdr2LKz1KKHVJpS5l6V1a1mVEZUXlXPQurfQoo9RllbqcpXd5WVcQVRRVctG7vNKjglJXVOpKlt6VZV1FVFVUzUXvykqPKkpdVamrWXpXl3UNUU1RLRe9qys9aih1TaWuZeldW9Z+ojqiui5611Z6+Cl1HaWua+ntL+sAUT1RfRe9/ZUeAUpdT6nrW3o3kHVDUSNRYxe9Gyg9Gip1I6VubOndRNZNRc1EzV30bqL0aKrUzZS6uaV3C1m3FLUStXbRu4XSo6VSt1Lq1pbebWTdVtRO1N7Aa/Zi4PuXtwNmZgfNmdlGOYO2St1BqdtbzqajrDuJOou6GDibFcCz6Qg8m64kXw+sAfrXCehfNxL/1gH96wz0r7vmbOiqZEA3pe6u1F0s2dBD1j1FvUS9DWTDAmCvHsCz6UMy2wuBvXoC/etL4t8iYK9eQP/6ac6GPkoG9FXqfkrd25IN/WU9QDRQNMjE13TAXv2BZzOYZLaXAHsNAPo3hMS/pcBeA4H+DdWcDYOVDBii1EOVepAlG4bJerhohGikgWxYBuw1DHg2o0hmezmw13Cgf6NJ/FsB7DUC6N8YzdkwSsmA0Uo9RqlHWrJhrKzHicaLJhjIhpXAXmOBZzORZLZXAXuNA/o3icS/1cBe44H+TdacDROVDJik1JOVeoIlG6bIeqpommi6gWxYA+w1BXg2M0hmey2w11SgfzNZ/i0S2Gsa0L9ZmrNhhpIBM5V6llJPt2TDbFnPEc0VzTOQDeuBvWYDz2Y+yWxvAPaaA/RvAYl/G4G95gL9W6g5G+YrGbBAqRcq9TxLNiyS9WLREtFSA9mwCdhrEfBslpHM9mZgr8VA/5aT+LcF2GsJ0L8VmrNhmZIBy5V6hVIvtWTDSlmvEq0WrTGQDVuBvVYCz2YtyWxvA/ZaBfRvHYl/24G9VgP9W685G9YqGbBOqdcr9RpLNmyQ9UbRJtFmA9mwA9hrA/BstpDM9k5gr41A/7aS+LcL2GsT0L9tmrNhi5IBW5V6m1JvtmTDdlnvEO0U7TKQDbuBvbYDz2Y3yWzvAfbaAfRvD4l/e4G9dgL926s5G3YrGbBHqfcq9S5LNuyT9X7R76IDBrJhH7IX8GwOksz2fmQvoH+HSPy7C+z1O9C/PzRnw0ElAw4p9R9KfcCSDX/K+rDoiOiogWy4B+z1J/BsjpHM9n1gr8NA/46T+PcA2OsI0L8TmrPhmJIBx5X6hFIftWTDSVmfEp0WnTGQDQ+BvU4Cz+YsyWw/AvY6BfTvHIl/j4G9TgP9O685G84qGXBOqc8r9RlLNlyQ9UXRJdFlA9nwBNjrAvBsrpDM9lNgr4tA/66S+PcM2OsS0L9rmrPhipIBV5X6mlJftmTDdVnfEN0U3TKQDc+Bva4Dz+Y2yWy/APa6AfTvDol/L4G9bgL9u6s5G24rGXBHqe8q9S1LNtyT9X3RA9FDA9nwCtjrHvBsHpHM9mtgr/tA/x6T+PcG2OsB0L8nmrPhkZIBj5X6iVI/tGTDU1k/Ez0XvTCQDW+BvZ4Cz+YlyWy/A/Z6BvTvFYl/74G9ngP9e605G14qGfBKqV8r9QtLNryR9VvRO9F7A9nwAdjrDfBsPpDM9kdgr7dA/z6S+PcJ2Osd0L9PmrPhg5IBH5X6k1K/t2TDZ1m7RZPPiUJG058Nn5G9gGcTKhrHbDsPEdYrGs6/0CT+hQD6FwLoX5hoerPBOd9/ZUBopQ6j1CGjfZkNYWUdThReFMFANoQEnk1Y4NlEJJntUED/wgH9i0TiX2igf+GB/kXWnA0RlQyIpNSRlTqCJRuiyDqqKJoouoFsCAM8myjAs4lBMtthgf5FBfoXk8S/cED/ogH9i6U5G2IoGRBTqWMpdXRLNsSW9U+iOKKfDWRDeODZxAaeTVyS2W4A7PUT0L94JP41BPaKA/TvF83ZEFfJgHhK/YtS/2zJhviyTiBKKPrVQDY0AvaKDzybRCSz3RjYKwHQv8Qk/jUB9koI9C+J5mxIpGRAYqVOotS/WrIhqayTiZKLfjOQDU2BvZICzyYFyWw3A/ZKBvQvJYl/zYG9kgP9S6U5G1IoGZBSqVMp9W+WbEgt6zSitKJ0BrKhBbBXauDZpCeZ7ZbAXmmA/mUg8a8VsFdaoH8ZNWdDeiUDMih1RqVOZ8kGd1k7RB4iTwPZ0BrYyx14Nl4ks90G2MsB9M+bxL+2wF4eQP8yac4GLyUDvJU6k1J7WrIhs6x9RL6iLAayoR2wV2bg2WQlme32wF4+QP+ykfjXAdjLF+hfds3ZkFXJgGxKnV2ps1iyIYesczq5RLkNZENHYK8cwLPJQzLbnYC9cgL9y0viX2dgr1xA//JpzoY8SgbkVep8Sp3bkg35ZV1AVFBUyEA2dAH2yg88m8Iks90V2KsA0L8iJP51A/YqCPSvqOZsKKxkQBGlLqrUhSzZUEzWxUUlRCUNZEN3YK9iwLMpRTLbPYC9igP9K03iX09grxJA/8pozoZSSgaUVuoySl3Skg1lZV1OVF5UwUA29AL2Kgs8m4oks90b2Ksc0L9KJP71AfYqD/SvsuZsqKhkQCWlrqzUFSzZUEXWVUXVRNUNZENfYK8qwLOpQTLb/YC9qgL9q0niX39gr2pA/2ppzoYaSgbUVOpaSl3dkg21Ze0nqiOqayAbpkfA9aoNPBt/ktmeA/TPD+hfAIl/C4D+1QH6V09zNvgrGRCg1PWUuq4lG+rLuoGooaiRgWxYBDyb+sCzaUwy28hsbQD0r8n/wWxtCPSvqeZsaKxkQBOlbqrUjSzZ0EzWzUUtRC0NZAMyt5sBz6YVyWwjs7U50L/WJP45gH/r1wLoXxvN2dBKyYDWSt1GqVtasqGtrNuJ2os6GMgGD+DZtAWeTUeS2fYE+tcO6F8nEv+8gP61B/rXWXM2dFQyoJNSd1bqDpZs6CLrrqJuou4GssEbeDZdgGfTg2S2MwH96wr0ryeJf5mB/nUD+tdLczb0UDKgp1L3UurulmzoLes+or6ifgaywQd4Nr2BZ9OfZLZ9gf71Afo3gMS/LED/+gL9G6g5G/orGTBAqQcqdT9LNgyS9WDRENFQA9mQFXg2g4BnM4xktrMB/RsM9G84iX/Zgf4NAfo3QnM2DFMyYLhSj1DqoZZsGCnrUaLRojEGsiEH8GxGAs9mLMls5wT6Nwro3zgS/3IB/RsN9G+85mwYq2TAOKUer9RjLNkwQdYTRZNEkw1kQ27g2UwAns0UktnOA/RvItC/qST+5QX6Nwno3zTN2TBFyYCpSj1NqSdbsmG6rGeIZopmGciGfMCzmQ48m9kks50f6N8MoH9zSPwrAPRvJtC/uZqzYbaSAXOUeq5Sz7JkwzxZzxctEC00kA0FgWczD3g2i0hmuxDQv/lA/xaT+FcY6N8CoH9LNGfDIiUDFiv1EqVeaMmGpbJeJlouWmEgG4oAz2Yp8GxWksx2UaB/y4D+rSLxrxjQv+VA/1ZrzoaVSgasUurVSr3Ckg1rZL1WtE603kA2FAeezRrg2Wwgme0SQP/WAv3bSOJfSaB/64D+bdKcDRuUDNio1JuUer0lGzbLeotoq2ibgWwoBTybzcCz2c7yNTGw1xagfztI/CsC7LUV6N9OzdmwXcmAHUq9U6m3WbJhl6x3i/aI9hrIhqLAXruAZ7OP5WtiYK/dQP/2k/hXHNhrD9C/3zVnwz4lA/Yr9e9KvdeSDQdkfVB0SPSHgWwoAex1AHg2f7J8TQzsdRDo32ES/0oBex0C+ndEczb8qWTAYaU+otR/WLLhqKyPiY6LThjIhtLAXkeBZ3OSZLbLAHsdA/p3isS/ssBex4H+ndacDSeVDDil1KeV+oQlG87I+qzonOi8gWwoB+x1Bng2F0hmuzyw11mgfxdJ/KsA7HUO6N8lzdlwQcmAi0p9SanPW7LhsqyviK6KrhnIhorAXpeBZ3OdZLYrAXtdAfp3g8S/ysBeV4H+3dScDdeVDLih1DeV+polG27J+rbojuiugWyoAux1C3g290hmuyqw122gf/dJ/KsG7HUH6N8DzdlwT8mA+0r9QKnvWrLhoawfiR6LnhjIhurAXg+BZ/OUZLZrAHs9Avr3jMS/msBej4H+PdecDU+VDHim1M+V+oklG17I+qXolei1gWyoBez1Ang2b0hmuzaw10ugf29J/PMD9noF9O+d5mx4o2TAW6V+p9SvLdnwXtYfRB+d+wayoQ6w13vg2Xwmme26wF4fgP65Refwzx/Y6yPQvxDR9WbDZyUDnGf1Vx1CqT9ZsiGkfC6UKLQoTHT92RAA7BUyOu5swpLMdj1gr1BA/8KR+Fcf2Cs00L/wmrMhrJIB4ZQ6vFKHif5lNkSQdURRJFFkA9nQANgrAvBsopDMdkNgr4hA/6KS+NcI2CsS0L9omrMhipIBUZU6mlJHtmRDdFnHEMUUxTKQDY2BvaIDzyY2yWw3AfaKAfTvJxL/mgJ7xQT6F0dzNsRWMuAnpY6j1LEs2fCzrOOK4ol+MZANzYC9fgaeTXyS2W4O7BUX6F8CEv9aAHvFA/qXUHM2xFcyIIFSJ1TqXyzZ8KusE4kSi5IYyIaWwF6/As8mKclstwL2SgT0LxmJf62BvRID/UuuORuSKhmQTKmTK3USSzb8JusUopSiVAayoQ2w12/As0lNMtttgb1SAP1LQ+JfO2CvlED/0mrOhtRKBqRR6rRKncqSDelknV6UQZTRQDa0B/ZKBzwbd5LZ7gDslR7on4PEv47AXhmA/nlozgZ3JQMcSu2h1Bkt2eApay+RtyiTgWzoBOzlCTybzCSz3RnYywvonw+Jf12AvbyB/vlqzobMSgb4KLWvUmeyZEMWWWcVZRNlN5ANXYG9sgDPJgfJbHcD9soK9C8niX/dgb2yAf3LpTkbcigZkFOpcyl1dks25JZ1HlFeUT4D2dAD2Cs38Gzyk8x2T2CvPED/CpD41wvYKy/Qv4KasyG/kgEFlLqgUuezZEMhWRcWFREVNZANvYG9CgHPphjJbPcB9ioM9K84iX99gb2KAP0roTkbiikZUFypSyh1UUs2lJR1KVFpURkD2dAP2Ksk8GzKksx2f2CvUkD/ypH4NwDYqzTQv/Kas6GskgHllLq8UpexZEMFWVcUVRJVNpANA4G9KgDPpgrJbA8C9qoI9K8qiX+Dgb0qAf2rpjkbqigZUFWpqyl1ZUs2VJd1DVFNUS0D2TAE2Ks68Gxqk8z2UGCvGkD//Ej8GwbsVRPoXx3N2VBbyQA/pa6j1LUs2VBX1v6iAFE9A9kwHNirLvBs6pPM9ghgL3+gfw1I/BsJ7BUA9K+h5myor2RAA6VuqNT1LNnQSNaNRU1ETQ1kwyhgr0bAs2lGMtujgb0aA/1rTuLfGGCvJkD/WmjOhmZKBjRX6hZK3dSSDS1l3UrUWtTGQDaMBfZqCTybtiSzPQ7YqxXQv3Yk/o0H9moN9K+95mxoq2RAO6Vur9RtLNnQQdYdRZ1EnQ1kwwRgrw7As+lCMtsTgb06Av3rSuLfJGCvTkD/umnOhi5KBnRV6m5K3dmSDd1l3UPUU9TLQDZMBvbqDjyb3iSzPQXYqwfQvz4k/k0F9uoJ9K+v5mzorWRAH6Xuq9S9LNnQT9b9RQNEAw1kwzRgr37AsxlEMtvTgb36A/0bTOLfDGCvAUD/hmjOhkFKBgxW6iFKPdCSDUNlPUw0XDTCQDbMBPYaCjybkSSzPQvYaxjQv1Ek/s0G9hoO9G+05mwYqWTAKKUerdQjLNkwRtZjReNE4w1kwxxgrzHAs5lAMttzgb3GAv2bSOLfPGCvcUD/JmnOhglKBkxU6klKPd6SDZNlPUU0VTTNQDbMB/aaDDyb6SSzvQDYawrQvxkk/i0E9poK9G+m5myYrmTADKWeqdTTLNkwS9azRXNEcw1kwyJgr1nAs5lHMtuLgb1mA/2bT+LfEmCvOUD/FmjOhnlKBsxX6gVKPdeSDQtlvUi0WLTEQDYsBfZaCDybpSSzvQzYaxHQv2Uk/i0H9loM9G+55mxYqmTAMqVertRLLNmwQtYrRatEqw1kwwpkL+DZrCGZ7ZXIXkD/1pL4twrZC+jfOs3ZsEbJgLVKvU6pV1uyYb2sN4g2ijYZyIbVwF7rgWezmWS21wB7bQD6t4XEv7XAXhuB/m3VnA2blQzYotRblXqTJRu2yXq7aIdop4FsWAfstQ14NrtIZns9sNd2oH+7SfzbAOy1A+jfHs3ZsEvJgN1KvUepd1qyYa+s94n2i343kA0bgb32As/mAMlsbwL22gf07yCJf5uBvfYD/TukORsOKBlwUKkPKfXvlmz4Q9Z/ig6LjhjIhi3AXn8Az+YoyWxvBfb6E+jfMRL/tgF7HQb6d1xzNhxVMuCYUh9X6iOWbDgh65OiU6LTBrJhO7DXCeDZnCGZ7R3AXieB/p0l8W8nsNcpoH/nNGfDGSUDzir1OaU+bcmG87K+ILooumQgG3YBe50Hns1lktneDex1AejfFRL/9gB7XQT6d1VzNlxWMuCKUl9V6kuWbLgm6+uiG6KbBrJhL7DXNeDZ3CKZ7X3AXteB/t0m8W8/sNcNoH93NGfDLSUDbiv1HaW+acmGu7K+J7ovemAgG34H9roLPJuHJLN9ANjrHtC/RyT+HQT2ug/077HmbHioZMAjpX6s1A8s2fBE1k9Fz0TPDWTDIWCvJ8CzeUEy238Aez0F+veSxL8/gb2eAf17pTkbXigZ8FKpXyn1c0s2vJb1G9Fb0TsD2XAY2Os18Gzek8z2EWCvN0D/PpD4dxTY6y3Qv4+as+G9kgEflPqjUr+zZMMnWX8WucWQz8fQnw3HgL0+Ac8mZAyO2T4O7PUZ6F8oEv9OAHu5xcD5FzqG3mxwzvdfGRBKqUMrdYgYX2ZDGFmHFYUThTeQDSeBvcIAzyYCyWyfAvYKC/QvIol/p4G9wgH9i6Q5GyIoGRBRqSMpdXhLNkSWdRRRVFE0A9lwBtgrMvBsopPM9llgryhA/2KQ+HcO2Csq0L+YmrMhupIBMZQ6plJHs2RDLFnHFv0kimMgG84De8UCns3PJLN9AdgrNtC/uCT+XQT2+gnoXzzN2fCzkgFxlTqeUsexZMMvso4vSiBKaCAbLgF7/QI8m19JZvsysFd8oH+JSPy7AuyVAOhfYs3Z8KuSAYmUOrFSJ7RkQxJZJxUlEyU3kA1Xgb2SAM/mN5LZvgbslRToXwoS/64DeyUD+pdSczb8pmRACqVOqdTJLdmQStapRWlEaQ1kww1gr1TAs0lHMts3gb1SA/1LT+LfLWCvNED/MmjOhnRKBqRX6gxKndaSDRll7S5yiDwMZMNtYK+MwLPxJJntO8Be7kD/vEj8uwvs5QD65605GzyVDPBSam+l9rBkQyZZZxb5iHwNZMM9YK9MwLPJQjLb94G9MgP9y0ri3wNgLx+gf9k0Z0MWJQOyKnU2pfa1ZEN2WecQ5XSyGciGh8Be2YFnk5tkth8Be+UA+peHxL/HwF45gf7l1ZwNuZUMyKPUeZU6lyUb8sk6v6iAqKCBbHgC7JUPeDaFSGb7KbBXfqB/hUn8ewbsVQDoXxHN2VBIyYDCSl1EqQtasqGorIuJiotKGMiG58BeRYFnU5Jktl8AexUD+leKxL+XwF7Fgf6V1pwNJZUMKKXUpZW6hCUbysi6rKicqLyBbHgF7FUGeDYVSGb7NbBXWaB/FUn8ewPsVQ7oXyXN2VBByYCKSl1JqctbsqGyrKuIqoqqGciGt8BelYFnU51ktt8Be1UB+leDxL/3wF5Vgf7V1JwN1ZUMqKHUNZW6miUbasm6tshPVMdANnwA9qoFPJu6JLP9EdirNtA/fxL/PgF7+QH9C9CcDXWVDPBX6gClrmPJhnqyri9qIGpoIBs+A3vVA55NI5LZdh4iqld9oH+NSfwLAfSvAdC/JpqzoZGSAY2VuolSN7RkQ1NZNxM1F7UwkA0hgWfTFHg2LUlmOxTQv2ZA/1qR+Bca6F9zoH+tNWdDSyUDWil1a6VuYcmGNrJuK2onam8gG8IAz6YN8Gw6kMx2WKB/bYH+dSTxLxzQv3ZA/zppzoYOSgZ0VOpOSt3ekg2dZd1F1FXUzUA2hAeeTWfg2XQnme0IQP+6AP3rQeJfRKB/XYH+9dScDd2VDOih1D2VupslG3rJureoj6ivgWyIBDybXsCz6Ucy25GB/vUG+tefxL8oQP/6AP0boDkb+ikZ0F+pByh1X0s2DJT1INFg0RAD2RAVeDYDgWczlGS2owH9GwT0bxiJf9GB/g0G+jdcczYMVTJgmFIPV+ohlmwYIeuRolGi0QayIQbwbEYAz2YMyWzHBPo3EujfWBL/YgH9GwX0b5zmbBijZMBYpR6n1KMt2TBe1hNEE0WTDGRDbODZjAeezWSS2f4J6N8EoH9TSPyLA/RvItC/qZqzYbKSAVOUeqpST7JkwzRZTxfNEM00kA0/A89mGvBsZpHMdlygf9OB/s0m8S8e0L8ZQP/maM6GWUoGzFbqOUo905INc2U9TzRftMBANvwCPJu5wLNZSDLb8YH+zQP6t4jEvwRA/+YD/VusORsWKhmwSKkXK/UCSzYskfVS0TLRcgPZkBB4NkuAZ7OCZLZ/Bfq3FOjfShL/EgH9Wwb0b5XmbFihZMBKpV6l1Mst2bBa1mtEa0XrDGRDYuDZrAaezXqS2U4C9G8N0L8NJP4lBfq3FujfRs3ZsF7JgA1KvVGp11myYZOsN4u2iLYayIZkwLPZBDybbSSznRzo32agf9tJ/PsN6N8WoH87NGfDNiUDtiv1DqXeasmGnbLeJdot2mMgG1IAz2Yn8Gz2ksx2SqB/u4D+7SPxLxXQv91A//Zrzoa9SgbsU+r9Sr3Hkg2/y/qA6KDokIFsSA08m9+BZ/MHyWynAfp3AOjfnyT+pQX6dxDo32HN2fCHkgF/KvVhpT5kyYYjsj4qOiY6biAb0gHP5gjwbE6QzHZ6oH9Hgf6dJPEvA9C/Y0D/TmnOhhNKBpxU6lNKfdySDadlfUZ0VnTOQDZkBJ7NaeDZnCeZbXegf2eA/l0g8c8B9O8s0L+LmrPhvJIBF5T6olKfs2TDJVlfFl0RXTWQDR7As7kEPJtrJLPtCfTvMtC/6yT+eQH9uwL074bmbLimZMB1pb6h1Fct2XBT1rdEt0V3DGSDN/BsbgLP5i7JbGcC+ncL6N89Ev8yA/27DfTvvuZsuKtkwD2lvq/UdyzZ8EDWD0WPRI8NZIMP8GweAM/mCcls+wL9ewj07ymJf1mA/j0C+vdMczY8UTLgqVI/U+rHlmx4LusXopeiVwayISvwbJ4Dz+Y1yWxnA/r3AujfGxL/sgP9ewn0763mbHitZMAbpX6r1K8s2fBO1u9FH0QfDWRDDuDZvAOezSeS2c4J9O890L/PJP7lAvr3Aeif82JG+WeXDZ+UDPis1M7/4V/1R0s2hJDPhRSFEoWOqT8bcgPPJkRM3NmEickx23mA/oUE+heWxL+8QP9CAf0LpzkbwigZEFapwyl16JhfZkN4WUcQRRRFMpAN+YBnEx54NpFJZjs/0L8IQP+ikPhXAOhfRKB/UTVnQ2QlA6IodVSljmTJhmiyji6KIYppIBsKAs8mGvBsYpHMdiGgf9GB/sUm8a8w0L8YQP9+0pwNsZQMiK3UPyl1TEs2xJH1z6K4ongGsqEI8GziAM/mF5LZLgr072egf/FJ/CsG9C8u0L8EmrPhFyUD4it1AqWOZ8mGhLL+VZRIlNhANhQHnk1C4NkkIZntEkD/fgX6l5TEv5JA/xIB/UumORuSKBmQVKmTKXViSzYkl/VvohSilAayoRTwbJIDzyYVyWyXBvr3G9C/1CT+lQH6lwLoXxrN2ZBKyYDUSp1GqVNasiGtrNOJ0osyGMiGssCzSQs8m4wks10O6F86oH/uJP6VB/qXHuifQ3M2ZFQywF2pHUqdwZINHrL2FHmJvA1kQwXg2XgAzyYTyWxXBPrnCfQvM4l/lYD+eQH989GcDZmUDMis1D5K7W3JBl9ZZxFlFWUzkA2VgWfjCzyb7CSzXQXoXxagfzlI/KsK9C8r0L+cmrMhu5IBOZQ6p1Jns2RDLlnnFuUR5TWQDdWAZ5MLeDb5SGa7OtC/3ED/8pP4VwPoXx6gfwU0Z0M+JQPyK3UBpc5ryYaCsi4kKiwqYiAbagLPpiDwbIqSzHYtoH+FgP4VI/GvNtC/wkD/imvOhqJKBhRT6uJKXcSSDSVkXVJUSlTaQDb4Ac+mBPBsypDMdh2gfyWB/pUl8a8u0L9SQP/Kac6GMkoGlFXqckpd2pIN5WVdQVRRVMlANvgDz6Y88Gwqk8x2ANC/CkD/qpD4Vw/oX0Wgf1U1Z0NlJQOqKHVVpa5kyYZqsq4uqiGqaSAb6gPPphrwbGqRzHYDoH/Vgf7VJvGvIdC/GkD//DRnQy0lA2ortZ9S17RkQx1Z1xX5iwIMZEMj4NnUAZ5NPZLZbgz0ry7Qv/ok/jUB+ucP9K+B5myop2RAfaVuoNQBlmxoKOtGosaiJgayoSnwbBoCz6YpyWw3A/rXCOhfMxL/mgP9awz0r7nmbGiqZEAzpW6u1E0s2dBC1i1FrUStDWRDC+DZtACeTRuS2W4J9K8l0L+2JP61AvrXCuhfO83Z0EbJgLZK3U6pW1uyob2sO4g6ijoZyIbWwLNpDzybziSz3QboXwegf100z3ZnZYa7KHVHpe5kme2usu4m6i7qETjbToVTzsXuIxfieXj4ON/2161vSD3/P3x96npnklNxUzyCscts9IqAvx7QjD0JGHsQMHYnYOxHwNiXgLEPAWNvAsZBBIwDCRgHEDD2J2AcRsA4lIBxCAHjYALGUQSMIwkYRxAwDidgHEfAOJaAcQwB42gCxkkEjBMJGCcQMI4nYJxGwDiVgHEKAeNkAsbCbsGfsQgBY1ECxmIEjMUJGEsQMJYkYCxFwFiagLEMAWNZAsZyBIzlCRgrEDBWJGCsRMBYmYCxCgFjVQLGagSM1QkYaxAw1iRgrEXAWJuA0Y+AsQ4BY10CRn8CxgACxnoEjPU1MLphGXX1DdDT18tDT19PTbx056a9L/oaW0/wb/xbCBh3EDDuImD88fvkGMYfv0+OYfzx++QYxh+/T45h/PH75BjGH79PjmH88fvkGMYfv0+OYfzx++QYxh+/T45h/PH75BjGH79PjmH88fvkGMYfv0+OYfzx++QYxh+/T45hHOAW/BkHEjAOImAcTMA4hIBxKAHjMALG4QSMIwgYRxIwjiJgHE3AOIaAcSwB4zgCxvEEjBMIGCcSME4iYJxMwDiFgHEqAeM0AsbpBIwzCBhnEjDOImCcTcA4h4BxLgHjPALG+QSMvxMwHiBgPEjAeIiA8Q8Cxj8JGA8TMB4hYDxKwHiMgPE4AeMJAsaTBIynCBhPEzCeIWA8S8B4joDxPAHjBQLGiwSMlwgYLxMwXiFgvErAeI2A8ToB4w0CxpsEjLcIGG8TMN7RwOiGZfzR90ffH31/9P3R90ffH31/9P3R90ffYN0X/TX6YoK/UVpBwLiGgHEdAeMCt+DPuJCAcREB42ICxiUEjEsJGJcRMC4nYFxBwLiSgHEVAeNqAsY1BIxrCRjXETCuJ2DcQMC4kYBxEwHjZgLGLQSMWwkYtxEwbidg3EHAuJOAcRcB424Cxj0EjHsJGPcRMO4nYLxLwHiPgPE+AeMDAsaHBIyPCBgfEzA+IWB8SsD4jIDxOQHjCwLGlwSMrwgYXxMwviFgfEvA+I6A8T0B4wcCxo8EjJ8IGD8TMDobBnfGEASMIQkYQxEwhiZgDEPAGJaAMRwBY3gCxgZuwZ+xIQFjIwLGxgSMTQgYmxIwNiNgbE7A2IKAsSUBYysCxtYEjG0IGNsSMLYjYGxPwNiBgLEjAWMnAsbOBIxdCBi7EjB2I2DsTsDYg4CxJwFjLwLG3gSMfQgY+xIw9iNg7E/AOJ3gb8TnMPwdOwHjIgLGH/P4Yx6DE6OD4GdIHgSMngSMXgSM3gSMmQgYMxMw+hAw+hIwZiFgzErAmI2AMTsBYw4CxpwEjLkIGHMTMOYhYMxLwJiPgDE/AWMBAsaCBIyFCBgLEzAWIWAsSsBYjICxOAFjCQLGkgSMpRjy0Y0gHwkYixIwFiNgLE7AWIKAsSQBYykCxtIEjGUIGMsSMJYjYCxPwFiBgLEiAWMlAsbKBIxVCBirEjBWI2CsTsBYg4CxJgFjLQLG2gSMfgSMdQgY6xIw+hMwBhAw1iNgrE/A+OP9KTCMP96fAsP44/0pMIw/3p8Cw/jj/SkwjD/enwLD+OP9KTCMP96fAsP44/0pMIw/3p8Cw/jj/SkwjD/enwLD2IOAsScB44/3p8Aw/nh/Cgzjj/enwDAOIGAcSMA4iIBxMAHjEALGoQSMwwgYhxMwjiBgHEnAOIqAcTQB4xgCxrEEjOMIGMcTME4gYJxIwDiJgHEyAeMUAsapBIzTCBinEzDOIGCcScA4i4BxNgHjHALGuQSM8wgY5xMwLiBgXEjAuIiAcTEB4xICxqUEjMsIGJcTMK4gYFxJwLiKgHE1AeMaAsa1BIzrCBjXEzBuIGDcSMC4iYBxMwHjFgLGrQSM2wgYtxMw7iBg3EnAuIuAcTcB4x4Cxr0EjPsIGPcTMP5OwHiAgPEgAeMhAsY/CBj/JGA8TMB4hIDxKAHjMQLG4wSMJwgYTxIwniJgPE3AeIaA8SwB4zkCxvMEjBcIGC8SMF4iYLxMwHiFgPEqAeM1AsbrBIw3CBhvEjDeImC8TcB4h4DxLgHjPQLG+wSMDwgYHxIwPiJgfEzA+ISA8SkB4zMCxucEjC8IGF8SML4iYHxNwPiGgPEtAeM7Asb3BIwfCBg/EjB+ImD8TMDobBjcGUMQMIYkYAxFwBiagDEMAWNYAsZwBIzhCRgjEDBGJGCMRMAYmYAxCgFjVALGaASM0QkYYxAwxiRgjEXAGJuA8ScCxjgEjD8TMMYlYIxHwPgLAWN8AsYEBIwJCRh/JWBMRMCYmIAxCQFjUgLGZASMyQkYfyNgTEHAmJKAMRUBY2oCxjQEjGkJGNMRMKYnYMxAwJiRgNGdgNFBwOhBwOhJwOhFwOhNwJiJgDEzAaMPAaMvAWMWAsasBIzZCBizEzDmIGDMScCYi4AxNwFjHgLGvASM+QgY8xMwFiBgLEjAWIiAsTABYxECxqIEjMUIGIsTMJYgYCxJwFiKgLE0AWMZAsayBIzlCBjLEzBWIGCsSMBYiYCxMgFjFQLGqgSM1QgYqxMw1iBgrEnAWIuAsTYBox8BYx0CxroEjP4EjAEEjPUIGOsTMDYgYGxIwNiIgLExAWMTAsamBIzNCBibEzC2IGBsScDYioCxNQFjGw2MOji7xtTD+b8fIcHA2yP/t5eneyYvL//MHv4OT0dtdw9fPx9vdy9vv0w+Dh+Ht493XQ8fT09/Hy+fzL5+vpndfR1env6OAG9fz4DAZj1xT975+9duoQIPyNk3sfw3tCLrB/ogQ7j93x44NKc6Z+5B/NDJGcrN8AUc1IsO+eTbakpZ9HMGXpyOdiTPOSTwObcnec7Ai9HRwdBzdg/ah6NjCJx/5cJxhG4nkq/uOpNwdmH5apmEsxsJZ3cSzh4knD1JOHuRcPYm4exDwtmXhLMfCWd/Es4BJJwDSTgHkXAOJuEcQsI5lIRzGAnncBLOESScI0k4R5FwjibhHEPCOZaEcxwJ53gSzgkknBNJOCeRcE4m4ZxCwjmVhHPa/8GfC04n+XnRDODPiyqR/LxoJsl1M4uEczYJ5xwSzrkknPNIOOeTcC4g4VxIwrmIhHMxCecSEs6lJJzLSDiXk3CuIOFcScK5ioRzNQnnGhLOtSSc60g415NwbiDh3EjCuYmEczMJ5xYSzq0knNtIOLeTcO4g4dxJwrmLhHM3CeceEs69JJz7SDj3k3D+TsJ5gITzIAnnIRLOP0g4/yThPEzCeYSE8ygJ5zESzuMknCdIOE+ScJ4i4TxNwnmGhPMsCec5Es7zJJwXSDgvknBeIuG8TMJ5hYTzKgnnNRLO6yScN0g4b5Jw3iLhvE3CeYeE8y4J5z0SzvsknA9IOB+ScD4i4XxMwvmEhPMpCeczEs7nJJwvSDhfknC+IuF8TcL5hoTzLQnnOxLO9yScH0g4P5JwfiLh/EzC6RaSgzMECWdIEs5QJJyhSTjDkHCGJeEMR8IZnoQzAglnRBLOSCSckUk4o5BwRiXhjEbCGZ2EMwYJZ0wSzlgknLFJOH8i4YxDwvkzCWdcEs54JJy/kHDGJ+FMQMKZkITzVxLORCSciUk4k5BwJiXhTEbCmZyE8zcSzhQknClJOFORcKYm4UxDwpmWhDMdCWd6Es4MJJwZSTjdSTgdJJweJJyeJJxeJJzeJJyZSDgzk3D6kHD6knBmIeHMSsKZjYQzOwlnDhLOnCScuUg4c5Nw5iHhzEvCmY+EMz8JZwESzoIknIVIOAuTcBYh4SxKwlmMhLM4CWcJEs6SJJylSDhLk3CWIeEsS8JZjoSzPAlnBRLOiiSclUg4K5NwViHhrErCWY2EszoJZw0SzpqaOENaOIPTfelraXrOSSzP2SMgSM/ZMeBL/zyD0mug9Szqfn+vQX8/V8f39hpsNyPu39driP28uX9Pr6H/MLu+Ad/ea9g/Xwc+39pruKtrKvO39Rrh8vr0CviWXiP/7Vr3+vpeo/6tl7ef99f2Gv3vvTL5uH9drzFf08vh4/41vcZ+XS+Hd+Z/7zXua3v5eNf5t17jv75XXY/MrntN+JZePp4ernpN/LZenv6Z/7nXpG/t5eOV+Z96Tf72Xj6Zfex7TfmeXvIZu15Tv6+Xb6aAv/ea9p29hMvd2mv69/dyeHl82WtGUHp5+rurvWYGrZcjwOu/vWYFtZe3r8dfvWYHvZen/3+aOeZAegU4uznmgnpJN8c8QK+/vk6c74b7OrE2ydfwfiGD7p/Dp06d2n5e3ion+mv4UMDnXMfQ9y3uQftw1A2J829jZI559Cc5mwDg2YyMzPGc6wGf81aSeaxPkuMNSDgbknA2IuFsTMLZhISzKQlnMxLO5iScLUg4W5JwtiLhbE3C2YaEsy0JZzsSzvYknB1IODuScHYi4exMwtmFhLMrCWc3Es7uJJw9SDh7knD2IuHsTcLZh4SzLwlnP0P/zh2cfneq///B5zyA5Dkjf742kORnOIOAP88YSvIznMHA51w53P+963nI/8EMG/p/MMOGkWTYcOD13DUmx3MeAXzO20l+Dj2S5OvaUSSco0k4x5BwjiXhHEfCOZ6EcwIJ50QSzkkknJNJOKeQcE4l4ZxGwjmdhHMGCedMEs5ZJJyzSTjnkHDOJeGcR8I5n4RzAQnnQhLORSSci0k4l5BwLiXhXEbCuZyEcwUJ50oSzlUknKtJONeQcK4l4VxHwrmehHMDCedGEs5NJJybSTi3kHBuJeHcRsK5nYRzBwnnThLOXSScu0k495Bw7iXh3EfCuZ+E83cSzgMknAdJOA+RcP5BwvknCedhEs4jJJxHSTiPkXAeJ+E8QcJ5koTzFAnnaRLOMyScZ0k4z5FwnifhvEDCeZGE8xIJ52USzisknFdJOK+RcF4n4bxBwnmThPMWCedtEs47JJx3STjvkXDeJ+F8QML5kITzEQnnYxLOJyScT0k4n5FwPifhfEHC+ZKE8xUJ52sSzjcknG9JON+RcL4n4fxAwvmRhPMTCednEk63UBycIUg4Q5JwhiLhDE3CGYaEMywJZzgSzvAknBFIOCOScEYi4YxMwhmFhDMqCWc0Es7oJJwxSDhjknDGIuGMTcL5EwlnHBLOn0k445JwxiPh/IWEMz4JZwISzoQknL+ScCYi4UxMwpmEhDMpCWcyEs7kJJy/kXCmIOFMScKZioQzNQlnGhLOtCSc6Ug405NwZiDhzEjC6U7C6SDh9CDh9CTh9CLh9CbhzETCmZmE04eE05eEMwsJZ1YSzmwknNlJOHOQcOYk4cxFwpmbhDMPCWdeEs58JJz5STgLkHAWJOEsRMJZmISzCAlnURLOYiScxUk4S5BwliThLEXCWZqEswwJZ1kSznIknOVJOCuQcFYk4axEwlmZhLMKCWdVEs5qJJzVSThrkHDWJOGsRcJZm4TTj4SzDglnXRJOfxLOABLOeiSc9Uk4G5BwNiThbETC2ZiEswkJZ1MSzmYknM1JOFuQcLYk4WxFwtmahLMNCWdbEs52JJztSTg7kHB2JOHsRMLZmYSzCwlnVxLObiSc3Uk4e5Bw9iTh7EXC2ZuEsw8JZ18Szn4knP1JOAeQcA4k4RxEwjmYhHMICedQEs5hJJzDSThHkHCOJOEcRcI5moRzDAnnWBLOcSSc40k4J5BwTiThnETCOZmEcwoJ51QSzmkknNNJOGeQcM4k4ZxFwjmbhHMOCedcEs55JJzzSTgXkHAuJOFcRMK5mIRzCQnnUhLOZSScy0k4V5BwriThXEXCuZqEcw0J51oSznUknOtJODeQcG4k4dxEwrmZhHMLCedWEs5tJJzbSTh3kHDuJOHcRcK5m4RzDwnnXhLOfSSc+0k4fyfhPEDCeZCE8xAJ5x8knH+ScB4m4TxCwnmUhPMYCedxEs4TJJwnSThPkXCeJuE8Q8J5loTzHAnneRLOCyScF0k4L5FwXibhvELCeZWE8xoJ53USzhsknDdJOG+RcN4m4bxDwnmXhPMeCed9Es4HJJwPSTgfkXA+JuF8QsL5lITzGQnncxLOFyScL0k4X5FwvibhfEPC+ZaE8x0J53sSzg8knB9JOD+RcH4m4XQLzcEZgoQzJAlnKBLO0CScYUg4w5JwhiPhDE/CGYGEMyIJZyQSzsgknFFIOKOScEYj4YxOwhmDhDMmCWcsEs7YJJw/kXDGIeH8mYQzLglnPBLOX0g445NwJiDhTEjC+SsJZyISzsQknElIOJOScCYj4UyuiTOkhdPTPZOXl39mD3+Hp6O2u4evn4+3u5e3XyYfh4/D28e7roePp6e/j5dPZl8/38zuvg4vT39HgLevZ0Bg75TA5/yboefsHrQPR4rQOP96xuQ459BA/1KSzHYY4HNORfKcwwKfc2qS5xwO+JzTkDzn8MDnnJbkOUcAPud0JM85IvA5pyd5zpGAzzkDyXOODHzOGUmecxTgc3Ynec5Rgc/ZQfKcowGfswfJc44OfM6eJM85BvA5e5E855jA5+xN8pxjAZ9zJpLnHBv4nDOTPOefgM/Zh+Q5xwE+Z1+S5/wz8DlnIXnOcYHPOSvJc44HfM7ZSJ7zL8DnnJ3kOccHPuccJM85AfA55yR5zgmBzzkXyXP+Fficc5M850TA55yH5DknBj7nvCTPOQnwOecjec5Jgc85P8lzTgZ8zgVInnNy4HMuSPKcfwM+50IkzzkF8DkXBj7nUNLDqROBT7htCDe3dqL2og6ijqJOos6iLqKuom6i7qIeop6iXqLeoj6ivqJ+ov6iAaKBokGiwaIhoqGiYaLhohGikaJRotGiMaKxonGi8aIJoomiSaLJoimiqaJpoumiGaKZolmi2aI5ormieaL5ogWihaJFosWiJaKlomWi5aIVopWiVaLVojWitaJ1ovWiDaKNok2izaItoq2ibaLtoh2inaJdot2iPaK9on2i/aLfRQdEB0WHRH+I/hQdFh0RHRUdEx0XnRCdFJ0SnRadEZ0VnROdF10QXRRdEl0WXRFdFV0TXRfdEN0U3RLdFt0R3RXdE90XPRA9FD0SPRY9ET0VPRM9F70QvRS9Er0WvRG9Fb0TvRd9EH0UfRJ9DvGfCySEKKQolCi0KIworCicKLwogiiiKJIosiiKKKoomii6KIYopiiWKLboJ1Ec0c+iuKJ4ol9E8UUJRAlFv4oSiRKLkoiSipKJkot+E6UQpRSlEqUWpRGlFaUTpRdlEGUUuYscIg+Rp8hL5C3KJMos8hH5irKIsoqyibKLcohyinKJcovyiPKK8onyiwqICooKiQqLioiKioqJiotKiEqKSolKi8qIyorKicqLKogqiiqJKouqiKqKqomqi2qIaopqiWqL/ER1RHVF/qIAUT1RfVEDUUNRI1FjURNRU1EzUXNRC1FLUStRa1EbUVtRO1F7UQdRR1EnUWdRF1FXUTdRd1EPUU9RL1FvUR9RX1E/UX/RANFA0SDRYNEQ0VDRMNFw0QjRSNEo0WjRGNFY0TjReNEE0UTRJNFk0RTRVNE00XTRDNFM0SzRbNEc0VzRPNF80QLRQtEi0WLREtFS0TLRctEK0UrRKtFq0RrRWtE60XrRBtFG0SbRZtEW0VbRNtF20Q7RTtEu0W7RHtFe0T7RftHvogOig6JDoj9Ef4oOi46IjoqOiY6H/E/+nhSdEp0WnRGdFZ0TnRddEF0UXRJdFl0RXRVdE10X3RDdFN0S3RbdEd0V3RPdFz0QPRQ9Ej0WPRE9FT0TPRe9EL0UvRK9Fr0RvRW9E70XfRB9FH0SfQ75nxeNEKKQolCi0KIworCicKLwogiiiKJIosiiKKKoomii6KIYopiiWKLYop9EcUQ/i+KK4ol+EcUXJRAlFP0qSiRKLEoiSipKJkou+k2UQpRSlEqUWpRGlFaUTpRelEGUUeR84XOIPESeIi+RtyiTKLPIR+QryiLKKsomyi7KIcrpfC8MUW5RHlFeUT5RflEBUUFRIVFhURFRUVExUXFRCVFJUSlRaVEZUVlROVF5UQVRRVElUWVRFVFVUTVRdVENUU1RLVFtkZ+ojqiuyF8UIKonqi9qIGooaiRqLGoiaipqJmouaiFqKWolai1qI2oraidqL+og6ijqJOos6iLqKuom6i7qIeop6iXqLeoj6ivqJ+ovGiAaKBokGiwaIhoqGiYaLhohGikaJRotGiMaKxonGi+aIJoomiSaLJoimiqaJpoumiGaKZolmi2aI5orct5r3nkfd+c90p33H3fe29t532znPamd93t23kvZeZ9i5z2AnffXdd671nlfWOc9V533M3XeK9R5H07nPS6d94903pvRed9D5z0Fnffrc94Lz3mfOec93Jz3R3Pee8x5Xy/nPbOc96Ny3uvJeR8l5z2KnPf/cd5bx3nfGuc9YZz3W3Hey8R5nxDnPTic97dw3jvCeV8G5z0PnPcTcL5Xv/N98J3vMe98/3bne6M733fc+Z7ezvfLdr4XtfN9np3voex8f2Lne/8631fX+Z61zveDdb7XqvN9TJ3vEep8/03ne1s63zfS+Z6Mzvc7dL6XoPN9+pzvged8fznne7c53xfN+Z5jzvfzcr5XlvN9qJzv8eR8/yTnexM53/fH+Z46zvercb4XjPN9VpzvYeJ8fxDne28439fC+Z4RzvdjcL7XgfN9BJx/o+/8+3fn35Y7/27b+TfRzr83dv4tr/PvZJ1/g+r8+07n3046/y7R+Td/zr+nc/6tmvPvwJx/Y+X8+yXn3wY5/+7G+Tctzr8Xcf4thvPvHJx/Q+D8/Xzn7747f6/c+XvWzt9hdv4ervP3Up2/p+n8vUXn7/E5f6/N+Xtezt97cv4ekPP3Ypy/J+L8vQnn7xE4f67u/Dmz8+euzp9DOn8u5/w5lfPnNs6fYzj/Xd/579zOf/f9n38HFTn/ncz570bOf0dx/ruC8/ts5/edzu/DnN+XOL9Od0ZliP/Y9b9fX//1EfhllFugnW7O38t1/p6q8/c2nb/H6Py9PufvuTl/78v5e1DO3wty/p6M8/dGnL9H4fy9AufP2Z0/d3b+HNb5c0nnz+mcP7dy/hzH+XMN57/zO//d2/nvwM5/F3X+O6Hz380Si5KIkoqSiZKLnN+XOb9Pcf7ueypRalEaUVpROlF6UQZRRuf3HSKHyMP5vZHIS+QtyiTKLPIR+YqyiLKKsomyi3KIcgZ+L5RblEeUV5RPlF9UQFRQVEhUWFREVFRUTFRcVEJUUlRKVFpURlRWVE5UXlRBVFFUSVRZVEVUVVRNVF1UQ1RTVEtUW+QnqiOqK/IXBYjqieqLGogaihqJGouaiJqKmomai1qIWopaiVqL2ojaitqJ2os6iDqKOok6i7qIuoq6ibqLeoh6inqJeov6iPqK+on6iwaIBooGiQaLhoiGioaJhotGiEaKRolGi8aIxorGicaLJogmiiaJJoumiKaKpommi2aIZopmiWaL5ojmiuaJ5osWiBaKFokWi5aIloqWiZaLVohWilaJVovWiNaK1onWizaINoo2iTaLtoi2iraJtot2iHaKdol2i/aI9or2ifaLfhcdEB0UHRL9IfpTdFh0RHRUdEx0XHRCdFJ0SnRadEZ0VnROdF50QXRRdEl0WXRFdFV0TXRddEN0U3RLdFt0R3RXdE90X/RA9FD0SPRY9ET0VPRM9Fz0QvRS9Er0WvRG9Fb0TvRe9EH0UfRJ9FnkvPhDiEKKQolCi8KIworCicKLIogiiiKJIouiiKKKoomii2KIYopiiWKLfhLFEf0siiuKJ/pFFF+UQJRQ9KsokSixKIkoqSiZKLnoN1EKUUpRKlFqURpRWlE6UXpRBlFGkbvIIfIQeYq8RN6iTKLMIh+RryiLKKsomyi7KIcopyiXKLcojyivKJ8ov6iAqKCokKiwqIioqKiYqLiohKikqJSotKiMqKyonKi8qIKooqiSqLKoiqiqqJqouqiGqKaolqi2yE9UR1RX5C8KENUT1Rc1EDUUNRI1FjURNRU1EzUXtRC1FLUStRa1CeH2t49dyp7za2nnx083csdrcWBefvV/98HF5z4Ffu7ywLaO6gNurFM/99nF5/7nheUfPhfCxedCuvhcKBefC+3ic2FcfC6si8+Fc/G58C4+F8HF5yK6+FwkF5+L7OJzUVx8LqqLz0Vz8bnoLj4Xw8XnYrr4XCwXn4vt4nM/ufhcHBef+9nF5+K6+Fw8F5/7xcXn4rv4XAIXn0vo4nOJAz83bcGva+LfCFlF/VxSF59LFvi5KrnvnYg96Goa9XPJAz+Xs0DrDWELdh2ufs4n8HN2WZAl8HMHRx/eO79/7brq57K5eFwOF4/L5eJxeV18Lr+LngVdPK6wi8cVdfG4Ei4+V8pFzzIuHlfOxeMquHhcZRefq+qiZ3UXj6vp4nG1XTyurovPBbjoWd/F4xq6eFxjF49r5uJzLVz0bOXicW1cPK6di8d1dPG5zi56dnXxuO4uHtfTxeP6uPhcPxc9B7h43CAXjxvi4nHDXXxupIueo108bqyLx4138bhJLj43xUXPaS4eN8PF42a5eNxcF5+b76LnQhePW+zicUtdPG6Fi8+tctFzjYvHrXPxuA0uHrfZxee2uui53cXjdrp43G4Xj9vn4nO/u+h50MXj/nDxuMMuHnfMxedOuOh5ysXjzrh43DkXj7vo4nOXXfS86uJx11087qaLx4UK/c+fCxP6n3uGc/G4CC4eF8nF46K6+Fx0Fz1junhcbBePi+PicfFcfC6+i54JXTwukYvHJXHxuOQuPpfCRc9ULh6XxsXj0rl4XEYXn3O46Onp4nHeLh6X2cXjsrj4XDYXPXO4eFwuF4/L4+Jx+V18rqCLnoVdPK6oi8cVd/G4Ui4+V8ZFz3IuHlfBxeMquXhcVRefq+6iZ00Xj6vt4nF1XDwuwMXn6rvo2dDF4xq7eFxTF49r4eJzrVz0bOPice1cPK6Di8d1dvG5ri56dnfxuJ4uHtfbxeP6ufjcABc9B7l43BAXjxvm4nEjXXxutIueY108bryLx0108bgpLj43zUXPGS4eN8vF4+a4eNx8F59b6KLnYhePW+ricctdPG6vi8/td9HzgIvHHXLxuD9dPO6oi88dd9Hz/7X3JWByFde5t9UzI02PRtOSEJuE2MHsvc1mO7EcBrDBxmBsMN5nprtBIBCLJJAQ0IAFxgYhgQwIBDbe7cRLvMRL4uTlJS+JE2d1Nid2NidxnP0lefZzHL88rujT/c/fp6pvT58aNUj1fdLcvnXqP6dOnTp1qm7dun/gKfdHnnLf8JT7pifvzzyYf+Ep91eecn/tKfcdT953PZj/4Cn3T55y/+Ip92+evP/wYH7PU+7/esr9p6fcjzx5/+3BTPW7y6X73eX6PeWWePIyHsylnnLLPOWynnIrPXmrPJhHeMod5Sm32lNurSfvOA/mCZ5yJ3nKneIpd5on7wwP5lmecud4yuU95UqevDEP5oSn3Is95V7qKfcyT97LPZjnesqd5yl3gafchZ68V3kwL/aUu8RT7rWecq/35F3hwbzSU+5NnnJv8ZR7uydvxoNZ9pSrespd7Sl3rSfvOg/mRk+5Gz3lbvaUu9+T924P5oOecg95yu32lNvjyXvUg/m4p9wTnnL7POXe68l7xoP5AU+5D3nKfcRT7uOevJ/yYH7SU+7TnnKf8ZT7vCfvCx7ML3nK/ayn3Fc85f6HJ+9/ejB/2VPuVzzlfs1T7jc8eb/pwfxtT7nf9ZT7uqfcH3ry/tiD+Seect/0lPszT7m/9OR924P5N55y3/GU+66n3D968v7Zg/mvnnL/5in3H55y3/fk/cCD+UNPuR95yv23p9yiAXde34Abc8BTbomnXMZTbtiTN+LBXO4pt9JTbpWn3JGevKM9mGs85dZ6yh3nKXeiJ+9kD+apnnKnecqd4Sl3ticv58EseMqVPOXGPOVe4cm70IP5Kk+5iz3lLvGUu8yT93oP5hWecld6yr3JU+6tnry3ezBnPOXKnnJVT7n1nrxrPZjXecpt9JS70VNukydviwfzVk+5bZ5y2z3l7vTk3eXBvMdTboen3H2ecu/y5D3gwdzpKbfLU+5hT7n3ePIe82Du9ZR70lPuKU+593ny3u/B/KCn3Ic95T7qKfeTnrxPeDA/5Sn3055yn/WU+xlP3hc9mF/2lPs5T7mf95T7RU+5X/Lk/Z4n7/c9/P7dU+4HnnI/9JT7kSdvaLE778F63jeHtl53xuTPzeG3s563MrrvocznX/0mzDtj0C3n2Z68nCev4MkrefLGPHkTnrwXe/J+vJ6n6Wydp9yUp9z5nnIXesq9ylPuEk+513rKXe4p9wZPuTd7yr3VU27GU67sKVf1lLvGk7fBg7nFk/fZpXreUP3vmrXP/a1DNM7uiF+9iLcprav/znWX8oOAa40/kZseHYzmJmP5i4OAGQC/IPh9YfBzddcXfaA2Fz8ivsP13/g6jpSRvEWQ98F63pJ6vlzfXb8eJLwQ7Y4yWettpSL/IqhbnM6tNfNSZryrMrREU0Hwx4uCf14Q/NEG/vlh5Bc3G10QBH+6of9XhNFPw2e9Mgx+Qz8XhtH/tOBfFAR/bFzwXxUEvzkmvToMfsP+LwZ8O99UmBX819TxoznY+eLEWLEwMVYolCu56fLYeHWyOJ4rzowWJ2dn8rniaGGiPD5dzOUqxcpsKVcemxwtV6YnR4vVmelJCUGjS1TsYmXmWajR6bGJmXx1eqyamymNTxSnq+Pj5enyZKkyPpor52fH8rOFfHViYnp0dHp2dDKfr1YmR6sTDexLg+glJ2F39Nog+MVGv70sCH5BQsvodTVN9x2lPN8Q7NeD7H2R3Xgp+JeHwW/02SvC4Dds5w1B2rYp/5W1qNu2bUmC/UZj2cemc5OVsaY/fpMx/szM2Ph0ZaLRr95sjF+cHatUi+ONtn2LMf70aKlaHS02xsO3GuOP5nOV0cK4TB2jtxnjT87kRscmJhrjyduN8Z8dA4rlyemGX5u21s9MJTdbzk/K/GOmji884iS8Z41519NkivhF0dz5VUT8MySrtZ9JET+UB/UjcxnRXbnWKmtWyUMfw3lp5Z7w0bDeZIj1ZkOstxhivdUQ622GWG83xJJ+HbavlRrjXDkIfk6WZqNKEPyiLOFG1TDyN+YdVwXBzzf0fzXgG86bGuP0+jD6aYyj14TBrwj+tXX8CLDzE8VCYbwYn3M8Uc7lS+XZwsSzM7SZUm42Nz1bqEyW8pPVUqFUnC3PzkyUJqbz1Vx1enayOvEcuGBvCCJ7sWH714XAzzflv74WwnaKjbnlxlqr7nNtpfMnwb6hc+x2qRH73ujGnrfpCPZNCnZhujibm6w+G8NOTI8/G4M/a765Zy9mJirVscL0zLMLA4VyPp+vlJ79r1AplyZnymP5mbHKeGF05ll2DZ3cXAtgL7l8IybdBPiGem/IvxnwUwHwtwTRTxP/ljD6acxXb63jh8DeGkb3DV+2LYzuG332tjD4DV+2PQx+Yz5/exj9N+KcO8LI38C/Mwz+pODXwuA31gvuCoPfmG/fHQa/4ZvvCYPfeH7xjiD4+YZ+dgC+nf0XGr753iD4xQb+fWHwG/75nUHwSw38+8PgN/z/u8LgN/z/u8PgN/z/A2HwG/OUB4Pgjzbizp1B8Mca9vNQGPzGPHpXGPyGfe4Og9+wz4fD4Dfs85Ew+I3xfU8Y/Mb4/p4w+I3x5dEw+I3x97Ew+I3x9/Ew+A3/szcMfsP/PBEEf7wx/j4ZBr+xDrYvDH7D/zwVBr/hf54Og9/wP+8Ng9/wP+8Lg9/wP8+EwW/4n/fX8aP5Yxf5Rrx/NN7nN7viOTxtf6RhLJGTvYd9zarMebYXX/fDfcN5QjnJsz3knyFZQzzbQ34iD+sHn+3FeQOKrFklj9twQOEzoPDJKnkc23SD9aQh1sOGWHsNsSzr+Jgh1h5DrMcNsS4yxNphiGWpe8s+NNWjWDsNsSxtwlL3lva1yxDLsm9PGWI9ZIhl6aOfNsTq1fFRYt6wsVVubFjhLUnyFgNvjKk4pek3yh3HqutXNHGZTtLSqLl/5eat189evHFT5ebIUyBOsgGb7/ea8lKUtyRBHaKovWJvT6BYDuBRtmHCxLIpBSut3GNjRp33OWRADGkrDoTX1X/nukr5YpJ6IP+FmkRoTkKbRIh+FofRTyFF+CjPYkU/bMPcdqmo2ZH7AQvpF0MdkR6vpTze+8v632zU2o9kY3dKyUsr90S/sex/SnXDtmE7DdMOpXxSOxX+mShkv2naqWYX2mA2GLW2s+XmwyTtqvm2QSVPsGQzMNop0i+BOiI9Xkt5vPcv9b/ZqNWm2U4HlfrgPbTT79avBx31WVf/nesqjY9r4xT3A9ST5cajpP1A+GeikHbX7AdaO2n+RHSXUWTNKnm86JNR+GQUPlkljwPRbrD2GmI9ZIi12xBrqkex9hhiPW6IdZEh1g5DrEcNsSztvhf15RsHO8WKk6Wt7jPEesQQy9JWLeu40xCrV/v2M4ZY9xpinV/H4jhT8KOoGSvxeL+u/jvXVXpu7ob8pB54D/lnSFZbeZqxkqZXLaYV/QyF0U9DniFFniFFP9KWS5U8wZK1FpwzIP0Q1BHp8VrK4z15kzFLmHHiOcNSpT54D+cMsgDCcangxWkh2gH5idx4D/lnopD9Jue1C63/D0at7Wz5YleSdkV5pS2HlTzBWlb/jXaK9EuhjkiP11Ie711Adoo2zXY6rNQH76GdvpzsFNuG7TRIO+Srie1U+GeikP2maaeaXQwpehyMWtvZUD+5JO2K8kpbLlPyBGuk/hvtFOmHoY5Ij9dSHu+9nuwUbZpfOlqm1AfvoZ2+po476KjPuvrvXFdptKS1pR3+eH5YqSf3M9S1nV0XE/cz4Z+JWu0iRD8bIXlcdiC6yyqyZpU8tpGswier8MkqeTyv6QZrtyHWDkOshwyxHjXE2mmItccQ6zFDLEub2GWI9aAh1pQRluafu5HrSSO54rTPEMuybz9jiGXpCy374+OGWJbteL4hlqVNWOp+yhDLso6WNrHXEKtX/YSlXAdDzDRlhHVoTDuw/fFhQyzLOr63R+WyjCcs68jPB3Bumar/HYxa+57hPLuSIn5SD7yH/DMkq608zXm2ptcRRa+iu+WKrFklj+fZyxU+yxU+WSWPx4xusHYbYu0wxLKs4x5DrMcNsfYZYlnq/hlDrEPt2BnW+YZYljaxyxBrryGWpf+aMsSy1L2lrVrqvlf9l6WtWtrXY4ZYlu1oaV9ThliW9vWkIdZOQyzLOvZqLGdZR8t4olfb0VL3lrHcew2xejXOsYwxpwyxDsUTB05fln7CUq4pI6z4mtdVu5HrKSO54mSpe8sYQMZa3u8m+HEKu4ZWSLzHltfQguzBarOGpu2tG4xa7dBQP/kk7YzySluuUPIEa2X9N+4JQ/rlUEekx2spj/deWVdKljDjtLk2V4YVSn3wnug33hN27qK5dcO2YTsN2Q7IT+TGe8g/E4XsNzmvXWhr6INRazsb6ieXpF1RXmnLlUqeYB1W/412ivQroI5Ij9dSHu9dQXaKNs12ulKpD95DO72U7BTbhu00TDsk3wsu/DNRyH7TtFPNLrRxajBqbWdD/eSStCvKK215mJInWKvqv9FOkX4l1BHp8VrK470K2SnaNNvpYUp98B7a6dvqP0Yid//s1E9r8RjrEMtxfwjS3vlKLml/EP6ZKGT/bPaHlQn1Kvo5LIh+ytUk9oPySluuUvIE6/D6b+wPSH8Y1BHp8VrK470t1B+w73B/WKXUB+9hf7iB/Da2DdtpkHbI5apJ7VT4Z6KQfrJpp5pdaOPfYNTazobyVJK0K8orbXm4kidYR9R/o50i/SqoI9LjtZTHe+8gO0Wb5nd4Dlfqg/fQTu+o/xh01Gdd/Xeuq1TJa21ph1+YHFR0bYc/MzGotJch/pjgHxkEf6Kh/6OC4I829HN0mPZt4K8Ogl8sCv6aIPiVhvzHBMEvNfDXhrHPRv86Ngj+ZMM+jwujn0b7Hh8Evzoq+CeE0U9D/pMA33KuLfinBMHPFUUfJ0fNlFbqJPxlrD0R6FOOv4LFecIrQ1ih4hqtbig/z2tOBnlQBy6skzvEGlTyQrTpSZ56I/9hj6xcjzjdW7PRSZx2GWI9YIj1pBGWFrt1I9d9NTusC4ywtPixG6zDDbHSRlhx4o8wdSPXEUZyabFpr2AdZYQVp1fW7OQ62kiu+Hq1IdYaQ6xjjLDixB8P6UautYZyPWEo17FGcsXXxxliWY0d8fXxhlgnGGHF6dyaHdbmHsV6VR0r7HpOaTLsek5xOux6Tqkcdj2nNB52Pac0K7G0jDHCA9sexwy7uL+U+B0l4Z8hWW3lac6/VpM8rB/pN6K7NYqsWSWP+9Aahc8ahU9WyeM9Zt1gPW2ItdMQ61FDrD2GWLsMsXYYYj1miLXbEGuqR7EsbfUiQywr3Wvjaq/YqmV/3GeI1av98SlDrClDrF7V/SOGWJZ+wnKstfTRlrq31Fev2pdlbGLZjpa6nzLE6tV2fMYIK77mOWY3cr3LSK44ndejWO80woqvef7dK7p/0BDLSq74mte6u8FKG2HFycom4vSAIdb9hliW9mUpl5Wt9qovjK+XGsplaauW7WjpV3tVX5a2ymurvdK3Lf3X+YZYOwyxHjbEslxTsIzJLecKlmuPU3UsWcc+CvJS9b9hnwHk5v0M4Kgw8nifARyl6FXb72koTzlJO6O80pbHKHmCJc+0+wEL6ddAHZEer6U83ttdb7gsYcaJ95Yfo9QH74l+473l707PrRu2DdtpmHZI/m1C4Z+JgvabvM8uVit61OxCymaVPI7pk7aX1va8N60brL2GWA8ZYu02xJrqUaw9hliPG2JdZIi1wxDrCUMsyz5k2Y5PG2LtNMTaZ4hl2bct7cuyD1n61YNB948ZYk0ZYokv1N4TMow/ctp7PIb4jXcC1np0gfx5L47ka38Fi/OEV4awjOuW99XNN3fDOJz3y2pYazvE0t79CtGmx3jqjfzDvus2Wgj7rtvoWNh33UpVsfnjQZ8p0t0JQdpyIvFZHsI/Q7KG6lMnkDysH54PnaTImlXyeO+e9q7SSQqfrJLH43Y3WE8bYu00xHrUEGuPIdYuQ6wdhlhPGGI9aYhlqftetdV9hli7DbEs7cvS5+w1xDoYdP+YIZZlHad6FMuyb19kiGWl+/ia9+X2iq32agxgiXVo3D40bof0q4fG7UPj9qFx+4U3bsdpyhCrV231KUOsKUMsS59jqftHDLEs+5DluN2rPrpX4wnLOlrGvpbtaKn7KUOsXm3HZ4ywUlHr/pxusI4xxLJaJ4+v1xphxYn3Hncj11JDud5lJFecHjTEesAIK77m51+HdO+vI7870Y1c59Xs5DrCUC5LfR1nJJelrcbJsg/1qt33ah1f6L7QUq44HRo7nv9jR5zebYQVX1vuebDSV3x9pKFc9xvJFSersTZOluOjpb56ceyI0/mGWDsMsR42xLJ8pmO5DmC5PmG5P2eqjiV7vU6AvFT9b9jz0J97fwv5ST3wHvLPkKzG8uR9ej1B0Wvgs79nU4SP8mjne0tbnqLkCdap9d/4fhvSnwx1RHq8lvJ475/7nvubJcw48fttpyj1wXui3/j9tr/rm1s3bBu20zDtUEj8fhufhR+o33jPwtf6v2YXUlZrLx73k7aXhrXHEGvKEOshQ6y9hlhPG2LtNsR6skfl2mWItcMQ6xlDrHsNsc43xLLU1+OGWJb9cZ8hlqXdTxliWbbjw4ZYlj7H0iYeM8Sy1P3OHpXrCUMsS5uwjE0sx23LduxV/2VpX5b9sVd9tCWWpX1dZIgluudvWAl+nMJ+Q61QShE/qQfeQ/4ZktVWnuZcT9Or9r0K0d2piqxZJY/3Spyq8DlV4ZNV8tg3d4O11xDrIUOs3YZYUz2KtccQ63FDrIsMsXYYYj1hiLXTEMuyP+4zxLK0L0t9PWqIZWlfln3I0q9a2oSlX+3Vvm3ZHy370NOGWJb98WCwr8cMsaYMsWSsHannYbyN55FgHvLxxfxYXuiGlXKp+t9Bki8VWcbYk4nP6xD+GUUnIWL+UxPqVXT3IkXWrJLHe1depPB5kcInq+Tx2NQN1tOGWDsNsR41xNpjiLXLEGuHIdYThlhPGmJZ6r5XbXWfIdZuQyxL+7L0OXsNsQ4G3T9miGVZx6kexbLs2xcZYlnpPr7m8zp6xVZ7NQawxOrVcdtS95YxgKWPtownetVWD43bB25M69W+fSgmP2RfnHcoLjxw9tWLcWGcpgyxetVWnzLEmjLEsvQ5lrp/xBDLsg9Zjh296qN7dUyzrKNl7GvZjpa6nzLE6tV2fMYIKxW17nHqRq53Gsp1jJFc8fVSQyzL50OW+jrSUK4HjeSK0wNGWPE1v9PfCzYRJ363uRd0b9m3rfujVR+Kr9caYcXJsj8eDPbF5w11I9d5NTu5jjCUy1JfxxnJZekL42Tpo3vV7nu1ji/0sdZSrjgdik2e/2NHnN5thGUZT8TJSl/xtWVMfr+RXHGyGmvjZDk+WuqrF8eOOJ1viLXDEOthQyzL51aW60yW61+W+wun6liyV3Up5KXqf2WfL/q6mM+6+u9cVymf+Lwh4Z+JWscqO3ma+3wPi1r1ulTRq+hulSJrVsnjufEqhc8qhU9WyeNnvt1g7TXEesgQa7ch1lSPYu0xxHrcEOsiQ6wdhlhPGGJZ9iHLdnzaEGunIdY+QyzLvm1pX5ZyWbajpVyWfsLSJizb8TFDrClDLPGrEjukIU9insBx10SK+EVRsrgrHUQef9yVVvTaSdwVp1fUmnS91HfeY4hlKZdVPBhfL45ssKzreDD5ml7Tl+WY8T5DLMvYslfjG8s4dZchlmUdnzHEutcQS9bheHyP07r632eHw+LEWLEwMVYolCu56fLYeHWyOJ4rzowWJ2dn8rniaGGiPD5dzOUqxcpsKVcemxwtV6YnR4vVmenJ8cGo1QfbjdWjk4J/eBD8fF7wjwiDXxD8I8PgFwX/mDD4JcFfGwZ/VPCPDYM/FvbsgHzD/l8UBn9C8E8Lg9/oX6eHwZ8W/DPC4JcF/8ww+BXBPysMflXwzw6CX8gJ/jlh8Bv+MxcGv+E/82HwG/6zEAa/4T+LYfAb/rMUBr/hP0fD4Df851gY/Ib/HA+D3/CfE2HwG/5zMgx+w3++OAx+w3++JAx+w3++NAh+seE/fywMfsN//ngY/Ib/fFkY/Ib/XBcGv+F/Xh4Gv+F/fiIMfsM/nBsGv+EfpsLgzwj+eWHwZwX//DD4Df92QRj8hn97RRj8hn97ZRD8UsP/XBgGv+F/LgqD3/A/rwqD34jfXh0GvxG/XRwGv+E/XxMGv+E/LwmD34jfLg2D3/DPrw2D3/DPl4XBb/jn14XBb/jn14fBb/jny8PgN/zzFWHwG/75DUHwRxvx55Vh8Bv+/41h8Bv+/01h8Bv+/81h8Bv+/y1h8Bv+/61h8Bv+/21h8Bv+/+1h8Bv+fzpqpiZ2sTLz7KOK0emxiZl8dXqsmpspjU8Up6vj4+Xp8mSpMj6aK+dnx/KzhXx1YmJ6dHR6dnQyn69WJkerEw3ZZ1TsblLzucJsCL3kqw2/UAb8lJn8Ew38SpB2beJXg+in3PDLV1m3bT6XG3gWY0t9o4Gcj3w11KOf2mR9/bd8czNOW2pNmqshH+m/mHnub8xvW51fkn08fSF0+uyzghTxiyJ9H4/wX6h9PH0kD+uH9/H0K7JmKS9O/Fy3X+HTr/DRsM43xNphiPWEIdZuQ6zHDbF2GWLtMcSyrONFhli9al87DbGeNMTaZ4hlaV+W+nrUEMvSviz70F5DLEubsPSrU3Wswah1LLQbm8cKMtZibC1J8jA2TlFeGegvqTXpOKXpN9ZpybP/HlzRxGU6lgfjplnAd8UMcRI9DkC+ZYwj+INh8Iui+yXRXJ1ynQYdupJ87a9gcZ7wykSteg8RH2p1Q/m5vywBeVAHLqwlHWINKnkh2nTAU2/kP+yRVasHz280f6TF30I/6JEL6UcU3lJWdJiBPEMdFnw6xL4o/JeCnOXKzOarXrURp56N8qgH0duRRPeGWlMPbINLHFgR/T6S7qUBD1PYOeOBHQekTp2OA6jbWcqbr9+LE/sG1nmc4rb+Y1pbSCt1YhtyrS2kIR/pv7W4ye+b9esh4LnUw3OY5Eb6OL2hNpd+GdQtrdAsJRmF/q/qcsXt91S9/TTdiTyDVP6FZMtSp05tGduRZRNMsR1uW1e7/DO0y/tWNGVmfsOeesjvaYWfyJ4l2jhJGy+H+4ZrXIm/BSb8MySr8TjUiGGWkzysH/EtsQ6H6tcbNk6Xz52+4ebNGyqLSJUjcI3wWYITGqTFlAWRIgcdN3ucrqq1luMkqhyJWrt1lnghflq5x643q8gmZi66Oaw+1sZu64e0/MpmHKfBqFW3hqYwm9Q0hX8mCukOm6Y5QvK4dC/6CdRVZlJRa7dIKzxFXmnL5UqeYNW92xwXifTYX5Aer6U83hus21Y2au3eV9bmyqB1fbwn+t0/vNZxR5T6LKO6ae02ouBmlfKsQ+zHm2pz8/qVuknegCdviSdvUKmX5GWg3BYqN6RgxjK8fUkTz6UbtCsJXzTf5PKtLqxLCQvLLyesFW2wqoSF5VcQ1so2WGXCwvIrCeuwNljbCAvL89Fmq9pg3UZYWH4VYR3eBms7YWF5PvrziDZYdxAWlufjOo9sg3UnYWF5PkLsqDZYNcLC8kcR1tFtsO4iLCx/NGGtboN1N2Fh+dWEtaYN1j2EheX5c7XHtMG6hrCwvJQdVrA4DgjzylzyOED4Z0jWUHHA2qhVr6gffgx7rCJrVsljv3WswudYhY+GtdIQ6zBDrFWGWIcbYh1hiHWkIdZRhlhHG2KtNsRiv9VuvF5fe+6vb7yWcmi7SJcGGm2MRgxXPIBzNrx/TIL64D3WzTEOfi75UDcy3/TFHyNUTpM524aPT2ah02LmW2pz83CJneNbXA7mOByXypdT3qBSL46ZsV05Zka9YczcT/WZrd8PuxyXy6H9uXTF6xLa3yhKtlyrLbmH5rNogfhwfZYZ8kEsWfY8cEt8uUqSeiD/0Et8oouVHl2EOZqrlHi5k4/mWhlIF2KL7eZt/EhRm5tpYwkuj15V2fTsQ7qf2Pq66asWAym6VRZnmOiW0+8VDrHWEd1h9FvCP5YDsTCxHL7lV42/5kbkul+5HydtWsvLsFqz4T3fMuzhHj4ru+SzUuET9uSX5s6No8LgN57ya0sJWCfhP6zoqRPXjrwyUWsbhXADWt187YxTjCRLLkd2iBX2NJ9mmx7hqTfyH/bIqtUDnxajnxuox4ZxWLdryVxszVeE3T1WHEtqj8J/oXaaJ93pooXqUjZLeXHiL0Vou04GFD4a1l5DrKcMsR43xNpliLXDEMuyjpbtaFnHhwyxLOv4mCHWE4ZYjxpi7TbE2meItccQy9ImLPujZR+ytAlLfV1kiDVliGWp+4cNsSx1/6QhlqW+LH3hTkMsS331qi+01JelzzkYYiZLm7Act610H1/zaem9YveWun/EEMvS7i3raOknLGMAS309Y4h1PmFZvMGirUsdLG+wjBKdxRsso3QvHelvsMTYf0zbc/ntlziFXY8tFlLEj+sYEf8MyWrc/o01K217mLbuKbo7WpE1q+QdB9eYh3yOVvhklTwet7vBeswQ6wlDrEcNsXYbYu0zxNpjiGVpE48bYu0wxLK0CUt9XWSIZamvhw2xLPX1lCGWpa3uMsQ6GNrxSUMsS31ZjkM7DbEs9dWr45Clviz9vaV9Wfocy/5oaROWMZOV7uNrXoPpFbu31P0jhliWdm9ZR0s/0avx1zOGWLIGo71KxK8waHPYozx8sPxRCbC0+bDQa68e+dZ6tFePwn6lq7nWo7WH9vrSfNZ6RG95ouO1HvRtqx1YEf3O0z3XWg/vW9paX8gK+5U4fas571fEPaO8L7LTV22x/IiHz8ou+axU+ITVZeenaGQpD0+85VccKoCFp6BwStNvrG/cLz7QwQkb2B6zDsx+hTZFeUL77sGmHJ+qyxF23+HCtYm86py0TaS+sS4+02Wb8P5XlFt7XTrJa9zaa/hZpfxyD58TuuRzgsJnWCmXcvwVPnyP+Wgy+9bb58sHsaQPh12779z+Wc9o/7w3F0/Q5lP0qpCHz4E4aX1DdBH3je8l6BthnzctnA75lTfUIfZtTpoORRdJdTgSteqQ+/aIUg+t3yPGfPq9JkOvjRMrKQ/b+DDKwzZeRXnYxvy86irIS1Eenso+QHnrIY9PQrwG8jKUdy3kYVtzajeenbSyict0EfFEu0kynmlHqAhu2FfKisUkfh/5Z0hWW3maz0G1V4S1kztFd6sUWbOUF6f7a006zksr9xZ5sPYYYk0ZYj1kiLXXEOtpQ6zdhlhP9qhcuwyxdhhiPWOIda8h1vmGWJb6etwQy7I/7jPEsrT7KUMsy3Z82BDLsh0t/Zelvp4wxNppiGWpL8s+ZBlPWOrrUUOsQ371wPlVK93H1/wctFfs3lL3jxhiWdq9ZR0t/cRFhliW+rKMV+8zxJJ4VcrhHB+fWQY+x6Dx1c+jw+A3zknwPctF/jynl3ztr2BxHu/bXhWmbt592z47wLXxJEeEHtUh1oE8zwR1zeeZaLJq9TjMUCdJvoCirS112ra+I1sD97HGnoLDPHpC/t28P1IguktrTT1w2x3pwIrod4HuufYUjEStbTrokFP48j22FSzf7+GT6ZJPJiGfbJd8sgn5rOySz8qEfA61z1w+B7J9xA/jmUXy3DZ+5jKT0Xnikfp4VhPvmRD6vfA13ErGXcc01R/9hBxFGPYLXJ0/J2NdlpX6pBQs7RmT1KnTL8XgO3ooG2K6vhQzAPlIf1OmKcvgah0zBZj4riJ/RUj67EDUrDfSsAxCvwVkkK8IMWafo15LHJgPgC1uzeiYkYKp1StD9WIZBkkGob8d6rUUzlpHGvmNdnJrba5sQwqvyHGPfdqQI8/Ht13Z+Bq/IsR5bCusLyzv0inbitDf67GVAUUGrC+3K8vANBmHDO9SZMBjK2c33rC1/lWfiBJ/nKyffnNTchMMKDiuJGqIyzyQ0XGQThKbHw7FSxQeGYeMWDZWjzRvubKhsqniUNAiAut3MFsU6Sns1z7DjBva/gr0vZy0MUXqG5cbWd3EZTpJ+E72obhqfnEVY2nxUpxma818pP8Q+JG1q3XMRQ7Mam0uvTamaXuThF6bM/pibrRHnqdrvFGX7HdXdShru/WGQZJVm4smlfXSBZa1v0NZMwpvHHueda7rt1RuunjjpsYp2pEiRkTXPO4wDY8XSxyiLiW6EfrNxyqze19Bv4cU+bTEMmuypKP2Sbqo6Orz0EWPd3TRKNK7qJg9T7+wLE6/xCRuUuiE581UH6RHnkK/CfhoIc5NVG+h/4oS4mQVmUSeQSpvO+yOj4oON0etSfK2RHPrjnm3AP1rak06TtrQKnWKdXF7B9M1bEeWTTBxyMC2dbXLV6Fd+MOeyO/myF0P+X2Ywo91Kflxkja+Be7btfHodIr4Sd3wHvLPRK26DbHMfwvJw/rR3LDnw56b4RrhryQ4oUFaTFeCSJGDTmv2VUo5TqLKfpL572FW/XVyW9j1+XvEKENaucfRVp8iv8ZnoEs+Awn5PJ/rwzut47SpNjdvvVJX3mkdJ/5Y47WQxx+A3BC11kvyrvNgXu/B3OjJu8GTd6OSF8t01dKmjDy8aF2dPyqJbefq1y6sSwkLy99CWLe2waoSFpa/lbC2tsEqExaW30pY29pg8Uclsfw2wrqtDRZ/VBLL30ZY29tg8Uclsfx2wrq9DdYdhIXlbyesO9pg8UclsfwdhHVnGyz+qCSWv5Owam2w+KOSWL5GWHe1wbqbsLD8XYR1dxss/qgklr+bsO5pg8UflcTy9xDWO9pg8YfesPw7CGtHG6yrCAvL7yCsez1Y8TW/EY3l7yWs+9pgHUFYWF7KDitYqfpfCSffCfftwrd84rdchH+GZLWVpxlOvjNq1Svqh99yuV+RNavk4ViEecjnfoWPhrXZEOsWQ6xbDbG2GmJtM8S6zRBruyHW7YZYdxhi3WmIVTPEussQ625DrHsMsd5hiLXDEIvHMl9cH1/zW8BaXC/l0J/xcleayiA9YrjmDelInw/cl6A+eI91c5+Dn0s+1I2cSNPtPCW+XktY852nxNfHEtZ85ynx9amENd95Snz9IsKa7zwlvj6NsOY7T4mvTyesbuYp76jNxepmnnIzYc13nhJfnxHNxZrvPCW+PpOwsDz79rvbYJ1FWFi+k3lKfH02Yc13nhJfn0NY852nxNc5wupmnpInLN885Z1tsAqEheXfSVj3t8EqEhaWv5+w3tUGq0RYWP5dhPXuNlijhIXl301YD7TBGiMsLP8AYT3YBmucsLD8g4S1sw3WBGFh+Z2E9ZAHK06X1eZiYfmHCGtXG6yLCQvL7yKs3ZG/jpPRXCwsv5uwHm6D9WLCwvIPE9YjbbBeQlhY/hHC2tMG66WEheX3ENZ72mD9GGFh+fcQ1qNtsH6csLD8o4T1WBuslxEWln+MsB73YMVpQ20uFpZ/nLD2tsF6LWFh+b2E9UTkr+O6aC4Wln+CsJ5sg/VywsLyTxLWPg9WnCq1uVhYfh9hPdVGrp8gubD8U4T1dBuscwkLyz9NWO9tgzVFWFj+vYT1vjZY5xEWln8fYT3TBut8wsLyzxDW+9tgXUBYWP79hPWBNlivICws/wHC+qAHK06ym2tEKf9BwvpQG7leSXJh+Q8R1ofbYF1IWFj+w4T1kTZYFxEWlv8IYX20DdarCAvLf5SwPtYG69WEheU/Rlgfb4N1MWFh+Y8T1k+2wXoNYWH5nySsn2qDdQlhYfmfIqxPtMG6lLCw/CcI65NtsF5LWFj+k4T1qTZYlxEWlv8UYX26DdbrCAvLf5qwfroN1usJC8v/NGF9pg3W5YSF5T9DWJ9tg3UFYWH5zxLW59pgvYGwsPznCOvzbbCuJCws/3nC+pk2WG8kLCz/M4T1hTZYbyIsLP8FwvpiG6w3ExaWl7LDClaq/newfv0luG/3XKmUTxE/qQfeQ/4ZktVWnuZzri9FrXpF/fBzri8rsmaVPF5z/LLC58sKHw3rVkOsrYZY2wyxbjPE2m6Idbsh1h2GWHcaYtUMse4yxLrbEOseQ6x3GGLtMMS61xDrnYZY9xtivcsQ692GWA8YYj1oiLXTEOshQ6xdhli7DbEeNsR6xBBrjyHWewyxHjXEeswQ63FDrL2GWE8YYj1piLXPEOspQ6ynDbHea4j1PkOsZwyx3m+I9QFDrA8aYn3IEOvDhlgfMcT6qCHWxwyxPm6I9ZOGWD9liPUJQ6xPGmJ9yhDr04ZYP22I9RlDrM8aYn3OEOvzhlg/Y4jFa47t9sm9pX7t2ycn5XDdiV/NTFMZpEcM1z68dKTvr/tigvrgPdbNFx38XPKhbt5av7bY9/c2wupm39/bCQvLd7rvbxVhafv+RpRyvE90i4dPnHz7RLd4+HyxSz5fVPho7yneUpubtz5qrav2RRh+9xG/CLOZ8jYo9eL3FLGP8HuKaIP8niLaFL+niDbC7ylim+N7ivI+rujomvr9Qaqb9N119d+5LpP2dUXWI7ZbyvE3ilqfTcSJ7QO/CpRaID6LFogP12ezIR/EkmMOtP7Lx3d02n+x/BYHlhxtECf80uM1kI/02+u2vP/LS3TUhrZHfT3ce4OnrlJW+giPb+vqv3PdpbzgbwuDX/SNj1gn9imou07sC3llCMtad766ofxshzheJ4kjtnaINajkhWjTWz311sYQTVatHq6+iXx8pyBv88iF9L74SXSIMYyhDgs+HWox2HxOQRa9rSY6/rKyFosyVkS/V9O9dOQ/BRnbdNAhp/Bt58exPMdhW0gu7a/w4XvMR5NZ+OB5Fngq7RN0NoPYHR6Zg+9RHQ75SH/piibmU3VM7T0vV19JAT88C4OPWhJ+rqOWrnHI934Y9/hEy2uUOh/ukVkw8bwRlFnO/WAZPkJxZKAxUo0jhdcIycvtw3XR2oTtbpOiB5du44RxCsYxSP+JDuMUtG+OU1AmKavN+fk0Ro2Pb5zMKHy6jQ80PprMPHeLE/bzL1A/F3tAm8eyV9Wa+Uj/MujnX/b0c94/xDEN+z7u58LP1c/ZboT+Fzz9XIuZr6q5ZRZM7OcoM/dzof9l6ueB4hq1nwsvbRzjft7pOKb5cY3PUJd8hhQ+ocfLIeJzqyEfxOJzmFz99feov0q7av2Vx22kz0B//QPqr2jvvvbkseNWhS/3mShKtkbpezeZfVScfGOH0H/LM3b45gBx8s1xfWvCSIc0vnXTtIcH2hPel5gVx7RriHYr0d7qoXXN5+Lrmfp12Dn3+Iz0BVz7lSR52xWZJQ/fyb621qTjlKbfWKfYVk5NcKKzNjfc7sBkncaJT3+XOi9ScLcRLvoA1pect8b9/0f1vhD3/39bquOxncTphjpe2Hnl+Cy3LyZuX9YPJ619Re64fS/voH2xDW+nPPTZfMYfjpGCEet+cZ1pr/al+fSXy7vsL5o++VkE6lMwUJ/9hHH6cJNmcHiuTELD40WcpP9InxX99Snl48Sxn9AP13nG+nn/ap2/r79Fke4XUA981uj2SJdFq7PQnkr2iH3Mzh5LeWnHO0hm5H1nIN5J4jXkP6zII3JnlLy+LmQdzY+PF8ZK5dHqzNjE6GglRfgiK9/jtcOaQj+i0Iuu74LydroulqWrpWtN/BroNU59kHcn5fVDnsgY96EPrZ4rfy2Q/En0j/yzCj2fap+0LbMKH56rdYN16zyxVkRz+4A2FmJsw2Mhxi94Huz5Dr+cxNeJb2O/j/VkP3gu+Toc/wxtqKTFo+zr7gjEO6mvE/7DkbttM0peN76uPFrKl6qTozPlarFSHq+motYxIa3cY1+n2e0yhT6wr8hpvo79WR/k3UF56OtERs3XhRkXi7kk+kf+WYWefV3StswqfNjXdYN16zyxxNdhHMRxKvo6jlO3KfVBX8fzsleSTwrzSQd9jZB9KsobJ5xDbwM9sX4ZB+9h3IxleM1G6C+FuP3iYV0+qcOVinza3iWs12XDbrptCl08VZY46qrKpsuunr6pUr6sMntTZVM60sXjKnL1eToVEV2c+MtlG+k3L9+sJxwZgpN+uUz+IpbWdIjNQ+8VMOX5NLmwa4jXuvrfXJdJmzryUBvm8Voh8bRC+GeiVpMLsa1DW9pE/fDwGOaxRCEXf7iJHxnE6bpaq25YDrEX7dEd6o/7QpLHlOsVPtrnF1KOv8KH7zEfTWb57XO1Ltd4C7jGq4eb9OxrkmzZSvIoHu8hfZny8BFdyoPPyy3Xg79YSktIGFJJPWQrQx/kWfbnWI7PghxstxiuufqZ9rkQofdtJYuTPNLwbS3SbAttSWxEa2dfnwrx6F/jM9wln2GFT+i+O0x8XI/q7nH0SdejurMhH+l/uLyJeS+1p8t37a9XrZm3QH2m0Gmf0fyUr8+0e3VDdKg9Yr2+NjdPs3fWa5xmanNlWK/IoI2nWaW80CWJU1A+uzbKJ45ThP9CxSnXJNSr6GdLGP3kfLa5RdEPbw3gtkPfjX1fm/5oj/twnODp4vvqnd23pcDXd7RH8Pu3/9G0KHQcxH0LX586B7DKtblyhdr2gf6S28PQ9ktS722eejP/+B8+BtK22zI9z3kYn1+RkvL44XfNttgePwcx6SeHdcwo8sekrJOBSB8v+bG30H9GiSO1NsbHhp+jcRV1yVuNtip62L+VLsF4rz3G5/H+F2C8/zLJpfkfLa7iGL7TuErjw1hJtwgK/S9Cu/AHl9t9Fi3J1njUrcij6ca1DUP6RpzKtea9Wx280S6xb0hZtstfg/o/RV8Pxf7n2g7keqUxHfntK0X/eOkuTrfXWvlrj0Xif+vqv3NdJvZlfcBju6IPfnzzdepvsnybVuqq6fV2hS8uAYtO+on+69COXyU7FtmGotZ+prUJb0vnvrC1Njdf6L8BfvaPaKx2ben/82GddybS7dDVT1BW7Ic7anPzhf5boK+vOeYGKI8mq9ZHq7XmvU77aJVkFfpve/qoz5a0mI638mh9lOVO0f2kdiH0/wB28V1PDId28QPSNW8pjJPPP3DssK7+O9dl4rbEfqr5S27Lf6d6Sf9NK3XV2nS7whcf4bJ/2E58Nf+Ar/SJHBXg67LjfkXmOHGfE/rve/rcNUqdNTvQxljfKx34yrRGz3UR+h8lXPeTeCDsGkZeXffDvtNfm1tv7TPBWmzFeoocepLYJRu198m4jUubL1VqzXykX1F/Pr5/y9yyuXX1rUkEehw5mSJ+ohu8h/wXak2i07bdosgv6z8avdbHtDWPeErAa7hZwBK++Gr4NrqnrVPwepRrbnP4srlya2tgaHcyl2OecZqp6TwRF3lqa9fsJzv9VLf2uDrsutL4tLb9SRJvz0U707bn8ivJuD0B5/Wc+Fkz285vd7B1F9tD5F6oZwmW61La3DpLMnf6qpLWN0OvWWWJz1aFT+BjEhL7ceGfiVp9QAg/7otlUK++MfpWD712pJB23AH6cZEJbQVfS4gIW+5p/pBj1079IZbfRHlavNju2ddLlunyuNaM7qg185H+EVgL+3EaD7T1Lt9zzvnqxvecCPks75LPcoWPNqfv1mdoMms+kOvTqQ/E8gvlA5cTH5d9XkL2Od/XnjeBfV7msU+f3fhesWTb7bQNrknIZ6FeAX6h1eeF3EfWG/WRGegjG6iPaM9Afa/YzlfPSfm8ENpzqyEfbT7Yzm5uI7vBdZ8kdiP0F4Ld3JHAbjTduI5nQr4LZW8+LF9sqT0b88WuWqyrza94zikYcQr7SkzyPSjCP0Oy2srTnCdon/G+TdHd0qg5R56u3JwvTExVZm/aesMmbgwBzEZzlbydAIU+ot9cLhaqj2i2KDziJAbOhsSTW56IMH4SmdrRtsvXOuFtjnpGUbJOiOVdndB1hgS/Oyv0j9QdUdIzJNB4OjlDwuVA0kodMpHuSPChjTaAo0xanYX+CU+dt7ap86VUZ9cZbfib6bQHNkuiVhtADE3H+M7LfOwJyy/U4L6C+LgG3Q/ToNvuXJgq5CP9OAy6H6NBN+m5MHz2S6d61viE1jOf/7XVU59Oz7bUzpL0tVMVaFwPBPsUzDjxyzhC/8V6W4Y9t0N/r6xxBkLUaof4ssCXjWz4NLDhr5ANa5voNRvmdurUhpPycfWVVDT/vrJQ9fFhaf0hRTIj/fM6oM1Xckl8EPJ/3ge0f56aq+SkAS2X8wW0TMvOUAyp24BWk8lF22lAiytWHNB2+iRMezoY9sl8oWU3PO5kws7EK263QB20QM31VDDlwGdHiS8Ua7rjHcpC/ycQzL5rzXPXWlutdMgXRcnaCssv1JtJK4lPiKcGceI3C9rZxtkklyuI/VsKALRDhzEAwEkc0n8j28T8LgUASXdQJ1mxZ1uMomRPenz9IKlds476FMw4uQ4d7q+/xR72rejR3IF7Gj2aeFDmwwK0nZ4ZJa+rg57Gq/nc2Nh4sVqYnqiMjvHYJbLyvSRPqo9W6MOu6JXUg54w8I9TH+Rto7x+yMMn3nz4SZiAqVROon/kn1XoXW+waFhxWhQASw4s8e0y5qfxcfJ9JETol9R9RtLDt7co9fEdCp2m3+zL2FfFaV39b7sWrrZJEeltsSIL78puLDaBXh5cM7cu2k4z8R1pD49IuZeK3LpjHtqC4Otqc/O2JpBNW7BDDNeuvBhDm3QfRXXpdDHlKEWekE++kGe7+GXtSLMM9k/Xk697as18pP9ViF+Or2Nqb3y7JvWpSI8d2Kfg7m9tQZj9gNCfAvbe7qMJWE+WETGTfjRB6M+g+CXQjjZ1QUt4LdRpJIzVFzXfSkD/+PraXF0J/X/UdRW3c36kM8zLHZhvBcxSh5hXODBfA5jjHrvH/st9SutnrGMsz2/6hnnrvvmBqg1h8BsfM7pW0QXWSfj7dvsn8ZnIa6F242t187UzfniQ+5KGdW2HWINKXog29Z2MgPyHPbJq9eC4QuOTVnQi9Nd55EJ66cNo+1JWdIgfdDTUYcHX3tcBT+E/nw9Uid6OIDr+QBXqfoMDK6LfR9C9dKR/oGr/KVD1uEEbl5Y6ZBYZ2o1LWJ7tP4zPHJ/Q3h6RpL09gjJyStNvlDtu7/UrmrhMhxhsx66P/mo+14WhrX226/dxwsX7w+rXN2/aeFPlkpvWb5neVDlvS+X6TYr9LqH6sd1tpN8biJZPGpI8fjh7Lf2+gX7fqMjDiXWCaVihc6V2/eNkuJ5P/8DyvnXFNV3yWaPw8WGdrGD5/Pcahf5g8d8nEp3M7brx3yfSPZf/Zllw/oSH6vKat9DXaD4UJiaZLA5HrT5N6iK8rwvEO0X8okiPS4X/sCKPyJ1R8rpZzy1MFPP5iWcfBVdypdx0OefrY3iP++T1Cv0pCr3o+oYoiK7Vw6yvB73GqQ/yrqO8fsgTGbX13DB+YzKR/pF/VqHn9ZKkbalhXTpPLFnPRd8rfTtsX+88/uK3iX2nKOFzC1x7jihpcZvUN7anDySI23wnH4Sdly+cDtFWOWk6lPp2qkO0NdZhmL68cDrEPspJ06HUN9bhZzrQIdoar2Gjb+KPOPeKflOUh8+hLqk16Ti10+GDHehQWwdPR616Wq9g8TxkWpFH6nljNFd+bL848XMtLH8jYW1qg8WbpbF8kjfaEKtKWL79C7e2wSoTlu9Nma1tsLYRlu8Enm1tsG4jLN/pZ7e1wdpOWK7T1uJ/29tg3UFYWJ5PU7u9DdadhIXlbyesO9pg1QgLy99BWHe2wbqLsLQPhGhrHRjjDCv3pK+H/dhJvuOPgGnzhRBr3JretbhQdFdTZM0qeThuYx7yqSl8NKxrDLFuMcS63hDrRkOsTYZYWwyxbjXE2mqItc0Q6zZDrO2GWLcbYt1hiLXBEEvWkbV10OuIT6froFg+yTqo5kOXRs1nBvvXzc+dvuHmzRsqESWMW4UH/r7BwT+rlI88WFjGVxffqcni512nJvOeDqH/B9jTsZTWaMI81x0f017qkiR5PD5gHsatMu/Q5itoH5y0OYnUN9bFSIITsbRnC2gTq6kONxB/vse2juWFTuOzpks+axQ+PqzVCpbQa3MK37MFbR9Z4NPXG88WtDmeNi+Zz7MF0dtqouNnC9pcj7Ei+r2a7rV7tiCyuF4A5mcLQn943bYHFVnt2mOi6HtvIew+9YnEzxb4I/Pa/s6MktfNs4XqRCE3W6xWcqPFmZnZXNnXxzo9SeJ4hT7snroJ9dkCroPFqQ/ybqW8fsjDUy752UIYvzGRS6J/5J9V6HncTtqWlljybAF9r/TtsH29d58t4J6ETtbFcbzkQwhQhyfANeaJPHyP2/0ERdZhpVzK8Vf48D3mo8msvb+G+59PzTbLoF3h/mcse3etmY/0n4f9z6d79mzwHJ1tFW0jTtxP8EtpScZDoT+nLpO2/1l7t+Lumltm4dEH933vbwl9icbkMOOivv9ZeC3UaYth6zg+qb0/IEnzN7yHFtcYeO8BrhlcT3m4BsDrejynxzxcE72B8mqQdwvl3QV5/E7q3ZCHNspJ85l4KMtJK5u4TBcRT+10eJ4Ton61fUgnwTXmiax8j+0Ny29wlGM/EnjPUz5wn27sK9be2cI6cayrrdMnGV+Q10Kto2t18+3VwHUGXkfWsG7pEGtQyQvRptd76q35BE1WrR68Lqj1s5MUnQj9rR65kF47bGih1wM0HVqtB4jeziA63iuONniLAyui32fQPdd6gOZHr3HIKXzb+dGk75hgvFjO6jyTvu8v9PsgXrwKrnlNDrGujubmXQ15m+vXgfdXlbT1joh0txl48xxoi1KfpGM27qG6fZ57qFA2xMT2uxloXGvPmyGeHlytY6YifQ7BMb3YRNJ3GoV+qyemF5o+R72udWA+BLa43WHrkYKp1es6qhfLsIFkEPoa1GspLBiy/0UbitOttbmyXa/wihz3eMy53pHn49uubHx9E1xzHtsK6yv+J8+nXDplWxH6+z22or3L4dtTyjIwzXUOGR5UZIjHo6F6/uzGG7Y6Hmf1wTW7Z60puQmuUXBcSdQQV++hrI4jv33mp21/xbLXOWTEsnjGVbmyobLJ9bxvEYGtdzBbFOkp7HtRY7PaHnxJ2j5CHjewL19NeRshD30vJ21Mwfepkj4327L4ueuFikmSxBpxmq0185H+/dDv+CumG0AODVP25Am9Fmf6DsJrN18T/qJLLe738db2NQr9rR3Kqj1rwBj6epLVd0hmO1kvXWBZN3Qoq7aPAX31s85o/ZbKTRdv3FTB7sFiRHQ9SPeYhre5XucQdSnR8TIyHzHC4wO/5rdRkU9LLLMmSzpqn/i84s9AFz3e0UWjyL+dQttmjKFlmaYW2iMUnzkmOZZD+1h8nPjYEKH/ssc1Jf3QnNBr22VxCZSXgLEb8LFP+JgPl3Tj1Ad5hlP5svYRR9RBfy15fTX9aFuAteMZs0SPutIetfAyKA5heFbuqWR/vo/TanXzbSHCc8DTCsY1tWY+0n/NY3/aNmftvFmh17Yy43I5LwmjfqWsZn/4SkWc+iDP0P4qmv2hDtj+fPXV9KNtE8ZHBvwRUXxksJ3y0F6Ep+b/8AOvctSR9hg35fgrsvI936PtK2tz+YT6uIk8ZmN/qYVy8bUcaSmhPure8vEb9x9cgrhDkYc/Vv4dWnaogX40v352NJf+ToVvDWjWE987iS9+BJmXnOOEy4HfJVlvB2xedvfVuR/O//5H8pNamMlHY/4LyL5rjbs8j4EYq/ERAK6j1lD/WE+0Tfa3Qv9/QM5H6nJqPg+Xz+PUB3mGtlrtdMzVxgTfmNtuTOBxFfsHT3+0qRTq3DX9GVDoEY9jUfk6Ey6/adPTbST7pg5lTxrD3gL14ON2fe2hyXEHYGn02H+RflDRCWNiX8A23u7AXAqYJ3WIWXVgjgAmxzPa+Kudq85+F+lxTBZ5tNepapSHsvO4eyfwZ9qriL/2+lek8I088vKY3U5e9rmSdwr47KPr14NR63gT4pGp1pYnKvVJ2pa3eOrPWDi+sr1qfehORV/HL9cx+zvEPAnsXcY9LVa6pdbkfQrx1nwI+iv2TbcocmEsoM1v+DGgyHam0l8P2BwgX8lp4yHqkcdDbZ7m+45GuzkozwGQfnNtbp7vWyHa8ljS8QaPGP1ygm+xCE/fekV8fTjRS73Rx6PNzEI+0r/U4+M1/WrbPny2j/NSPjYU2wrnXfvL15p5eMxCnPogL7S9+uI3TT/butAP26s239fslV8XtLLXD5O9aj5Ia0vuP0n7KetpwEHPMZDQX5IgrkIZfK8KJF1f0Ma4OyOdN/ZN1MlVtbn1EfrLe8mf5/J5rX+gXrl/+HQYp05jRF63qUEex2PYP+6gPG2tNonfjZOv70hZ/Ais74OtnfZXllGbL2u+Xuiv8vh6bez1+fp2fZpfAUDfIWUP3Fxdt2XUQRJf75vvdOPreS6sbQVu57vXe+zPtf6Csl7jqVu7ZyPsG5M+GzmQbb+Qz0ZccSnrCnWCWJpv0NZNON6ab7wZJxmjWCeueJPXJoX+3g7jTZ8dPq/jzXnYYa/Fm5oPwnXCSzw+iLe2aPbni88sfFBakQvHYu010Ditq//NdZl8z3QCf6d0NEX8RB94D/lnFD0aypP3tau2BhD2c065UuymtOdx19VadePyO+zD5VlanMqAw9vTtE/Nxf3pA7TWpMWBWFZ4cBz4MVg7+zBhaq+rJY1/8XXClySYO/ra3BevbAc+Gj2OTUj/Sc/8UPOVvrWnds9i+PN52vN55q3tN9DGUqH/XE/NDwv5A/3Mn8cs39wRbZCPItLGIuwX3Ae0mAv7qza/SDn+Ck++x8/uXa94Y13x2T3acrlO3wvP7lEetu9fJ99UA/1o6yhl0kO7Z/f8LOZO4qs9u8c9O+ibv+Z4DoB9ekuCOv85+Obfrl8n+XQn+hde09BidbQHXn8S+t9P6F9Erl6bsyf99nNSn+57vs5Ho7X7JjjP27TPJHN8iLixfXxhuL3825Wy3D8GHPS4bon03/aMo/jsTfPR5zgw/w7s/m/Jb2I7ynObmO5fl9vw/gfPnLQGvLWxgG3oLoW+BjSNZ+tR6xglZbne3Fb/Sn5BGwNZJ5lI97231+bKqj0nTUG+q1/dqdSRdTgQ+Z/99xP99z17R25zyOmSTzsGQ3uNEJ89fC2B/xWevk9DxontRIsxtONetLkzfzp24X1xodDps11ffTX9JJ3fa/bAx3pqvti3hqYdk6/Nd9AX31NvDH4mv7T+apq2L0fb566tubV8bhUwk6zj++ww6Vqlto6y3VNOW0dBXuvqf9t/mDbZZ2ul3y5WZHE9LzwC9CifrdXWFebK213yzQUGI93v2vAuJP4cuPDPKLoMseaTNE4LO1/JV3HNB+0X13xcR4bjMy32dzhPOJ5el9V8APq5syAf6U9d0cQ8yYEZRd09//+9pXNxrZ+B+Z5P8H5ALY717QcUGdrtfZyFfKQ/B3yDb2+xyBV2b0r1gD975+frNchLsl8KbcH1vs1A5J938Xrei6GNOD70Pf+/tUPZtc/Scz/nviP9XIvfbknAs5vn/4dDPtJPLWDccOj5fyv9fJ//o70kff7/hbrv1t7bSPL5E2290zdmoX0fAflIf7nH/nrl/UzRU2D7KxzoPQjSvknez/Q9+9WOrY7t74m6/YXU4/hErhHTShvisZOY+iAf6a+u22QG6iF/uzqyeHw6Xy1OV6dHp8vl0uw0HyMZJ2mz+DX42B5mVzR1Jnqy1lmcBL8/DH7jvQI8HyWt1En4iy3xsSPa3yjS5yzCK0NYxnXL++qG8vPzmj6SR65dWH0dYg068tbZ1LvRpmlPvZm/i17rA3J/wIOP9OLX0YYHSBeLw+ii4Gu3AeAp/OdzTJ78XkN0fGw+6rvfgRXR7zV0Lx3px+SxXxqOWustZQL7lEJSPyD8M1HQ/tDwA/0kj6vv4nEnGzZOl+snL7HL46ZDdSIcV5ubrjEs0j02Bz7BSUI9bQhlOVMKhqYC/kJgSuGvuZK0g28UNc2V3Uc7LLlOe2RxYaQIY9iDcajrHOo6SjrUdZJ1HetovDAxMTZZmMmVxsuz1XKp2C4at+Y/OzM2U6rMzI7lS2PFUq7cyWyAow2cdacV/fUT/Uc8T6AWeTDjxCctCf3HPTN5LSrS6pnEDaA8I1GrXfEMYqHsaXx6YmZydrI0XRrLzebGx+bTnlq9UffygVGhl8hyIPLPpvqJ/gvKKilj4qz5nlorJsuM7YMRO3+sQeh/FmR4FFbTWQ88JGI0bTgEzaaIXxTpQ6Lwz0RBh+g8t4fIw/rhJ2GBZjgzKcJHeRYr+pG2XKLkCZasBKGvQfrFUEekx2spj/e+WretLGHGSU5PSil5aeWe6DeW/ZcodMO2STn+Ci7f4xk86oZ9GPpPfHL4Ww7/gfrEsuI/uC/+BTw5/F16SqHZPvv1VNQ+TkB+Ln/F45XQ/yH4Cj5cmMcrrCfLiPz6FL5xYn8l9H9KK3GB+r36cRnhpY13qUjXRxQlW4XSxsdhhY/oayjyr7T4/IRvxUv63ICDXvD6if5vPGPZEiiTVuTiWEbo/84Tywwq9dL6tdzPKPSDSr1Golb/J2W1pxKi+8AnWM1qTyVQh/219vpZ3IV+xAayRI+60nzoYuLTbmrJT3G1VTT0uRi/jSj8uZ5afxhQ6unrD1r92Hb/q8PYDj/EtdghQ9LYrjFurmzKsNcT2+FYtmilX1b2Nzj3QfrBlU3M/vq1tI+2Cqr5wTTlYVuKjtAPDii4Wn9mm9D6CtJzrC22P+Cgx3gK6UegPdgmMlBGiy85ZhD6FYDJPnIoaq0XzmNYD0sV+qGoVQ8jUasPWBrpvLE+qGf+wJ7QH6nUR/O7+EQhTn2QZ+h31dN6Ua/sd306jBPrfFihR11K/bJEj/rX+s4Q5SHfJSRDu7kN+2Qt3kDfoS2vog5EzkGlvnZtN5tPET+pH95D/pmo1eZDzCWT2ojoZziMfnI+GxxW9CPyLAsiT67xkeWswltkrW/8n+NXkH4YdIj0eC3l8d4kfBwwvj8C5QQ/S3lx4nks5qWVe4sOEFZWwUK9SZvG/fhs0gWffK/9FVy+xzJie4rN+3zEfPkglsQ3Wn+K/62r/851lYoFqccypR7CG+3Kru+Mjif1dcI/EwXty3mfDaN+eK6bVWTNRq02/M5ak66dfSMfDWtfj2LtNsR6zBDrCUMsS33tMcR63BDrIkOsHYZYlnXca4hlKddDhliW/dGyHXcZYln2oSlDLMt2tLTVpw2xLO3rSUOs9xliWdp9r/ocyzo+Y4h1ryHW+YZYlvqyjE0s7atX40JLu+/VWG6nIdajhliWdt+rsVyv2v2UIdahMa0zrF6N5XrVF1rGcpa+0LIdLfVlaauW8dd9hli9Gn89bIhl2bct+5ClvqYMsSz7UK/q3tJ/Wa7L9era0JQhlmXs26sxZi+OHfE1P7OyGDu0Z72LgG5QkcPyea/grwiEL7pa7tEV8udnv5Kv/RUszhNeGcIyrlveVzffM2J8Ho46cGEt7xBrUMkL0aZZT72R/7BHVq0ew4Y66TfE4r1t2p4N7bmq0K9Q6DU7GVF4S1lp25WQZ9i2BV/boo8Q/vN5e1v0djnRVWtNPXDfWO7Aiuj35XQvDXiYRqJWW1vikFP48j22FSw/THLIb9nzgntgZZ+Itrcn/reu/jvXVRor+Hxr2HFmrJjUdwv/hfLdPh8WJ94bkcSHxeldtSZdN34nTu81xHrCEGu3IdZDhlj7DLEs67jLEGuHIZalTew0xLK0ifcYYh0MNvG4IdZeQ6xe7duWurfU18OGWJZ1fNQQy7IdLe3+IkMsS7t/xBDL0iaeMcSytIlD8dcLw0dbjrUPGmIdDL7wfEMsK58TX/Ncuxu5nqrZYVn2IUsfbTmm9Wpc2KtjWq/OrSx1b9mHLPVl6aMPjR3P/7EjTpZzK0tf+KQhlqW+Dq0pHDjdW9bxfYZYvTofstT9HkOsXl0vtIxzDvmJAxdPHPITB073veonksRfeE4gn8urPccXrBVtsC4lLCy/grBWtsGqEpa2n0HKHebgg2de4B6MwxTeGr5gaPs44n/r6r9zXaVCeViRK1X/K7xXwX27Z+ulxOeHCv+MovMQz/pXRa1thPrhZ/2HK7JmKS9OD9SadJyXVu4t8mDtNcTaZ4i12xBrhyHWI4ZYOw2xpgyxLPVlWUdLuS40xLK01ScNsSz7tqXuHzfEOuS/DvmvkHW01P1DhliWdv+UIZZl3+7V/mjpo3t1rLVsx12GWAfDOHQw1NFSLku/2ovjdnzN8/ZesS9Lfb3XEGuPIdaUIVavjmmH+uOBq2OvjtsHwzzN0kfz3q4Xot0/YYjVq2sdTxtihfDR/N5enNbV/+a6SsWSrEXjs41UNJdvmHX8XCVF/ERHeA/5Z6LW2Gih1vFRP4tIP4eHkaecxIZQXmnLI5Q8wTqy/hufMyH94VBHpMdrKY/3HqgzyiqY7CePUOqD90S/8fvQ99ZxO+gDhdlqvjhaGR/NjU2XRstjxUK5MJ4rl0ar+fxEvjBZmigWq7OlifJEoVgtjBdmh6PWduc+EKiNS0n7gPDPREH7ZN5nc6uUNtJsTsqyLcTp1lqTrhNbsLQrTa5Ntbn18Z3vHsYWijPztYXQ57trtuA73z2pLby71qTrtv12GmLtMcR61BBrtyHWLkOsHYZY+wyx9hpiWdbxIUMsyzo+Zoj1hCHWU4ZYlvZl2R8t7cvSF1rK9bghlqXdHww28YghlqV9TRliWdbRUvcPG2JZ2v2ThliH/MQLw09Y1vF9hliW8USv6v4ZQ6xDfagzrAcNsQ71oQOne8u5u+Uc+fw6Fq8hxWld/W+uu1QYVPgaYZcE+0h77MYZsUd1j13mG4J9tL3cVcFebY5dHJW1NPxmO37D+6i6AYlt1j/9PWddH7/dvAjykX7r4U3MNfXrYcCNACNOg4SXiizXHAu5FPGLIn0NVPhnSFZbeZproItIHtYPr4GmFVmzlBen+2tNOs5LK/d8WHsMsaYMsR4yxNpriPW0IdZuQ6wne1SuXYZYOwyxdvaoXPsMsSzt3lIuS90/aohl2Y6Wun/YEMuyjs8YYt1riHW+IZalvh43xOrVvm05dkzVseTdaIwf5XvxI1Fr7DRE/PogD/ElLh2g/HX137nuUl7wl4TBb3zzYLGiY6yT8Jc4sx/oU46/gsV5witDWNa689UN5Wf7WQzy8LcRNKzFHWINKnkh2nTAU2/kP+yRVatHH+mkT+GTUnQi95d45EL6EYW3lBUdDkKeoQ4LPh1iXxT+8/lehOjtWKKTcyYWRa02uNiBFdHvY+leGvAw8ZwbfeRw1OozhW/sH6V9joF8/tbEMcArrdzj/oLlj3FgaWsNcZqtNfOR/s76+kKMvXb1XMy1inw+2z1WoV8LNCKPphspO6zw7sSHolxZRYb0AvHpWyA+SxaIz+AC8RlYID7s34815HMs0PQTn+MM+RwHNEuJz/GGfI4HGo79ToA89Dcix4mKHDI+nQT3DcenxPt3hX+GZDWWpxFrnUTysH54bDlZkTWr5OHeV8xDPicrfDSstCGW2MZI1GorJxKfExQ+J3j4nKjwEbs6leqzrv4711UqTEi7vChqTZJ3Gtx7f60pB6c0/Ua5Y5++b00Tl+mYJ+r1NMrDPnY65WFbnUF5p0DemfXrkahVv8gb86SOfI/bEcuf6uFzUpd8TlL4DCvluvWVmm64nSz4oN5OIj4nGfJBvZ1MfE425IO2eArxWQPl8Hnbr9PzNimHMTCWrdaa+Uj/g6ObmL9ZxxRfchrIZehLpqVup0etSfLOAN5ss2dCHtvZWZDHtnE25KHOOWn+SXQR+6evdOCfXgR5UidpAyn/LXjm+Q165oltyO+E4Ph5JeWdouTF+A8f1ZQH9RDH7GI3g1CW7Ubov0+2EmbcGRvXxhaOpU4PxDtJf9bGFpRH5M4oeX1dyFqdncgVc2Nj5cpYaWa0VE1FrX0qrdzjeesZCr32PUDR9ZlhdF2QvpCuNfFxXI5TH+SdTnn9kCcyxn31Q6vnyn9GIPmT6B/5ZxX6KtShk7YMiYX+wAJr8TyxVkStY5L4nMCx76TmgyRpfT5LeWhzyykP+xN/ExrHMlzr49Qunv7DDsYrHBdPd2DKWIBzARlj+ol2cX3zVyx/3xFzeWFM+Ora3DyMvYRPjLH2iOZ95INrzTJOxukWh1yr6zhhY51SWYt1ePw6IxDvpOMXz39QHpE7o+R1M37N5KvFSm5mplSYKY+OjY35xiO8x+PXmQq9dsat6PqsMLqe0cavM0GvceqDPB7bcPwSGbXxK8z4W5pJon/kn1Xot0AdOmlL8e1a3KT5is21uXk458NYdy318TBxYmGG+w0mzc/z+IA2yeMDzll4fDgH8jodH0QXnY4P6CexTojZB/c0H99P9GfBGHEGjRE4pgvvmO5DRHeGInfYPpN8rVX4az40xFqr5hO1fqfZH/dvzDsCrjEP+Zyl8NGw+g2xxC5GolYbPYP4nKbwOc3D5wyFj9gV9j+7dizmpF1yUWuSvDzc63StVeTudK0V9ZqnPOxjBcrDtipSHvq3Uv16JGrVL/LGPKkj3+N2xPLnePic2SWfMxU+w0q5lOOv8OF7zEfTjW+tZL58NH/PbW7BB/V2FvE5y5AP2uLZxAdjdFxrvZLmHFIO11q1uXc/0X8X1lrfTLEJ9oMD5Us0my1AHttZEfLYNkqQhzrnpPkn0UWna63oq7FOKHvS2ETor6F2ChRL5FZQvTSd+tZAey3GCTOf9sc42jjeaYyD54ux7+k0LjnJEEtseySKnHFJivKQzxkePlq8dLDGOJoPWagYh2PVTmMPLP9Ci3Fca1QWfLT1jYMtxnnUKMb5BsQ4exdk/cU2xmE7CxXj4PrLV4zmYO3WSlLE2xULXV177i+v03wc1mk+eoRbrlOB9wlHzqU7tE5z8K7T+PY48djX6R4nbb/IwRrDoF4XOoZB3pgndWwXW2D5F1oMs1B77w7WGOYPjWKYr0IM843n4ToN29nzaZ0Gn+cniU2E/js9tE5zglL/sHtUksc4wj9DsoaKcbRxXNvbro1PUlbzPbxOo8VSZyp8NKyTDLF4nQaxTyA+2jsRJ3n4aPuew+5rKFR4/MekjZedxji416GTGAf1yr4Q+1iO8jpd3xmJWvXb7boelj/Lw+fULvmcqvAJPVYv1H78hYqlDtS6kyvGWXlkswyWSxrjCP2XIMY5vI4ZeJ9MR75Es9kc5LGdYRzBtqGt7yT1T/Ndp0Ffzf4J10qETlsr0fpO4Dgi8TdwOI4I9D6jN47QxsqlUfNd16sqmy7ZPLNh/exFla03v/z68iXTN21aP73h5eXyTZWbb8basNVwbdlamEaus8p9xDi9TS3kDX9theR0wjqjDdalhKXtQmcv4sKqEpbmuXhE0nobR1NIj/Kc1Uaecs0tz1mEdXYbrG2Epc08BeucNli3ERaWP4fK5Rx8kAa9YU7hreGz3ebbyLy9NldmlItnZ4U2WHcQFpYvEFaxDdadhIXli1Su5OCDNDgLLgGflHJPk6dWc8tTIqzRNlh3ERaWHyWssTZYdxMWlh+jcuMOPkgzBvfHgU9KuafJc0/NLY+UTTLCoayGI0riXfHCf6FGuHZ65ZnyhCJrVsnjWcSEwmdC4aNhnW6IdaYh1hmGWGcZYp1jiJUzxMobYhUNsQqGWCVDLPGJ2pMI/jJ2p08isPxCPYlYSXxwRQ5nmzfQbFNsEGebWFbGon6i/wjMNm+uY2orZL4nPrzq0qmeNT4y1qANG67qj4l+cQyXJHk4zh0F15y02anI3enqGeqVx2T0MxOUh35jkvKw7764fj0SteqXfaIWB+I9nx0XPXxyXfLJKXyGlXLd9ktNN6H7P6+K5gz5aPMHth8LPtrcop0/ew/5Mynn8mcSy/YT/WPgzx6n1TPsBwfSl7DNanGJ5E1CHtvGiyEPdc5J80+ii05Xz9BXs3/S+sRg1Gp7B+LpmvDPRK19LsScQVsT0MZAzX9LWa0/HQ3X3G/Tyj1f3zzJEEvmkr7YIUV5yMf3dE2LNQLHByV+Co9pmOocp06frs03PkC9jlIe9rExysO24n6LflF8kTZus710Om5j+RdafLBQT9cO1vjgtzqMD/jpmtDfB/HB71J8gOthvRofsJ2Fig9EF53GBzi3Hwd8ti+kwzbUbD1S7qUUHO5zeQf/OG2sPfdXW1tfRTy0sRzvsX2vUuT19dewY9lzp4sjP6kH3kP+GUUnIWKkYkK9arZVJJ1rdsA2gnxKCh8Ni/2gb108H0ZfiWNc4b9Q6+JavLhK0etC2LernXMeecL4++ZJ9O2eD4k88ckiA1GrDWnPxVhufI4k91xt43ue7Xu22O55ID/PdtXB1Ua+59maDvop74j64lyswx8dOZdGnsOOAM1/024ObCfu04GedSXu0/ysayyMPN5nXagftNnFkd92sO1c+wDOVurKtnxWG5nYljvdc4BYbMu+PQe5Nlhsy1ie4wL01byzTdsJznNQxN+/G+0oN37Og5/34Bc9+NoOWG1Nu0R5OPccBfzVHvwzPPhnefDPVvAZU/xGFvJOoDyhXVvHiGPkPcfo8gpGnMKeKpfcpwj/hdppru2H8u001/Yp+d5a8/kJ3y5cxDrdEEuen4fdAV4samsakrT1q4XaAY7twv0d9czrV9gveP0K9yTIOLFQO7M1Pt3ay+kKn2GlXMrxV/jwvSRveXI7WfDR9kNym1vw0fZKsv1Y8PHtAMd4FdeoLqATvLUd4FqsyzvAb4E1qgvrmGHfnrLdAc52hjEh20Y3O8DxNOmvdPmGSrw7Wd7Ovqqy6aLK1sunN6wvT29av/H611Zu3Fy5eVMfwXL3YTM/wyEu4kQeceO0iPJOonw5VHNRpKckyxZhhqfk4YjwX6hli3ZbmDkcOVuRNavkrYZr7kpp5d4iD9Zphlj8oRTE5qWyTg9hPEmR+dAhjIcOYXTxOXQI4/z49MLL/a5Hc3dR2IOH0Sd5NCf0V0HY8w4Ke8KMCc/PQxhFF928+Mb+CT9mIwfzS96JUI4/toQf5MIX5uRjNtp2EHkJbIR+x9fykcJ+kutjZA/4MUNDe2h8FED7iFTYF/yKiV9/cE3jUO6MktfNRwEKlZnZsenpanG2mpudrla4r4usfG8R8GffK/TLFPrAB5NNS3/BjwJg/41TH+TxK4j9kIcvovJHAcIctlmcTqJ/5J9V6N8AdeikLbUp/3w/hCcfGMCPm/BHd9E3cV8M4weSz12Ef4ZkNZanMXfRPma8RtGrNtWVslrszgeTdbpFT/PvFlgy9mhjxRrio30Yeq2HzxpF5l76YFGcFupjnahXXqLBPsZLbthWHONgn+alVNQv20unfgjL+w6yO7ZLPscqfEIvpa4lPqE+PM0+N9SHpw/UR0Fdc5c/cHx0MencReivgLnLH1Osyh8yXlf/nesqdf7xM7ZZXG5lO8P5JtsGzldQ55w0/yS66Gbuwv5J6xO9Gh+sDSOPNz7QxsBO4wM+1KubMf1FhlhiFyNRa3vzuKLp5lgPH80/HqzxAeqV+59va4ZFfBBi3Nb4nNAlnxMUPqHjg4Uat08gPicY8vFtHVqo+MD1Me9lRzfLuOID38e8hf4CiA+W16/Fl4QZE2zjA7azTj/0ndQ/iS46jQ9wLne6A7NfoT2G8oR2LbTXVP16RCl/XDQ37xjIO57ytLmrNm4hBvJAm8N+PlubWwehP7kud6zLR9bomIscmGLH2joZzpXj1Ad5dvY7m4/l/uzqphyo0/31rc2tE/qktELPa5Fa3IG+6Lj6dZIYRlt7OA7uyVqbpk+R8UDo8ziQMYk+kb5TfYqOfOs8qai13bQ41qfP4+r3DoQ+UcYk+tRi8xTpBOlRn6KjbNSqw1MI6zgFC/s7rwUL9oBCzz4J6V8OPmfp6rnyaettkneMgo2+N0UYWI+MUo9hysOyMe5Rh8/F1Z5L+NpGOy7wNIWX+Hft491hnxEUprX5giRtjOfxP+kaAI//uGfBtxUcdcJJiw1ET7FtPQbbrZkOr5GP4LIdsc2sUWTUYsHT2uB2ajM8l32+2wyvKaHNsD09H2wG/TfbzAmKjNr6YrtjRtlmtK3zGLOzzWgHJD+fPvLU7R4KycPXVlAnnDSbwee5ndhMuwP1fTaDH2bi/TRnt8Flm9H2ZGn9S2xG25MV9qMaheqwIqsktietfZMeKs1rVdoraZo9oU44aTaDH9zoxGbaHe/LNqOtp2lbz7XXLLV9eUKvHYuK+mA/o722NaiUM/Qzo8OKrJIkD1+P5L2U+ConjzHacY6Sh0cs8L4pPGKBj7fFpNmM6KlTm9GO+k3qZ6SsdqRGu1dz2Wa015uT2oyUDWwzPXU0l+S9BPKebzbzHjoiEn00H/OUT8hT6Nu9Zs72p9kr+nef/fERpFIO19hQfj5uTug/BfPdtbAWsF+mWpOH6CnsmkSuoq1JoF77a3Pr7dNhnDrt86KzbNTqjwuUpx0X6durqh17ah0bSbzwQomNeJxL+jGyXo2NcP7EPut0RUbtwyzaa/vaxz19fgz1zzaDdiFlwx6DWMwPK7JK0tqexzJse7YLre21eRbbIfZ9/owCJs1mRE+d2ozmD5LaDB4PwB8s1GxGey/qYLWZJP7ihW4zjyawmUN+ppnHaz0Ho81cSTbzIgX3RLiX5H0KfDbJzyHwuRC/r4nlenUfAj9r0D4Wqa03834PtBPUCSfNZkRPndrMKYSL7RMn33MIKRvbzK/Xn11liFf8t6t3fMrlSr6UH5+cqJRK5cnRFYQfJ7G/oQD8S6PT47PT4/n8ZClfKeXb8o/1P7tirj77oAy23bByT3DF/vup7Lp51oPVmiJ+UaTvFRX+GZLVWJ7GXtF+kof1w3tFBxRZs0qetMFI5G6TFOWhDH2KDFmlfF8CLK0+S+v/4nTzpo03Vc6dvuHmzRsqESW2Fe7Tixz8U0r5yIOFZUL0q9nRsZnZZztXrpLfb48L3a9HyzMTufHC9GR5dqxcHJ1daP6VmdLk+Mzk7GiunJvMTxY78SvDUattpRx/45T2YGcVrFtrz/0VH4T9yNIHCf5iks8IvxEX9it6Et5LgtStWk3qX4V/Jgrq7xv+dQnJw/rhd10Hw+inEh/VKLaHPmtA0Q3LsZhkzASSUVszFZkkrw/yRI6Y5nePmSvjokAyhu2j1bIWo+Be5JeubvLFtsE1a7T7RZCP9C9f3cR8Wf16JJo7LqGfGoL8xUq+/Jb2WqTQ4jX/FtlZr0gvNjngqOsA1VXoL6jXL5btqRU6JuoP5VrkwLwQMNdSm+BeNF+fF/ohhR77mMgzErX2zSEqh7IPRnMT3tPaJ0W0PAbLOIXlXL8HFRyXDEsUHB4nGZN5arEez6XSCh/sUzjmDyr8DceHUW2slKTF2inKw7rfWGvScdLmrlKnuL6n0vMqpGN5tL5mGRvJ/X64z3w5Hh8gWhzPWWf9BjJmFT4DhLvYI3+KcPqUcsOR3h+1v0nlTSny+ubD8+WDWDfV5vLBdp7zGUPyn+jH00rZd9Sa+Ui/Gca0mxOOaexLsA4315r32GdzHMt9kp9r89jFNDiOI/02Zexi/4BY8b3tCWIELe7jGGEf6PNO0qcWA4xErbphGx4kXhgfy/jCOrgP5HjHajcv0euwp47xvftX63QoA9IxhjZ2CobWr6XciCIX9z32HQMeHtp4pvHop7xu20cbtzHW0GIYLR/Hc+TD9xYp9O3ij4wDW8MdUHA0P7+E8lJKHvswrC/6MI5NtDkZ+kat37nazhd7a7IniasGPLJr+kM/ZL2Wk5vI5XOz46PVar48Nj1TareWI/cX1+bWa/9fuNcP9YrTEqSnvEHI66vN5Z+p/+4DPoglcvQT/aegreM0AGWkfFbhP0D858it3ENbY6y0ck/o4zb9aF3GEGt0hdHJienJmVy+UC0UihNj7dpV0xOuHcRJdI1tMaDUrZ/ovwBjzpcoRu5X+MV0v+ahSzn+7sdQ7vXV5t7T2ghtV+iFd6bWKqPkDUFeP/FZWv+N+kIskaOf6P8X2S7am5TPKvyXEP85civ32HaHFPohhT5un58nf4R1t17728+T8PEey/ZrAfvVWGksPzExPTE7NludLM3OLPTa++zkWHWyWJzJFyfLlcn8WK+sveM4GHqOKHlafJaiay12GPDwwfJCp631G9p4SfguATk5ztHiFYxR0lFr7LTYoYuUA98Vu/Q5dCfzTp7rZOsP2mPav6D5k6+OcSrX9Dpiv0cabnvpbwMOmcsks9D/jWddU5tDYxx8FWEK/d91uK6p2b/cb7eu6ZsX8brmEORxm2vYSJ924GQIh+spcXScbq+1YksfGyacdfXfuS6T4Mlz6j7gMazUtZ/ov0ftN0I69eks/rdM4SsYqJN+ov8e2NBXSQaRbSjS1yK4TXhNn+1qa21uvtD/F8Rv/0nzfZzf4DrUojU67wzIutQj65AiK/aZHbW5+Y161PnG+vqaQ1aUB2XVnpmJzYZ9zyCvnn2AfqufZNL8hzaudeo/slGr/fqeI7D/9c3VfWPMgIOebVbol0E787kI2npy/FfGJd+6Top+o7/TxhFtzaEfeB62Rsd1rcdeU5tbX6G/DcbUIxyYEgfE6Y5ak6YxD41a+4FhHJNjG8C4QVsTZj9zLNVLbAXboF/BEfolCl9cKxOd8HrcsWBL4mO1Z6IYz2rPriNDXSbZ/xGoHSdTxE/0gfeQ/0Lt/9DW0nz7P8Lsj8lN4P4PXHO+rtaqG5aDnxe5nuOcTn0B+4zmN+Qzm/1EXwS/cRb5P/RZ/NyB+5YmSypq7SdR5J9T8XMFzON1RqRfFPnnC5pP57kp20+cxN+yPrDdtP0gcXL5k0nwJxz3a2v3vv0M2jivzYm05xEcU2m8tWf8zNu1R4Sfbwj9OmVsZsz+KJmPFvpzPTrVYhufTpcq9NqcaCRq1eNSwmqnU+mXLGtSnQr9hR6dYqycRKdC/2qPTjUd+XQ6rNAvVeo1ErXqm+d87XRaremyJtWp0L/Oo1PN3/p0KvRXHECdYp2HqZz2fBD9N97PRHqdZY6qYWYcmJr/cu2NdLWl5tO4Lac9banVK5OwXkNG9RrqsF5Cf1WgeqUd9Up3WK9Mm3pxrC/01yWol7aPME683ib0Nyh9T5vT47punPpqc+VdV7+f6yrpc3pcN+yvza235veQvtPYgOft3EcxT9tj4bOJpM/fG89qomZMK/4K5wscq7Xbt+Rac70zoQ0I715b12m3X8AVoyK9tuc2q9BvId7a+0taO/vWgZKuh5i/k1IqzlTz1cnxmWI1V5zIL/g7OdO5QqWUn5kZzVemJyerC/5OTj6fr46VZibGZgu5annB3wkqVcenx6rjudFCuVQplKcXmv/0eGWyNFYszBark9MTuYmF5j9THpvNTRbz5enp8dz42MR8nstiX5NyspbB4/W6ecpJKfF3N+ReJtJ9/DobefJJxxy55mfavrEtTvJ955SSl1buLVpgLC2WZ5+v6ca3/qKNx0ne3w21Xz+pzQn/hXp/N+n7rrw2i2X5GUSc2E60cVabBz5fsKR8nLQ9Jptqc/OwjVmnSW1VYhf2pZ3Elni/X5GXY8tfqscuoZ+j8NiBvAK/Wz+mxaiStOeo3O44d+C21eafkofjMb/3jSlNv1EXMe+/TnB+hGYjKcobUOqh7RvmsSalyOV7V9S3/1wbJ+RbwinCjCJ9viAxu/buRrt4hN/FidNC7IVCflKvKNL7QyZqba+Fevakzcu0fsDtqb0zkKI85KOtAWhYSeaGSbH6qD7YHmwLgWLBxHGC8M9ErToNYQtan0spetViU18MiO+Ecl6n8WSvY/nmPEnaXePD9o98cHzH56z/Qc9ZpRyuO2FZefbQT/R3H9PE/D6tc2nt73sG67OzRZ76a3wGlXLr6n9znaUS3wh7zkJummMDTJI3pNQ5pdBrcYPI3em3+zBuGKI8HIeWUh6OmcOUh75X9v5pNsIxS6c24ttHrcUn8+WjxU+h+3w/8Qn9jrIvTpovH+39L22vZbd8tP0p2liPvvLoY5plsBz6SixbrjXzkf4m8JXH0FkjgfbsTPIcBJM2B2GbRT/DdobPZNk28Nk2nxWESfNPoov4byff7sNxIAP43F/SSlnfelCgOWfimP+FcJ5bnDie6vQdFd8ep26wfONBmvh0Oh5o65mB55IT2jNXSZo/eH+tKQcnrX+K3J3GD6jXQcrT+u584w5tvYJjZG1ei/d84+1iD592e+/a8fGd5RFqHFyoOIXn1qHexztQ8ZArfngdxQ/aM34sy3MtoZ+B+OEKih8CjQkd+RLNZpPGFmwbGFugzjlp/knudRo/oE1InXBPrraupI2LqajVx2p7hISftvYqZXstPuT21eahWhty+2J8yP11GeTxewaY2sWOnZyprMUPSMd7fVKKjFpf12xAWzMS+nZ7m9hmtL10vbo+4evbml2wf0W7YDscgTzUCad26yGd2IzmD5LaDJ4lJPNL37MKua+tQfYrPH0y+vZVtfNZfA6QdlYg88ZxDuUv15r5SP+uuj7a7WUTPYXdy5YbPdD7GfkZu+aPtXiL1ze0Z8O4Fmy9N2i8MDs6XRydzM1WRsenx8Y72RvkO+cqSdyN78SxruLEz7qF/mmKqwL5UPVZd6fnEHCcKPRfhDjxGfItvL6JedqcwHdGmnaWKLeD9t7LEk8dhP6jCX3AwuxpzpU0H4D9ln2A773jOLEPaPduDr+n7IqPeTzQdM5jBMYvPp/P85HPQhvxu8ho1xmSXZtLa+slvJakneMay/I71GcDPRMf1+bhkrTnGSnKw37CMZG2R903T0opMmixjeii0z0iFn4CY/798tVa5ToQ/RbHZ+63vrE4ilr7bbt+LusA2vkCbN/aWNBJn4mTb686xpzSZ4aA10CtSWvYBo3vloiu0yBzX60pu/AXe8Hzv4SuMS8OI2tOZJXzwmTcQp5Yl0VEz9d8Pt+3YX6IdcR29J2zp51Vhme4iYzauXZDtc6wlhDW4i6wRC7t/LbF85RLwxogrEEFC++JfuM+8QfQJ7R9Ya69FN9JsL7n20sh9P8P4ra/p7jNcs9eO1/NPq+hy0gfq9bVf+e6S4n3PQn/TNQ6roZ4Hpb0zBnRz1AYeUq+WFEbo+LzGpZFrW2G8uG5UJLKtef++tYl2dbb6SarlOe9oNjGvj2kPDYm2UOK9j4U+eeXKcLS+rEWI2m60NZmeL6WXvvc3/1rQfVr31m9Wv/lfu87K8G159hlW761i3bvavN6ke/9dw1rsYf3MoV+2MMb5cKyzNvVR7Q4VnRzINagMPbkONY3n4xTEl1q7ZgletSd1o9961NDlIf9j/u49nwY+4u2xoXzWhmjR+oC4BmSUWQ/dmD/s8afyE+M8/MaY/mLQd+FyheqgffW5MTuLqg18bVnxGmi4zJol68Amlc4aF4JNK900FwINBc6aC4CmoscNK8Cmlc5aF4NNK920FwMNBc7aF4DNK9x0FwCNJc4aC4FmksdNK8Fmtc6aC4DmsscNK8Dmtc5aF4PNK930FwONJc7aK4AmiscNG8Amjc4aK4EmisdNG8Emjc6aN4ENG9y0LwZaN7soHkL0LzFQfNWoHmrg+ZtQPM2B83bgebtDpppoJl20MwAzYyDZhZoZh00ZaApO2gqQFNx0FSBpuqguQpornLQXA00Vzto1gPNegfNNUBzjYPmWqC51kGzAWg2OGiuA5rrHDTXA831DpqNQLPRQXMD0NzgoLkRaG500NwENDc5aG4GmpsdNJuAZpODZjPQbHbQbAGaLQ6aW4DmFgfNrUBzq4NmK9BsddBsA5ptDprbgOY2B812oNnuoLkdaG530NwBNHc4aO4EmjsdNDWgqTlo7gKauxw0dwPN3Q6ae4DmHgfNO4DmHQ6aHUCzw0FzL9Dc66C5D2juc9C8E2je6aC5H2jud9C8C2je5aB5N9C820HzANA84KB5EGgedNDsBJqdDpqHgOYhB80uoNnloNkNNLsdNA8DzcMOmkeA5hEHzR6g2eOgeQ/QvMdB8yjQPOqgeQxoHnPQPA40jzto9gLNXgfNE0DzhIPmSaB50kGzD2j2OWieApqnHDRPA83TDpr3As17HTTvA5r3OWieAZpnHDTvB5r3O2g+ADQfcNB8EGg+6KD5ENB8yEHzYaD5sIPmI0DzEQfNR4Hmow6ajwHNxxw0HweajztofhJoftJB81NA81MOmk8AzSccNJ8Emk86aD4FNJ9y0HwaaD7toPlpoPlpB81ngOYzDprPAs1nHTSfA5rPOWg+DzSfd9D8DND8jIPmC0DzBQfNF4Hmiw6aLwHNlxw0XwaaLztofhZoftZB83NA83MOmq8AzVccND8PND/voPkFoPkFB83/AJr/4aD5RaD5RQfN/wSa/+mg+SWg+SUHzS8DzS87aP4X0PwvB82vAM2vOGh+FWh+1UHza0Dzaw6arwLNVx00vw40v+6g+Q2g+Q0HzdeA5msOmt8Emt900PwW0PyWg+a3gea3HTS/AzS/46D5XaD5XQfN7wHN7zlovg40X3fQ/D7Q/L6D5g+A5g8cNH8INH/ooPkjoPkjB80fA80fO2i+ATTfcND8CdD8iYPmT4HmTx003wSabzpovgU033LQ/BnQ/JmD5s+B5s8dNH8BNH/hoPlLoPlLB81fAc1fOWi+DTTfdtD8NdD8tYPmb4Dmbxw0fws0f+ug+Q7QfMdB83dA83cOmu8CzXcdNH8PNH/voPkHoPkHB80/As0/Omj+CWj+yUHzz0Dzzw6afwGaf3HQ/CvQ/KuD5n8Dzf920Pwb0Pybg+bfgebfHTT/ATT/4aD5P0Dzfxw03wOa7zlovg8033fQ/F+g+b8Omh8AzQ8cNP8JNP/poPkh0PzQQfNfQPNfDpofAc2PHDT/D2j+n4Pmv4Hmvx000V1NGrlmmhTQpBw0i4BmkYMmDTRpB00f0PQ5aPqBpt9BMwA0Aw6axUCz2EGzBGiWOGgGgWbQQZMBmoyDZghohhw0S4FmqYNmGGiGHTTLgGaZg2YEaEYcNFmgyTpolgPNcgfNCqBZ4aBZCTQrHTSHAc1hDppVQLPKQXM40BzuoDkCaI5w0BwJNEc6aI4CmqMcNEcDzdEOmtVAs9pBswZo1jhojgGaYxw0a4FmrYPmWKA51kFzHNAc56A5HmiOd9CcADQnOGhOBJoTHTQnAc1JDpqTgeZkB80pQHOKg+ZUoDnVQfMioHmRg+Y0oDnNQXM60JzuoDkDaM5w0JwJNGc6aM4CmrMcNGcDzdkOmnOA5hwHTQ5ocg6aPNDkHTQFoCk4aIpAU3TQlICm5KAZBZpRB80Y0Iw5aMaBZtxBMwE0Ew6aSaCZdNC8GGhe7KB5CdC8xEHzUqB5qYPmx4Dmxxw0Pw40P+6geRnQvMxBsw5o1jloXg40L3fQ/ATQ/ISD5lygOddBMwU0Uw6a84DmPAfN+UBzvoPmAqC5wEHzCqB5hYPmlUDzSgfNhUBzoYPmIqC5yEHzKqB5lYPm1UDzagfNxUBzsYPmNUDzGgfNJUBziYPmUqC51EHzWqB5rYPmMqC5zEHzOqB5nYPm9UDzegfN5UBzuYPmCqC5wkHzBqB5g4PmSqC50kHzRqB5o4PmTUDzJgfNm4HmzQ6atwDNWxw0bwWatzpo3gY0b3PQvB1o3u6gmQaaaQfNDNDMOGhmgWbWQVMGmrKDpgI0FQdNFWiqDpqrgOYqB83VQHO1g2Y90Kx30FwDNNc4aK4FmmsdNBuAZoOD5jqguc5Bcz3QXO+g2Qg0Gx00NwDNDQ6aG4HmRgfNTUBzk4PmZqC52UGzCWg2AU0aaDYDzWaiGQRMvL+u/jvXRZrIlcaD7sHNF8q+c56CvqubL1RSxC+KYA0H/uL3uVFWU3ngXSLtHRHtPBjfeReS11drrYfk9UMenhN/SapJx7bF74DhOWBiv9p5iWK3Mf6bUs3rt6fmyo5l0sQ/ilrfowrRFhP58bGwe8/zOa3tGutR9b99kMfvSSdpuzjdC/6CdZcOrLsw/SSfX6nIz++8L65FjZQmXaP+tPeI05SH74L21ebykXd25fwNxhI5+B3fN9YBtHdw+d1V5M/vrs6RW7nH7wZ38q7rZfVC+P73ubUmnqXvE/ypIPilnOCfF0b+kuCfHwQ/n5P3jb9Tb5PQ78b4zm8OezZpPp90XO7V71yEPY8vn0sRPsqjfVvDdwajYPm+PY24i4ger6U83ruh3mDau738vrp2Jpb2znKs82soRgl17qnr/V3t25s4JvF7+/elmrJvoZin3ZmRU7W59HiuDdMjXj/Rb4O4659SOqarXi7MO6Fet1ObDCh1iO/tcNQ/Ffl1mrT+ixyy3gP1/1eHrCgPysrzFCwT/73fQ9ev0KVI1nSkx/oyXvn88XztXDsTIvCZZiX2N1q9mX/8bwjqkI5afZDrXMGUA3+I6BvvZke6L+XzrYT+CbD/PQn6Nc6XMJZy2XWSPvi40q+1Nka7Frm1cwLw3CXGiNO6+t9cdykf1NaeXVvQziJJ2cmf087yMMSf4Dk2+5JnyN7kXfykPlzoPwI2/EGyC/QtHE9o53YPRa3ntEZR975KO7NB5FsGZbR+Jj5U2isL5S1jZpFH5nToS7KKPP1E/xlqzxWgnzTVFXGEfrnCF8+Q5HFxOfGN7ePfaRzTzneI7eRzJOsIYKeprK/Ovwq29wWyPeTN5+lrZ0uk6LfWD+J0Pski9D8Hevge6CFOuE4jci3E99F/QO2Bfaq/NrfeI5CXVuj5PI+sQo9nJHMfxH6zjLC0s0S0sU6LsUVGza8IrubvNPmXKWW5fww46AWP+8dvKOMrY6KtoZ76HJi/A3b/W9TG2AZ4jsk3Hbyx/mmlPuxPXHHzcpJV6H/fU/+sUv/lgDlImEL/R0pfYzmxXim4x3a8UqFfodRrJGrVi5TVdC90qHsNg/2P8MtEuk0MkayYh/yx7lrfXq7I6mvr5QofbutvK22tjcEjxE+TD32C9H9tXGmsgUbNcSWkbx2faJ7hKH4dz3DE1Af5SP+PdQDr87Cr49P5anG6Oj06XS6XZqfbnYdtzb80Oj0+Oz2ez0+W8pVSfnSh+RcmJsYmCzPPPnksz1bLpeJC8x8rjeUnJqYnZsdmq5Ol2ZmF5j87OjYz+2wj5Cr5/epox197foCxSpzkGQQ+o0B6jAuR/kcwRv03jFH7aRV+Md2yRW66lOPvfgzlXl9t7j3t2QU+0xF64Z1RZJQ8PA8U46g4La3/Rn0hlsjRT/RD9bpLm+BzGCmvnUeK57syL41/kvNehxT6uH366j8a673A23rNfD9Pwsd7LJvYTmzXeRoHnpdnsOXGZp/XZ7A9u4iyUGew4RlnvjPYXOeipYHGdS4a0rjORUMa17loSOM6Fw1pXOeiIY3rXDSkcZ2LhjSuc9GQxnUuGtK4zkVDGte5aEjjOhcNaVznoiGN61w0pHGdi4Y0rnPRkMZ1LlqcH3i/1fRC7DvBPhZBXcJ+GyH5c92Dbb9VAejYtnz7rcR+tf1WYrcx/o8Br/OiubIjnm+uHXTPUG50NvA4pu634nbtq83ljXnYdn2gzwLpJ0ScgvoJof9YPysd8st1nGReEEV6/C06OlB7ql5a/93Le6pG69cLsKeqEHZPVTN2Pi8MfuA9Vc/FznG6IAh+vrHn7BVh5K8I/itD4D+7/CB7zgZg7u+KHZKM7XHiZwp8tjzyCfVNXsnzfcfIFxv4vl2gxTFh98s191QsATm157+85wvn1tqeh8UOXaQc+IMLU9+W/W/at++Qv7bPIIps/WCMGWifwQR/f/Dd9b9xXa8knvhsgdsoTuir439LqY2YhvvGMPDW+oOU5Werb63/3f8duNRcTG1PHX6H4ALCFPppwBxJ6XJGkT+ulfvtvhMh8mg+YxmV8z2D1LCRPu3A4WdMXM9FcC+jYGt7HwxtVN37kFJ4ijy8D2AjyYV7H1KRX2fxv+UKX1w7zxDf5cQ3tqEVZEMi21Ck+5dGLBvpfWVd/Xeuu1RiPfZHrXbL/Qjpt9T/xvmb6tfatwgXA93tVBeck2t7BVgXy4LootBiZ6gLzT7Yzm6r/43rvSrl1sWAogvf/H8h9oIcSfKi3+0nmTT/p8Utnfo/7dsu/N1RbY9sSpFBiyHYX+KeRY2ebV7o76//jX+fnZorn+v7LzKuaj7e9f1U9NfaONhuD99DDlzX3iWZS/QT/fcB8+H6deC1+wluU4wjmSfKE+jbZ964cEiRh23myWhuWzT6e6T7/zTRL1X4avsWef+l8MUxKK3wQPvS3jGJDHWZ5P2fQO04mSJ+og+8h/wX6v0f7Tuuvvd/loaRZyKOXbTvuuI6gPZtMrQXzS/h+P9huM99RvNLsobVT/SfAsyP1a9HFN59lMd9S5MlFbX2kyjyz8lxXZfzcF8F82q3t7iT781HgItrQzwmSxv2R7o/YH8i9J+v/9XmRdo+TV9c0O7bfSJPkm/3abyx3aZqOm/XfkXc7470P1f/i2M/Y/Y76tPvwPwFwGSdarGTT6faXjltzjgSteqR99210ym/YyJ8kupU6H8latb/bEf9k+pU6L8KmKxTTUc+nbbby8w61fb9JtUprkcjn6Q6FfrfiZr1Z51q/tanU6H/OmAutE6xzlkqh7Jz3MD+LuMol/FgDjswNf/lGhtdban5NG7Lb9X/am2p1Ws4Yb2WGdVrWYf1EvpvB6pX2lGvdIf1Gm5TL471hf67CeqFfQ/Hbl6PFPp/BEzpe9qaAa5Lx6mvNlfedfX7ua6SvmZg+T3YdrEBrwtwH8U837uZmk1gDDZVi+bUUXuGjTGt9r10jtV873nHybUm/cP633Y2ILx7bd1Ie2fVN0ZocyLtm9PZqLVt+flSv4KltbNvnSnpekuvv18wVAd4ob1fcKD393e6v/4F937B5Fh1slicyRcny5XJ/NiBfL9gTR0g7pdryVf2K/xiurM8dCnH3/0Yyr2+2tx7vf5+wel1gF5+v+BE8ltYd+s1uf08CR/vsWxiO73w3tRk/fp5/X5D/aw3TMbyB/7GfHHB3m+YqjXxfe83CB2XifN5zRJpwu4/LY2GPQe0mAu8Z6jIcb3onOvEZ1zMd68b8uq1feza2TD8fLPTfW8a1oFsU9Q1tul+mlozz7cHPOn+/eOAjvsg79/HOQCeiXoG4J1Zvw76rgmc0xlo7GnsKUf5ObaQWDCK9JhLdH6g9pSfXv/dy3vKT6xfD9X/xTZUBDxXH8G5Ne+J1fZIBO7PBZG1T5FV29cZrzWtql/fvGnjTZVXXn/erZXZzZvWb7z+3OnZqysRJex8aJiLIvfAjBXVMNJQXku40b+vNrfcuvr9XBfJYrFhov77QC82rK5fP79f+i1NLFRQHChoLYV9EVAPijWHIzYsD9zwWmQSmguA5gKgiZMvcOZBO07nUZ728E8LEIVv7IBlg+n+TT3168Avj04cyAFdBh5xyLFzPq5+ff3GTeurW8+7/sbNlc2V8iWbZzasnz1/8/WzzznqDRsiShx0p+j3IvrNPrlPweGE5VJQh1731UfXfx9oX/2CWMCov3CNKZSvDjT5Gzu0gNE+BV/AgDHz0AJGx+nQAoan3tym+2lqzbwDuYAhG04PyAIGHJZxaAHj0ALGoQWM6NACxoEOit9Sv36eB8ULdmpZoAWG0dBvoAuuLBS4OngnCxivAJpXOGheCTT4tkectOBa5NMWOXghA/vbBZSHDu0VlId+BgMCcWz7d6CBjHHCk9tSlIcntom8YU8fagYSgQLcgu+LZc/3U2BkwH4ZtCMP2KlobjuGDKiRXxTpE5te/XJUHBDIidSzzy6MXXLT+i3TmyqyVoZVQNhFShV5OOdNWBoduwh2C+wKsPsjrqs83xPe2scm+MVhblK+55vP+VxkyvFX+ERt+Ggya+52vnxCur44ZUlW5BXYLY5qQ0hEOvS1I7oR7gORot8IaPAQt/MAl+lYHmwHfE6B9dDaS5vXaxuetSFC7gdewxrTXDfXnzdtY5628Ttpe+B6RCft4Von4b6ZpjxtjeP5MNWZqv8+0FMdHPJ9L+2ORK3ttIjotEMPcJyR0Cj0B6n4UIVX1f/Gdb2CZNbWI9KKrpKEAFhfbf1icQLeqK+pms57INL9EB+iIfSX1f/G9X9j/dr3UrU2lvCYiOWkji/Ejf4H5Ybgwuzz+8DzwsTEoedp7VPw52mFibFDz9PmnQ49T/PUm9t0P02tmXcgn6f9xt1NjAV/nlb33aF8RpwOPU9r8j/0PK1tOvQ8bT7phfQ8TRYUBhV5QqyRhzqZDid/EdUF+bIOtA2MKcfvRfTXR5vy4A4reYIpa9Mor9RDNrziFx8F11KX+JXsAPiNCVKoIEWzBbzHEwBsKx748cTtALJONwZlkCFNPFlGpNHsdxH97qP76QS0mv1KXmPw9ZQbVGTFexzoRQp9YyCv/+13YC2GfKTnU2BCteFKRaaUg/eqMDI0+tRhYfBV/7oKrg+jeqJdrTOSQfDEBrSHGvwQrhH4kXwpe/nyESXNv0gSmzkM7ok+/z/88uTGjeoXAA==",
      "debug_symbols": "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RgetrNFBKyt0mNun0kEra3TQyhodtLJGR6Cj0EEra3TQyhodtLJGB62s0UErK3SY26fSQStrdNDKGh20skZHoKPQQStrdNDKGh20skYHrazRQSsrdJjbp9JBK2t00MoaHbSyRkego9BBK2t00MoaHbSyRgetrNFBK+fpLMztU+mglTU6aGWNDlpZoyPQUeiglTU6aGWNDlpZo4NW1uiglRU6zO1T6aCVNTpoZY0OWlmjI9BR6KCVNTpoZY0OWlmjg1bW6KCVFTrM7VPpoJU1OmhljQ5aWaMj0FHooJU1OmhljQ5aWaODVtbooJUVOsztU+mglTU6aGWNDlpZoyPQUeiglTU6aGWNDlpZo4NW1uiglRU6zO1T6aCVNTpoZY0OWlmjI9BR6KCVNTpoZY0OWlmjg1bW6KCVFTrM7VPpoJU1OmhljQ5aWaMj0FHooJU1OmhljQ5aWaODVtbooJUVOsztU+mglTU6aGWNDlpZoyPQUeiglTU6aGWNDlpZo4NW1uiglRU6zO1T6aCVNTpoZY0OWlmjI9BR6KCVNTpoZY0OWlmjg1bW6KCVFTrM7VPpoJU1OmhljQ5aWaMj0FHooJU1OmhljQ5aWaODVtbooJUVOsztU+mglTU6aGWNDlpZoyPQUeiglTU6aGWNDlpZo4NW1uiglfN0Vub2qXTQyhodtLJGB62s0RHoKHTQyhodtLJGB62s0UEra3TQygod5vapdNDKGh20skYHrazREegodNDKGh20skYHrazRQStrdNDKCh3m9ql00MoaHbSyRgetrNER6Ch00MoaHbSyRgetrNFBK2t00MoKHeb2qXTQyhodtLJGB62s0RHoKHTQyhodtLJGB62s0UEra3TQygod5vapdNDKGh20skYHrazREegodNDKGh20skYHrazRQStrdNDKCh3m9ql00MoaHbSyRgetrNER6Ch00MoaHbSyRgetrNFBK2t00MoKHeb2qXTQyhodtLJGB62s0RHoKHTQyhodtLJGB62s0UEra3TQygod5vapdNDKGh20skYHrazREegodNDKGh20skYHrazRQStrdNDKCh3m9ql00MoaHbSyRgetrNER6Ch00MoaHbSyRgetrNFBK2t00MoKHeb2qXTQyhodtLJGB62s0RHoKHTQyhodtLJGB62s0UEra3TQynk6kbl9Kh20skYHrazRQStrdAQ6Ch20skYHrazRQStrdNDKGh20skKHuX0qHbSyRgetrNFBK2t0BDoKHbSyRgetrNFBK2t00MoaHbSyQoe5fSodtLJGB62s0UEra3QEOgodtLJGB62s0UEra3TQyhodtLJCh7l9Kh20skYHrazRQStrdAQ6Ch20skYHrazRQStrdNDKGh20skKHuX0qHbSyRgetrNFBK2t0BDoKHbSyRgetrNFBK2t00MoaHbSyQoe5fSodtLJGB62s0UEra3QEOgodtLJGB62s0UEra3TQyhodtLJCh7l9Kh20skYHrazRQStrdAQ6Ch20skYHrazRQStrdNDKGh20skKHuX0qHbSyRgetrNFBK2t0BDoKHbSyRgetrNFBK2t00MoaHbSyQoe5fSodtLJGB62s0UEra3QEOgodtLJGB62s0UEra3TQyhodtLJCh7l9Kh20skYHrazRQStrdAQ6Ch20skYHrazRQStrdNDKGh20cp5OYm6fSgetrNFBK2t00MoaHYGOQgetrNFBK2t00MoaHbSyRgetrNBhbp9KB62s0UEra3TQyhodgY5CB62s0UEra3TQyhodtLJGB62s0GFun0oHrazRQStrdNDKGh2BjkIHrazRQStrdNDKGh20skYHrazQYW6fSgetrNFBK2t00MoaHYGOQgetrNFBK2t00MoaHbSyRgetrNBhbp9KB62s0UEra3TQyhodgY5CB62s0UEra3TQyhodtLJGB62s0GFun0oHrazRQStrdNDKGh2BjkIHrazRQStrdNDKGh20skYHrazQYW6fSgetrNFBK2t00MoaHYGOQgetrNFBK2t00MoaHbSyRgetrNBhbp9KB62s0UEra3TQyhodgY5CB62s0UEra3TQyhodtLJGB62s0GFun0oHrazRQStrdNDKGh2BjkIHrazRQStrdNDKGh20skYHrazQYW6fSgetrNFBK2t00MoaHYGOQgetrNFBK2t00MoaHbSyRgetnKUzDcztU+mglTU6aGWNDlpZoyPQUeiglTU6aGWNDlpZo4NW1uiglRU6zO1T6aCVNTpoZY0OWlmjI9BR6KCVNTpoZY0OWlmjg1bW6KCVFTrM7VPpoJU1OmhljQ5aWaMj0FHooJU1OmhljQ5aWaODVtbooJUVOsztU+mglTU6aGWNDlpZoyPQUeiglTU6aGWNDlpZo4NW1uiglRU6zO1T6aCVNTpoZY0OWlmjI9BR6KCVNTpoZY0OWlmjg1bW6KCVFTrM7VPpoJU1OmhljQ5aWaMj0FHooJU1OmhljQ5aWaODVtbooJUVOsztU+mglTU6aGWNDlpZoyPQUeiglTU6aGWNDlpZo4NW1uiglRU6zO1T6aCVNTpoZY0OWlmjI9BR6KCVNTpoZY0OWlmjg1bW6KCVFTrM7VPpoJU1OmhljQ5aWaMj0FHooJU1OmhljQ5aWaODVtbooJUVOsztU+mglTU6aGWNDlpZoyPQUeiglTU6aGWNDlpZo4NW1uiglfN0Rub2qXTQyhodtLJGB62s0RHoKHTQyhodtLJGB62s0UEra3TQygod5vapdNDKGh20skYHrazREegodNDKGh20skYHrazRQStrdNDKCh3m9ql00MoaHbSyRgetrNER6Ch00MoaHbSyRgetrNFBK2t00MoKHeb2qXTQyhodtLJGB62s0RHoKHTQyhodtLJGB62s0UEra3TQygod5vapdNDKGh20skYHrazREegodNDKGh20skYHrazRQStrdNDKCh3m9ql00MoaHbSyRgetrNER6Ch00MoaHbSyRgetrNFBK2t00MoKHeb2qXTQyhodtLJGB62s0RHoKHTQyhodtLJGB62s0UEra3TQygod5vapdNDKGh20skYHrazREegodNDKGh20skYHrazRQStrdNDKCh3m9ql00MoaHbSyRgetrNER6Ch00MoaHbSyRgetrNFBK2t00MoKHeb2qXTQyhodtLJGB62s0RHoKHTQyhodtLJGB62s0UEra3TQynk6gbl9Kh20skYHrazRQStrdAQ6Ch20skYHrazRQStrdNDKGh20skKHuX0qHbSyRgetrNFBK2t0BDoKHbSyRgetrNFBK2t00MoaHbSyQoe5fSodtLJGB62s0UEra3QEOgodtLJGB62s0UEra3TQyhodtLJCh7l9Kh20skYHrazRQStrdAQ6Ch20skYHrazRQStrdNDKGh20skKHuX0qHbSyRgetrNFBK2t0BDoKHbSyRqd6rTzLi84SC3TCGJbPy8Mo8x/TqV4r30qneq18Kx0TrZzCRidNqUBnfd4ZZHr95VGWR0Amo/KSvNKV0qIHNKY5bTer9PHnX5fvJ0DmtwzEL5c/ljD6X0K4fglrGLYlxHXSl5DmefvbIb6V0Uddf/zX//7/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JB7HiKTgcaxI4nGsSOJxrEjicaxICiSNSOJxrEjicaxI4nGsSOJxrEjicYxIzngcK5J4HCuSeBwrkngcK5ICSSOSeBwrkngcK5J4HCuSeBwrkngcI5ILHseKJB7HiiQex4okHseKpEDSiCQex4okHseKJB7HiiQex4okHseI5IrHsSKJx7EiicexIonHsSIpkDQiicexIonHsSKJx7EiicexIonHMSIZ8ThWJPE4ViTxOFYk8ThWJAWSRiTxOFYk8ThWJPE4ViTxOFYk8ThGJBMex4okHseKJB7HiiQex4qkQNKIJB7HiiQex4okHseKJB7HiiQex4bkOuBxrEjicaxI4nGsSOJxrEgKJI1I4nGsSOJxrEjicaxI4nGsSOJxjEiOeBwrkngcK5J4HCuSeBwrkgJJI5J4HCuSeBwrkngcK5J4HCuSeBwjkgGPY0USj2NFEo9jRRKPY0VSGiIp43a1jGn5cvVjtS35kPJqW/IK5dW2pOfLq21Jc5dX25IuLq62qfn15dW2pC/Lq21JA5ZX25JOK69WulptV1qqqbnk5dV2paWamu9dXm1XWqqpOdnl1XalpZqaN11ebVdaqqm5zeXVdqWlmpp/XF5tV1qqqTnC5dV2paWamsdbXm1XWqqpubbl1XalpZqaD1tebVdaqqk5q+XVdqWlmppXWl5tV1qqqbmf5dV2paWamp9ZXm1XWqqpOZTl1XalpZqa51hebVdaqqm5iOXVdqWlmpovWF5tV1qqqTl95dV2paWamndXXm1XWqqpuXHl1XalpZqav1ZebVdaqqk5ZuXVdqWlmpoHVl5tV1qqqbla5dU2paVknJ6rXcdhZ7VNaaniapvSUsXVNqWliqttSkuVVtvUvKTyapvSUsXVNqWliqttSksVVytdrbYrLdXUHJzyarvSUk3NkymvtictFZuay1JebU9aKjY136S82p60VBykq9X2pKViU/M2yqvtSUvFpuZWlFfblZZqav5DebVdaamm5iiUV9uVlmpqHkF5tV1pqabO9S+vtist1dT5+OXVdqWlmjpnvrzarrRUU+e1l1fblZZq69zz4mq70lJtnXteXG1XWqqtc8+Lq+1KS7V17nlxtV1pqbbOPS+utist1da558XV9qSl0g3PCpb1efW8xOl9tY+IbrhvDi/+w/I9ov36D9MzEdO0xkJE05KG59Vx+D6o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VVpa67zpprijmyo/4tF2rU3ppsJam9JNhbU2pZsKa21KN+lrrfz4Stu1NqWbCmttSjcV1tqUbiqsVTpaq1/d9IjfrxZ6xO9X3zzir1uzLMPwDGSZlnEn/rp1SDH+yo/mLMdft14ox1+3BijHX/e+Xo6/7r26HH/d+285/rr333L8de+/5fid77+VH81Zin+u/GjOcvy+99+58qM5y/H73n/nwff+O1d+NGc5ft/771z50Zzl+H3vv3PlR3MW46/8aM5y/M7338qP5izH73z/rfwIzXL8zvffyo+kLMfvfP+t/IDHcvzO99/Kj0ssx+98/6388MFy/M7338qPCSzH73z/rfzsv3L8zvffys/+K8fvfP+t/Oy/cvzO99/Kz/4rx+98/6387L9y/M7338rP/ivH73z/rfzsv3L8zvffys/+K8fvfP+t/Oy/cvzO99/Kz/4rx+98/6387L9y/M7338rP/ivH73z/rfzsv3L8zvffys/+K8fvfP+t/Oy/cvzO99/Kz/4rx+98/638jL5y/M7338rP0ivH73z/rfzMu3L8zvffys+mK8fvfP+t/Ay5cvzO99/Kz3orx+98/638TLZy/M7338rPTivH73z/rfyMs3L8zvffys8iK8fvfP+t/MywcvzO99/Kz/Yqx+98/638DK5y/M7338rPyirH73z/rfz8q3L8zvdf5+dfzc7Pv5qdn381Oz//anZ+/tXs/Pyr2fn5V7Pz869m5+dfzc7Pv5qdn381Oz//anF+/tXi/Pyrxfn5V4vz86+Wwff+uzg//2pxfv7V4vz8q8X5+VdL7edfSXxevMxj+B5/7edfTevG/+OFhT8dB/m8OE5puzbEZefaFJ9/OKWv1z64VL6v38alcr1wG5fKdchtXAQuu1wq1023calcj93GpXKddxuXyvXjbVwq16V3can9vLnbuKB397mgd/e5oHf3uQhcdrmgd/e5dKt3l+e14zCEHTDdCt4SmG4VbwlMt5K3AKb2Mx7vA9Ot6C2B8at6H/H7VaeP+MV5/H7V3iN+v6rsEb9f8fSI36/GecTvV4r8HX/tp1IW4/e7sT/id77/1n4qZTF+5/tv7adSFuN3vv/WfiplMX7n+2/tp1KW4q/9VMpi/M7339pPpSzG73z/rf1UymL8zvff2k9FnGN6xr+MpcbYOKdhera75jRO2/Wf3a7az/BTVvuIv/K7VTH+uu9W67o+L17Xt2d4+386rMv8eXVY1+n9Tz8WW/etzXixdd8HjRdbt2kxXmzdDsd4sXVvh8aLrds72S628uMPjRdbt8757WJTeC42vqmKbbF1iyLjxbaloAqLlYYWO4XhKY6nENbvi21JQRUX25KCKi62JQVVXGxLCupjsYO22MrPRPzlYmV8Xj1JGL4vtqV9trjYlvbZ4mKb2mdLi21qn51S3BY7DvqfntP6vHXPKe3czZralH9DZhm2+/wy7AjRys+evKZm9sk0td3LtGkbmcc//DS11F05Sma3Zio/ifO3ZLYnbJOk+H2xbUnEwmLbkoiFxbYlEQuLlUYXO7/9KmJbbFMSsbTYplRfabFNCbnSYpvSZtMrkHlc9T89LvGp58dV3g5Dk+lvNGvlh5H+Es26Hf02rWn6I9m6Vn7M6YlkCiZwrfwA1WtqZp9MU0ro9aenfzyU2rnRDGn7wtk4DTs3GmkJTQyyofkuEtfKj4g1XmxTuqm02KZ0U2mxTemm0mKbalMVFlv5GbjGi21KyZUWW/nvIEy/x77Wftaq8Wor/42F8Wor/0Wk8Wor//2k8Wp7+rXNWvvJpLarrf28UePV+v0l1ZHV+v3d1e5qJ3mtdg5vq92/OrxdvXxj05jyMmUjsMmyaUzV/YKNjNs3cCS8Pct4kmlMARqSaUwtGpJpTFkakmlMhdqRqf200BvJNKZuDcn0q4RLZPrVwSUyApkMGTRwjgwaOEemNQ2cc4k7fztuX+v62KKH0t9O8bnID4xvEz3n+ZNka5r5PpKtaWwbkn+zqf2E3VvZtKaz1Y5X5qzZcTvOfwohFVY7xuF58scYxzc2f4383Vnt8FrtsLyv9hHRfH1E4RXR919Ur5nzYO+MaK0uolhdRKm2iDLnqp4akSyvO0vhe6NBtltcEPn+jdrMsapuwg++w598hy++w599h7/4Dn/1HX6sPPwQX+F/F2Rzch3+UvuuWwi/8l13np+aJ8zLH/6aaal8i/7NWku/T1oq38/ncdrWuhYOV4jD8w9HeYv5+XujpfK933KplesEy6VWriksl1q5/rBcauVaxXCpa+0762+WOj/DiOvyZak7f3icXp3zt3NzZC/k8PpJ7vDl0gfC2jdsBwhb0gE3IRQQ/inClnTLTQhb0kM3IWxJZ92EsCX9dhPCyvtdDhDGyntuHhDiTv4YIe7kTxGmXqX18JoCMr59SWUXYYzPINIYCn94THHcvpCTYnhd/xf+B/NetfidzHsV73cy71Xt38m8V3twJ/Ne/cR9zOPQqwG5k3mvjuVO5r1anDuZ9/rE5k7mAvPLmeNDr2eOD72eOT70eub40OuZ40MvZz7iQ69njg+9njk+9Hrm+NDrmQvML2eOD72eOT70eub40OuZ40OvZ44PvZx5wIdezxwfej1zfOj1zPGh1zMXmF/OHB96PXN86PXM8aHXM8eHXs8cH3o58wkfej1zfOj1zPGh1zPHh17PXGB+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cwFH3o9c3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMax8J2CRzfOj1zPGh1zPHh17PXGB+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cxrH5LbJHN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjlzFd86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhlzOP+NDrmeNDr2eOD72eOT70euYC88uZ40OvZ44PvZ45PvR65vjQ65njQy9nnvCh1zPHh17PHB96PXN86PXMBeaXM8eHXs8cH3o9c3zo9czxodczx4dezTwN+NDrmeNDr2eOD72eOT70euYC88uZ40OvZ44PvZ45PvR65vjQ65njQy9nPuJDr2eOD72eOT70eub40OuZC8wvZ44PvZ45PvR65vjQ65njQ69njg+9nHnAh17PHB96PXN86PXM8aHXMxeYX84cH3o9c3zo9czxodczx4dezxwfejnzCR96PXN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjlzAUfej1zfOj1zPGh1zPHh17PXGB+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cxnfOj1zPGh1zPHh17PHB96PXOB+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczX/Ch1zPHh17PHB96PXN86PXMBeaXM8eHXs8cH3o9c3zo9czxodczx4deznzFh17PHB96PXN86PXM8aHXMxeYX84cH3o9c3zo9czxodczx4dezxwfejnziA+9njk+9Hrm+NDrmeNDr2cuML+cOT70eub40OuZ40OvZ44PvZ45PvRy5gkfej1zfOj1zPGh1zPHh17PXGB+OXN86PXM8aHXM8eHXs8cH3o9c3zoxcynYcCHXs8cH3o9c3zo9czxodczF5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfMRH3o9c3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMAz70eub40OuZ40OvZ44PvZ65wPxy5vjQ65njQ69njg+9njk+9Hrm+NDLmU/40OuZ40OvZ44PvZ45PvR65gLzy5njQ69njg+9njk+9Hrm+NDrmeNDL2cu+NDrmeNDr2eOD72eOT70euYC88uZ40OvZ44PvZ45PvR65vjQ65njQy9nPuNDr2eOD72eOT70eub40OuZC8wvZ44PvZ45PvR65vjQ65njQ69njg+9nPmCD72eOT70eub40OuZ40OvZy4wv5w5PvR65vjQ65njQ69njg+9njk+9HLmKz70eub40OuZ40OvZ44PvZ65wPxy5vjQ65njQ69njg+9njk+9Hrm+NDLmUd86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhlzNP+NDrmeNDr2eOD72eOT70euYC88uZ40OvZ44PvZ45PvR65vjQ65njQ69mPg740OuZ40OvZ44PvZ45PvR65gLzy5njQ69njg+9njk+9Hrm+NDrmeNDL2c+4kOvZ44PvZ45PvR65vjQ65kLzC9njg+9njk+9Hrm+NDrmeNDr2eOD72cecCHXs8cH3o9c3zo9czxodczF5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfMJH3o9c3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMBR96PXN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjlzGd86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej3zbn3oml7MV515iOOTxjC+X/pA2K2tNEO4dOsS7RB2a/rsEHbr4ewQdmvJzBCuntR+1C9el+e167p8X6knjf1nK/WkbP9spXfoyfG10kLw2p9+xJ98x3/LnHTL+Efn8Qfn8U/O4xfn8c/O41+cx786j9/5/hud77+p9v13XraGYJgKf3qU9HQ1H83Z8P6nH4utfbM2XWztO7vpYmuXAb9ZbIjrZm9iSoWrp5Dic5HT+HJOyycZgUyGTO3S5T4ytYuiE8lMS9rIxPWNzPdrZdwoShjXbxRrl2Y+KNYuEH9HcVifFNM4FK6O2xrj9FpiiHsUU3yGkdLXax8Ua5epHiiGoSWxfB/FllT4fRRbkvf3UWzLN9xFUaBoQLEtP3IXxba8y10U2/Iud1HEu1hQxLsYUBzxLhYU8S4WFPEuP6K4PK8dhyHsYMS8mGAUMFpgxL6YYMS/mGDEwJhgbMrBpNdTqaGIcZR1YzOPb3877kWyDM+HWEt4+/J9jJ8cm/Iw93EMTbmYGzk25WNu5NiUk7mRY1NW5kaOTanHMznK8+JlHnc4sl//kOPy/MH+ssTvHKeO9+t53MKeJ/nC8cGm4z24yKbjfbXIpuO9sshGOr5vb4F8sJkL9+2Pt4/yCiX983uXYWqqnXcryZ41mS3Jppp6t5Lsua9nS7IXp/D3aqUXPf9YbS8K/bHaljT3NEzrttpUCmQcl/l5+ce/307aGcd576+rv58K0pJCv5ekQNKIZEt6/mSSZr9eC9KS9vdDvSWf8Fvqa9j++JiGqUDd9OmDtOQqPHFvyYM44j635IY8cW/Jl3ni3rNDvJN7z9r9VO76twBm9MxJ3PVvDczomR9zLz0RXdAodizRHXYs0RJ2LHvuN/92nzJ9+rcI5G8ijya+i3zPPe17ydPXvos8TnCf/IMOfk2hs+LANDode6owzNtNKnysuHBP+3jS+Zq7GN+gpPGTZceeypxlx57KnKXA0oxlx77HnGXHTsacZcfexJxlx27DnGXH3sSaZfXD4ipiGbZH+uHj3zss2cd/zHKW4clynvdYso/bsWQf32f5oMPOrNFhr1XoNDVq77d0wrjNbwvh/b5z5LcsTc3xu5dkz4rOlmTP/cJfkrT7pU9T0w39UO/Zu3yhvow7+3zPbqRMp2d/UabTs7+YYtzoiJS+4RGWsHVYlunt6vS8S/XsRv6E5fqN5dTU5MMLWUrYYdmze/ktyy2WsCzzF5Z7sSzDFsvy3r+W3XWum2GPcSpcHcNzmVHGL9c+ctqzj2o1pz07ulZzKuS0uZz27EZbzWnPHrrVnPbs/FvNKf2K9nJK38RhTufnV7fivH7PaVPTX7vJqWyf0zeAr5zSR3Kd02XayamQ0wpyGubpCSXMc9jJE56zjjyt22DMZZx38oSP9JEnvKGPPOH3fOQJD+ciT03Ns205T3gtH3lCl1fhidPri25pr8fY1JzalvOELveRJ3S5jzyhy13kqam51S3nCV3uI0/oiJPyFGTeEMa5kKdpidPz6iWmnTyhI3zkCR3hIk9NzcttOU/oiBryJNM2GEamuPP9iJ5nFNeUp7T1YSXFne8m9TwBuc48zcOwd98T8uQiTzzX8JEnnmv4yBP9CB95oh/hI0/0I1zkqeeJ1a7yRD/CR57oR/jIE/0IH3kS8uQiT/QjfOSJfoSPPNGP8JEn+hE+8kQ/wkWeFvoRPvJEP8JHnuhH+MgT/QgfeRLy5CJP9CN85Il+hIs8rejyk/I0btMBpnEufm952vI0TXvfs1zR5dXlKe18b3lFl/vIE7rcR56EPLnIE7rcR57Q5T7yxHNCH3niOaGPPPGc0EWeIv0IH3miH+EjT/QjfOSJfoSPPAl5cpEn+hE+8kQ/wkee6Ef4yBP9CB95oh/hIk+JfoSPPNGP8JEn+hE+8kQ/wkeehDy5yBO6/FCe1lDI07o8D3xd12W7VsIndmT2DdhlQDXfgh0R/GPs6/q8PMRhKmBPH33/z6uTDG9j1+PuXhDTay94u3jdiyPFcVvlEPSLx3FYt+SMX6DEzwpAXltUwIMlEvjHLGNIG8t52GFJm//nLBfZWC7Ld5Zjz3f5edriDvM6Flim9XnK/DiMbzfXj8AfKHu+XS7DuKFcvwQ+7/71tG1U4d09ZVRNfE4V+vjbqXT1OG634lHWwtUxPaGkcedWM/Z82241p0JOm8tpz9/Q8JrTlKZtQx3il6R+v3hJ2yqXNBZcU/yQRp8Xx7CEb85m7FlBUi6/Lpeev69Cufy6XHpuz1Muvy6Xnh8rUC6/LZfQ8+MQyuXX5dJzg49y+XW50MSkXH5RLvRHmyqXR1KFpLaXVDqkDSaVPmaDSaXb2GBS6Qk2mFQ6d/6SOg5h2LIqX58l71ydlu37Vik189XOCZvvsHKnuN2PphS+348m3HiLWRWy6jyraSer+PEWs4ohbzGrOPIWs4olb1Et4ckbzKrwpZcWs8p3U1rMKr2lFrNKb6nFrApZbTCr9JZazCpdiBazShei9qw+8kRfwUWeZjoFPvKE968iT2HYDlsKYS9PuHkfecKf+8iTkCcXecJD+8gT37jwkSf8Ux15knnL0zp8z9OC3qsjT9v3vcP0j0geeULvVZGnad4+T1/O6t/yJOTJRZ7Qez7yhN7zkSeeVvnIE8+ffOQJ/+QiTyvPn3zkiedPVeRJpuf3I4LEqXD1Is8RDMvy6jFNy15y0mtQxvAWxv7FMm0/9Rd5A/LX1Y9yoS1CufyiXOjOUC6/KBehXCiXLTfj9HyWMo9RClcvyzRscUzjTnHR2aK4Tisu2nEU12nFRQ+R4jqtuGh8UlynFRfdWorrrOKKtJgprtOKi744xXVacdFFp7hOKy567hTXacUlFBfFdVZx0aGnuE4rLjr0FNdpxUWHnuI6rbjo0FNcpxUXHXqK66ziSnToKa7TiosOPcV1sLjWaauS9YPITnHRoae4TisuOvQU12nFJRQXxXVWcdGhp7gOF9c0b8U1rzvFRYee4jqtuOjQU1ynFRcdeorrtOKiQ09xWRTXEr4V1zzQ56K4DhdXfBXXG+5XcdHnorhOKy6huCius4qLPhfFdVpx0eeiuE4rLloRFNfR4pKwPf75iP97cY185YbiOq24hOKiuA4WV5yfQNa47BUXgp7ieuVGtilNs4zDTrkg0SmXX5QLD5cpl1+UCx6NcnnLzRi23EzzTrnwAJhy+Xm5BH50Rbn8olzo6VAub7nZ+stzHMadcuELI5TLL8qFr4BQLr8oF6FcKJdXbpZhK5dQ6gGPIS3bH5+GYefbjoEuMOV1YnnRNaa8TiwvusyU14nlRVea8jpaXtOwPYD/+PfeL00CXWzK67zymuh6U14nlhddcsrreHmF5a28pqJWe6X+49/LWLp+nuPzCwcf/05pp3zp2lO+jsuXpwiUr+PyFcqX8vVbvjw1oXwdly9PZShfx+XLUx/K13H58lSJ8nVcvjy1onwrLt9hK99l2PmlmfBUjPK9rny3Vf5VvqVoRomvBEkcd566CZ0Hyrfe8p3jq3zXuFO+dB4oX8flS+eB8nVcvnQeKF+/5TvzjTPK93j5RtnKdwyhWI7jdmTNx79l55iAmW+QUY4VlSPfCKMcKypHoRwpx3rKkb4p5XhdOS5v5Rh3TvWY6YNSjhWVI31NyrGicqRPSTleV46vX7p+lGP5+uIz+gUnTvnWW77L+irfdd0pX6F8KV+/5YvTp3wdly+dAcrXcfnSSaB8HZcvnQfK13H58tssytdv+a78NovydVy+fD+V8q23fEtfr175Pivl67h8eepG+TouX6F8KV+/5Uvfl/I9XL5jeE1iGeedU1tW+rKU14nlRd+U8jqvvCJ9TcrrxPKi70h5ZXKz06aO9Pkol1+UC301yuUX5SKUC+Xy83Lh29qUyy/KhW9HUy6/KBe60pTLL8qFLjPl8spNmp8A5xTn7+WS6LtQLq8/PMRnJpdx3Lm7JPoulMsvyoW+C+Xyi3IRyoVy+Xm50HehXH5RLvRdKJdflAt9F8rlF+VC34Vy+XG5LANGmnJ5/eFR1q1c/jGW5FEuaBfK5RflgnahXH5RLmgXyuUX5cIvDSiXt3LZrl7Czle7l5FfDlAuvygXnkhTLr8oF4w05fKLcuGJNOXyi3IRyoVy+Xm58ESacvlFudDVpVx+US50dSmXX5QLXV3K5RflQleXcvl5uQS6upTLL8qFri7l8vrDYftZ2hLi+gdXP4qLHjDFdVpx0TGmuA4W1xiXLeq//i075SWUF+V1XnnRkaa8TiwvOtiU14nlRceb8jqxvOiQU14nlhcddcrrcHmt4yvx6zx+L6+JDjzldWJ50bGnvE4sL3r2lNeJ5UXXnvI6sbyE8qK8zisvuvaU14nlRdee8jqxvOjaU14nlhdde8rrxPKia095nVdeQtee8jqxvOh7UV6HyysOaUt8HHd+xiE4R8rrcHmlt7tXmvbuXjjH68vrQR5TdRd5/MZN5Gek+EnkV5GNvMw75PluyV3k+drFXeRxZneRF8jfRJ7n2HeRx6ifRX59qcp13CGPh72LPB72LvJ42JvIL3jYu8jjYe8iL5A/iXx6qcq07JBH25xEPsrzuUuI87RDHm1zF3m0zT75v+ms6A+NDhpBo0MvWqNDv1ijI9BR6NB31ejQG9XooPE1OuhwjQ5aWaET0coanZ61cgrbF29DSusXOt+vX4bXYetvXZr4+S3K2LOutiXZswa3JSmQNCLZs7a3JdmzD7Al2bPu+yXJ7Ys7y9vvtzaSib37xySX189a4g5J9u59kg867McaHfZYjU7H++Y0rc+7zjjJHAr3qPEjmO2U4DGur59ULp8sO+62mbPsuDdnzrJjRWfMch067vuZs+y4S2jOsmOvYc6yY7dhzlJgacYSffkLltsPxscxDeMby+9Xp3F9Rp7Gt7MvPrmP7PkncQ/D84+nEOI37uiDe7ijJe7hju7Y5/6gI9BR6HTc5fwBnZ67nPP4ojO/qcoXnZ51ZZlOz53IMp2ee4tFOqFn51Cm07O+L9PpWYWX6fSslct0BDoKnZ61cpkOWlmjg1bW6PSslZe0dYL+6hl/obPz10N6fg1zmkb5Zy+o53nTtiR7Hq1sTLJnvf5Lkh/XbyS/PFH6fq2MG3UJ47enTz0P172Res/+4gv1sLPP9zwy9a9fSLzRWXbo9OwvPnaJF515/MMdp2cvYkuyZ99iS7Jnj/NLkob7cc9+6DbqPQ+4+0p9+X525UekXaug+EZn55m7dOxbZFi3uGWUP/tF7trzHEBjkgJJI5Idexxjkh17HGOSHXscW5I9T1P7LUn1DIi150lRvyWpngGx9jz5SSX5oMN+rNFhj9Xo9LxvTtP2rEOmf8xJ+H59WNfnX//4Z/xnv6TnqUXGJDvu99mS7HmqkDHJjvt9xiR77g3akuzZX/yO5PgBa1vnush3lgJLM5Y9+xFrlj27F2uWeB0zlj3Pi/o1y/V1tsvHv9M3luzjv2C5xhfLuHxjyT5ux5J93I4l+7gdS/ZxO5Z0Le1Y0rc0Y9nzjCWV5YMO3UiNDh1GjU7PbkNedx2Zg+zQEegodHp2BGU6PWv8Mp2eVXuZTs86vEynZ2VdpJN61splOj1r5TKdnrVymQ5aWaMj0FHo9KyVF9nOSZAlTl/ofL/+A8Qz8DANb99STeGTZc/K2pplzzrcmmXPqt2aZc8a/w9Y/vUX/8Ey9jypzJxlz/7BmmXPbuOXLKdNYIYpzTsse/Ym1iwFlmYs8T12LPE9dizxPXYs8T12LPE9Zix7ntZozhLf82OWszyXGeb30+I2lgJLM5bs4z9l+dFnC9tff796Y8k+bseyl33879V2M93ssdpe9sLHapvq0k2yrXZal9LVrwPe/zrL/e1q+WTTVNfNmI3AJsumqa6YMZumulzGbJpSu8ZsmlKvxmyaUqO2bNqaCmbMpimla8wGXZxngy7OsxHYZNmgi/Ns0MV5NujiPBt0cZ4NujjLpq2JT8Zs0MV5NujiPBt0cZ6NwCbLpl9dLOP6ZCNjGr6w2fnb6sTO2NaEpRs59qu3bTn2q81/ydFskmmUfjX/bczbmiL2O+ZhmjYyaywwl5ief1tSCIWr5/X5p+f0hi9+Qu/XpNwIvV/3cyP0fm3VjdAF6NdD79gI/g56ml/Ql/TdUrc1CPBWkh2bwV+STNtne/hySNCTZMd28Lckw0ZS4g7Jjk3eb0luYQ/z8p1kW0MDbyWJH7Mi2bHJmobnnU+mf7DZiUTWJ5JxHt8iiXtx66PgY1sDBt1QF6jfQL1jn3Uj9Y492Y3UO/Zv91Fva2RiPdTlefEyjzvU0TCnUF+ef3pZ4g51gfrPqM/jtsh5ki/UHyTRJVYk0RpWJNEPViQ77v/+cnfawv4gORd2p49go7wCT9++ntLWqEY/3Nsa6+iIe8ed6Fu507e+h3svru+xWulqtb04osdq23It8Xn1JGHeWW1Tuixu36OZ0iDfV9vU8DUZt6tlTDuV3NRArI/tanu+vY7Dzmpb+tyWV9tSR6C82pZcu6yvb2rEYShcHbc1xum1xBD3fiKStpt9Sl+vfVBs6V5/F8XU1Kin+yi25I/vo9iUnrmNYkve9T6KAkUDik1p9tsoNuUFbqPYlMe4jSLexYIi3sWAYlPjmu6jiHexoIh3+RHFZXvuNgxhByPmxQSjgNECI/bFBCP+xQQjBsYEY1Pau/DUNDU1aK282qa0bHG1TWnOMGynhgSJO6ttShoWVytdrbYpoVVcbVN6qLjapmRLcbVN9Uen+Rm2yJuW2r96Wbbfr8aXoAtBPsk0pbssyTQ1UMyWTFN6Tvle2I6N2c4AHMf09qfnJ5qmxJ8tGunoW8CprRFYxdU29X324mqb+qVs2n7NOqWldPW4PneGMEyFlo/hc5y2hl+5IN7UbzY8EG9rUFcdxAtN57bmf/lA3tRvZ30gb+pnsz6QC8ivRt6U4fKBvCnXl7aT0mSUUrMjrNPzHISwfhnBNOxBH7fj7GIYly9XP0i25SjvJNmWU7yTZFsO8EaSbY1Nu5VkW4btTpJt+bA7SbZlr+4kKZA0ItmWGbqTJB7HiiQex4okHseKJB7HiGRb88VuJYnHsSKJx7EiicexIimQNCKJx7EiicexIonHsSKJx/khyY+P75NkiuMOSTyOEcm2Zr3dShKPY0USj2NFEo9jRVIgaUQSj2NFEo9jRRKP8zOSaQjD59VpeJ9+tJHE41iRxOMYkWxrlt+tJPE4ViTxOFYk8ThWJAWSRiTxOFYk8Tg/JbmmJ8lxSDsk8ThWJPE4ViTxOEYkEx7HiiQex4okHseKJB7HiqRA0ogkHseKZL8eZ3qdPD79fWCDSnJcX5Gsi7yH/QDZr8UxBtmvwzEG2a/BsQQpQ1PTo28F2a+9MQbZr7sxBtmvuTEGKYD8GcgPyf3U78NQCHv52Hs+L16GcYd6vz7oROpz2kzTPnU800+pbyd/h2EKetjyNnPkdeko0+4S02uNMS2vsKdh/EwSfsxBkvB6DpKEj6w/SU1NCW82SfhfB0nCWztIEr7dQZKEJNWfJFoIDpJEx8FBkug4OEgSHQcHSaLjUH+SAh0HB0mi4+AgSXQcHCSJjoODJAlJqj9JdBwcJImOg4Mk0XFwkCQ6Dg6SRMeh/iRNdBwcJImOg4Mk0XFwkCQ6Dg6SJCSp/iTRcXCQJDoODpJEx8FBkug4OEgSHYf6kyR0HBwkiY6DgyTRcXCQJDoODpIkJKn+JNFxcJAkOg4OkkTHwUGS6Dg4SBIdh/qTNNNxcJAkOg4OkkTHwUGS6Dg4SJKQpPqTRMfBQZLoODhIEh0HB0mi4+AgSXQc6k/SQsfBQZLoODhIEh0HB0mi4+AgSUKS6k8SHQcHSaLjcGmSHtDpINwAnY7ADdBx+GdAn55Tn2SN36GvOPYboOPAfwY9jNsiw/gWyfw5PWvFJRuBxMkagRRA2oDEEf4U5DRtIFP6DhLXZgQSJ2YEEndlBBLHZAMy4oKMQOJsjEDibIxASksgp7ihkTB/ufqx2qZUc3G1TUnb4mqb0p8yvVa7LoWrxzW+em/btX/fHL5dGzcecUqFa9OGPKWv1z6INyVUXRBvStF6IJ6akr51EF+e147DEHaQNyWSfSBvSk77QN7UIwUfyAXkVyNvynD5QN6U65P4/FrBFGUsIQ9xYzNN8nb13lf6pnnc0jnH4cvVD5JtOco7SbblFO8k2ZYDvI/kx80TkkYk2zJsd5Jsy4fdSbIte3UnSYGkEcm2zNCdJPE4ViTxOFYk8ThWJPE4RiRHPI4VSTyOFUk8jhVJPI4VSYGkEUk8jhVJPI4VSTyOFUk8zs9ISpheP+afww5JPI4RyYDHsSKJx7EiicexIonHsSIpkDQiicexIonHsSKJx/kpyTU9SU7/ILnzt2X7aeY4j29xx71VLsPzK59LePt6aIyfOcI91Z8jfFn1OZpwfPXnCC9Zf45wqfXnCK9RQY7kefEyjzs5QtdVkKMlPHO0xJ0coetOydE8bkjm978dH+fLjIJWu4c7+use7miqe7jznOCcPXhb5Af3ubAHfyztFUoKad2uXz6zJGTJQZbwHB6yxLMTD1niuYyHLOHg97L0YINzzrKZcbd5Nh070Ol1d1qGqXAvC2F4jsMJMu0825879pTGJDt2icYkBZJGJDt2W8YkO3ZExiQ7di3GJDt2FsYkO/YhtiSXjl2LMUk8jhVJPI4VSTyOFUmBpBFJPI4VSTyOFUk8jhVJPI4VSTyOEckVj/NDknN4Xh3mvV8WrnicH5KUKW0kl6Fwtd2MqnHFO9WeITxZ7RkSMlR5hvCQtWcIb1p7hvC8tWcIL117hvDolWco4v1rzxA9hdozRE+h9gzRU6g9Q0KGKs8QPYXbM6SPMx4jTYXqU0RXofoU0VaoPkX0FWpPUaKxUH2K6Cz8eYoeJOkAWJHEqVuRxAz8kOS8rBvJFApXj3Mapucfn9PbWYuPu2oY/G58j/j97gqP+Cu/F6dpK58kUvjTYV2egYR1nd7/9GOxld8ubRcrPS228nab7WIr36tsF1t5C8h2sZU3U2wXW3lbwnSxtc9L/+Vi0/NI7BBH+b7YykWR7WLbUlCFxbakoKaPW9Ar7PX7YqWnxbakoIqLbUlBFRfbkoKaXj/P211s7TN7f7dYGZ9/evrQS98X29I+W1xsS/tscbFN7bOlxTa1z04pbosdB/1Pz2k7mnhOaedu1tSm/Bsyy7Dd55dhR4jWPt/1kprZJ9PUdv96bjPJ24SsY5+mlrorR8ns10xLrZhJ1mUjk+K3xdY+5NN2sW1JxMJi25KIhcW2JRFfi53fvn2zLVZ6WmxTqq+02KaEXGmxTWmzKWzfMpnHtfCnl/jU8+Mqb18bkekTTVMSZI2b413T9GeytfZBl+eRKZnA2kdRXlIz+2SaUkKvPz3946HUzp8e0vanx2n4fqOpfZ7j79DEsIUdd0Ri7WMRbRfblG4qLbYp3VRabFO6qbTYptpUpcU2JfsKi619qJvtYvmVx19/+/Jv1DOJ7CbuAvdbuHPSwkncJ3lxfzu/eclcHd6uXr5lid9XecgS5y14yBJHLtyfJRm372z89RXLbznizIXqc8S0Ogc54tSF+nOE068/R3QF6s+RkKPqc0S3of4c0WuoP0d0GurPEX2G+nNEn6H6HDEx8rQc5fqkO387TttXc8dlKf3ttK3yI6Fvq5znz5zSl2gvp/Qx6s7pI0t0MjxkScjSxVl6cO/YV4W4SbZpkgLJD1TPb9DLNBe5y/qSg2/fQRnj7u8W5Hnx8vbL3DHGzxx17KvqydH65LfEeSdHHfsqLznqeRqfmxx17JPc5Khj31NRjsYtR8tOjjp2PW5yJOSo+hx1/Py2nhwtTw+7LHEnRx0/v3WTI/oM9eeIPkP9OaLPUH2Oeh7O5yZH9BnqzxF9hvpz1JQ/mmTL0bQuhatlGsKL+vvV8ufU9SdCbU0frIe63vdMTXkYN9SbciVuqDflM5xQnxxPN62butbjnRzPZPVMvSl174Z6U88F66GuuqRpEKjfQB1vegd1vOkd1PGmd1DHm95BHW96A/XaJ1I3Sr0pvT5MG/UhlQIZZZHnY42Pf8f3vz7vXB/m+PxV7cc/36Ck8MlSYGnGsiltfTPLphTzzSyb0sE3s2xK3d7MsinNei7LdTtKI6wyfGdZ+8x2VyybevZxM8umnmjczBLfY8dSYGnGEt9jxxLfY8cSffljlkt6Bv7xz+k7y9rHgtfEMsbn5SEN8w5L9vGfsvxoMr/+etjxkLUPNXfFkn3cjiX7+M9ZrmH76/Hr3vO7qx/k6XbeRZ7e6DnklzhvP32Jb6duLp/c0bm3cBd6rvdwpz97Eve0QVlSWL9xxwPewx2/eA93gfst3PGh93DHs97DHcd6D3f86lncX0c1pPk7d/zqLdxn/Oo93PGr93DHr97DHb96D3eBuwH3B0s0+U9Zfv0ejuywRGfbsUQ7m7Fc0MN2LNG4P2cZXiyn4lP3sM1FnaZR/rnnL2jce7ijce/hLnA/h/u0pI17fPcWv7n2kSOe39SfI5711J8jPOj9OdLn0k8L3rb+HOGZq8/Rihe3yNGDJV785yxfk8PXNe6wxF//nGXcfkO4pp3fxKx45kN1uctSYGnGEr9qxxI9/GOWcX4u8+OfeyzRrWYs25pzfzNL9KUdS/Tlz1lK0Fmyj/+cZeGMirbmR9/Mkj6uHUv0pRnLtmby3syy597GNA0byyktBZbjus7T8/qPf7+wfPaCk8DSjGXPmsiaZc+a6Ncs1/hi+TZ17cmyZ01kzbJnTWTNsueemy1LaWty680se+65WbPsuedmzRLfY8dSYGnGsmd9OWwT1UcZZS2wXF4/Kp1fZ609p61JW/MczyWpTrKXtmY03kmyrbmLt5LsWVfakuxZVf6W5LiRXHZI9qwpbUkKJI1I9txH/yVJdXqvdD3Z05YkHseKJB7HiiQex4hk1xM9bUnicaxI4nGsSOJxrEh2rCenaTvGbpxkDgWS4we0rcs+puF9ssb3q9O4PiNP47fTCSR0rD5v5d6xVj2XexifUFII37l3rGzv5D51rINv5d6xar6Ve8ca+2Tu07hxn9I37h0r8lu5C9xv4d7xE41bueNX7+GOX72HO371LO5DeOnI+I07fvUW7j1PBb6VO371Hu741Xu441fv4S5wv4U7fvUe7vjVe7jjV2/h3vOU1JDCdipOSOkPfznW89zT35LUf1vS8yRTY5Idq2ZjkgJJI5IdK9tfk1R/pTN3rFWNSXasPo1Jdvz847ck9W/69jz71pZkz5NvjUnicaxI4nGsSOJxrEgKJI1I4nGsSPasJ5dh3EiuXwKfd/96Gjcoy1y4OqzpNVfvHyeQPcj3rD9PJR/Ds30f4hS/k+95OuTN5HvWt/eS71kPn0t+2GbYxXHdId+zfr6XvED+JvI96/N7yff8zOJe8j0/47iXPB72LvJ42JvI9zyB9mbyeNi7yONhzyK/vmbhrjvdg4iHvYu8QP4m8njYu8jjYc8iv0X+QT7tkMfD3kUeD3sXeTzsWeQlbuTn6Tv5nieG30weD3sXeTzsXeTxsHeRF8jfRB4Pexd5POxd5NHzJ5FftmMRPv52Kl0t0/S8+qN/XLh6kde3lF+d/2nZS06K26ze4S2M/YuXMD8BLiGW/vRfJz9sX66OcRy+XP9Xec09j6GnvP64vOSV+Pe716u8cGaU14nlhf2kvE4sLzw25WVTXkvYKS+hvCiv4+Ulr/Ja59JfTxvvJb1/G2nv4hi2vx3DW+WOz8KlD0Phuixc2lgUrsvC5ZssFK7LwuWLQBSuy8LluQuF67FwR57oULguC5dnRRSuy8LlKRSFe7hwU9gAfvx7+XL9o7zotlJex++L6fUNoDTsfANoxKFTXsfvXuMr8Wkav5dXQNVRXufdvQLai/Ky0V7TXnnxDSDK68TyEsqL8jqvvHCOlNeJ5cW3aSiv4+U1vRq2SWSnvPjOC+V1YnnR96K8Tiwvvj9CeZ1XXhPf8qC8TiwvuvaU14nlRdee8jpeXqVnjhNde8rrxPISyovyOq+86NpTXieWF117yuvE8qJrT3mdWF507SmvE8uLrj3ldV55CV17yuvE8qLvRXm9cjNOzy/Pz2OUwtWrLM+//fHPtFNcQnFRXGcVFz0viuu04qLjRXEdLa5lE13rEtad4qLfRXGdVlx0uyiu04qLXhfFdVZxzXS6KK7Tiotvp1JcpxUX302luE4rLjr0FNdpxUWfi+I6WlxzfFbJOqewU1y4RYrraHGt6Rn0GvceXC+4RYrrtOLCLVJcpxUXbpHiOq24cIsU12nFJRQXxXWwuOI8bsW17ExOXvg+F8V1WnHR56K4Tisuvs9FcZ1WXHyfi+I6rbjo0FNcZxXXSoee4jqtuOjQU1ynFRcdeorrtOKiz0VxHS2u9+9z7XXoV/pcFNdpxUWfi+I6rbjoc1FcpxUXfS6K63BxLdu3IpY1fi+uKBQXxXWwuNaN37qOO2MPIm6R4jqtuHCLFNdpxYVbpLgOa660vopr3iku3CLFdVpx4RYprrOKK/FskeI6rLnmrRWxzjuaK/HrH4rrcHG9/fpnnApXjxLnLRSJe32xJBQjxXiwGOO4bMW419FP9MUoLos73W5x0RejuE4rLvpiFNdpxUVfjOI6rbjoi1FcJxXXMvBrIYrrtOKiL1ZFcQV5IgxhHb5c/ciTkKca8jSF598Ok0w7eaL74iNPNDJ85ImeQB37U3zl6R+RPPKEvfaRJ5yqizyNmD4feeK0BR954stFPvJEP8JHnoQ8ucgT/QgfeerZPw3zK08fKy6ylK0RH+a3WNK4F0tIz+76NL39Gmf55N6zH7qRe+jZ35zKfVrSxj2ub9x/c+0jRz17Gy856tnXeMlRz56mlhzJuO1HEsbvORJyVH2OevYyXnLU83PVX+Zoen3nY3r/zsdujub1mdA5vQH8/BpP6Pkx6Y3Yce23YMe034F9wrPfgh0b/mPs8mqzyvtf38W+pK0/vKQ3KTPuEYxBnrxjWML3LGHEPWQJK+4hS0KWHGQJO+4hSxhyD1nCv3vIEnbfQZYEv/TjLM1haxPPYf6SpQdLgeWPWcr2haB5HnZYco//Ocvt8jAvcYcld2I7lnRTzVjOtEgt7pcH7q4zu/5d5Ol8nkN+ifMT4RLX1+ENn4/aZ3qZ93AXuN/CnX7jSdzTBmVJ4dtXemY6iPdwxy/ewx1veQ93fOgt3Bc86z3ccaz3cMevnsV9ezCzpPk7d/zqPdwF7rdwx6/ewx2/eg93/Oo93PGrFtz/Zrl2rMnHNWx/fExD6YTrUdYnlHF+m4o1xr3Il1cJz+PbtZ/f2Vk71uTncl83KxTnHe4da/JbuQvcb+HesSa/lXvHmvxk7tsXZ+Oyw71jTX4r9441+a3cO36GdC735TXPJn7nHjt+hnQrd/zqPdzxq/dwx6/ew13gfgt3/Oo93PGr93BvSb+H9DpWbxiHEnfLfnpqSY+fylHvW6WW9PWdHFvSy3dybEn/3slR4PgvBv221JI+vZNjS3rzTo4tPe84laOuw1NLzy/u5IifseC4DvgZG474GRuO+BkbjvgZG44CRwuO+2Mtx/U58iK8tUND3JuPETfkcUqFa1N8Uknp67WPYOaagllqCmatKZhYUzCpomD2h/zdFcxYUzChpmCmmoKp6Q4caroDh2vvwMu2qw5D2IlmrSqaWFU0qaZopqGqaMaqotm/20hKm6Scg65t4/D81EZ5k9gyfb7DfPo7LKe/w3r6O8TT3yGd/Q4y/Pk7zE8HFtflyzvsuKQhPa1MGIfX1bJnkmJ8nvOcxlD6w1N6rjPI8Hp4Nm0LHXtZaOhloVMvCy3f79cvC328aj70quXIq+bh7PvUPJ7+DuH0d5hOf4fTlcF8ujKYl04+1vPay0JjLwtNnSx0GY7sEst46FXhyKsyZzOEbQ70NI2vgzc+jVXmYIHCi+TIi/a/gvSLkdb5ax9vsJz9BuvZbxD/9A30qd9r5meXdm+Q+X2h4RtkdpDfPFv6uOLz4vn9Ydvz2VKM579FOv0t0nD+W4ymbyHDzluE899iOv8t5Py3mP/8LZbh+clbwrLzFsv5b7Ge/xbx/LdIZ79FHIbz32I8/y3C+W8xnf8Wcv5bzOe/xXL+W6znv0U8/y3O/3SP53+6x/M/3aPF50L9+VwcLSpK/aZRzHxrZB6372DNk3x5i8fL0qGXZb6JUXzZeOxlmfvv9o2xj5fNBXxjCnGjnUL6p2KPmW8tGL+JXPEm8xVvslzxJusVbxKveJN0wZtM4fQ72WShU9Tf0sVJzn+L+fy3WM5/i/X8t4jnv0U6/S3EQqeoPxSLMp7/FuH8t5hO1yki57/FfP5bLOe/xfmaUeL5b5FOf4t5OP8txvPfYr9oh3V72V//Tv/c8jOPZIePRtv2sjgu3162HntZPPaydOhlmUdZw4cIeb3s7dT158vGYy8Lx142HXtZJm/pdf78kJbx28syJFN8nkM/jsPwjeQ6HHvZeOxl06G17T+tK78s88FJaXoLcv72suXYy9ZjL4vHXraf7o9L0+tl4T0B/+n36dp/Fmb9JuMVbxL+/E3053px/8BA27eQ899i/u1bPF62HHvZeuxl8dDdJx67RaZjt8h07BaZeV5YfNl07GVy7GXzsZctx162HnlZyjz+Weftxrqub88hhz1pFtZh+7bOGsK3twjnv8V0/lvI+W8xn/8Wy/lvsZ7/FvH8t0inv0Xm8Y/pW5z/6R7P/3SP53+6x/M/3eP5n+7x/E/3eP6nezz/0z2e/+kO53+6w68/3Y+XhWMvm469TI69bD72suXYy9ZjL4vHXpYOvWwajr3sWJVMx6pkOlYl07EqmY5VyXSsSqZjVTIdq5LpWJXIsSqRY1Uix6pEjlWJHKsSOVYlcqxK5FiVyLEqkWNVMh+rkvlYlczHqmQ+ViXzsSqZj1XJfKxK5mNVMh+rkvlYlSzHqmQ5ViXLsSpZjlXJcqxKlmNVshyrkuVYlSzHqmQ5ViXrsSpZj1XJeqxK1mNVsh6rkvVYlazHqmQ9ViXrsSpZj1VJPFYl8ViVxGNVEo9VSTxWJfFYlcRjVRKPVUk8ViXxWJWkY1WSjlVJOlYl6ViVpGNVko5VSTpWJelYlaRjVZKOVMk8DMOxl43HXhaOvWw69jI59rL52MuWYy9bj70sHnvZsSoZj1XJeKxKxmNVMh6rkvFYlYzHqmQ8ViXjsSoZj1XJeKxKwrEqCceqJByrknCsSsKxKgnHqiQcq5JwrErCsSoJx6pkOlYl07EqmY5VyXSsSqZjVTIdq5LpWJVMx6pkOlYl07EqkWNVIseqRI5ViRyrEjlWJXKsSuRYlcixKpFjVSLHqmQ+ViXzsSqZj1XJfKxK5mNVMh+rkvlYlczHqmQ+ViXzsSpZjlXJcqxKlmNVshyrkuVYlSzHqmQ5ViXLsSpZjlXJcqxK1mNVsh6rkvVYlazHqmQ9ViXrsSpZj1XJeqxK1mNVsh6rknisSuKxKonHqiQeq5J4rErisSqJx6okHquSeKxK4rEqSceqJB2rknSsStKxKknHqiQdq5J0rErSsSpJx6rkWO91PNZ7HY/1XsdjvdfxWO91PNZ7HTO917R9eW9MMu68LFMl67q9LIUvL9s7cdZonsVHOGtd4cS6wklVhZPrbd8VzlhXOKGucKa6wpG6wpnrCqeuu/JY1115rOuuPNZ1Vw513ZVDXXflUNddOdR1Vw5X35XVUUwf8cyVxbNUFs9aWTyxsnhSXfFMv743P142HntZOPay3XtSGOPzCI8QxrkAbVzWaZvuu6zL62CdPWwhTs9DZKbh/RCeYf8o0GE7AOvjSe52dZo/45fK4/9ooT7jn6fpe/yz8/gX5/GvzuOPzuNPvuPf/wKGo/hH5/EH5/HXvv+W4ne+/4rz/Vec77/ifP8V5/uvON9/Z+f77+x8/52d77+z8/13dr7/zs7339n5/rv/zVRH8Tvff2fn++/ifP9dnO+/i/P9d3G+/y7O99/F+f67ON9/F+f77+J8/12c77+r8/13db7/rs7339X5/rs6339X5/vv6nz/XZ3vv6vz/Xd1vv9G5/tvdL7/Ruf7b3S+/0bn+290vv9G5/tvdL7/Ruf7b3S+/ybn+29yvv8m5/tvcr7/Juf7b3K+/ybn+29yvv8m5/tv8r3/hsH3/hsG3/tvGHzvv2Hwvf+Gwff+Gwbf+28YfO+/YfC9/4bB9/4bBuf77+h8/x2d77+j8/13dL7/js7339H5/js6339H5/vv6Hz/HZ3vv8H5/huc77/B+f4bnO+/wfn+G5zvv8H5/huc77/B+f4bnO+/k/P9d3K+/07O99/qz78qxe98/3V+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv5VcH7+VXB+/lVwfv7V5Pz8q8n5+VeT8/OvJufnX02D7/13cn7+1eT8/KvJ+flXk/Pzrybn519Nzs+/mpyffzU5P/9qcn7+1eT8/KvJ+flXk/Pzrybn519Nzs+/mpyffzU5P/9qcn7+1eT8/KvJ+flXk/Pzrybn519Nzs+/mpyffzU5P/9qcn7+1eT8/KvJ+flXk/Pzrybn519Nzs+/mpyffzVVf/7V608vaxrf49+7+Bn1EpfXH47xc62179WWa619X7dca+0awHCt1Z/XZbnW2rWF5Vor1yFzmuNrrUFfq6zpGYfEKW4Xf7zPbtjjukU9yetqCZ9sKtc4t7IR2GTZVK7N1lnC59XrMiw6mw+n8vzL8hZ02GO+zM+Q53V4u3jajTml7S8PQ/xy9QNj5RLRC8bK1acXjJULWy8YK9fMTjDWfnyfF4yVK30vGCs3EV4wVu43vGAUMFpgxMWYYMTFmGDExZhgxMWYYMTFWGCs/RBULxhxMSYYcTEmGHExJhgFjBYYcTEmGHExJhhxMSYYcTEmGHExFhhrP0raC0ZcjAlGXIwJRlyMCUYBowVGXIwJRlyMCUZcjAlGXIwJRlyMBcbaD+T3ghEXY4IRF2OCERdjglHAaIERF2OCERdjghEXY4IRF2OCERdjgbH2sSZeMOJiTDDiYkww4mJMMAoYLTDiYkww4mJMMOJiTDDiYkww4mIMMErtw6G8YMTFmGDExZhgxMWYYBQwWmDExZhgxMWYYMTFmGDExZhgxMVYYKx9xJ4XjLgYE4y4GBOMuBgTjAJGC4y4GBOMuBgTjLgYE4y4GBOMuBgLjLUPKvWCERdjghEXY4IRF2OCUcBogREXY4IRF2OCERdjghEXY4IRF2OBsfZxz14w4mJMMOJiTDDiYkwwChgtMOJiTDDiYkww4mJMMOJiTDDiYiww1j6E3gtGXIwJRlyMCUZcjAlGAaMFRlyMCUZcjAlGXIwJRlyMCUZcjAXGGRdjghEXY4IRF2OCERdjglHAaIERF2OCERdjghEXY4IRF2OCERdjgXHBxZhgxMWYYMTFmGDExZhgFDBaYMTFmGDExZhgxMWYYMTFmGDExVhgXHExJhhxMSYYcTEmGHExJhgFjBYYcTEmGHExJhhxMSYYcTEmGHExFhgjLsYEIy7GBCMuxgQjLsYEo4DRAiMuxgQjLsYEIy7GBCMuxgQjLsYCY8LFmGDExZhgxMWYYMTFmGAUMFpgxMWYYMTFmGDExZhgxMWYYMTFGGCcB1yMCcbKXcyc5vjEGMdUwLjG58VTfAt7Sute2BKegYyyvmVo3PvTYxyef3pMr4vDshf1NEzjdvW8vgL5a73fro7j8gwkhuG1xhD3wpZ1mD6vlvWvEnn+7Tl9prRyR0VKf5/Syt0dKf19SoWUtpbSyl0vKf19Sit34KT09ymtvBtASn+f0so7E6T09ymtvEtCSn+d0rHyjg0p/X1K6R41l1K6R82llO5RcykVUtpaSukeNZdSukc/S6mM6fmnJYZCSj+eWW5PQAd5pXT8fKQ50uC5gzo9mDuo0ya5gXqgk3EHdZoNd1CnH3AHdSz7HdQF6jdQx/jeQR1vegd1vOkd1Kvypo+QqjJuf4c0VeVqHiFVJfkfIVWlhx8hVSUWHyFJfSFVJTMeIVW1Bz9CqmqDeoRU3917qu/uLfXdvaW+u7fUd/eW+u7edc24f4RU3927rtnrj5Dqu3vXNRP8EVJ9d++6ZlU/Qqrv7l3XDOVHSPXdveua7fsIqb67d10zZx8h1Xf3rmsW6iOk+u7edc3ofIRU3927rtmRj5Dqu3vXNdPwEVJ9d++6Zu09Qqrv7l3XDLhHSPXdveuaTfYIqb67d10zsx4h1Xf3rmuW0yOk+u7edc0YeoRU3927rtk3j5Dqu3vXNZPlEVJ9d++6ZoU8Qqrv7l3XDItHSPXdveuarfAIqb67d11n/j9Cqu/uXddZ9I+Q6rt713VG+iOk+u7edZ3d/Qipvrt3XWdKP0Kq7+5d11nHj5Cqu3svdZ3B+wipurv3Utd5rI+Qqrt7L0N1d++lrvMcHyFVd/de6jpP7xFSdXfvpa7zzP4Oqa7zuB4h1Xf3rus8pEdI9d296zqP5hFSfXfvus4DeYRU3927rpMkHiHVd/eu6wyCR0j13b3r+vX6I6T67t51/e75EVJ9d++6fjH7CKm+u3d9v7Vc6vut5VLfby2X+n5rudT3W8ulvt9aLvX91nKp77eWS32/tVzq+63lUt9vLZf6fmu51Pdby6W+31ou9f3Wcqnvt5ZLfb+1XOr7reVS328tl/p+a7nU91vLxeg3TcP6Cmlc30L6+01+//ubx8vGYy8Lx142HXuZHHvZfOxly7GXrcdeFo+9LB162XqsStZjVbIeq5L1WJWsx6pkPVYl67EqWY9VyXqsStZjVRKPVUk8ViXxWJXEY1USj1VJPFYl8ViVxGNVEo9VSTxWJelYlaRjVZKOVUk6ViXpWJWkY1WSjlVJOlYl6ViVpENVsg7DsZeNx14Wjr1sOvYyOfay+djLlmMvW4+9LB572bEqGY9VyXisSsZjVTIeq5LxWJWMx6pkPFYl47EqGY9VyXisSsKxKgnHqiQcq5JwrErCsSoJx6okHKuScKxKwrEq2X9mJcv2si8TZ7aX7T9XkmV8vSwM/0u323GQz4vj9DoBNsQ9/5/is1eQ0tdrH+GMdYUT6gpnqiscqSucua5wlrrCWesKJ9YVTqoqHKnrrix13ZWlrruy1HVXlqvvysvz2nEYwk48c2XxLJXFs1YWT6wsnlRXPEYHOKoPqFajIxkLbzJf8SY2D2JlfL3JnN7e5HcPJB8hrfWFFOsLKV0dkozpOR5EwvdKMjo00TCgsbaALv8CTelmef15icWIpLqI5uoiWqqLaK0uolhdRKm2iK4/KLEY0VhdRNXds9fq7tlrdffstbp79lrdPXut7p69VnfPXqu7Z8fq7tmxunt2rO6eHau7Z8fq7tmxunt2rO6eHau7Z8fq7tk3nIo4D8Pzb8+SSn87zdufTnF8W8D6WMANZyj+bgExTc+rh+nrAnZ6u+Py/EVBDEMqXC1xa1dKfOsbT/PnFyJuOM3REZwAnDycCTh5OAKcPJwZOHk4C3DycFbg5OFE4OTh1K5ib4QTBxSyAqcbhfxYbjea97HcblTsY7nS1HI/gt2WO4fC1R+i/Hn1x3YwFa6e1mfYMsnr2mFvia8wQpim94sf0NvSu06gt6WjnUBvS587gd6W7ncCvS0/4QP62JZPcQK9Lf/jBHpbLswJ9La8oBPoAvTroeNIb4COI70BOo70Bug40hug40ivhx5wpDdAx5HeAB1HegN0HOkN0AXo10PHkd4AHUd6A3Qc6Q3QcaQ3QMeRXg99wpHeAB1HegN0AfoJ0OcX9GX5Dh31cgL0VbYlrrN8h456uQE66uV66IJ6uQE66uUG6PTTb4BOP/0G6AL066HTT78BOv3066HPVc2s/n71Mm8/MF7mtzZGmj/jF+fxVzUN+0D8VY3OPhB/VXO2D8Rf1VDuA/En3/Evg/P4R+fxB+fxO99/rz8h3zh+5/vv4nz/XZzvv4vz/Xdxvv+uzvff1fn+uzrff1fn++/10w6M43e+/67O99/V+f67Ot9/18r33znNzyFiy8fN8lv8sfL9txh/5ftvMf7K999i/JXvv8X4K99/i/FXvv8W4698/y3GX/n+W4y/8v23GH/l++/HM7vwefW6DMt7/DvPBafntZO8BR32uCzb3I95Hd4unnZjTmn7y8MQv1z9N8ZU+W2kDozTkNLzL3/hsXv1ukW8blfK9Mm78ttec7wrv003x7vybaU53myDV/JOQ+W2uTneldv85nhX3pZojnflbZTmeAu8L+WNv7yWN/7yWt74y2t54y+v5Y2/vJT3iL+8ljf+8lre+MtreeMvr+Ut8L6Ud+16MMRli35IOu/xg9wzjnV5+1nrtPuEfHj+qnWW4cu1DzK1K7fbyITaNdZ9ZGpXQ/eRqV233EemdoVxHxmBTIZM7V3h+8jU3r+9j0ztndb7yHSsgRd5kkmxcK2E+YlRQpQvpuNvjlO/O1ncLn7/ru3+tWEK21mpIsXjdMbldZzOW9D7V0vcfnUjMbxqfZo/a/2G02/J0W9z1O/u7idH/eoMPznqV/H4yVG/2stPjvrthLrJkfTbk/WTo367w35y1G+f2k+O6DPUnyMhR5fm6EGdzsEd1OkF3EEdd38C9VrGiakz3JLQNeg393Qjus39TJej39zTPek393Rl+s093Z5+cy/kvtvc08vqN/d01PrNPX29fnNPX6/f3NPX6zb3tQ8TJPcn5p6+Xr+5p6/Xb+7p6/WbeyH33eaevl6/uaev12/u6ev1m3v6ev3mnr5et7mvfUg5uT8x9/T1+s09fb1+c09fr9/cC7nvNvf4+4ZzP79yvyzfch/R+e3mfpXntWGd5Xvu0fn95h6d32/u0fn95l7Ifbe55/l9v7nn+X2/ucff95t7nt/3m3ue33eb+9RvXy+F5xrTPBeunYd1G6MyDu+V8jkZJfXbI7Pl2G+/yZZjv70bW47S794Yn8OgxuFtDm5mc3wd5vnx7HAtbY62RxGnjhsWfpLUcWfBT5I6bgH4SVLHXt1Pkjo21U6StAxDx99q8ZOkjr9+4idJHX9PxE+SOv5Ch58kCUmqP0l0HC5O0gM7PYRbsNMVuAU7Pv8M7B5+bPORfPoH/SZ/pC/RcfLpd3ScfPooHSef/kzHyReS32/y6Sd1nHy6Wh0nn95ax8mnw9dx8unw9Zv8QIev4+TT4es4+XT4Ok4+Hb6Oky8kv9/k0+HrOPl0+DpOPh2+jpNPh6/j5NPh6zf5Ex2+jpNPh6/j5NPh6zj5dPg6Tr6Q/H6TT4ev4+Tj81tOvjYcaRkEtd9w8tUTdD+Sj9rvOPmo/Y6TLyS/3+Sj9jtOPs/zO04+z/M7Tj4+v+Pk8zy/3+TPPM/vOPlN+fwlyJb8tZjPNDyvDmmeClfLMDxrRT7ul29XL58km9pAf0VyGoZxCyQWuf9u3Jjt+aZzUztdq1lamtqSms1SU0+Hms1SU49xms1SvzrMU5aELDnIUlNPMJrNUlOPGprNUlPPBJrNEr0HD1mi93B1lv7mvtJNuIc7/YF7uOP4T+Hu4wv7K52EnrMvZL/j7NP56Dn7dFR6zj6dmp6zTweo5+zTWeo4+5H+Vs/Zp8vWc/bp9fWcfXp9PWdfyH7H2afX13P26fX1nH16fT1nn15fz9mn19dx9hO9vp6zT6+v5+zT6+s5+/T6es6+kP2Os0+vr+fs0+vrOfv0+nrOPr2+nrNPr6/f7I8Dfr/p7KuzV8YBzd9y9vVzOccBzd9z9tH8PWcfzd9z9tH8HWd/5Pl+z9nn+X7P2cfv95x9nu/3nH0h+x1nv+Ne34fdfQYyzmvhalnTMxCJMrxdvXyS7LhvZkyy4x6UMcmO+znGJDvujYzrRjKEEslfziozPed4DB33MBxlqeNeg6MsddwTcJSljr27oywJWXKQpZ69sJ8s9eyz/WSpZw/vJ0s99wf8ZIneg4MsTfQers7SgzvdhHu40x+4hzuO/xTuPn6ZMwnZ7zj7dCh6zj6dj56zT0el5+zTqek5+3SAOs6+0FnqOfv0t3rOPl22nrNPr6/n7AvZ7zj79Pp6zj69vp6zT6+v5+zT6+s5+/T6Os7+TK+v5+zT6+s5+/T6es4+vb6esy9kv+Ps0+vrOfv0+nrOPr2+nrNPr6/n7NPr6zj7C72+nrOP3286+/qMpQXN33L2C6fuLmj+nrOP5u85+2j+jrO/ovl7zj7P93vOPs/3e84+fr/n7AvZ7zj7PN/vOfuV+/05zc8UrXEsZH9a45bP+Bb2lPYojtP0PDVz/Lj89afHnYs/QD+Rxzce8/SJsXLj7ARjrNyBesFYuZXzgrFyT+QFY+XmwgtGAeNPMM7zc4XzsoexcrnrBWPlz4irwbhJ9XlNOxgrf9jqBSMu5mcY03OLWYZpByMuxgJjwsX8FuM47mDExZhgxMX8COOyPoEscdjBiIsxwShg/BHG+Ax6SbKDERdjghEX8yOMH89dnmGMcQcjLsYEIy7mtxjDsoMRF2OAMQy4GBOMuJifYUzb4/JBdjDiYkww4mJ+hDFuH+q4s1OHQcBogREX8zOM0/TEKGEHIy7GBCMu5rcY52EHIy7GBCMu5kcY0/i8Nu3J7xEXY4IRF/MzjNMTSJJxByMuxgQjLuZnGLfv8KRl70MtYLTAiIv5LcZ1pzUx4mJMMOJifoRxHObnV8rGYdkR4CM+xghkx05GwjOQUd5+jrYLchrjE+T08WR6uzgse1FPwyrbGuOruTb9td6dsMen25zWN7v519V/Jyl07JP8JKljF+YnSR17PD9J6thB+kmSkKT6k9Sx+/WTpI69tZ8kdezc/SSp466AnyTRcag/SRMdBwdJouPgIEl0HBwkiY6DgyQJSao/SXQcHCSJjoODJNFxcJAkOg4OkkTHof4kCR0HB0mi4+AgSXQcHCSJjoODJAlJqj9JdBwcJImOg4Mk0XFwkCQ6DqckaftR4zTOayFJ8TVsJobhtcb9gTCyDs+Uyjq+zjaY5vSZUvoTraV0ppvRXErpfTSXUjolzaWUvkpzKcU7ukvpdtDhxz+XnZSieL2lNA7PX51LDMP3lC4o3qpT+kgSGtZBklClDpKEzrw/SZVMcX6FEcI0vV/8KBWhVCiVn5UKzzIplR+WCq6YUvlhqfBcl1L5YanwdJlS+WGp0MOjVH5WKiu9QUrlh6VCh5JS+WGp0CelVH5YKnRrKZUflopQKpTKz0qFbi2l8sNSoVtLqfywVOjWUio/LBW6tZTKD0uFbi2l8rNSiXRrKZUflgrdWkrlh6VCt5ZS+WGp0K2lVH5YKkKpUCo/KxW6tZTKD0uFbi2l8sNSoVtLqfywVOjWUio/LBW6tZTKz0ol0a2lVH5YKvRVKJVnqcyvUlmW76WCA6JUPhOzyvPasM7yvVRwQJTKD0sFB0Sp/LBUcECUyo9KZRpwQJTKD0uF76tQKj8sFb6vQqn8sFToq1AqPywVoVQolZ+VCt9XoVR+WCp0a39WKiE8D7GeprdRTPulYntA9jTQJ3WQJDqUDpJEb7D+JI105RwkiX6YgyTRiXKQJHpADpIkJKn+JNH3cJAkOg4OkkTH4eIkPbDTQ7gFO12BO7AHfP4Z2F38omAK9A86Tj59iY6TT7+j4+QLye83+fRnOk4+fZ+Ok08/qePk09XqOPn01vpN/kSHr+Pk0+HrOPl0+DpOPh2+jpMvJL/f5NPh6zj5dPg6Tj4dvo6TT4ev4+TT4es3+UKHr+Pk0+HrOPl0+DpOPh2+jpMvJL/f5NPh6zj5dPg6Tj4dvn6TP+PzW06+OtJlmlH7DSe/cELkLCS/3+Sj9jtOPmq/4+Sj9jtOPs/zO04+z/P7Tf6Cz+84+TzP7zj5PM/vOPl0+H6WfJm25EscC8mfxu2YzWmUN357QMZVnrDHdXm7eC/oReTz2mWe3i99ZFPIZkPZpAfnK5tbYpa37WHLJk01Z9l8bpzrsPPZpEv2w2yO6ZXNUMjmPIxPIPMg63s2H9RpT91Bnb7QDdRXGjJ3UKcTcgd1WhB3UMf730FdoH4Ddbz0HdTxvHdQx5veQR1vegd1vOkJ1CWluFGf0/9Su2oyp2cXWxYZvqUoYmSrTxGut/oUYZGrTxF+uvoUCSmqPUU49epThK2vPkX0AKpPEQ2D6lNEd6GuFE3fUpToLlSfIroL1aeI7kL1KaK7UH2KhBTVniIU3YEULYUUjbJ9C3uUKeopWgZ5/ullSIN+8Qel4Xn1x7/n5Z8ZlQEB2FpG0YutZRR52VpGUaOtZVTIaGMZ5Uma64ym7xnlwVtrGeU5XWsZ5bFeaxmlZ9RYRkd6Ro1lNPS8jw4xk9EHmp43pAKanu/sOpqpqVtknGVDsw4lNOPrZjOG15lp019BfbtatlPhRF6n1UzD3rXT+DraJny59sG8qca3E+ZNtaadMG+qeeyEucD8cuZNNWCdMG+qReqEeVPmywnzplydE+ZN2UUfzAUfej1zfOgPmY9hYy4F5ndN8BTB4baUTbxzS9kUstlQNvH7LWWTTkJL2aRH0VI26X60lE36Kg1lc6Zj01I26QW1lE16QS1lk15QS9kUstlQNukFtZRNekEtZZNeUEvZpBfUUjbpBTWUzYVeUEvZpBfUUjbpBbWUTXpBLWVTyGZD2aQX1FI26QW1lE16QS1lk15QQ9lc8Zuusjm/srks37MpZNNRNld5XhvWWb5nE03bUjbRtC1lE03bUjbRtC1lk+ebDWUz8nyzpWziN1vKJs83W8omzzdbyqY0lc20/en0np/dbE7bX5a3MPaP3969dJzDJ8SmWjBp2gY3DksJYhyXZyAxDKlQuB8ybTsbKYa3j9ucPkk21f64lWRTrYdbSTZl+28l2ZTlvpNkasru3kqyKat5K8mmbN6tJJuyWLeSFEgakcTjWJHE4+yRfLDBteTZ4EPybDp2Fq/v7sUwh8Ld6a6vEM5Dx47FSYY6dkJOMtSxw3KSoY6dm5MMCRmqPEMdO00nGerYwTrJUMc+2kmGOnbzTjJET6HyDI30FGrPED2F2jNET6H2DNFTqD1DQoYqzxA9hdozRE+h9gzRU6g9Q/QUas8QPYXKMxToKdSeIXoKtWeInkLtGaKnUHuGhAxVniF6CrVniJ5C7RnCD92eIfWw0HlCy92dIf0Ij3lCy9WeISFDlWcILVd7htBytWeI50O1Z4jnQ7VnCD9UeYaE50O1Z4jnQ7VnqCot9wipKvHyCOne3Xoq1fEYt9Ico8Ttagmf8Sff8c+D8/hH5/EH5/FPzuMX5/HPzuNfnMe/Oo/f+f47O99/F+f77+J8/12c77+L8/335tHjfx6/8/13cb7/Ls7338X5/rtcvv9O4/Tsu0xjGgp/O0xh++aHyFho/9gegjqvA3DycEbg5OEE4OThTMDJwxHg5OHMwMnDWYCTh7MCJw8nAicPB4WchxO7UciP5XajeR/L7UbFPpbbli718eOa62d7An2ObeloJ9Db0udOoLel+51Ab8tPOIHelk/xAT215X+cQG/LhTmB3pYXdAIdR3oDdAH69dBxpDdAx5HeAB1HegN0HOkN0HGkl0NfBhzpDdBxpDdAx5HeAB1HegN0Afr10HGkN0DHkd4AHUd6A3Qc6Q3QcaTXQx9xpDdAR6efAV09hnoZUS8nQNfP6VpG1MsN0FEvN0BHvVwPPaBeboBOP/0G6PTTb4COTr8BugD9euj002+Afr0j/WhHPKGHGErQX7/J/HjdWoJu+uPlJazAycOJwMnDScDJwpkG4OThjMDJwwnAycOZgJOHI8DJw5mBk4eDQlbgdKOQH8vtRvM+ltuNiv17udKWLvXxPQRpS+86gd6WjnYCvS197gS6AP166G35CSfQ2/IpTqC35X+cQG/LhTmB3pYX9AF9xpHeAB1HegN0HOkN0HGkN0AXoF8PHUd6A3Qc6Q3QcaQ3QMeR3gAdR3o99AVHegN0HOkN0HGkN0DHkd4AXYB+PXQc6Q3QcaQ3QMeRXg99RaefAV0/3mdFvZwAvfAL1hvmoQN9Rb3cAB31cgN01MsN0Omn3wCdfvr10CM6/Qbo9NNvgE4//QboNzjS9Lx4mt5OSfrrbz9CWuoLaa0vpMsVkAzT82/LMJc+LdrVjwUk5wu4fnLz7xawxFk+r/4o4PHtLz/CH32HH3yHP1UefhqeG9IH6vVb+OI7/Nl3+Ivv8Fff4Ve+85bCr3zf1cNfh9p33UL4te+6hfBr33UL4bveddfB9a67Dq533XVwveuug+tddx1c77rr4HvXHX3vuqPvXXf0veuOvnfd0feuO/redUffu+5Y/a4rW5sqzd/Dr37X1cOvftdVww/V77p6+NXvunr41e+6evgnb1uPN+HLT39dbfzMdgrPQ5XDNM3vFz+g8+WnG6Dz5afroTc2CKQW6OO0QQ/Ld+h8+ekG6Hz56Qbo/BznBugC9Ouh83OcG6Dzc5wboONIb4COI70BOo70euiMALoDOiPOr++93DAYBejCiPMboC9Av/6evgL9eugR6NdDT0C/HPoNg1GAfsNgFKDfMBgF6DOO9AboAvT/r72z25HetsHwvfR4D/RDkdK1FEXRpkERIGiKNCnQg9x7Pbtr2V9MjcZvZmY9FnsQzPbzY0l8aYmiZPn5RrcZ6RcY3WakX2D0p8fpIce5qdH52Ll3KinPhsm+1KtL0uxS4rw5lBwvlonlhRM1z/+2hCm0UyFvCh1coWAKHXscev4nLkyhnQqRKXRwhZIpdHCF2BQ6uEJiCh1coWwKHVwhyykcXCGxnMLRFbKcwtEVspzC0RU61XxoOVo3ZnEdhfxU4lxrH1Z6Xiq1uZp8mG1Oq2tdPFIOT041dxpezVPNs4ZX81RzsvOr2Rk3TzV/G13NfKq53vBqnmpeOLyap5pDDq/mqdawh1eTTM0TqWm5oDOpabmgM6lpuaAzqWm5oBOpWU4135ycs6q5qnZDTarve3iSxTTFa7cONUMaY86LHVmr9Ytsmy6nmp6a+PvEP9Vs1sTfJz6Z+CcWvzPmn2qubOLvE/9UU2sTf5/4p5qJm/j7xD/VxN3E3yf+qfZ8mPh7xM/uVFtETPx94luGb2DxLcM3sPiW4RtYfDLxxxXf5vm3ie/z6oA47ogfly/ZRr/6Nq2+/PsaKwHZWVbAXOVGV7EcgrnKba7iLeNgrnJbrOItP2GucqOrWDbDXOVGV7Hch7nKja5C5irmKre5iu2cMle50VVsn5W5yo2uYtlac5UbXcWyteYqN7qKZWvNVW5zlWDZWnOVG13F8ipf7yqeF1dxpSM+SZmvnn4uNYmpfEpKJumLSTrlrGZJ1xZZJLU8xctJGmKVNAZFUssnnE5Sm/efTlKbn59OUptHn03SaPPd00lqu4heTlInVdLgFEltt8/pJLXs0ekkJZP0bJJa9uh0klr26HSSWvbodJJa9uhsktLB56US8nxrEdeR1HOY1528rETyUbW7l+oAIUjn6rDYPYQoHbu/yGtwdPAprKn/UPUPPts19R+qPpn6Z1b/+j4pOvgc2tR/qPoHn26b+g9V/+Azc1P/oeoffBJv6j9U/YPvFjH1H6l+OvjGElP/oepbrm9k9S3XN7L6lusbWX0y9QdWf+D5vnN1bdXl3tWT9ar6RP5V1L+e508Dz/dN/TTwfN/U54Hn+yOof33c54Hn+6Y+DzzfN/V54Pm+qc9k6g+s/sB7e0x9Hnhvj6nPlusbWX3L9Y2svuX6BlZfLNc3svqnmu+Lqy9bCpeOnjnPlvHOdcU/46s8Qib+uOKfarZv4u8T/1STfRN/35h/qrm+ib9P/FNN9U38feKfaqZv4u8SP59qom/i7xP/VHt6TPx94p9qS4+Jv098y/ANLD6Z+OOKbxm+gcW3DN/A4g88z68XT2ubPe3P+O5OGXiaP7z2A8/yh9d+4En++bW/Pt6Xgef4w2tPpv2w2g88wx9e+4En+MNrP/AOnuG1H3gDz/DaW15vVO2Ls7zeuNpbXm9c7S2vN672z5/fJzfXPiQqvXtPmcf5ahfPkUgvjs3ozze6mNGfb/RsRn9+n17M6E83undm9Ocb3ZvRn2/0YEZ/vtGjGf35Ricz+vONbjPSLzC6zUi/wOg2I/0Co9uM9PlGD6rRyc25AwpL1T1FzSyxzB9L8uQXs8Tp6o8iysOLiO7xRfjHFxEeX0R8fBH0+CLS44vgfUV8QIJAGYH0ZyrWfkHyFiIHQPonIEnmXpbWZycW+oQiAhECqa6Q/DxmpBC/gbQVr+UlsJwXV/D5swR+eAny8BLyw0sojy5B/y7RXUvwDy8hPLyE+PAS6OElPPyZ5oc/0/zwZ1p0X6L5DNxEsu0u9YMfk8wQk1MgQUrSu5w0D7uJSYH0XiSHGSpxC+lnG/Ugj0ABgSICEQIlBNIfhewqpOiUBYEyApXrEDulTfprsElKhbICqR7BfrYex6JAoVOS9jzpb2x1HkL9VZ8ehDzu+kZTH9LcKB94Ywpx+h7FPuYxLGBYxDDCsIRhjGGCYRnDGl6SpWIlbDHv+hgrmMewgGERw3QviW7uQqafWcEShjGGCYZlDCsQFhyGeQxr6MZV7ihRwXRLLjGeT6Q8AaFhklKfN3Jpi0XXx5THNHoMCxgWMYwxTLck1c2gUxLDbzE9DdLHdEsSu4qx0ikQNbClbeIUrNG2VF2ZsuKTyWGYxzDdS6jU73BMCXYFixhGGJYwjBtPd9UtBeUxTYJhGatkgTB2GOYxLED9pJ7J6GOEYQnDMtRzMdZzCdZziUcw3xiEpzG09ng++mU8jZw/QY+CAQUjChIKJhRkFBQUzCioeymnWL2bE4ct2IhVbgA9CgYUjA1Q/AJmDdR1ZM61N+Tp0VNAXUeWsFRViBUwo2ABwUakdAPoUTCgYERBaoB5tY+gKE8HJRRkFGx4Tl4eZM7rxcwKZhQsIJhanrN6rLL/9rFSVmmDUL0+CPve9VN6eYmzUilKxfxRKxaOWrF41IrRUSuWjloxPmrF5KgVy19VsdrBJl5NqpaKlTtVLMZVxUrvesr1q5nTb6/ERUxfVLG0bOjJooyenI5aMT5qxeSgFZNWdJHWez810KNgQMGIgoSCCQUZBQUFW3FplMXBkjKHkgKC2aGgR8GAgg0HKMtQctmMo4AJBRtylGUh5LJFYwvqS+f+kkKawcuEWQEDCkYUJBRMKMgoKCiYUbA0QM4LmLfRSGis/V+GkAVc7T7Re/7LWTefl19ewahX+6zur6/7j3JYZXb8XCV/vCqF41UpHq9KdLwqpeNViY9XJTlclRq7TaZ/qElaWb9UVDu0xg4QCSkuoNYTNvaA3AAmFGQUbPT2IS69faC4BYNDwUafHHhVVSXACI2FoRvAiIKEgg0do6vBsMQQFJBRUFCwESdEWoFJeToaC0N9sLEwdAPoUTCgYERBQsGW58Q1yArIKCgo2PKcJW01/VaejlhAkBwKehQMKBhRkFCw5TmyAosyBBCjoKBgw3NoNSJTUMaOxlJUH2wsRd0AehQMKBhRkFCw4Tnk1iApIKOgoGDDc8LyxTehmH7rZReXF6Kn39qwmMqdCoqr/TWpm/Pvpj0DuztVLNFSMVa8gv0DLKAWFJ5VUHxWQfSsgtKdCqrv106/S7iDl/KdKlYWC0ydg1KQ3N8CekH5WQWVJxUk7lkF3aknIS9LQTH+cS+VO/U8FFcWICWql/gAC6gF0bMKSs8qiJ9VENCTfIAZBQsIZgdme7JHwYCCaA4tozm0jObQMppDy4KCGQQba23dRbrQWmtzq1PZ159MXsCIgoSCrRXM4lagEro31tpuAAUFMwoWDIyNtbYbQI+CAQUjCOpJ1ESziydahvSPk6wmhgFGACYDTNnP6LnSDuMBJgBMBBgCGMAPYuNAg3ryxmo3f2UEYDLAqH7A9aQ4XoW2M6NnPjuMB5gAMBFgCGASwDDACMBkgAH8IAF+kAA/0PNs0/SiHpUoibZUa0fWktVz2+eBHUR5iAoQ1Qh+So22suctRRCVIIohSiAqQ1RBqFaOokN5iAoQBfmGQL4hkG8I5BsC+YZAvtGYCJdly3ChLdWYBfco/aT27Odc0TQPXM24inqs6/KpqRxX7/vrV1NejnHMYXXvVD6rRMerUjpelfh4VZLjVSkfr0rlcFXSzwb72ir541UpHK9Kx+u9yz1671DP58u02u/YuNrzcqr46mQJ/ZxwEjcPiCTrF3VqA9KrN4BfvQHy6g3Ir96A8toNIOdevQH+1RsQXr0B8dUb8OIjMbkXH4nJvfhITO7FR2JyLz4Sk3v1kdgffhyoe+qmn6w04Oi9UGdGRv5QvdBHlQ7Vr3xU6VA9xUeVnv/sH+QDXUs1Qtgux1FwZhjdMN4MoxsmmGF0w0QzjG4YMsPohklmGN0wbIbRDSNmGN0w2QyjG8YiX90w0SLfhmEs8m0YxiLfhmEs8m0YhswwumEs8m0YxiLfhmEs8m0YxiLfhmEs8tUNQxb5NgxjkW/DMBb5NgxjkW/DMGSG0Q1jkW/DMBb5Ngxjka9umDRuHJMWwzBvDTPsqHT9NWJKw45KPcMMOyr1DDPsqNQzzLCjUs8ww+ZjeoYZNh/TMQwPG8f0DDNsPqZnmGHzMT3DqJFvdG7+EGN0qzOd9KZ6z8sZzp5DzzRh+t8yTVkdqhjzZ6XoHpVKKSyVyr6n1303vutnx7xWE/j1myCv34T8+k0oL98E/fCj12qCf/0mhNdvQnz9Jrz+6CwHG50/KnWw8fajUgcbQT8q9RVj4muk+KWYaRqmyc5M0zKNN9O0TBPMNC3TRDNNyzRkpmmZJplpWqZhM03LNGKmaZnGouGmaSwabpmmWDTcNI1Fw03TWDTcNI1Fw03TkJmmZRqLhpumsWi4aRqLhpumsWi4aRqLhhumSc6i4aZpLBpumsai4aZpLBpumobMNC3TWDTcNM3Icc3Vt7eSH3iEur69N/mBR6ieaQYeoXqmGXiE6plm4BGqZ5qB8zU90wycr+mZZuC4pmeagfM1HdOEgfM1PdMMHPLFMO/7nqZQaWuagUO+nmnITNMyzcAhX6wvdk5W2s68w8AhX880A4d8PdMMHPL1TDNwyNcxTRw45OuZZuAEaM80I0fDHdOMHA13TENmmpZpLBpummbYg6w6M6hxDxbvGGbcg8V7hhn2IKtOHzPuweI9wwx7hGvPMGSG0Q0z7BGuPcMMe4RrzzDDHuHaM8y4kW/HMONGvtcNM+5R9D3DWOTbMAw93TD7Dh2TMl89/VzqPx86lr7gyPidp6Z5mhuQfVEawEdvQIi1ATEoDZBXb0B+9QaUF2/AFxw9fucG+FdvQDh6A64fPpk4vnoDjj4Sdxtw+JG414DDj8S9Bhx+JO414PAjca8Bhx+JOw3Qj8v1ru6O9S6XzSxCP8+2S6lqT8uYc8DsvYQtVRBKP6a0S3mICjqVeaa+EWqm1O7TU/AzRUEpiyFKICpDVEEo/SCtLuUhStdryvHPVBK/pSJEEUQliGKIEojKEKX7xmTbmWK/eWmX9WMlupSHqABREaIIohJEMUTpKsdYqZjClioI5R1EeYgKEBUhiiAqQRRDlEAU5Bse8o3Q8A3Olcp+S3mIChAVIYogKkEUQxQSOXDIEIVEDhyRyIH1NPLUd81ZeaYto7aq8Oy6RXjLlP2Mnh3rMB5gAhDFs5546VIEUQmiGKIEojJEFYTSP5/UpTxEQb4hkG8I5BsC+QY032V95nq9t9DnrSXMs/dCWyYDT77+/YBOOQQwCWAYYASwAdAzZ6Bn1mepJc9+8M1S7sx4gAkAEzvt0RgCbJAAhgEG8IMC+EHZ7wfiHMB4gAkAEwFmpx9Mf/jLhTGphU0xwuyp08/Vewn8/mnSqG9C6FIJohiiBKIyRBWE0oPELuUhKkAU5BsM+QZDvsGQbzDkGwz5BkO+IZBv6IHiFJ3NaWyeOootpeo19XZzInDqkHhLJYhiiBKI0vUqpVyj9GBs6l+lUrK1fCaIShDFCKUHFxJdteF6s1mlCKISRDFE6b4RY92dNw0FWypDVAEo0kONLuW7FIct1dArL1TJWypBFEOUQFRGKD0hLRSqR9HqhNFKCULpCU7JaU5iSWaF0p9Kqim9y1ejtxRBVIIoXWWue2Xlmw/dz5RAVIaoglB60rFLeYgKEBUhStcr5eq90+rpltJtKHVxSfI23iD9tc0u5SEqQFSEKEKeZf09qi7FECUQlSGqIFSC+kN913+XChCVus+X4huJIUogKkNUoz+suYBLNnRD6bO2S9JjpsTTlkoQxRAlEJUhqiCUOIhqjClFFiptqQBREaIaeqXqUesDGCsl3b7Xf/tUKidkUE51dZOy4reNxH72fK2HF2i8y9B4l6HxLkPjXYbGu8bs9Ro1/RUu1zZWtHx0dTnGR7+RrbGk1cUChkUMIwxLGMYYJhiWMUxf9uQU56TK9Hs7L23s5exiHsMChsUGJn7B8hYjDGtYkmug7qfl4k1839hlOa32Lm2b5nEbzGNYwLCIYYRhCcMYw6SBLXuFp4XjzYPT2G3ZxQqE+caGy2l5uj7enL3fch7kAsi1PGX18GQfelFCEKrXhyk+7l2fUq4ip1TKtl500Hqlg9aLD1ovOWi98kHrVY5ZL+8OWi//VfWq/Wpi57b1Cneq17Krd6pX6c/W3LJn8/f3f69XPGi98hfV6/rs1vtyzHoFd9B6+YPWKxy0Xq14Iq3iS1Y4BjkBuQxyBeOiAzkPcgHkGv1pjrL41XZ12UcCuQRyDHICcg3dyzLOcuFNztKTA7mGDoWXehbZxg/66o+XqYOdOfHbXSpeX/+5gcsgVzBOXwW6gfMgF0AughyBXGpwy7s84vM2rkstf1n8THzpZdW51HCIy+p9dZ/Vl9vrG6E5rLJm/rNGcrga5cPVqBytRuwOVyN/uBqFw9UoHq5Gjf4o1K2Zl9+bFUXfeH1KQl1SnH4r/V9juanPeZALINfo30Nc+vdAccsxyDV64cCreirxR2MZqM8VjMsO5Br6RVfjY4lhO69vLAX1uQhyjXgg0opL2+ehcZRIn2OQE5DLIFcwrrHc1eda/hLX3DYuKwHkIsi1/GXJ702/t89DSSDHICcgl0GuQFxwDuRa/iIrrrgtF0AuglzDX2g13lKIWy6BHIOcgFwGuYJxjXWFPtfwF3JrjrZcALkIcg1/CXkZbymm33p5xOVM4un3dtwLPt2pnPp6w/Q7dddBevnN4PlO9VrOD6PIij/IA9qvlZOfVE55TjnBPakcf6dyhJdySvjD/hnCnepVlvZPfcK2nHj/9qvl0JPKSU8qh59Uzp36D/KylBPjH/fPO/U3FFftp7Qtpzyg/Uo50T2pHP+kcsKTygH6j3eOQC6BHEP5mhAF5DLIYfmvQA7kPMgFkIsgRyAn0PpbaK2HOVfH0+k3b7mCca31sC7XWFcuxa24bVzeWA/rcxHkCOQSyDHICchlkCsAN/0VL1frLxamOGfx0+psl2lF+VKgvq58HZH9SN6PlJ3I9BddrtRnJCTzwdu8mv1OY9g7mMx6b3/iy5V6vMz1hYjs0goM7z7L+xHZj+T9SNmN6GHfdUTtcXN9OSCvvu48I2E/EvcjtB9J+xHej8h+JO9Hym5ED5quI7r69d2cvNoLfEGUL37VQ/6jrOd7H7cPj719fOzt6bG3T4+9PT/29vLY2+fH3r7c8fY5/v72evh7v9v7x95eP8svzKmNEuX3/UiK+xHaj6T9CO9HZD+S9yNlN6JvCrmO+P3IfvVlv/qyX33Zr76+zSTUL1oGlt87v77D5DqS9yP613hknsWHsnkq9S0l1xG/Hwn7kbgfoZ3I9JfYJGf6879/+/mHv/39x+//MyGXf/31X9/98sNP//r885f//Xv+l7///MOPP/7wz7/+++efvvv+H7/+/P1ff/zpu8u//cl9/ufP4op/E+/DX94PSf2zcIxvwsn/5X1CPv37JIi4LJd/vwA0/T9vJB/AOxF9epv+I/Wc1ctlaUrypMCfd7lsDYnE9R55ukWpd6DC05+5nrNwuWRKfL1FN9ciuTd2Mx04vE2P00wHzm9BXM0gvJcX3ijM1yf/lniZW7/fwk93qLPmNsGV4PjGeS5ySmRMtZ/9sYX/Nqn1fw==",
      "brillig_names": [
        "discover_new_messages",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_to_radix",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "_emit_open",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "resolved_order_bytes",
            "type": {
              "kind": "array",
              "length": 613,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13459246948365409099": {
            "error_kind": "string",
            "string": "Function _emit_open can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_emit_open"]
    },
    {
      "name": "_check_order_commitment",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14563046062317426044": {
            "error_kind": "string",
            "string": "Function _check_order_commitment can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_check_order_commitment"]
    },
    {
      "name": "get_filled_order_block_number",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5048864367174250545": {
            "error_kind": "string",
            "string": "Function get_filled_order_block_number can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["get_filled_order_block_number"]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": ["public", "initializer"],
      "abi": {
        "parameters": [
          {
            "name": "portal",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["constructor"]
    },
    {
      "name": "claim_private",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15663063161611103517": {
            "error_kind": "string",
            "string": "Invalid secret"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "settle_private",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+xdB3wVxdd9IbQEkNAREBFQkfpeeqwoCqiIih1rKkWa9E7AoPReFey9995777333nv3u/v3TXJzM2/fCzmz5n6yv99NZmd3z5w5M3O2vt2k0D/THo1DoRdS/kknUSRH/9eh6CTyzH+ermdZr5Elr4klr6klr5klrzVFX5G3vWW9Tpa8HSx5nS15O1vyulE0FHm7WPK6W/J6WPJ6WvJ6WfJ6W/L6WPLClryIJS/dkpdhycu05GVZ8rIteTmWvFxLXp4lb1dL3m6WvN0teXtY8va05O1lyetrydvbkrePJa+fJW9fS95+lrz+lrwBlryBlrz9LXkHWPIOtOQNsuQdZMkbbMk72JJ3iCXvUEveEEveYZa8wy15R1jyjrTkHWXJO9qSd4wlb6gl71hL3nGWvOMteSdY8k605J1kycu35BVY8goteUWWvGJLXoklb5glb7glb4Qlb6Ql72RL3ihL3mhL3hhL3lhL3jhL3imWvPGWvAmWvImWvEmWvMmWvCmWvKmWvGmWvOmWvBmWvJmWvFmWvNmWvDmWvFJL3lxL3jxL3qmWvDJL3nxL3mmWvNMteQsseQsteYsseYsteUsseUstecssecsteSsseSsteasseasteWsseWsteesseesteRsseRsteWdY8s605G2y5G225J1lyTvbkneOJe9cS955lrzzLXkXWPIutORdZMm72JJ3iSXvUkveZZa8yy15V1jyrrTkXWXJu9qSd40l71pL3nWWvOsteTdY8m605N1kybvZkneLJe9WS95tlrzbLXl3WPLutOTdZcm725J3jyXvXkvefZa8+y15D1jyHrTkPWTJe9iS94gl71FL3mOWvMcteU9Y8p605D1lyXvakveMJe9ZS95zlrznLXkvWPJetOS9ZMl72ZL3iiXvVUvea5a81y15b1jy3rTkvWXJe9uS944l711L3nuWvPcteR9Y8j605H1kyfvYkveJJe9TS95nlrzPLXlfWPK+tOR9Zcn72pL3jSXvW0ved5a87y15P1jyfrTk/WTJ+9mS94sl71dL3m+WvN8teX9Y8v605P1lyfvbkuf9kXlJlrw6lrxkS15dS149S159S14DS15DS16KJS/VktfIktfYktfEkreNJa+pJS/NktfMktfcktfCktfSktfKktfaktfGktfWkretJa+dJa+9Ja+D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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAAGuayPZ8O\n/IYWjU60rE1nFIHndoeb0J3B/6er0Ect4i8GcI/7OeGhBm1hp2bqZNOq/ORPfN1y4C2Sbb7bXQ0A\nWCY0DhHHC706x+L6GF/u8Zgf4c4V/Jwt2MATW8Sp8D+4Ip5/ANXm7fU27sB3pNfn/kdai/2kIzX3\ngW0fzAAhY80JZmKI2IjiXck3QNMTOUi6UPAUyjSWg+XvS9E3XN57ki9X7SjXt3B4SJEjByUaIXUQ\nyvNpn2job75OdsJDkqyILEYdrnUocKZknCUDrLQ2BQm9O8rQ6AxUeFql8eKF3lkvpqtDCy25oADo\n41DVpfugpFzkNdNTTNsVyjIJuoQPHxV2liqKvLa6/0ila9FKrGf1yNFb6L+0xXH6dKeCV6G/Lvzg\nXAmEcIjSJwY8Hb2kGcF6HptqQ41XbKQFnFCqBgIZp923zBOhiiOsyA2NjHPO95TOC13ukwKeIJCU\nBMl/Bw//17v+TRVsiOmToT8zyGeWtcID84j0vsjlGooZPI21IuSmLVifXcWOAD4X0sKeZqqcjXq3\nWBuYEO2nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icB/IHH2MD94rUWlzv20a\ntArRxbjxpkkiXppB89/o7Ok4JaCJjTg81haHGNuMZlYdT8Km48XYr6vH3KqU+kUrVk8COxI/qOF1\nTn2qOG2xnELI2Ue6WAjv/X38mvq71CwXhxoKjm3S1M7dXFRi2toet7AdlFoYeDYUGu5Ql/yvGMXT\nBxywwNE9Gg57hfT+L5mEUs5uPvDHdOQe1o5/Y/+vspMR4B+Ksz3ATig4MwMh/ge/TLSVXJz+O2+t\n08g0Xxd4dCHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk\n6o4uDu5wKlMm81nJR8AUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxu\na015bsn0E4YWuRKVxKct3D6sKlhhK8NPrqsabYVbKtq5oYe32yE556XjVyJnWxbaT3rN4zgPQX2a\ncI41FcYanjN6lWdujpTpbgOeBAOK0v1VDL+j+yA2eXIxO8DT6XTgI1jm0S5Y4tCsjSu1ucXqDvt7\ngdCHASbThUXwUhfXV9LkZ1JWQ1Qkn5334BBBeubPKfr1xNUBPYWx6BRKCJq/S1oFYUqOhzFiS1X/\njweX12QCTpxShiGYANWl7lgXxioICOVnNRCXrJ720VREsbfc7ga9rS7wF/chdyY7znUuxnpg8U+0\ngRnZ2egJoD2DK7Up9IINEucMuHjGv55fjnLxUPkRmtERRIAcW3A1FalV8ruLR9Zw0iwDK+gL9jxd\nNJ1t1rJKKzs2kTfYzyJFLfYTMm4Nva/HCwdJAbXawVMxxpFPzRpqLq6anb+MFXKyQf+ulkfqi7Ep\nojeA5nKLatcE1SwSn3czJwCihq/tuTLif0KKxdoujBDMlB9nul/iQfF1Y7iCOJ8dITXMDmvuP8VF\nXVcyoTn8IgxextYog+HI3guJmqVhpldlYMYjmvNTWpXxTonbqGYdaoD/7dbkD8fUBdXEjV1PPLtj\ntRKro9TJmzRg9mrdvQXI3PWZiEk8sb/lxfybOUT0BwAIJZVALKXanX+iKN53FBqK6U3fG1EBgxIk\nFaJfPDmbjs2uEoB6Liv9GzPWilckSzLSDX3GX/2W7ccHmXwQo08c6lTHel1veqMYUPnHmRev62x2\n7pYD2M9Ns0NhmYCyAR2LfP2EzcRL3jXOt1vDBng17+34C1gXVaAjULVNaesBroUdZWK+ouqskLZG\nqfEUwy9nSOd598iuVamojKfHnlQhCOqpJLST5Qj0XX57zxAoqtx1Nsj14OtC+xqxo1GsW0GdqFah\nvIm0lDIYUvfLAHYXaAmc4dFUb8HF2T8KO2o9Ml9fz2XeBm/nwG55ldcBazN1btkZIJ9Nb1xpPOIS\nQctqyc8U7pzyCvnJ83Em6gMIU1PxSp2rBzzBk7mLR7GQkPwwLqaUFvfU+HMKjogaLESUKWtigfab\nefMtYKTgpFbKL/hvYxhz/mw3BiBl7EAtm+c5KAbUenket2ewpJYNTV7J9tYNWNz+Y4AqqMsQoA6e\nfOievCZP3GlpR5CVadLo3HzKsWxO4cFJtAqHGXu8IO1CrgTw2toWiVQkdyQBK/11f+E0D/PzBUjh\nc8VPLg0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAACILX/1t7hW7fxl0XIESHAJyDvjaP1drSGpYvH8I69PZcX0VR+1JNd6G2xaOe5\n/dmAOxzm7s+WiwuYw8ntLOmJqgDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04s\nAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJ\niS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "5048864367174250545": {
            "error_kind": "string",
            "string": "Function get_filled_order_block_number can only be called statically"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6017907102598075401": {
            "error_kind": "string",
            "string": "Function get_order_status can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7354432299782447020": {
            "error_kind": "string",
            "string": "Function _assert_order_status can only be called internally"
          },
          "8412360910299423372": {
            "error_kind": "string",
            "string": "Invalid order destination domain"
          },
          "9169818942746597700": {
            "error_kind": "string",
            "string": "Function _update_order_status can only be called internally"
          },
          "10391454703121400355": {
            "error_kind": "string",
            "string": "Function _assert_order_commitment can only be called internally"
          },
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "10852400770788842366": {
            "error_kind": "string",
            "string": "Invalid order domain"
          },
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "11094545764365153162": {
            "error_kind": "string",
            "string": "Function _assert_nonce_and_set_order_details can only be called internally"
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13459246948365409099": {
            "error_kind": "string",
            "string": "Function _emit_open can only be called internally"
          },
          "13594925270014003382": {
            "error_kind": "string",
            "string": "Function _trigger_settlement can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14563046062317426044": {
            "error_kind": "string",
            "string": "Function _check_order_commitment can only be called internally"
          },
          "15254322136740517089": {
            "error_kind": "string",
            "string": "Function _emit_settled can only be called internally"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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HQwBHAEdAigCAR4EAKMBOAAJAR4BIC4NASABHx0MAR8BIAIdDAEgAR4AHQwBHgEfAigCASAEAKQBOAAJASABIi4NASIBIR0MASEBIgIdDAEiASAAHQwBIAEhAigCASIEAKUBOAAJASIBJC4NASQBIx0MASMBJAIdDAEkASIAHQwBIgEjAigCASQEAKYBOAAJASQBJi4NASYBJR0MASUBJgIdDAEmASQAHQwBJAElAigCASYEAKcBOAAJASYBKC4NASgBJx0MAScBKAIdDAEoASYAHQwBJgEnAigCASgEAKgBOAAJASgBKi4NASoBKR0MASkBKgIdDAEqASgAHQwBKAEpAigCASoEAKkBOAAJASoBLC4NASwBKx0MASsBLAIdDAEsASoAHQwBKgErAigCASwEAKoBOAAJASwBLi4NAS4BLR0MAS0BLgIdDAEuASwAHQwBLAEtAigCAS4EAKsBOAAJAS4BMC4NATABLx0MAS8BMAIdDAEwAS4AHQwBLgEvAigCATAEAKwBOAAJATABMi4NATIBMR0MATEBMgIdDAEyATAAHQwBMAExAigCATIEAK0BOAAJATIBNC4NATQBMx0MATMBNAIdDAE0ATIAHQwBMgEzAigCATQEAK4BOAAJATQBNi4NATYBNR0MATUBNgIdDAE2ATQAHQwBNAE1AigCATYEAK8BOAAJATYBOC4NATgBNx0MATcBOAIdDAE4ATYAHQwBNgE3AigCATgEALABOAAJATgBOi4NAToBOR0MATkBOgIdDAE6ATgAHQwBOAE5AigCAToEALEBOAAJAToBPC4NATwBOx0MATsBPAIdDAE8AToAHQwBOgE7AigCATwEALIBOAAJATwBPi4NAT4BPR0MAT0BPgIdDAE+ATwAHQwBPAE9AigCAT4EALMBOAAJAT4BQC4NAUABPx0MAT8BQAIdDAFAAT4AHQwBPgE/AigCAUAEALQBOAAJAUABQi4NAUIBQR0MAUEBQgIdDAFCAUAAHQwBQAFBAigCAUIEALUBOAAJAUIBRC4NAUQBQx0MAUMBRAIdDAFEAUIAHQwBQgFDAigCAUQEALYBOAAJAUQBRi4NAUYBRR0MAUUBRgIdDAFGAUQAHQwBRAFFAigCAUYEALcBOAAJAUYBSC4NAUgBRx0MAUcBSAIdDAFIAUYAHQwBRgFHAigCAUgEALgBOAAJ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HQwCTgJMAB0MAkwCTQIoAgJOBAE7ATgACQJOAlAuDQJQAk8dDAJPAlACHQwCUAJOAB0MAk4CTwIoAgJQBAE8ATgACQJQAlIuDQJSAlEdDAJRAlICHQwCUgJQAB0MAlACUQIoAgJSBAE9ATgACQJSAlQuDQJUAlMdDAJTAlQCHQwCVAJSAB0MAlICUwIoAgJUBAE+ATgACQJUAlYuDQJWAlUdDAJVAlYCHQwCVgJUAB0MAlQCVQIoAgJWBAE/ATgACQJWAlguDQJYAlcdDAJXAlgCHQwCWAJWAB0MAlYCVwIoAgJYBAFAATgACQJYAlouDQJaAlkdDAJZAloCHQwCWgJYAB0MAlgCWQIoAgJaBAFBATgACQJaAlwuDQJcAlsdDAJbAlwCHQwCXAJaAB0MAloCWwIoAgJcBAFCATgACQJcAl4uDQJeAl0dDAJdAl4CHQwCXgJcAB0MAlwCXQIoAgJeBAFDATgACQJeAmAuDQJgAl8dDAJfAmACHQwCYAJeAB0MAl4CXwIoAgJgBAFEATgACQJgAmIuDQJiAmEdDAJhAmICHQwCYgJgAB0MAmACYQIoAgJiBAFFATgACQJiAmQuDQJkAmMdDAJjAmQCHQwCZAJiAB0MAmICYwIoAgJkBAFGATgACQJkAmYuDQJmAmUdDAJlAmYCHQwCZgJkAB0MAmQCZQIoAgJmBAFHATgACQJmAmguDQJoAmcdDAJnAmgCHQwCaAJmAB0MAmYCZwIoAgJoBAFIATgACQJoAmouDQJqAmkdDAJpAmoCHQwCagJoAB0MAmgCaQIoAgJqBAFJATgACQJqAmwuDQJsAmsdDAJrAmwCHQwCbAJqAB0MAmoCawIoAgJsBAFKATgACQJsAm4uDQJuAm0dDAJtAm4CHQwCbgJsAB0MAmwCbQIoAgJuBAFLATgACQJuAnAuDQJwAm8dDAJvAnACHQwCcAJuAB0MAm4CbwIoAgJwBAFMATgACQJwAnIuDQJyAnEdDAJxAnICHQwCcgJwAB0MAnACcQIBKAAJgMMCcy4NAnMCch0MAnICdAIdDAJ0AnMAHQwCcwJyAgE4AAkAAwJ1Lg0CdQJ0HQwCdAJ1Ah0MAnUACQAdDAAJAnQCLggAAQJ1KAICdgQBLgEQAAECdgABKAMCdQQAAQEoAnUAAgJ2LgwCdgJ3Lg4ADAJ3ASgCdwACAncuDgAPAncBKAJ3AAICdy4OABMCdwEoAncAAgJ3Lg4AFQJ3ASgCdwACAncuDgAXAncBKAJ3AAICdy4OABkCdwEoAncAAgJ3Lg4AGwJ3ASgCdwACAncuDgAeAncBKAJ3AAICdy4OACICdwEoAncAAgJ3Lg4AJgJ3ASgCdwACAncuDgAoAncBKAJ3AAICdy4OAC4CdwEoAncAAgJ3Lg4AMgJ3ASgCdwACAncuDgA2AncBKAJ3AAICdy4OADgCdwEoAncAAgJ3Lg4AOwJ3ASgCdwACAncuDgA9AncBKAJ3AAICdy4OAD8CdwEoAncAAgJ3Lg4AQQJ3ASgCdwACAncuDgBDAncBKAJ3AAICdy4OAEUCdwEoAncAAgJ3Lg4ARwJ3ASgCdwACAncuDgBIAncBKAJ3AAICdy4OAEsCdwEoAncAAgJ3Lg4ATQJ3ASgCdwACAncuDgBPAncBKAJ3AAICdy4OAFECdwEoAncAAgJ3Lg4AUwJ3ASgCdwACAncuDgBVAncBKAJ3AAICdy4OAFcCdwEoAncAAgJ3Lg4AWAJ3ASgCdwACAncuDgBaAncBKAJ3AAICdy4OAF0CdwEoAncAAgJ3Lg4AXwJ3ASgCdwACAncuDgBhAncBKAJ3AAICdy4OAGMCdwEoAncAAgJ3Lg4AZQJ3ASgCdwACAncuDgBnAncBKAJ3AAICdy4OAGkCdwEoAncAAgJ3Lg4AawJ3ASgCdwACAncuDgBtAncBKAJ3AAICdy4OAG8CdwEoAncAAgJ3Lg4AcQJ3ASgCdwACAncuDgBzAncBKAJ3AAICdy4OAHUCdwEoAncAAgJ3Lg4AdwJ3ASgCdwACAncuDgB5AncBKAJ3AAICdy4OAHsCdwEoAncAAgJ3Lg4AfQJ3ASgCdwACAncuDgB/AncBKAJ3AAICdy4OAIECdwEoAncAAgJ3Lg4AgwJ3ASgCdwACAncuDgCFAncBKAJ3AAICdy4OAIcCdwEoAncAAgJ3Lg4AiQJ3ASgCdwACAncuDgCLAncBKAJ3AAICdy4OAI0CdwEoAncAAgJ3Lg4AjwJ3ASgCdwACAncuDgCRAncBKAJ3AAICdy4OAJMCdwEoAncAAgJ3Lg4AlQJ3ASgCdwACAncuDgCXAncBKAJ3AAICdy4OAJgCdwEoAncAAgJ3Lg4AmwJ3ASgCdwACAncuDgCdAncBKAJ3AAICdy4OAJ8CdwEoAncAAgJ3Lg4AoQJ3ASgCdwACAncuDgCjAncBKAJ3AAICdy4OAKUCdwEoAncAAgJ3Lg4ApwJ3ASgCdwACAncuDgCpAncBKAJ3AAICdy4OAKsCdwEoAncAAgJ3Lg4ArQJ3ASgCdwACAncuDgCvAncBKAJ3AAICdy4OALECdwEoAncAAgJ3Lg4AswJ3ASgCdwACAncuDgC1AncBKAJ3AAICdy4OALcCdwEoAncAAgJ3Lg4AuQJ3ASgCdwACAncuDgC7AncBKAJ3AAICdy4OAL0CdwEoAncAAgJ3Lg4AvwJ3ASgCdwACAncuDgDBAncBKAJ3AAICdy4OAMMCdwEoAncAAgJ3Lg4AxQJ3ASgCdwACAncuDgDHAncBKAJ3AAICdy4OAMkCdwEoAncAAgJ3Lg4AywJ3ASgCdwACAncuDgDNAncBKAJ3AAICdy4OAM8CdwEoAncAAgJ3Lg4A0QJ3ASgCdwACAncuDgDTAncBKAJ3AAICdy4OANUCdwEoAncAAgJ3Lg4A1wJ3ASgCdwACAncuDgDYAncBKAJ3AAICdy4OANsCdwEoAncAAgJ3Lg4A3QJ3ASgCdwACAncuDgDfAncBKAJ3AAICdy4OAOECdwEoAncAAgJ3Lg4A4wJ3ASgCdwACAncuDgDlAncBKAJ3AAICdy4OAOcCdwEoAncAAgJ3Lg4A6QJ3ASgCdwACAncuDgDrAncBKAJ3AAICdy4OAO0CdwEoAncAAgJ3Lg4A7wJ3ASgCdwACAncuDgDxAncBKAJ3AAICdy4OAPMCdwEoAncAAgJ3Lg4A9QJ3ASgCdwACAncuDgD3AncBKAJ3AAICdy4OAPkCdwEoAncAAgJ3Lg4A+wJ3ASgCdwACAncuDgD9AncBKAJ3AAICdy4OAP8CdwEoAncAAgJ3Lg4BAQJ3ASgCdwACAncuDgEDAncBKAJ3AAICdy4OAQUCdwEoAncAAgJ3Lg4BBwJ3ASgCdwACAncuDgEJAncBKAJ3AAICdy4OAQsCdwEoAncAAgJ3Lg4BDQJ3ASgCdwACAncuDgEPAncBKAJ3AAICdy4OARECdwEoAncAAgJ3Lg4BEwJ3ASgCdwACAncuDgEVAncBKAJ3AAICdy4OARcCdwEoAncAAgJ3Lg4BGAJ3ASgCdwACAncuDgEbAncBKAJ3AAICdy4OAR0CdwEoAncAAgJ3Lg4BHwJ3ASgCdwACAncuDgEhAncBKAJ3AAICdy4OASMCdwEoAncAAgJ3Lg4BJQJ3ASgCdwACAncuDgEnAncBKAJ3AAICdy4OASkCdwEoAncAAgJ3Lg4BKwJ3ASgCdwACAncuDgEtAncBKAJ3AAICdy4OAS8CdwEoAncAAgJ3Lg4BMQJ3ASgCdwACAncuDgEzAncBKAJ3AAICdy4OATUCdwEoAncAAgJ3Lg4BNwJ3ASgCdwACAncuDgE5AncBKAJ3AAICdy4OATsCdwEoAncAAgJ3Lg4BPQJ3ASgCdwACAncuDgE/AncBKAJ3AAICdy4OAUECdwEoAncAAgJ3Lg4BQwJ3ASgCdwACAncuDgFFAncBKAJ3AAICdy4OAUcCdwEoAncAAgJ3Lg4BSQJ3ASgCdwACAncuDgFLAncBKAJ3AAICdy4OAU0CdwEoAncAAgJ3Lg4BTwJ3ASgCdwACAncuDgFRAncBKAJ3AAICdy4OAVMCdwEoAncAAgJ3Lg4BVQJ3ASgCdwACAncuDgFXAncBKAJ3AAICdy4OAVgCdwEoAncAAgJ3Lg4BWwJ3ASgCdwACAncuDgFdAncBKAJ3AAICdy4OAV8CdwEoAncAAgJ3Lg4BYQJ3ASgCdwACAncuDgFjAncBKAJ3AAICdy4OAWUCdwEoAncAAgJ3Lg4BZwJ3ASgCdwACAncuDgFpAncBKAJ3AAICdy4OAWsCdwEoAncAAgJ3Lg4BbQJ3ASgCdwACAncuDgFvAncBKAJ3AAICdy4OAXECdwEoAncAAgJ3Lg4BcwJ3ASgCdwACAncuDgF1AncBKAJ3AAICdy4OAXcCdwEoAncAAgJ3Lg4BeQJ3ASgCdwACAncuDgF7AncBKAJ3AAICdy4OAX0CdwEoAncAAgJ3Lg4BfwJ3ASgCdwACAncuDgGBAncBKAJ3AAICdy4OAYMCdwEoAncAAgJ3Lg4BhQJ3ASgCdwACAncuDgGHAncBKAJ3AAICdy4OAYkCdwEoAncAAgJ3Lg4BiwJ3ASgCdwACAncuDgGNAncBKAJ3AAICdy4OAY8CdwEoAncAAgJ3Lg4BkQJ3ASgCdwACAncuDgGTAncBKAJ3AAICdy4OAZUCdwEoAncAAgJ3Lg4BlwJ3ASgCdwACAncuDgGYAncBKAJ3AAICdy4OAZsCdwEoAncAAgJ3Lg4BnQJ3ASgCdwACAncuDgGfAncBKAJ3AAICdy4OAaACdwEoAncAAgJ3Lg4BowJ3ASgCdwACAncuDgGlAncBKAJ3AAICdy4OAacCdwEoAncAAgJ3Lg4BqAJ3ASgCdwACAncuDgGrAncBKAJ3AAICdy4OAa0CdwEoAncAAgJ3Lg4BrwJ3ASgCdwACAncuDgGxAncBKAJ3AAICdy4OAbMCdwEoAncAAgJ3Lg4BtQJ3ASgCdwACAncuDgG3AncBKAJ3AAICdy4OAbkCdwEoAncAAgJ3Lg4BuwJ3ASgCdwACAncuDgG9AncBKAJ3AAICdy4OAb8CdwEoAncAAgJ3Lg4BwQJ3ASgCdwACAncuDgHDAncBKAJ3AAICdy4OAcUCdwEoAncAAgJ3Lg4BxwJ3ASgCdwACAncuDgHJAncBKAJ3AAICdy4OAcsCdwEoAncAAgJ3Lg4BzQJ3ASgCdwACAncuDgHPAncBKAJ3AAICdy4OAdECdwEoAncAAgJ3Lg4B0wJ3ASgCdwACAncuDgHVAncBKAJ3AAICdy4OAdcCdwEoAncAAgJ3Lg4B2AJ3ASgCdwACAncuDgHbAncBKAJ3AAICdy4OAd0CdwEoAncAAgJ3Lg4B3wJ3ASgCdwACAncuDgHhAncBKAJ3AAICdy4OAeMCdwEoAncAAgJ3Lg4B5QJ3ASgCdwACAncuDgHnAncBKAJ3AAICdy4OAegCdwEoAncAAgJ3Lg4B6wJ3ASgCdwACAncuDgHtAncBKAJ3AAICdy4OAe8CdwEoAncAAgJ3Lg4B8QJ3ASgCdwACAncuDgHyAncBKAJ3AAICdy4OAfUCdwEoAncAAgJ3Lg4B9wJ3ASgCdwACAncuDgH5AncBKAJ3AAICdy4OAfoCdwEoAncAAgJ3Lg4B/QJ3ASgCdwACAncuDgH/AncBKAJ3AAICdy4OAgECdwEoAncAAgJ3Lg4CAwJ3ASgCdwACAncuDgIFAncBKAJ3AAICdy4OAgcCdwEoAncAAgJ3Lg4CCQJ3ASgCdwACAncuDgILAncBKAJ3AAICdy4OAg0CdwEoAncAAgJ3Lg4CDwJ3ASgCdwACAncuDgIRAncBKAJ3AAICdy4OAhMCdwEoAncAAgJ3Lg4CFQJ3ASgCdwACAncuDgIXAncBKAJ3AAICdy4OAhkCdwEoAncAAgJ3Lg4CGwJ3ASgCdwACAncuDgIdAncBKAJ3AAICdy4OAh8CdwEoAncAAgJ3Lg4CIQJ3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AQIyAAEnAwQEAQEoAAQAAgIyLgwCMgI0Lg4ACgI0ASgCNAACAjQuDgA7AjQBKAI0AAICNC4OAD0CNAEoAjQAAgI0Lg4ARQI0ASgCNAACAjQuDgBHAjQBKAI0AAICNC4OAEgCNAEoAjQAAgI0Lg4ATQI0ASgCNAACAjQuDgBPAjQBKAI0AAICNC4OAFMCNAEoAjQAAgI0Lg4AVQI0ASgCNAACAjQuDgBXAjQBKAI0AAICNC4OAFgCNAEoAjQAAgI0Lg4AWgI0ASgCNAACAjQuDgBdAjQBKAI0AAICNC4OAF8CNAEoAjQAAgI0Lg4AYQI0ASgCNAACAjQuDgBjAjQBKAI0AAICNC4OAGUCNAEoAjQAAgI0Lg4AZwI0ASgCNAACAjQuDgBpAjQBKAI0AAICNC4OAGsCNAEoAjQAAgI0Lg4AbQI0ASgCNAACAjQuDgBvAjQBKAI0AAICNC4OAHECNAEoAjQAAgI0Lg4AcwI0ASgCNAACAjQuDgB1AjQBKAI0AAICNC4OAHcCNAEoAjQAAgI0Lg4AeQI0ASgCNAACAjQuDgB7AjQBKAI0AAICNC4OAH0CNAEoAjQAAgI0Lg4AfwI0ASgCNAACAjQuDgAZAjQBKAI0AAICNC4OAIECNAEoAjQAAgI0Lg4AgwI0ASgCNAACAjQuDgCFAjQBKAI0AAICNC4OAEECNAEoAjQAAgI0Lg4AhwI0ASgCNAACAjQuDgCJAjQBKAI0AAICNC4OAIsCNAEoAjQAAgI0Lg4AQwI0ASgCNAACAjQuDgCNAjQBKAI0AAICNC4OAI8CNAEoAjQAAgI0Lg4AkQI0ASgCNAACAjQuDgAXAjQBKAI0AAICNC4OAJMCNAEoAjQAAgI0Lg4AlQI0ASgCNAACAjQuDgCXAjQBKAI0AAICNC4OAJgCNAEoAjQAAgI0Lg4AmwI0ASgCNAACAjQuDgCdAjQBKAI0AAICNC4OAJ8CNAEoAjQAAgI0Lg4AoQI0ASgCNAACAjQuDgCjAjQBKAI0AAICNC4OAKUCNAEoAjQAAgI0Lg4ApwI0ASgCNAACAjQuDgCpAjQBKAI0AAICNC4OAKsCNAEoAjQAAgI0Lg4ArQI0ASgCNAACAjQuDgCvAjQBKAI0AAICNC4OALECNAEoAjQAAgI0Lg4AswI0ASgCNAACAjQuDgC1AjQBKAI0AAICNC4OALcCNAEoAjQAAgI0Lg4AuQI0ASgCNAACAjQuDgC7AjQBKAI0AAICNC4OAL0CNAEoAjQAAgI0Lg4AvwI0ASgCNAACAjQuDgDBAjQBKAI0AAICNC4OAMMCNAEoAjQAAgI0Lg4AxQI0ASgCNAACAjQuDgDHAjQBKAI0AAICNC4OAMkCNAEoAjQAAgI0Lg4AywI0ASgCNAACAjQuDgDNAjQBKAI0AAICNC4OAM8CNAEoAjQAAgI0Lg4A0QI0ASgCNAACAjQuDgDTAjQBKAI0AAICNC4OANUCNAEoAjQAAgI0Lg4A1wI0ASgCNAACAjQuDgDYAjQBKAI0AAICNC4OANsCNAEoAjQAAgI0Lg4A3QI0ASgCNAACAjQuDgDfAjQBKAI0AAICNC4OAOECNAEoAjQAAgI0Lg4A4wI0ASgCNAACAjQuDgDlAjQBKAI0AAICNC4OAOcCNAEoAjQAAgI0Lg4A6QI0ASgCNAACAjQuDgDrAjQBKAI0AAICNC4OAO0CNAEoAjQAAgI0Lg4A7wI0ASgCNAACAjQuDgDxAjQBKAI0AAICNC4OAPMCNAEoAjQAAgI0Lg4A9QI0ASgCNAACAjQuDgD3AjQBKAI0AAICNC4OAPkCNAEoAjQAAgI0Lg4A+wI0ASgCNAACAjQuDgD9AjQBKAI0AAICNC4OAP8CNAEoAjQAAgI0Lg4BAQI0ASgCNAACAjQuDgEDAjQBKAI0AAICNC4OAQUCNAEoAjQAAgI0Lg4BBwI0ASgCNAACAjQuDgEJAjQBKAI0AAICNC4OAQsCNAEoAjQAAgI0Lg4BDQI0ASgCNAACAjQuDgEPAjQBKAI0AAICNC4OAB4CNAEoAjQAAgI0Lg4BEQI0ASgCNAACAjQuDgETAjQBKAI0AAICNC4OARUCNAEoAjQAAgI0Lg4BFwI0ASgCNAACAjQuDgEYAjQBKAI0AAICNC4OARsCNAEoAjQAAgI0Lg4BHQI0ASgCNAACAjQuDgEfAjQBKAI0AAICNC4OASECNAEoAjQAAgI0Lg4BIwI0ASgCNAACAjQuDgElAjQBKAI0AAICNC4OAScCNAEoAjQAAgI0Lg4BKQI0ASgCNAACAjQuDgErAjQBKAI0AAICNC4OAS0CNAEoAjQAAgI0Lg4BLwI0ASgCNAACAjQuDgExAjQBKAI0AAICNC4OATMCNAEoAjQAAgI0Lg4BNQI0ASgCNAACAjQuDgE3AjQBKAI0AAICNC4OATkCNAEoAjQAAgI0Lg4BOwI0ASgCNAACAjQuDgE9AjQBKAI0AAICNC4OAT8CNAEoAjQAAgI0Lg4BQQI0ASgCNAACAjQuDgFDAjQBKAI0AAICNC4OAUUCNAEoAjQAAgI0Lg4BRwI0ASgCNAACAjQuDgFJAjQBKAI0AAICNC4OAUsCNAEoAjQAAgI0Lg4BTQI0ASgCNAACAjQuDgAmAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuCoCYAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuCoCYAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuCoCYAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuCoCYAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuCoCYAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuCoCYAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuCoCYAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuCoCYAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuCoCYAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuCoCYAjQBKAI0AAICNC4KgJgCNAEoAjQAAgI0LgqAmAI0ASgCNAACAjQuDgFPAjQBKAI0AAICNC4OAVECNAEoAjQAAgI0Lg4BUwI0ASgCNAACAjQuDgA2AjQBKAI0AAICNC4OAVUCNAEoAjQAAgI0Lg4BVwI0ASgCNAACAjQuDgFYAjQBKAI0AAICNC4OAVsCNAEoAjQAAgI0Lg4BXQI0ASgCNAACAjQuDgFfAjQBKAI0AAICNC4OAWECNAEoAjQAAgI0Lg4BYwI0ASgCNAACAjQuDgFlAjQBKAI0AAICNC4OAWcCNAEoAjQAAgI0Lg4BaQI0ASgCNAACAjQuDgFrAjQBKAI0AAICNC4OAW0CNAEoAjQAAgI0Lg4BbwI0ASgCNAACAjQuDgFxAjQBKAI0AAICNC4OAXMCNAEoAjQAAgI0Lg4BdQI0ASgCNAACAjQuDgF3AjQBKAI0AAICNC4OAXkCNAEoAjQAAgI0Lg4BewI0ASgCNAACAjQuDgF9AjQBKAI0AAICNC4OAX8CNAEoAjQAAgI0Lg4BgQI0ASgCNAACAjQuDgGDAjQBKAI0AAICNC4OAYUCNAEoAjQAAgI0Lg4BhwI0ASgCNAACAjQuDgGJAjQBKAI0AAICNC4OAYsCNAEoAjQAAgI0Lg4BjQI0ASgCNAACAjQuDgGPAjQBKAI0AAICNC4OAZECNAEoAjQAAgI0Lg4AIgI0ASgCNAACAjQuDgGTAjQBKAI0AAICNC4OAZUCNAEoAjQAAgI0Lg4BlwI0ASgCNAACAjQuDgGYAjQBKAI0AAICNC4OAZsCNAEoAjQAAgI0Lg4BnQI0ASgCNAACAjQuDgGfAjQBKAI0AAICNC4OAaACNAEoAjQAAgI0Lg4BowI0ASgCNAACAjQuDgGlAjQBKAI0AAICNC4OAacCNAEoAjQAAgI0Lg4BqAI0ASgCNAACAjQuDgGrAjQBKAI0AAICNC4OAa0CNAEoAjQAAgI0Lg4BrwI0ASgCNAACAjQuDgGxAjQBKAI0AAICNC4OAbMCNAEoAjQAAgI0Lg4BtQI0ASgCNAACAjQuDgG3AjQBKAI0AAICNC4OAbkCNAEoAjQAAgI0Lg4BuwI0ASgCNAACAjQuDgG9AjQBKAI0AAICNC4OAb8CNAEoAjQAAgI0Lg4BwQI0ASgCNAACAjQuDgHDAjQBKAI0AAICNC4OAcUCNAEoAjQAAgI0Lg4BxwI0ASgCNAACAjQuDgHJAjQBKAI0AAICNC4OAcsCNAEoAjQAAgI0Lg4BzQI0ASgCNAACAjQuDgHPAjQBKAI0AAICNC4OACgCNAEoAjQAAgI0Lg4B0QI0ASgCNAACAjQuDgHTAjQBKAI0AAICNC4OAdUCNAEoAjQAAgI0Lg4B1wI0ASgCNAACAjQuDgHYAjQBKAI0AAICNC4OAdsCNAEoAjQAAgI0Lg4B3QI0ASgCNAACAjQuDgHfAjQBKAI0AAICNC4OAeECNAEoAjQAAgI0Lg4B4wI0ASgCNAACAjQuDgHlAjQBKAI0AAICNC4OAecCNAEoAjQAAgI0Lg4B6AI0ASgCNAACAjQuDgHrAjQBKAI0AAICNC4OAe0CNAEoAjQAAgI0Lg4B7wI0ASgCNAACAjQuDgHxAjQBKAI0AAICNC4OAfICNAEoAjQAAgI0Lg4B9QI0ASgCNAACAjQuDgH3AjQBKAI0AAICNC4OAfkCNAEoAjQAAgI0Lg4B+gI0ASgCNAACAjQuDgH9AjQBKAI0AAICNC4OAf8CNAEoAjQAAgI0Lg4CAQI0ASgCNAACAjQuDgIDAjQBKAI0AAICNC4OAgUCNAEoAjQAAgI0Lg4CBwI0ASgCNAACAjQuDgIJAjQBKAI0AAICNC4OAgsCNAEoAjQAAgI0Lg4CDQI0ASgCNAACAjQuDgAbAjQBKAI0AAICNC4OAg8CNAEoAjQAAgI0Lg4CEQI0ASgCNAACAjQuDgITAjQBKAI0AAICNC4OAD8CNAEoAjQAAgI0Lg4CDwI0ASgCNAACAjQuDgIRAjQBKAI0AAICNC4OAhMCNAEoAjQAAgI0Lg4APwI0ASgCNAACAjQuDgIVAjQBKAI0AAICNC4OAhcCNAEoAjQAAgI0Lg4CGQI0ASgCNAACAjQuDgIbAjQBKAI0AAICNC4OAA4CNAEoAjQAAgI0Lg4AEAI0ASgCNAACAjQuDgASAjQBKAI0AAICNC4OAh0CNAEoAjQAAgI0Lg4CHwI0ASgCNAACAjQuDgIhAjQBKAI0AAICNC4OAiMCNAEoAjQAAgI0Lg4CJQI0ASgCNAACAjQuDgInAjQBKAI0AAICNC4OAikCNAEoAjQAAgI0Lg4CKwI0ASgCNAACAjQuDgItAjQBKAI0AAICNC4OAB0CNAEoAjQAAgI0Lg4AHwI0ASgCNAACAjQuDgAhAjQBKAI0AAICNC4OACMCNAEoAjQAAgI0Lg4AJQI0ASgCNAACAjQuDgAnAjQBKAI0AAICNC4OACkCNAEoAjQAAgI0Lg4AKwI0ASgCNAACAjQuDgAtAjQBKAI0AAICNC4OAC8CNAEoAjQAAgI0Lg4AMQI0ASgCNAACAjQuDgAzAjQBKAI0AAICNC4OADUCNAEoAjQAAgI0Lg4CLwI0ASgCNAACAjQuDgIxAjQBKAI0AAICNC4OADgCNAEoAjQAAgI0Lg4ACwI0ASgCNAACAjQuDgANAjQBKAI0AAICNC4OABECNAEoAjQAAgI0Lg4AFAI0ASgCNAACAjQuDgAWAjQBKAI0AAICNC4OABgCNAEoAjQAAgI0Lg4AGgI0ASgCNAACAjQuDgAcAjQBKAI0AAICNC4OACACNAEoAjQAAgI0Lg4AJAI0ASgCNAACAjQuDgAqAjQBKAI0AAICNC4OACwCNAEoAjQAAgI0Lg4AMAI0ASgCNAACAjQuDgA0AjQBKAI0AAICNC4OADcCNAEoAjQAAgI0Lg4AOQI0ASgCNAACAjQuDgA8AjQBKAI0AAICNC4OAD4CNAEoAjQAAgI0Lg4AQAI0ASgCNAACAjQuDgBCAjQBKAI0AAICNC4OAEQCNAEoAjQAAgI0Lg4ARgI0ASgCNAACAjQuDgBJAjQBKAI0AAICNC4OAEoCNAEoAjQAAgI0Lg4ATAI0ASgCNAACAjQuDgBOAjQBKAI0AAICNC4OAFACNAEoAjQAAgI0Lg4AUgI0ASgCNAACAjQuDgBUAjQBKAI0AAICNC4OAFYCNAEoAjQAAgI0Lg4AWQI0ASgCNAACAjQuDgBbAjQBKAI0AAICNC4OAFwCNAEoAjQAAgI0Lg4AXgI0ASgCNAACAjQuDgBgAjQBKAI0AAICNC4OAGICNAEoAjQAAgI0Lg4AZAI0ASgCNAACAjQuDgBmAjQBKAI0AAICNC4OAGgCNAEoAjQAAgI0Lg4AagI0ASgCNAACAjQuDgBsAjQBKAI0AAICNC4OAG4CNAEoAjQAAgI0Lg4AcAI0ASgCNAACAjQuDgByAjQBKAI0AAICNC4OAHQCNAEoAjQAAgI0Lg4AdgI0ASgCNAACAjQuDgB4AjQBKAI0AAICNC4OAHoCNAEoAjQAAgI0Lg4AfAI0ASgCNAACAjQuDgB+AjQBKAI0AAICNC4OAIACNAEoAjQAAgI0Lg4AggI0ASgCNAACAjQuDgCEAjQBKAI0AAICNC4OAIYCNAEoAjQAAgI0Lg4AiAI0ASgCNAACAjQuDgCKAjQBKAI0AAICNC4OAIwCNAEoAjQAAgI0Lg4AjgI0ASgCNAACAjQuDgCQAjQBKAI0AAICNC4OAJICNAEoAjQAAgI0Lg4AlAI0ASgCNAACAjQuDgCWAjQBKAI0AAICNC4OAJkCNAEoAjQAAgI0Lg4AmgI0ASgCNAACAjQuDgCcAjQBKAI0AAICNC4OAJ4CNAEoAjQAAgI0Lg4AoAI0ASgCNAACAjQuDgCiAjQBKAI0AAICNC4OAKQCNAEoAjQAAgI0Lg4ApgI0ASgCNAACAjQuDgCoAjQBKAI0AAICNC4OAKoCNAEoAjQAAgI0Lg4ArAI0ASgCNAACAjQuDgCuAjQBKAI0AAICNC4OALACNAEoAjQAAgI0Lg4AsgI0ASgCNAACAjQuDgC0AjQBKAI0AAICNC4OALYCNAEoAjQAAgI0Lg4AuAI0ASgCNAACAjQuDgC6AjQBKAI0AAICNC4OALwCNAEoAjQAAgI0Lg4AvgI0ASgCNAACAjQuDgDAAjQBKAI0AAICNC4OAMICNAEoAjQAAgI0Lg4AxAI0ASgCNAACAjQuDgDGAjQBKAI0AAICNC4OAMgCNAEoAjQAAgI0Lg4AygI0ASgCNAACAjQuDgDMAjQBKAI0AAICNC4OAM4CNAEoAjQAAgI0Lg4A0AI0ASgCNAACAjQuDgDSAjQBKAI0AAICNC4OANQCNAEoAjQAAgI0Lg4A1gI0ASgCNAACAjQuDgDZAjQBKAI0AAICNC4OANoCNAEoAjQAAgI0Lg4A3AI0ASgCNAACAjQuDgDeAjQBKAI0AAICNC4OAOACNAEoAjQAAgI0Lg4A4gI0ASgCNAACAjQuDgDkAjQBKAI0AAICNC4OAOYCNAEoAjQAAgI0Lg4A6AI0ASgCNAACAjQuDgDqAjQBKAI0AAICNC4OAOwCNAEoAjQAAgI0Lg4A7gI0ASgCNAACAjQuDgDwAjQBKAI0AAICNC4OAPICNAEoAjQAAgI0Lg4A9AI0ASgCNAACAjQuDgD2AjQBKAI0AAICNC4OAPgCNAEoAjQAAgI0Lg4A+gI0ASgCNAACAjQuDgD8AjQBKAI0AAICNC4OAP4CNAEoAjQAAgI0Lg4BAAI0ASgCNAACAjQuDgECAjQBKAI0AAICNC4OAQQCNAEoAjQAAgI0Lg4BBgI0ASgCNAACAjQuDgEIAjQBKAI0AAICNC4OAQoCNAEoAjQAAgI0Lg4BDAI0ASgCNAACAjQuDgEOAjQBKAI0AAICNC4OARACNAEoAjQAAgI0Lg4BEgI0ASgCNAACAjQuDgEUAjQBKAI0AAICNC4OARYCNAEoAjQAAgI0Lg4BGQI0ASgCNAACAjQuDgEaAjQBKAI0AAICNC4OARwCNAEoAjQAAgI0Lg4BHgI0ASgCNAACAjQuDgEgAjQBKAI0AAICNC4OASICNAEoAjQAAgI0Lg4BJAI0ASgCNAACAjQuDgEmAjQBKAI0AAICNC4OASgCNAEoAjQAAgI0Lg4BKgI0ASgCNAACAjQuDgEsAjQBKAI0AAICNC4OAS4CNAEoAjQAAgI0Lg4BMAI0ASgCNAACAjQuDgEyAjQBKAI0AAICNC4OATQCNAEoAjQAAgI0Lg4BNgI0ASgCNAACAjQuDgE4AjQBKAI0AAICNC4OAToCNAEoAjQAAgI0Lg4BPAI0ASgCNAACAjQuDgE+AjQBKAI0AAICNC4OAUACNAEoAjQAAgI0Lg4BQgI0ASgCNAACAjQuDgFEAjQBKAI0AAICNC4OAUYCNAEoAjQAAgI0Lg4BSAI0ASgCNAACAjQuDgFKAjQBKAI0AAICNC4OAUwCNAEoAjQAAgI0Lg4BTgI0ASgCNAACAjQuDgFQAjQBKAI0AAICNC4OAVICNAEoAjQAAgI0Lg4BVAI0ASgCNAACAjQuDgFWAjQBKAI0AAICNC4OAVkCNAEoAjQAAgI0Lg4BWgI0ASgCNAACAjQuDgFcAjQBKAI0AAICNC4OAV4CNAEoAjQAAgI0Lg4BYAI0ASgCNAACAjQuDgFiAjQBKAI0AAICNC4OAWQCNAEoAjQAAgI0Lg4BZgI0ASgCNAACAjQuDgFoAjQBKAI0AAICNC4OAWoCNAEoAjQAAgI0Lg4BbAI0ASgCNAACAjQuDgFuAjQBKAI0AAICNC4OAXACNAEoAjQAAgI0Lg4BcgI0ASgCNAACAjQuDgF0AjQBKAI0AAICNC4OAXYCNAEoAjQAAgI0Lg4BeAI0ASgCNAACAjQuDgF6AjQBKAI0AAICNC4OAXwCNAEoAjQAAgI0Lg4BfgI0ASgCNAACAjQuDgGAAjQBKAI0AAICNC4OAYICNAEoAjQAAgI0Lg4BhAI0ASgCNAACAjQuDgGGAjQBKAI0AAICNC4OAYgCNAEoAjQAAgI0Lg4BigI0ASgCNAACAjQuDgGMAjQBKAI0AAICNC4OAY4CNAEoAjQAAgI0Lg4BkAI0ASgCNAACAjQuDgGSAjQBKAI0AAICNC4OAZQCNAEoAjQAAgI0Lg4BlgI0ASgCNAACAjQuDgGZAjQBKAI0AAICNC4OAZoCNAEoAjQAAgI0Lg4BnAI0ASgCNAACAjQuDgGeAjQBKAI0AAICNC4OAaECNAEoAjQAAgI0Lg4BogI0ASgCNAACAjQuDgGkAjQBKAI0AAICNC4OAaYCNAEoAjQAAgI0Lg4BqQI0ASgCNAACAjQuDgGqAjQBKAI0AAICNC4OAawCNAEoAjQAAgI0Lg4BrgI0ASgCNAACAjQuDgGwAjQBKAI0AAICNC4OAbICNAEoAjQAAgI0Lg4BtAI0ASgCNAACAjQuDgG2AjQBKAI0AAICNC4OAbgCNAEoAjQAAgI0Lg4BugI0ASgCNAACAjQuDgG8AjQBKAI0AAICNC4OAb4CNAEoAjQAAgI0Lg4BwAI0ASgCNAACAjQuDgHCAjQBKAI0AAICNC4OAcQCNAEoAjQAAgI0Lg4BxgI0ASgCNAACAjQuDgHIAjQBKAI0AAICNC4OAcoCNAEoAjQAAgI0Lg4BzAI0ASgCNAACAjQuDgHOAjQBKAI0AAICNC4OAdACNAEoAjQAAgI0Lg4B0gI0ASgCNAACAjQuDgHUAjQBKAI0AAICNC4OAdYCNAEoAjQAAgI0Lg4B2QI0ASgCNAACAjQuDgHaAjQBKAI0AAICNC4OAdwCNAEoAjQAAgI0Lg4B3gI0ASgCNAACAjQuDgHgAjQBKAI0AAICNC4OAeICNAEoAjQAAgI0Lg4B5AI0ASgCNAACAjQuDgHmAjQBKAI0AAICNC4OAekCNAEoAjQAAgI0Lg4B6gI0ASgCNAACAjQuDgHsAjQBKAI0AAICNC4OAe4CNAEoAjQAAgI0Lg4B8AI0ASgCNAACAjQuDgHzAjQBKAI0AAICNC4OAfQCNAEoAjQAAgI0Lg4B9gI0ASgCNAACAjQuDgH4AjQBKAI0AAICNC4OAfsCNAEoAjQAAgI0Lg4B/AI0ASgCNAACAjQuDgH+AjQBKAI0AAICNC4OAgACNAEoAjQAAgI0Lg4CAgI0ASgCNAACAjQuDgIEAjQBKAI0AAICNC4OAgYCNAEoAjQAAgI0Lg4CCAI0ASgCNAACAjQuDgIKAjQBKAI0AAICNC4OAgwCNAEoAjQAAgI0Lg4CDgI0ASgCNAACAjQuDgIQAjQBKAI0AAICNC4OAhICNAEoAjQAAgI0Lg4CFAI0ASgCNAACAjQuDgIWAjQBKAI0AAICNC4OAhgCNAEoAjQAAgI0Lg4CGgI0ASgCNAACAjQuDgIcAjQBKAI0AAICNC4OAh4CNAEoAjQAAgI0Lg4CIAI0ASgCNAACAjQuDgIiAjQBKAI0AAICNC4OAiQCNAEoAjQAAgI0Lg4CJgI0ASgCNAACAjQuDgIoAjQBKAI0AAICNC4OAioCNAEoAjQAAgI0Lg4CLAI0ASgCNAAC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",
      "debug_symbols": "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",
      "brillig_names": ["public_dispatch"]
    },
    {
      "name": "_assert_order_commitment",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10391454703121400355": {
            "error_kind": "string",
            "string": "Function _assert_order_commitment can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_assert_order_commitment"]
    },
    {
      "name": "fill_private",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10852400770788842366": {
            "error_kind": "string",
            "string": "Invalid order domain"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["fill_private"]
    },
    {
      "name": "get_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6017907102598075401": {
            "error_kind": "string",
            "string": "Function get_order_status can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["get_order_status"]
    },
    {
      "name": "_update_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "status",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9169818942746597700": {
            "error_kind": "string",
            "string": "Function _update_order_status can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgMEAicCBAQAHxgABAADgEgdAIBJgEkELgiASAABLgiASQACJQAAAFIlAAAAdigCAAEEgEonAgIEADsNAAEAAigAgEMEAAMoAIBEAQAAKACARQQAACgAgEYBAAEoAIBHBAABJiUAAAJxHgIAAwAeAgAEADM4AAMABAAFJAIABQAAAJolAAACmh4CAAMBHgIABAAKOAMEBSQCAAUAAAC2JQAAAqwnAgMAAC0IAQQnAgUEBAAQAQUBJwMEBAEAKAQCBS0MBQYtDgMGACgGAgYtDgMGACgGAgYtDgMGLQ0EBQAoBQIFLQ4FBCsCAAUAAAAAAAAAAAIAAAAAAAAAAC0IAQYnAgcEBQAQAQcBJwMGBAEAKAYCBy0MBwgtDgMIACgIAggtDgMIACgIAggtDgMIACgIAggtDgUILQ0EBQAoBQIFLQ4FBC0NBgUAKAUCBS0OBQYtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS4KgEUABi0IAQcAAAECAS4KgEQABycCCAAFJwIJBAotCAAKLQwFCy0MBAwtDAYNLQwHDi0MCA8AEAAJACUAAAK+LQQAACcCCAQJLQgACS0MBQotDAQLLQwGDC0MBw0tDAEOABAACAAlAAACvi0EAAAtDQcBCygAAYBEAAgkAgAIAAACFCcCCQQAPAkBCScCAQQILQgACC0MBQktDAQKLQwGCy0MBwwAEAABACUAAAPnLQQAAC0NBAEBKAABgEcABS0NBQQKOAQDAQsoAAGARAADJAIAAwAAAmUlAAAE+hwMAgEAMAwAAQAEJigAgAQEeAANAAAAgASAAyQAgAMAAAKZKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQV/Qb2+oQ8ZRDwBAQImJQAAAnEtDQMGLQ0EBwsoAAeARAAIJAIACAAAAuQnAgkEADwJAQkLKAAGgEMAByQCAAcAAANzIwAAAvktDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAADHiUAAAUMLgQABoADKACABAQABCUAAAUeLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAA14lAAAFrC0OCgEtDgcCLQ4FAy0OCQQjAAAD5icCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAPnLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAFHi4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA+YmJQAAAnEuCIBFAAUjAAAD9w0oAAWAQwAGJAIABgAABGcjAAAEDC0NAQUtDQIGLQ0DBy0NBAgnAgkEBC0IAQonAgsEBQAQAQsBJwMKBAEAKAYCCycCDAQEACgKAg0/DwALAA0tDQoGACgGAgYtDgYKLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAASFIwAABPEtDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAAUeLgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABPEtDAYFIwAAA/cqAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAU5IwAABUQuAIADgAUjAAAFqy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAWXLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAVmKAGABQQAAQMAgAYAAoAGIwAABasmKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z3bbuM4DIbfJde5kKgDyXmVwaLoIVMECJIibRdYFH33dTKx4ySMVVPZWRTmTVE3+kP6MyVRdG19zJ4WD+/Pd8v1r83r7MfPj9lq83j/ttysm6OPz/nsYbtcrZbPd/0/z9zuh4ewF7y+3K93x69v99u32Q8fILn5bLF+2v0eKDVf8mu5WjRHLnzOL9s7gLa5i9Br7YTWMWd/aB0zuq51JqExJZcOjSmB7zf+a974T7fxn7lt7j3/Qf/Djfgn6vhTib9PiG3rHMKw/5y4PVnOIZ77H/2t/fdw6v/eCv8JKymKVjxzJwPnc8FKpBDb6KBeX7gSHQhddBCe003yeUOvu8Fpfwv/cbzmrzCK8cSjvY51OkSdjkDSAQTfRkzzey/2kxcDJofjsHBs7DOI3Sq3X+2OlyRAFNoix5YyMh+/GXYxcNE6YOt07PVAkPo2gE+9ExxunGI7DqRI/aZ7gmgE6wiyN4KVBLMRrCLYzFdGsJKgxWAlQW8xWEswGcFKgmwE6whCNIKVBMkI1hGUqyVGcARBW9V9gSC19ZLUK6YdCEbLZmoJWkZdSTA5I1gkmLu2+bTpjiBaL64laGuSSoJkvbiWoMVgJUG2GKwlaDFYS9BqM3UEg7N1cS1Bq81UEvR2x72WoNVmKgmCrepqCVptppJgsIz6nOAeSzQsEhbLfSUs0RJaEYtlCBKWZKmniMXmcglLtglaxGJ1LBGLTdASFrQJWsRiZSQJiz2NIWOxCVrCYs9NyFgs+RewRHvCQcZiY4uEZbJ3KYJvXYamyHuBZapjyzAWsGgRsUx1bBnGMtnKfwFLNCwSlqkuFYexRBtyRSw25EpY0lST/wIWixYJy2Qr/wUsU638F7BMtfI/jGWylf8CFltBS1jIJmgRiw25IhYbciUsHA2LhMWiRcCSJvswCMbuBDHpG+8ZTnU2H8PQZ2rfdOnRnT+knib70qIbMgTry/UMp1povSHDMNWq7CiGyN17lclfzMuTffXODRlO9uU7t2Ro83I9w6kuPW7IMFluU8/Q5pRqhtlym3qGFofVDCf7SrJbMrTc5gsMOXTnx/GCIdm8XM/wJuOhp+MmJzEVGKbE7XdngqP7zZWQKHZbwiAeXxLr0e/dZ/jO7mfnvrf79K3d918ZPyIX3I+uteEj4ImRy9bksO2N5OhIRtzhyHvX2wbquMNRiPDbf/of/A+58z/RsP9Iod2sDIld6WSbe83d2abe3aLfGzqhfKfDu24sbGjx2fCG8o4OJVGSt3JKXeHR43nhEa/sTzcsCl4jygpRdLKIctf33AWILLsXoRcxF5bkf9IqiVghkv/BpyRChYg058Qa91jeJjDF7uIm9GciclEhutI1CqKsEMkPp5REqBAFjaUr/Slxlzdlf/54FsWoEbFClFAhyqARaUCg04g09OjKDpTH/DYkuBCRQiRnlSVRHi9iOQEsiaJGpADBPmhEGksAGpEGedAgD1eQ5y5BC3Q+sPCVObcgQoUogUZEClEOChF6jUgx5zIq8gimoBEpLHknp5aY23QUc7zQyPMTd2ULxnyhkUOvoIkKDY3XXAnWwZy8UaFGlb1KlTUqVNlClS1S2SKVLVbZYs318s6rVJrzamQqVVSpSKMCUKlw9Bjj5YUoQ7si5yhoxo9LXu7Fw3aywjd5EVrQ8HiNvAQdZoDjx0xPCjtyaZepjYOTmvRBI2e+Bc14O1d2e+2dj6QZH28gv0WjoOHxGhg/d0JwCk0ar1HkAqDIBUCRC0BSXJ80Mg4+m6O/77fL+4fV4rVR7D58Xz++LTfrw+HbPy/tJw/b5Wq1fL572W4eF0/v28XdavO4+2zmDj9+Ng7MAXE/yzWHzUWZe6B9V9h9ijQHco3VxvK/",
      "brillig_names": ["_update_order_status"]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": ["aztec::macros::functions::utility"],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZRcx3Ul+BO1AJVAoZIASZAEuIGQuEu51uK1ZImSRYq0NkvW7qzKTIoWSIAASAEkAP5CFUAIxEpSpGTLm7wvsuVVXmTN6Fjj02O3Pe7RsdvubndPd8+Z6Z6Z9nSPZ3rsPu7jxif/y7x58/34PytfFJIE4hygfv6IuO/FixcvXiw/Ihd0Qi7+OxoMEATk2pte/TsR/14H8SMX/83Hv4uDhdIE0bXEny3OzU0o5TPkvzIRY+b84BcF35P8i+tjnM+HHXwsi9DdcPHfRnh+Mujoh6/yS/35LP9WR5lFd94aBu3QoVuqzE5XyrPT5XKjWaw3pmdac5WZYmWhVplbXCgVK7XybGOmXikWm5XmYrXYmJ6rNZr1uVqltVCfmxbst6nYlebCRahafXp2odSqT7eKC9WZ2Uq9NTPTqDfmqs2ZWrFRWpwuLZZLrdnZeq1WX6zNlUqt5lytNdvGvi/0IrOy4L/dC36lJvjvAPzRwLZNReG7/eC3bdo7/eC35X+/F/l3+H8gxg8Ce9m/ywvvpTb+g35kUxX8h/zgVwT/ewA/5wH/3X7w27rzHj/4bd1/rx/5twT/fTF+ANil2Uq5PFOZmynOzTaKpWpjsTx70fovVIuLxfpiuTlXLc21quVqZbGxuDBbna2XWsVWfXGuNfsquGC/X8Eu9hdK/EKwv9eLXCptvf9A6KNeK+0+64P9y6aUhi7Y39c/dlpo91UfSsZetdoI9ocV7HK9slicaxXrtdn6THO2dtHNKF58WJhttqbL9YWLDke5USqVmtWL/5WbjercQmO6tDDdnCnXFi6Sa8vkI6EPfSktCv5HjfGn68W55vT0jOB/zBh/YWF6pn5RnoL/cWP8yuJ0s1WZaduxTxjj12vVVqtWqQv+9xvj10rFZq0809bNujH+3EKxNj0729afBWP8i/5ypTFXXxD8RWv5LDSLi43S3GSM04jxhUYUhHbTmHYc5nJEL4jx+Z3QzxOv1v5kjughPw14J+MukV0r7OW1oMShjeG4EeWd0NGwPmaI9XFDrE8YYn2/IVbdEGvBEEvatd+2Vm33oy0v+JVZwX/YC36xKfif9IFf6vhejwB+YMd/G/8HAD/nAf9TfuTfxt/tRz7t8dijMb4P7Mf8yKbtg+3xg98ec+z1g9/2UR/3g9+2Dfv84Lfnzvf7wW/7qAf84Ld9vCf84Ld91Cf94DcE/9Ne8Ett+RwEfDvbWW7btkNe8Ctt/Kf84Lft29Ne8Ktt/MN+8NtzNkf84Lft81E/+G37/Iwf/LbvE3rBr7XHyEte8Kfb+nPMD357rnjZD35bP1f84Lf187gf/LZ+nvCD3/YfnvWD3/YfTvrBb/sPn/GD3+6/TvnBb/fvz/nBb/fvp/3gt+3bGT/4bft21gv+TLt/P+cHvz0He94Pftt+XvCD37afz/vBb9vPF/zgt+3ni37w2/bts37w2/btJT/4bfv2sh/8tv35XIwfrB67wi+ivULRPqFtW1/F23Tx3+YY++Hmge/avWfxUw898ehCcx/OSEsJg6B7plpGPhwi1C0d1LfueezAvvrigbc0Gvua+/czwjoFOUhAzQPqJ+uPPPbORhI/faJ9oLlv/yN7HmO00Yxosh9qDNIb+qzFyRhvnPhD2utJCja0Sw2t5lnKSD9PvBqPv0s5oif8sHxw3SKK26DwWlDiuA43KHQ2KHQKStxKaId1zhDruCHWGUMsyzI+Z4h10hDrtCHWCUOsg4ZYlrJfMcQ6P6RYS4ZYljqxYohlqV/LhliWbdtSJ44ZYlna6BcMsVYMsSz7Dhmb+PWtirOTCm0JEoffYqBPxYE9ceQ7wr9xaweX00nYBPT2H3ps8aE9B5r7A0eGKMhGfH4/bMJjhzCfoQxBkC7YUgbBsgOPvE0SJubNKVjaEIeVGWU+nsADYkhdoSNsOIioZCkH0l+rQYRmJLRBhMhnwo98yjnCR34mFPmwDnPdRf/kw6AxwML0+BEZpsdnyY/v/jL+Wwh625F8nJBT4kaUdyLfSObfpLJh3bCe+qmHaimrngr9fOCz3XT0VNMLrTObCHrr2XJjVZZ61WzbRiVOsDbFv1FPMX0eyojp8Vny47v/Pf5bCHp1mvV0o1IefId6+q/j54mE8szHv4sDhZkZrZ/idoBystwonrUdCP184FPvOu1AqyfNnojsNim8FpQ4nvTZpNDZpNApKHHsiA6CdcYQ65gh1ooh1vkhxTppiHXaEOuEIdZBQ6xThliWej+M8nL1g/1iRcFSVy8YYj1riGWpq5ZlXDLEGta2/ZIh1iFDLFmEZT9T8KMwEfS2PeuxG9KTcuA7pJ8nXm356fhKmlw1n1bkM+lHPm1+JhV+JhX5SF1uVuIEayr+jWMGTD8JZcT0+Cz58Z0MAAuEGQUeM2xWyoPvcMxwd667bFg3rKc+6wHpCd/4DunnA5/tpujUC639TwS99Wwon2KWekV+pS6nlDjBko+gUE8x/WYoI6bHZ8mP776T9BR1mvV0SikPvkM9nSM9xbphPfVSD6VWZj0V+vnAZ7vp6KmmF5OKHCeC3no2lE8xS70iv1KXBSVOsK6Kf6OeYvopKCOmx2fJj+8eJD1FneaPwwpKefAd6uk7YtyJhPLMx7+LA4VaVatLO/yZ0qRSTm5nKGs7va5kbmdCPx/06oWPdnYV8ZOkByK7LQqvBSWOdWSLQmeLQqegxPG4ZhCsFUOsg4ZYxwyxThliLRlinTTEes4Qa8UQa9kQKzTEOm+EpdnnQfg6Z8RXFC4YYlm27ZcMsSxtoWV7PG2IZVmPLxtiWeqEpeyt2nZgXEZLnThjiDWsdsKSr8vBZ7rSp1062Vu2x+OGWJZlfHFI+bL0JyzLyOsDOLbMxX8ngt62ZzjObuaInpQD3yH9PPFqy09nnK3J9SpFriK7rQqvBSWOx9lbFTpbFToFJY77jEGwVgyxDhpiWZbxpCHWaUOsC4ZYlrJ/yRDrSj32h/WyIZalTiwbYp0xxFoxxDpviGUpe0tdtZT9sNovS11dMcR6zhDLsh4t9cuyDVnq1zlDrCVDLMsyrhhiWbZHyzJa+hPDWo/D6su9aIg1rH6OpY95xZ94fbQhSzthyZeVfkXPPK86CF/PG/EVBUvZW/oAKzEW73cT/Cj4nUMrZ95jy3NoXvZgpcyhaXvrJoJePTSUTylLPSO/UpdXK3GCdU38G/eEYfqtUEZMj8+SH9+9JRZKgTCjwHvCrlbKg+9EvtGesG+Nf0wklGc+/l0cLMzyfKjQQNooJ0O9y3SJBNLPBz71rtMOtHrS7IvI7hqF10LQqzusD9codK5R6FzBGi6sdxthuWyYxEdhQslnbW+RnpQD3yH9fODVLpRcctXspcjnWj/yae9Rvlbh51pFPlKX25Q4wbou/o39Eaa/FsqI6fFZ8uO7JvVH2yAtt4FtSnnwHfZHn1jXXTasG9ZTP/WQ/ZsPoZ8PfLabjp5qeqG1/4mgt54N5VPMUq/Ir9TldUqcYF0f/0Y9xfTboIyYHp8lP77bT3qKOs16ep1SHnyHevpo/GMqSG6fWdoz4mp2m2WI+bg9eKnvUrOYtT0I/Xzgs3122sO2jHIV+VznRT6NVhb9QX6lLq9X4gTrhvg3tgdMfx2UEdPjs+THdyvUHrDtcHu4XikPvsP2cJTsNtYN66mXeigWW1n1VOjnA592sqOnml5o/d9E0FvPhvw0s9Qr8it1eYMSJ1jb49+op5j+eigjpsdnyY/vnic9RZ3mb/VuUMqD71BPT9N4l8szH/8uDhSaJa0u7fDrxQlF1nb45fZl9du94C/MCv4OP/jTgn+jF/zZdv3e5AW/1pbPzX7wG4J/ix/9afN/qxf8SkXwd3rBb7b5v80LfrWNv8sL/kK7/b7BC/5cW//f6Ec+7fq93Qt+qyb4d/iRT5v/O/3w37b/dwO+5VyE4N/rBb9YEXncE3TCiFImoS++yF2QPpfwV7A4TmjlCcuX36eVDfnncd89wA/KIAnrnj6xJpQ4H3V6t6PcSH/SwSuXIwp8Bs5qZRKFZUOsZwyxzhlhab7tIHw9ZcjX9UZ8af7vIFjbDbHGjLCiwJceDsLXDiO+oucbhxTrJkOsmw2xbjHEutUQa6ch1m1GWFHgy64G4WuXIV9nDfl6gxFf0fMbDbGs+o7o+XZDrDsMse40wooCz50OC5asIfud76rO+Z3vqtT9zndVG37nu2oVv/Nd1Rm/813VRfHVpT8UGqhbt8B7u3FFNfO3oEI/T7za8tMZ391C/LB8eP/OrQqvBSWO2+itCp1bFToFJY738g6C9YIh1pIh1ilDrJOGWMuGWAcNsZ4zxFoxxDo/pFiWunrCEGvFCCt65n57WHTVsj1eMMQa1vb4vCGWZRsaVtk/a4hlaScs+9oVQyxL2VvKa1j1y9I3WTHEspT95WAnXjLCip55DDsIX0cM+dpuxJclVhSeDu342mHIl5XsoxAaYlnqBM+lD4I1ZoQVBSudiMIzhliHDbEs9cuSLytdHWZbuNmQL0tdtaxHS7s6rPKy1FWeWx0GXY2Cpf162RDL0v86bohlOaewYohlOVawnHsU/17msW+CuFz81+8aQHHVawA3+eHHuQZwkyJXbT+sIT+NLPWM/Epd7lTiBOu2+Dfu7cf0t0IZMT0+S3589xNxxRUIMwq8t3+nUh58J/KN9vb/8Eh32W6BdKynfuoh+x2wQj8feG03JZde3KLIUdMLyVtQ4tinz1pfWt3z3rdBsM4YYh0zxFoxxDo/pFgnDbFOG2KdMMQ6aIh11hDLsg1Z1uMLhlhLhlgXDLFWDLEs9cuyDVna1ctB9s8ZYlnaaLGF2ndUhv5HUfvOyRC//c3BbQ5ZIH3eiyPx2l/B4jihlScs47KVXGVD/rme0Q9HGSRh3dYnlvZtnI863ekoN9L3+y1grez3W8DatN9vAast0fk3gDxzJLvbvdTlbOazVIR+nnj11aZuJ35YPtIORHZ3KLwWlDjeu3eHQucOhU5BieN+exCsFwyxlgyxThlinTTEWjbEOmiIddYQ65whlqXsh1VXLxhirRhiWeqXpc05Y4h1Ocj+OUOsFUOs80OKZdm2TxhirRhhRc+8L3dYdHVYfQBLrCv99pV++7XSd1zpt6/021f67den7IdVV583xLKUl6XNsZT9s4ZYlm3Ist9eMcQaVn91WPXL0vddMcSylP3lYCdeMsKKnnl/ziBYOw2xrObJo+fbjLCiwHuPB+FrsyFfR4z4ikJoiPWMEVb0zOtfV2TvLiN/OzEI1nZDrB1GWFGwlNcbjfiy1NUoWLahYdX7YS3j690WWvIVhSt9x2u/74jCUSOs6Nlyz4OVvKLnGw35OmzIl1VfGwXL/tFSXsPYd0ThZUMsyzHfcUMsyzWdFUMsy/kJy/05/H0b7g3LxX+18+IjOvPx7+JgoZEjelIOfIf088SrMT8ll1xvV+SqnXdvyM9ijvCRnzsV+Uhd3q3ECZack4nft2H6O6GMmB6fJX/Xu3jSpUCYUeDv27Sz0vGdyDf6vu2/jHaXDeuG9dRPPZQzf98m9POB13ZTcumF1v41vZC8Wn1xv5+1vjSsk4ZY5w2xjhlinTHEesEQa8UQ69yQ8rVsiHXQEOslQ6xDhlgvG2JZyuu0IZZle7xgiLViiGVpCy3r8bghlqXNsdSJ5wyxLGW/NKR8nTXEstQJS9/Est+2rMdhtV+W+mXZHlcMsSxttCWWpX6dMMRaibFkvILjm1z81/MdcNUc0ZNy4DuknydebfnpjPU0ud6pyLWf+8WiZ8s7m9g2D4J1xhDrmCHWiiHW+SHFOmmIddoQ64Qh1kFDLKu7kaKwZIhl2R4vGGJZ6pelvE4ZYlnql2UbsrSrljqxYog1rG3bsj1atqEXDLEs2+PloF/PGWJZ+gDS107Fcehv3xp00+nX58f8km5SyZeL//q9w3cu83kdQj+vyMSHz39PRrmK7O5VeC0ocbx35V6Fzr0KnYISx33TIFgvGGItGWKdMsQ6aYi1bIh10BDrrCHWOUMsS9kPq65eMMRaMcSy1C9Lm3PGEOtykP1zhlgrhljnhxTLsm2fMMRaMcKKnvm8jmHR1WH1ASyxhrXftpS9pQ9gaaMt/Ylh1dUr/fal69Ou+OT9YV3xyS+dfl3xCy+dfg2jXxgFS3kNq64+b4hlKS9Lm2Mp+2cNsSzbkGXfsWKINazjoWHVL0vfd8UQy1L2l4OdeMkIK3rmPU6D8PW0IV87jfiKnjcbYlmuD1nK60ZDvkIjvqLwjBFW9Mzf9A+DTkSBv20eBtlbtm3r9mjVhqLn24ywomDZHi8H/eLzhgbB2m6ItcMIKwqW8nqjEV+WtjAKljZ6WPV+WMv4eu9rLfmKwhXf5LXfd0ThqBGWpT8RBSt5Rc+WPvlhQ76s+tooWPaPlvIaxr4jCi8bYlnOKRw3xLJct1oxxLKc/7LcX8jnDW2GuFz8V/b5oq2L6MzHv4sDhVLm84aEfj7o7avs+Ons870u6JXrZkWuIrvrFV4LShyPja9X6Fyv0CkocbzmOwjWGUOsY4ZYK4ZY54cU66Qh1mlDrBOGWAcNsc4aYlm2Ict6fMEQa8kQ64Ih1oohlqV+WfJlWY+WfFnaCUudsKzH5wyxLO292FXxrdgnmI9/FwcKtZr4JujLiE81EfT6JoZ+3WyO6Imc8B3SzxOvtvx0/Dqt3lA+7NfdoPBaUOK4Dm9Q6Nyg0Ckocdw2B8H6jCGWJV9njLCi54nABsu6jAcNsZ4zxDpviHXCEMtSXhcMsT5riHXWEGvFEMtS9icNsZYNsSzL+JIh1iFDLJnnY98iCvPx34vdYWV2ulKenS6XG81ivTE905qrzBQrC7XK3OJCqViplWcbM/VKsdisNBerxcb0XK3RrM/VKq2F+tyMX9+hNjcR9Np4Q9+kJPjb/eCXBX+HH/yK4N/oB78q+Dv94NcE/zY/+NOCv8sP/ozfsw9Ks4J/rx/8dvt6kx/8uuC/2Q9+Q/CLfvCbgl/yg98S/LIX/HJR8Ct+8Nv2s+oHv20/a37w2/Zz2g9+237O+MFv289ZP/ht+znnB79tP7/FD37bfn6rH/y2/fw2P/ht+/ntfvAXBP87/OAvCv53+sFv2/95P/ht+/8WP/ht+/9dXvArbfv/Vj/4bfv/Nj/4bft/nx/8tv1/ux/8tv18hx/8tv38bj/4bfv2Tj/4bft2vx/8tn17wA9+2769yw9+27496Ae/bd8e8oPftm/f4wW/2rY/7/aD37Y/7/GD37Y/7/WD3/Y/3+cHv+1/vt8Pftt+fq8f/Lb9/IAf/Lb/+UE/+G37/H1+8Nv2+UN+8Nv2+cN+8Nv2+SN+8Nv2+aN+8Nv2+WN+8Nv2+eNe8Gtt//MTfvDb9v/7/eC37X/dD37b/i/4wW/b/0U/+G373/CD37b/TT/4bfvf8oPftv8PB53Qwa40Fy4utdTq07MLpVZ9ulVcqM7MVuqtmZlGvTFXbc7Uio3S4nRpsVxqzc7Wa7X6Ym2uVGo152qt2Tbvn1SxBwmddZFHfMil1GrbhR8A/JwZ/7Nt/E95wS+229VuL3rT4f9RL/JvtO3+Y4Gx7pSKxehe0NPrX8WaAtlLOdZTncheoDF4/lTYnUbiMf2f5F/9G9E7H4NOUp4Anicov22dleZyRC8gWgHRzyuy8bHPaYT4YfnwPqdRhdcCxUWB171HFTqjCh0N62VDrIOGWGcNsVYMsU4bYi0bYp00xLIs4wlDrGHVryVDrHOGWBcMsSz1y1JepwyxLPXLsg2dMcSy1IkVQyzZDzkR6H3hfPy7OFCYnpW+Fn13CRKHvjf30T8A6d8WdtJxGKHfWKYNF/+9ZWsHl9MxP+jLPAL4mpwkaPvaLX0cwV/vB78iOjUedMuUy7Q+QVYSr/0NAt0/FFr5oFfuPvxDrWzIP7eXceCH97prWON9Yk0ocT7qdMxRbqQ/6eBVK8coyUSzRzlFJvJ+vYMvTD+l0Ja8IsMNEGcow7JLhtgWhf4meG40F554+F17cEqknR/lIHK7jtLdH3bkwDo4noAV0G/+DmYE8DD4HTNe2n5A3vXbD6CteoTiVmv3osC2QavDqH7/2jG3kKRDWecWJP3frO/Q+3/i541Ac6OD5iaKw/RRuJ/oT0LZRpQ0G4lHSf+3MV9R/b0nrj9NdsLPBOV/PemylKlfXcZ6RN4QU3SH6zapXkY3dHh5/9YOz0xvU5BcDvn9sEJPeJ+itFGQOi7Ae8M5rsx3sQn9PPFq3A+1fZgC8cPyEV3bBHLcvafeeGt97/4ndjfXkSj5+COBLxCcpMG0GArAEqbn/Kyq7wp783EQUU4Fvc16inhC/BHlHZveKYU3UXORzV2xmkdm66r4eTLQ1TgKE0GvbA1VYTGragr9fODTHHZUczPxkyR7kY+nprKQC3qbxYhCU/iVuiwocYJ1VfwbTSSmn4IyYnp8lvz47uZYnwpBb/N+IOzmQWv6+E7kG+np9THulFKeSSqbVm/asS8FJT/LEHXykbA7blQpm8SNOeLGHXHrlXJJ3AbI9ynKl1cwIzpPbujgJckG9UrcF802JdnWJKz7CAvzFwjrqhSshwgL819FWFtSsB4kLMy/hbC2pmA9RliYfythXZ2CtYewMP/VhHVNCtZewsL81xDWtSlYjxMW5r+WsLalYO0jLMy/jbCuS8HaT1iYn4/1uz4F6wBhYX6+hu2GFKwnCAvz87G321OwniQszM9H8e1IwXqYsDC/5J1UsNgP8PPJYnY/QOjniVdffsCNQa9cUT48HLpJ4bWgxLHdukmhc5NCR8PaYoi11RDrakOsawyxrjXE2maIdZ0h1vWGWDcYYrHdSuuv3xu++tfVX0s+1F1MNwJptD4aMZL8ARyz4fsdGcqD71g2OxLoJfGHspHxpsv/mKJ8Gs9TKXRcPEs6zWfeHXbH4RQ7+7c4Hcx+OE6VFyhuvVIu9pmxXtlnRrmhzzxG5TkUv/c7HVcsYh0myQplnEv4GwTZpmsx37o1oBOF7wv909HKM2lIB7HeFnbTWfspvmIzSzmQvu8pPpHFFocstnqhXc083bmVZLHFkyxEL9PGbbykqI3NtL4Ep0cfbh64uEj3XYfeX38YVyTRrDI73CwK9PuqBLbmKd1W+i3uH/OBWBiYD55+5fTzKenxeVR5HwVtWMvTsFq14TvXNOw1DjpbBqSzRaEjTQtdXB87Nzyd8tde5demErBMQn9SkVM/ph1p5YPeOvJhBrSyueoZhxhZply29Yk1ocT5qNNrHeVG+pMOXrVy4Gox2rkd8bGCkVv307TUwfYB5eBn91hlOqs+Cv212mmedaeL5qpL3gLFRYFv6tB2nYwpdDSsM4ZYzxtinTbEWjbEOmiIZVlGy3q0LOMxQyzLMj5niHXWEOuUIdaKIdYFQ6yThliWOmHZHi3bkKVOWMrrhCHWeUMsS9kfN8SylP05QyxLeVnawiVDLEt5DasttJSXpc25HHwmS51YMcSykn30PBHYYEXBUu8tZf+sIZal3luW0dJOWPoAlvJ6yRAry9fYOQVL3mtfsGjzUpfLFyw1SmfxBUuN3o0E+hcs+MUEz4cFkN7vfGylnCN6XMaA6OeJV+P6d97up8179nu7H9+0PSw38lnehGR5+9opQ6wVQyzLG60sb4Wz1AnLG8Asb+2y1AlLeZ0wxLKU13FDLEt5PW+IZamry4ZYl0M9Wt6QOay3gC4ZYlnKa1j7IUt5Wdp7S/2ytDmW7fH1fgNr9MxzMMOi95ayf9YQy1LvLctoaSeG1f96yRBL5mC0T4n4EwZtDHudgw7mvy4DljYelvTap0euuR7t0yO/t6R15nq0+tA+X1rNXI/IrUTpeK4HbdsNCVgB/S7Ru6S5nrH4nexbOhcbT5Gvp/1o6lZz3q+Ie0Z5X2S/n9pqnytrdLYMSGeLQsevLPs/RYM/m8ATdfkTh08BFp6CwmGEfmN5o3bxwT5O2MD6eCQBc0xJu47iJO2PT3T4WIz58LvvcO3q5L6wk46DVidS3kgWrQHrhPe/It/a59JZPuPGd9y2tM+4NTq3D0jndoXOpJIvl/BX6PA7pqPx7JpvXy0dxJI27Hfuvn/9Zzmj/vPeXDyhm0/Rw9O1cR2Ig9Y2RBZRvp/P0Db8rjetnQz5kzeUIbZtDpoMRRZZZTgV9MqQ2/ZmpRxau0eM1bR7jYdh6ye2UBzW8VaKwzq+muJ2Ax3+JO5RyMdrWY9B3BjF7YE4PglxL8RtoLjHIQ7rmkNaf/YXffRnqDdZ+jPtCBXB9ftJWaWSxe4j/TzxastPZx1U+0RYO7lTZHe1wmuB4qJwOOyk47gR5d06B9ZJQ6zzhljHDLHOGGK9YIi1Yoh1bkj5WjbEOmiI9ZIh1iFDrJcNsSzlddoQy7I9XjDEWjHEsrSFlvV43BDLsh4t7ZelvM4aYi0ZYlnKy7INWfoTlvI6ZYh1xa5eOrtqJfvomddBh0XvLWX/rCGWpd5bltHSTpwwxBpWf/UpQyzxVyUfjvFxzdLzOQbtW0Wv94PfPifBtZaL9HlML/HaX8HiON63fbWfsjn3bbv0AOfGsxwRel2fWJfyPBOUNZ9novGqlWOroUyy3ICizS31W7euI1s9t7H2noKtDjkh/UG+HylTuvvCjhy47rYlYAX0u0zvkvYUTAW9dbo+gU+hy+9YVzD/qIPOhgHpbMhIZ2pAOlMZ6WwZkM6WjHSu1E83nUtZP2KH8cwiWbeNbODBvE5zDGjiWU28Z0LS/zLchvt0PrmMOSo/9uGy1uL3Bq7+18lYlnxrdAB/MWhrTFKmfm+KwW/0+KYYwcQ6w5tixiAe05/Md3j52nYdMweY+K0i3yIkbTbpFiHmQdKfBh7kFiHGHE0o13gC5hdBF8/ldcxAwdTKtYHKxTysJx4k/QtQrq/DJkVMg3QkPBp285ZXaAUJ79im5RPiXHTT8kbPGwmD9yywvm6i9JI/SaasK5L+Cw5dGVN4wPJyvTIPnGZDAg8/pvCAx1Yu7tl7KL7VJ6CApjun/Oaq5CoYU3CSgoghKt4X8zqO/HapH3bF4wqNDQk8Yt5IPGLiGs3dzQPNBAGtI7DRBGLrAj34ve3TT7+h7a9A28tB61OkvJF8vrG9g8vpJGi32F3xq5LpaH4VY2n+UhSaYSce0/8u2JFvbtcx1yVgyjUyrj5N25sk6bUxo8vnRn3kcbpGG2XJdvfqPnlNm29YT7xqY9GsvN4Xri2vo33yukGhjX3PReP6yJPNfQ/tOdA+RTtQ2AjoeYLesRnm/mI8gdVNlG4z/eZjldm8X0W/8wp/WhA+MDAvI0F6kCYqsvojaKJ/ntBEg0BvoqL2PPzCvDj8EpV4EtLxMPrTVB5MjzQl/UGgo7k4T1K5Jf03FRdHG5oLPxOU37bbnZkTGR4KeoPEPQW0eavY05D+rWEnHQeta5UyRbIo9TFcw3pE3hATuwys26R6+VdQL3yxJ9L7dJBcDvk9ptBjWUp8FKSOn4b3dnVcq+eInpQN3yH9fNArWx/T/E8TPywfzQw7LvY8BM8I/yGCkzSYFsOHgCVMz/m52q9X8nEQUY4Rz1K+yJz8ezJb2PS5e0AeRpR37G2NK/xrdDYMSGdDRjqv5fJkuQByRCmrdjkkX9a4B+L4Asi9QW+5eIe2hrnPgbnfEXfAEfeEEheV88imDo/cvWhNnS+VxLpLatdJWPcRFuZ/mrAOp2DxpZKY/zBhHUnB4kslMf8RwjqagsWXSmL+o4T1TAoWXyqJ+Z8hrDAFay9hYf6QsJZSsPhSScy/RFjHUrD4UknMf4ywllOw+FJJzL9MWCspWAcIC/OvENbxFCy+VBLzHyesEylYfKkk5j9BWM+mYD1MWJj/WcI6mYLFF71h/pOE9ZkULL4YDfN/hrBOObCiZ/nae0rJf4qwnkvB2k5YmF/yTipY0g+JO3ka3tu5b6XMX7kI/TzxastPx508HfTKFeXDQ5czCq8FJQ77IoxDOmcUOhrWIUOspw2xDhtiHTHEOmqI9YwhVmiItWSIdcwQa9kQa8UQ67gh1glDrGcNsU4aYn3GEIv7MpdfHz3LqSsuv17yoT3j6a4RyoPpESNp3DAS6OOB5zKUB9+xbJ5LoJfEH8pGLn4edJwSPe8krNWOU6Ln2whrteOU6HkXYa12nBI930NYqx2nRM/3EtZqxynR85sIC/OzbU8bp3w67MbC/P2OUz5CWKsdp0TPbw66sVY7Tomei4S12nFK9FwirNWOU6LnMmGtdpwSPVcIa7XjlOi5SliDjFNqhOUap5xOwZomLMx/mrDOpGDNEBbmP0NYZ1OwZgkL858lrHMpWHOEhfnPEdb5FKxvISzMf56wLqRgfSthYf4LhPV8Cta3ERbmf56wXkjB+nbCwvwvENaLKVjfQViY/0XC+mwK1ncSFub/LGG9lII1T1iY/yXCejkF6y2EhflfJqzPpWB9F2Fh/s8R1udTsN5KWJj/84T1gylYbyMszP+DhPVDKVj3ERbm/yHC+oIDKwrfG3ZjYf4vENYPp2C9nbAw/w8T1o8E7jK+PejGwvw/Qlg/moL1DsLC/D9KWD/mwIpCK+zGwvw/Rlg/nsLXdxNfmP/HCeuLKVjvJCzM/0XC+okUrPsJC/P/BGH9ZArWA4SF+X+SsH4qBetdhIX5f4qwfjoF60HCwvw/TVg/k4L1EGFh/p8hrJ91YEWhGXZjYf6fJayfS+Hre4gvzP9zhPXzKVjvJizM//OE9QspWO8hLMz/C4T1iylY7yUszP+LhPWlFKz3ERbm/xJh/VIK1vsJC/P/EmH9cgrW9xIW5v9lwvpyCtYHCAvzf5mwfiUF64OEhfl/hbB+NQXr+wgL8/8qYf1aCtaHCAvz/xph/XoK1ocJC/P/OmH9RgrWRwgL8/8GYf1mCtZHCQvz/yZhfSUF62OEhfm/Qli/lYL1ccLC/L9FWL+dgvUJwsL8v01Yv5OC9f2Ehfl/h7B+NwWrTliY/3cJ66spWAuEhfkl76SClYv/yjrX78F7u3WlailH9KQc+A7p54lXW34661y/F/TKFeXD61xfU3gtKHE85/g1hc7XFDoa1mFDrCOGWEcNsZ4xxAoNsZYMsY4ZYi0bYq0YYh03xDphiPWsIdZJQ6zPGGKdMsQ6bYh1xhDrrCHWOUOs84ZYFwyxnjfEesEQ60VDrM8aYr1kiPWyIdbnDLE+b4j1g4ZYP2SI9QVDrB82xPoRQ6wfNcT6MUOsHzfE+qIh1k8YYv2kIdZPGWL9tCHWzxhi/awh1s8ZYv28IdYvGGL9oiHWlwyxfskQ65cNsb5siPUrhli/aoj1a4ZYv26I9RuGWL9piPUVQ6zfMsT6bUOs3zHE4jnHtH1yi/Gza5+c5MN5J/40c4TyYHrESNqHNxLo++u+mqE8+I5l89UEekn8oWwa8bPFvr8mYQ2y769FWJi/331/1xOWtu9vSsnH+0SfctCJgmuf6FMOOl8dkM5XFTrad4q7w+64EaWs/J1i9MzfPu6BuEMUt1cpF3+niG2Ev1NEHeTvFFGn+DtF1BH+ThHrHL9TlO9xRUZh/H6Cyiaymo9/FwcM2u2KLEest1zC3yDorkMJrB+Yb90a0IkC31q0VuU5ZEgHseSYA6394oliq2m/mP+pBCw52iAK8o0vttMxSv98rMvRt8J/SUdtaHvUR+Dd/Y6ySl5pI9y/zce/i4OFkuAf9YNfcfWPWCa2KSi7fvQLaeUJy1p2rrIh/6yH2F9n8SOO9Ik1ocT5qNPDjnJrfYjGq1aOpLaJdPKKTCT9UQdfmN7lP4kM0YcxlGHZJUPNB1vNKcgit+2Ujm9W1nxRxgro93Z6NwJ4GDTbtjGBT6GbZscxP/thTxFf2l+hw++Yjsaz0MHzLKSfiHyeL9PZDKJ3eGQOfkd1A8R3pd/awfy1GFP7ziupreSAnutUM6GXdNTSaAJ/vwX9Hp9oqZ0sd4ODZ8FEXxh5lnM/mIffIz/SUx+p+pFCSzsRjb9p7vfUvoOKHJJkGwX0U9CPwfS/36efgvrNfgryJHm1MT+fnqrRcfWTmxQ6g/oHGh2NZx67RQHb+R9TOxd9QJ3HvHIewhil/5stHcw/dbRz3j/EPg3bPm7nQi+pnbPeSPo/c7RzzWd+V5jMs2Ci/iDP3M4l/T+jdu7Jr1HbudDS+jFu5/32Y5od1+hMDkhnUqHju7+cJDqHDekglrTJtPb676i9Sr1q7ZX7bUz/NWiv/ye1V9R3V31y33FYocttJgiyzVG6vk1mGxUFV9/RtlGOvsM1BoiCa4zrmhPGdJjGNW864qCB+oTvxWdN8j2QjuYvjybg5hQe5fRlv2PumZa0BZz7lSBxocKzxC1B+veFnXQcRug3linSlX+R4URnbWwYJmCyTKPAp79LmdcpuEcJF20Ay+uBsDtO0m6NCxO1/w2TOh7rSRRkns7vuHK2yPWLgeuX5cNBq1/hO6rfjTs6uJyOaWIdLlEc0uEz/rCPFIxI9jfGRIe1La2mvfQjT629aPLktQiUp2CgPMcIYx70/WbSd0nD/UUUpP1ImxX5jSr5o8C+n6S/LaYZyeeDO3T6rvYWBLpdQDnwWaNhoPOilVnSfjvp4xLlmY9/FwcK1ZLU4zHiGWkve6KdxV9D+pMKP8J3XokbHYDXWmlmpjxdbdRaC9OztVozR/jCK7/juUPtrI6rlPQi6+NeZF1pSFMbCTv4KyDXKIxC3DLFjUGc8Bi1oQ/v6OZ/xRP/WeSP9AtK+vvCTrp+6rKg0OGx2iBYh1eJtSXobgNaX4i+DfeF6L+IfY3s8kcT7HIWWye2je0+lpPt4IfI1oVEez7+XRwoVKqaP8q27pgn2lltndCfDJLrNq/EDWLrGrVqqdqaqy00WpVmY6aVC3r7hBHlHds6TW8LSnrPtqKo2Tq2Z6MQd4zi0NYJj5qt89MvVopZ5I/0C0p6tnVZ67Kg0GFbNwjW4VViia1bgvxh/KzZOvZTjyrlQVvH47JPkE3yc6WDPkfINhX5jQKOoY+CnFi+jIPv0G/GPDxnI+kfBr+9ManzJ2V4QOFP27uE5XpkMjndUSVdNIU0Jbw1D7zvk/V9zcb7mov7mgdGAp09LiIXn4dTAaWLAk/P7KffHM+Y0gVnvblM/iKWVnWIzV3vozDkaZIJGyVa8/Hf4oBBGzpyV+tnea2ceVgh9PNBr8r52NahTW2ifLh79LMsUS5Gww9eMojCJ8Ne2TAfrsvFeIm/32XKEYXOZKC3K+1vEGSb7k+aMkgztUmm8QyYxqOTnfRsa7Q6d12l4Nq2klPS86V6uESXc+DzdMsK2Iuv05QrulRSDrmVapTi5uP3xYFCuRTx8UmYymK9RXctqZ1p14VIetdWsijIkoZra5GmW6hLoiNaPbvalI+lf43O1IB0phQ6vtvuFNFJWqr7fEKbTFqqK0M8pv9lWKr7AtVnku16pVxhJ26N2ky53zaj2SlXm0n7dENkqC2xfiDsjtP0neUahUbYzcOIwoPWnxaU/JIui5/C/cV8/Ls4UChl9lOE/lr5KaMZ5SryecqPfIou3XxKkQ9vDeC6Q9uNbV8b/mjLfdhP8HDxN+PG7tpS4Go72hL8K9v/aFjk2w/itjUCPFYAS65H8r3tA+0l14eh7lel3Ecd5Wb60T9cBhohDC09j3kYnz+Rkvx48bumW6yPfwg+6TcmdcwgcPukLJPxQO8vedlb0v8jxY/U6hiXDf+Q+lWUJW81OqLI4ZWtdBn6e20Zn/v7/biVjvjS7I/mV7EP369fpdFhrKxbBCX9P4V64QuX065Fy7I1nttoFDTZJG3DwHxiZ7jtJOklto0HqfyS/l9C+d9Dt4di+0vaDpT0SeNI4NavHP3jqbvo3xaFvrYsEv2bj38XBwxsy0aBRqjww8s3/57am0zfjihl1eS6pNDFKeMtRHeJ6Eb1eHRHN6bwtjHobWdanfC2dObzUxQv6f9vsLP/gfrqpC39/9+kTjsf6HqY1E6QV2yHB8PueEn/NyCvpYSxAfKj8aq1UbyEvd82+hDxKun/ztFGXbqk+XS8lUdro8x3jt5n1Ys2zuZOuf/B4cOhXkxt7uaBtxSm2Qf2Hebj38UBA9cltlPNXnJdTlC5luL3I0pZtToNFbpLkIbtQ0h0NfuAn/QJH7sBM0mPxxSeo8Btrr3sATxwmxtVyqzpgdbHuj7pwE+mtfRcFkm/FXh1zfuJP+B3DqOkzvth2xkLu8utXROs+VYspyBBTmLfCkG6TZa06IvheKkVduIx/R1gJ27c3F1W15yEp+XIuRzRCwJ9TkLor9WcRL91+5TCfyNMTq+1MW3OI1o74TncAmAJXbyC+ii90+YpeD4qaWxzD9kGbQ4M9U7GckwzCo1Qp4m4SFOb62Q72c+cXJoMNP3Pop8aHdfa0kFDOtp2WNeYMUlf+Z1r7gbtMdsmH3MkzwCfWcY7IZQhi3+rfXKqbU/mtjuaIDueI5H0e8D2fie1K1cZo4DjUuZJG7vyPMBS0KGt8cxjV0n/Nuij0z6fw3JEgecDJP07AJPnA5Ygfxa7q23nWYI0wo/WJnjciGPAkOho2Lx1T8NZIhwuZ5KvLRja1rXo33z8uzhgELzlGA993hWFnzFK/72kxyeCbpm6ZBb9O67QxWOy2dc+TnQ1X1t4w7E41jvXCa9LM5885pL0H4H2/CHypbB/x/60vlmnjeOCZQevxxRel4AWjwsk/Scc4wJtzhN51XxyaZOXwidHuzUWdstHsx+u+cSs9kPbWniU4rC/znIESJY+ZjwhPeuspH9UGVO5PteN8PeQv4V0eD/AQSiDq5/iusK8Ec39m3Vc7EtQZg+H3eWV9A2YM3+S2mDSfNjBhDaoHXERhfuItqTfAbSfJhlqa0qutfucEpfFnx3NSOepBDpBRjpaeSz9Zm2+/mriud+1DMy/VntEriY6RxQ6nv3mzGNqoZ8Petu9jzG161hIlKuk1+ZLDjvSh0p67egpHFOjDQ+ILo6pQ3qntXOeR+x3jOXa56Wtf6bZuc/1aeceDzvxmP4/XtXB/CGyc8O2r+yaAelco9DxbTOuofI85ShPvzqF+dfq6IxriA72D6ifX0pYf+j3CJp/Avr55VXqp+u4i7U6JsXHHM3lUJ7Xcxv5A6M28t9BG/kfqY1o+9Fcx52sVs5Z6bwe6vOIIR1tbj5Nb/4iYU0vq95I+p8BvfnnGfRGk03SUZlId630zYXl8i21fUqueUnXGiqm147nEF3w+3ly9v3AQj9PvNry0xknLAW9sntGkd2moDM3VW/uL5Vn39Zc3Hdo7wGuDAEskJBDApT0Af3mfBFTSZ0bpo0CnieHilSg/DwQYfwsPKWlTYvXGuEzCeUMgmyNEPMnNcKk87xCiMf0/xEmubKc54XK0895XkkGZEQpQz4hH07qYxyW+X5HmSX9/+8o85GUMt8Xdpc56bxc/M3pRpQybAj0CXbXQuS1QTfv/eoT5l+rzv1aopPU6Y5MdfKgHJI+/HkU4jH9i9DpjseY/Z7Rx+fw9StnjY5vOfNZrEcc5en3nHHtXG9XPT0KaZI2Z2kbqqLAH0ZL+mviuvR8Nrf6jb/Q0r53xw83txnp8AnQ4RtIh7WJrrWaUOunreSC1beVtSqPC0trDzniGdO/ph3aUrOYxQYh/de8Q/uvct1CDglQ0gf0m/O5HFpOy8ZQFGlQh1bjKSltvw4t0maHtt8ZYsyPq+DYIGwVqdzzZSKuvoZAk2f2noYyaI5a0qx8LgGfDSUe7qLJjndCSfqZuEOIHMiVeHVfq6ttCfwFQba6wvxrNZu/jej42O0XBf7KM003ysRXkhP7VnIAtAsgtJVlvtxgGhyAt5MDoM0Su1aNspxWoe3Y1ToozfFM2uWQptcsI433KLBDKOkXyCH0c0JNrXjpVqNrmTtlPrhJ++omr8SNDsBrbaZVKk5Pz1Ra5fpsszbNfZfwyu+yrFTfrKT3O6NXVQ/dRMc/CqMQd5TixiBOeNQOovPjMFUbWeSP9AtK+qSviTWsKKzzgCWHx7m++OIdT1FwXdgm6ZvQd2a5COUppTyuCzpG6DfbMrZVUZiP/6bVcCslBCS39Qov/IWcpN0Ncnl2R3dZtEPqRMYjDhqB8i4XJMuOaYwoeO8Pu+OOZOBNm7BDjIMJfEYY2qD7JipLv5MpNyn8+Fz5Qppp/svT5L+krXw9GXbiMf0u8F+Okv+i7cZhPywX6L4D2xT8Ek+bEGY7IOmXQd/TLrDCcjKPiIn+C/LM/oukP0n+i6cdbeqEltBaq5PhGGs06OxaR/v4jrBbVpL+PfGgNKrns1P9YX53AubvTnUwL/SJ+c4EzF8EzBcden9d0E0P25TWzljGmF/S+T0BqXNZ6F4/+O2LJfcossAyCf1Bd9AirbX6MlIrm6ue9wA/3JY0rD19Yk0ocT7qdNRRbqQ/6eBVKwf7FRqd6xSZSPrHHXxhemnDqPuSV2SIl2sbyrDsqm+87Fvor+ayUJHbNkrHl4Wi7PcmYAX0exu9Gwn0y0Ijm/k/xHZe65c2J/AsPKT1S5if9d+PzZxZ1L7klaB9yYs8chih38h3VN83bu3gcjrEYD3mywRdNjcJQ5v7TGv3UcDJe9n9v//Ann3Nd+975Mn6geZ9TzYfO6Do74agu3zr6Def9Iy8Il+TlI4XZ/fQ7wP0+wmFHw4sEwyTSrqkkNY+7oTn1bQPzO+aV7x1QDq3KnRcWHcqWC77fauS/nKx37dROhnbDWK/b6N3SfabecHx031hJw3PeUv6v6LxkB+fZK4yGfTaNCmL0H7cE+0c0QsC3S8V+pMKP8J3XokbZD63PFsplWYvLgU3i9VivVF0tTF8x21yn5L+biW9yPpA4EXW6sUi+0CuURiFuMcpbgzihEdtPteP3ZjLJH+kX1DS83xJ1rrUsO5bJZbM56Ltlbbtt63373+NUJzrREtct8C5Zw6a3yblfeViuwx+m+sUKr/j8rWTIeoqB02GUt5+ZYi6xjL005bXTobYRjloMpTyRjJs9SFD1DWew0bb1D5VLhgu+fKGK1yHelvYScchTYZv6UOG2jz4SKDLibF4HPKwwo/Y6SeCbv6x/qLA61qY/wnCOpiCdR9hYf4sX84h1kOE5dq/cDgF60HCcn0pcyQF6zHCcp2GeDQFaw9huU5meiYFay9hJZ18G/0LU7AeJyzMHxLWUgrWPsLC/EuEdSwFaz9hYf5jhLWcgnWAsDD/ckI+tG9RmFTeSVv3e/Fcqe8LWbXxgo85bk3uml8osltReC0ocdhvYxzSWVHoaFijhlhPG2LtM8R6whDroCHWU4ZYhw2xjhhiHTXEesYQKzTEWjLEOmaItdcQS+aRtXnQx4lOv/OgPG+ThqXZ0E3xvyi8Mm/+1vre/U/sbgYUeI2U58sPJNAvKPkDypujd4UELMHJER7PUYidT7rBgvd0SPrvjgnj6V0TSn7DcUdd+6hLgsRh/8B9H/qtbwu747Sb/HIKHW18IO8iWXyDTocOFCxtbQF14hZ4xjihz+9Y1zG/pNPo3DognVsVOi6sWxQsSa+NKW5V0mvjE8nr+Sac9tqCNsbTxiWrWVsQuW2ndLy2oI31GCug39vpXdragvCS9AEwry1I+v2xbk8ovNrVx2zF9d2C333qs5nXFoT+pMIPnxTO+yHnV8lra7ZcXKy0msVaZWFhsdhwtbF+T5J4g5Le7566WXVtAefBojAKcYcpbgzi8MRxXlvwYzdmi1nkj/QLSnrut7PWpSWWrC2g7ZW27betD+/aAu5J6GdeHPtLPoQAZXg7PGOc8MPvuN5vV3idVPLlEv4KHX7HdDSete/XcP/zSqGTB/UK9z9j3ifCTjym3wL7n5917NngMTrrKupGFLid4KmwWfpDSX8afGXe/6x9W/FEmMyz0MByub7fkvQXqE/20y/q+5+FluukO5ZHEHTqxPVtnCYHv2WcaWjfD0jQ7A3vocU5Bt57EELcPopbAjrfF3bH4Ziexz3LEHeA4rS5NYk7DnGjFIcnn6OOctBsJh7K8hd92Eztph4eE6J8tX1Id8Azxgmv/I71DfPvTcjHdsTznqeS5zbd3lesfbOFZWJfV5unz9K/IK21mkfXyubaq4HzDDyPrGE93SfWhBLno073Ocqt2QSNV60cPC+otbM7FJlI+sMOvjC9dtjQWs8HaDK0mg8Qud1N6XivOOrg0wlYAf2+m94lzQdodnQ0gU+hm2ZHs35jgv7i1ws6zazf+0v6v4Pvm74Bzzwnp8lvin5Hfw/Fz573V81q8x0Bye4Q0cY4XgsKgiBzn417qEqr3EN1iOgLJtbfpyFN0tzz/wz+9Ne265i5QB9DsE8vOpH1m0ZJ/+cOn17SjCaUa08C5v8FuviXCboeKJhauR6ncjEPe4kHSf9Xyrx+EPTaX7Ypj4bdvO1TaAUJ77jP2ZcQ56Kbljd6fpIw2Kdgff00pZf1qSSZsq5I+v/NoSvatxyuPaXMA6d5PIGH/0PhIeqPNsbxi3v2HkpYzsLmkwt6l7e4KrkKRhWcpCD4UfGkOTCO/Hapn7b9FfM+nsAj5sUzrhrN3c0DSet965QCaMTWBXrw/F1UUduDL0HbR8j9Bvu3GLcf4tD2ctD6FPyeKuu62en1rz6vlU+SxdeIQjPsxGP6f4B2xzfI7QU+NEy8PZoblmtuRNKnjdeEvshS8/tdtLV9jZL+cJ+8amsN6EPvI15dh2Sm8XpfuLa87u2TV20fA9rqi8bokSeb+x7ac6CJzYPZCOh5gt4lbUuQ348nsLqJ0vE0Mh8xwv0Df+a3X+FPC8IHBuZlJEgPfF7xVDx9HDXRP09ookHg3k6hbTNG1/LrNLTQllBc6uhyYbVzTxGDjw2R9Nug3Gyasl76K+m17bI4BcpTwNgM+NgnXObDKd0ojEKc4VC+oV3ehzIYC7OXV5NPqKTXjmcsUHqUlbbUwtOg2IXhWbkrpH/akWWusrm2EMU/Ey9XfTjsxGP6Ox36t6TwoJ03K+mPKemXIA1PCYcQJ3k1/cNPKqIwCnGG+tfU9A9lwPrnKq8mn2UlPS4ZSP0WKD3KSuJQX4SmZv9E5njUkbaMm0v4GxAel01b2n4g7Kbj63ITWWZje6m5ctFzOX4WV59lPx//Lg4YuP3gFMQxhZ+eS5Sv6i7XCshHs+vloDv9skJ3hcqKdJeJLl6Sy1POUcDpwLcTr0uAzdPurjIvwPLxO+Nnl5vJR2O+C3g/tSM5P/eBvN0H41wXm2rHhKFusr2V9O8FPs+AjKOANg+nz6MwCnGGutrqt89dgrgsfW5an8D9KrYPHv5oQymUedLwJ+lSXDyqFtN/DOqIL8XFvp0v9D3YJ+9ZfdinoRx83K6rPjQ+jgGWlh7bL6ZvKTJhTGwLWMdhAuYjgPmXfWI+moC52+HPaP2vdq46211Mj32y8KN9TrVCccg797vLQJ/TPkb0MQ7bFtMNHPxyn53GL9tciVsGm/3p+Fm7gN7HkqlWl3cp5clal087ys9Y2L+yvmptaFmR19GrdMyxPjGXlH5P85V2hx3aywl9dhS4z44C26anFb7QF9DGN7wMKLx9Rmmvl2wMUGoWtf4Q5cj9oTZOc92jESrp+XjkKBSU9D8Qdse57grRpsey9jd4xOi2DHexCE3XfEX0fAOll3KjjUedeQTiMf3nHTY+VHjQtn24dD+ENHxsKNaV5HVtjb4U+ury30KlvEcHkA/rK9pNPnYb9YU/F7TS1xHSV80GaXXJ7SdU+NHaKctpPCG94HEf+qUMfhXy4PpUIOv8gtbHLQc6bWybIeDzBaCS/teGyZ4XSyWtfaBcuX24ZBiFfn3EMH52fU6qtY9jFKfN1Waxu1FwtR3Ji5fAamPjpCOg02gyj9p4WbP1kv4bDluv9b0uWx8q6TUboNkOyXvpxuq6LqMMsth613hnSUkfBt1liYJm63ksrG0FTrPdf+DQP15Wznq/mEtX+FMppJ11beRS1v1aro0k+aUsK5QJYmm2wTWnMqi/GQW+SzfN3+S5SUn/b/v0N116uKSkDyHNUPubq9DDUCnvpfQ3NRuE84Rfctgg9vk0/XP5Z2k2iK+v0mzQiMIX9sXaZ6BRmI//FgcMrjUdz/eU1nJET+SB75B+XpGjIT8lV71qcwB+r3MqViMzpa3HfTLslU2S3WEbLmtpUXgQcERXteMgcH1ILrTmNoM2GPMKDfYDx7d0MEcIUztWDW0w+7/asWoR7ueo7fO1YUhTq3OXvxwCHS099k2YfmNcVm18uKTw4Jp7SluL4fFxCHHHAp22tt9A60sl/VVQnks/PiyXLvWaP/dZrrEj6uAS0dH6Iu0zWu0zBBwDBgltC9fUsW3xMYPa599JPEZB1km5XXKb0MokR/axv7ZT0TFuhwFgboV3/fojrjklrqNQwXJ96iz5x5X0iMdt7M4MNiNpXodlKunvcchUaxMumaa1iTB+zjJPFSpYKNP7Qp3XrDKV9BWHTNPmylimkn7aIVNNRi6ZZp2Hcq1VZpUpb4kWOlllKum/3SFTXC/KIlNJP38JZYplXqF8IcSxf8z2Lp+Qb4sDcykBU95jPtfRplpdajaN6/J+R11q5VrKWK5jRuU61me5JP27PZXrqYRyPdVnuZZSysXrrpL+AxnKpc2TRIHn/iX9hzL6dpdyrmIt50t5ThR14ymKQ1+J5/etxjcHaXzD188jTW0/O/LBOiDpP5lRB9ZmT7muA671fM2Pdo2p0uZ0uJ61Y440HeA5Ve1Ilqz+PR6Zs39zdzrkJ5fwV2jyu3UZysZtC8cRKFcZRwzD3lzkh+3mURofaXtzQwWH+9ekvbm812qZ6Gp7c5PmXkLiFfu4LHMvkv4FmHtZjp81n0fGp9r8Ads0rY9BfUjqY05mtC/C17D1MUsQl6WPGWT/bEhYWj+i7Z/V5ht4DU9bl4n0448n0/kPlbzcPsYDtz/I7eNlhz+zDHm08WYlAfMLoPc/uKW7/FiPsi8rSveTW2xo/6hjHKONS1xrTseV9GhzhJ8p4gHzcrm5rn6S7II2x8UyQb8Z07PfrO2DzAXp44FlpYwsw/GE9GgrMf0vKHpWUMq5RPQ0/rL230vAa5jB/gpN19XvUWA9cfk+Im+kjfPXuL72Sv6wE7c2trhcvtS+nshH0wc+tl+zxSPwzmWL+foh9M3QFn8+rgz20f970GHed6/5/chXkt//+w57pcnNpYehkl7bi6DNOYeOfNo6KdKaj/8Wi62BgtBbivHWK7wIXfa1/gjk+OwOnddcD7+DBddYYCLQ7a4N7XIxR/SCoHesgfTzga4P8yb8dNZ0l4gflg+v6foZr5RauKaL+otrulg3mv+n7dPAccKfkc+i2QC0cyWIx/T/HPylv0jADAK3vUvbI/bvNnXjhgquxZyNZluWKA7z8ToQ1gnb/rRvm3gvpKT/t2AbXN8OCl9+9563LvneWpGZtrc2y/cQqAtJ39OPB+5xF6/X/7XDP3Tt7z3cJ+9HFd65nXPb+TPyHZHm0xloau01RzST9vfeAPGY/m/X0G+4sr+3N30YdJclCln296K+ZN3f+8ex7da+y85yvaE25+3qs1C/t0M8ps/HC4DDfP6KyMmz/pUv9R5jqd8s56+49nZq19JE+vflWP98ynFmttj2aaUO8Vh5DKMQj+l3xDqZh3LI39EB+GzN1EutSr1Vr9UbjepinY+Jj4LUWXTMVaQP27Z2ZMZt23JeXvDH/OC3vxsehbKOKGUS+qJL6yB9LuFvEOhjFqGVJyzjspVcZUP+eb1mlPiR5ySs0T6x/B6p2KnTEUe5mX5Seq0NyPtxBz6mF7uOOjxOsljvRxZlV72NA02hv5pjsOX3DkrH12KhvMcSsAL6vYPejQT6Mdhsl7TrTSSPZ5tSzmoHhH4+8Noe2nZgjPhJart4nOHuPfVGfLIqmzyuOhQnwnGxuera3SK9Y3VYR/nE1dO6UOYzp2BoIuAbwHMKfc2UjCTQDYKOurL5SMOS5xEHL0kYOcKYdGBcaTpXmo4SrjSdbE3H2hsvz85Oz5UXitWZxmKrUa2keePW9BcXpheqzYXF6VJ1ulItNvoZDbC3kXT5wzqIx/QfgVE3r0Ctc2BGgU9SlfQfd4zkNa9IK2cWM4D8TAW9esUjiLXSp5n67MLc4ly1Xp0uLhZnpldTn1q5UfYHwu704lkmXVwseGOU/lNQV7xbYxzyCNaTYS8m84z1gx47X8Ym6fcAD+dp1gPlwF0ietOGXdBijugFgd4lCv184LWLLnF9CD8sH14J8zTCWcgRPvKzXpGP1OUGJU6wZCYIbQ2mXw9lxPT4LPnx3ZFYtwqEGQU5HTWnxI0o70S+r5yyRq4b1k0u4a/g8jsewaNs2Iah/cSVw2MJ9gPliXnFfnBbfHFrB/N4/Kz5F1x/bJNdfgLSS7JX3F9J+lNgK/jyEO6vsJzMI9IbVehGge2VpD9HM3Ge2r16eaTQ0vq7XKDLIwiyzUJp/eOkQkfktTFwz7S47IRrxkva3HhCesEbo/Sfd/RlGyDPiMIX+zKS/gsOX2ZCKZfWruV9Xkk/oZRrKui1f5JXW5UQ2Xs+oXZRW5VAGY6F6fJZP4B8RAcKlB5lpdnQ9UQnbWjJq7jaLBraXPTfphT6XE6tPYwr5XS1B618rLtf7tO3w4t21yfwkNW3k/S/Djy84PDtsC/7za1uXtne4NgH0/8e9GW/TfWjzYJqdpBXYrEuRUZoB8cVXK09s05obQXTs68tuj+ekB79KUz/+w6dyEMezb9kn0HS/4HDRm4MesuF4xiWwyYl/cagVw5TQa8N2BTotLE8KGe+QFvS/2OlPJrdxRWFKIxCnKHdVW/jQLmy3XXJMAos80klPcpSyleg9Ch/re1spDiku4F4SBvbsE3W/A20Hdr0KspA+JxQymtXd4ulHNGT8uE7pJ8PenXex1gyq46IfCb9yKfo0sFJRT7Cz2Yv/BQroisFhbbwGh9C1mVXMP0kyBDT47Pkx3f/gfR1CvIJfoHiosDjWIwbUd6tu0RYBQUL5SZ1GrXjf0Oy4JuttL+Cy++YR6xP0XmXjVgtHcQS/0ZrT9G/+fh3caBQKUs5NivlENqoV3ZtpzaT1dYJ/XzgtS2XXDqM8uGxbkHhtRD06vDTYSddmn4jHQ3rwpBirRhiPWeIddYQy1JeJw2xThtinTDEOmiIZVnGM4ZYlnwdM8RaMcSyrMdlQyzLNnTeEMuyHi119QVDrBVDrHOGWJ81xLLU+2G1OZZlfMkQ65Ah1suGWJbysvRNLPVrWP1CS70fVl9uyRDrlCHW5eDLDaveW/omV/q0/rCG1ZcbVlto6ctZ2kLLerSU17D6X08ZYg2r/3XcEMuybVu2IUt5WfZDlm1oWGVvab8s5+VWDLGGVb8sfd9h9TGHse+InnnNyqLv0NZ6cY/ihMKH5Xqv4G/xhC+yusohK6TPa78Sr/0VLI4TWnnCMi5byVU21xoxroejDJKwruoTa0KJ81GnBUe5kf6kg1etHJOGMhkzxOK9bdqeDW1dVdJvUdJrejKl0Ja8UrdbIc6wbsuuukUbIfRX8/W2yO0DlE5uc1gX9LaNqxKwAvr9AXo3AngYpoJeXduQwKfQ5XesK5h/kviQ37LnBffAyj4RbW9P9G8+/l0cKEyXXbbVbz8zXclqu4X+Wtlulw2LAu+NyGLDonAk7KQbxO5E4UVDrLOGWCuGWMcMsS4YYq0YYi0bYh00xLLUiSVDLEud+Iwh1ooh1rDqxGlDrDOGWMPati1lbymv44ZYlmU8ZYi1YohlqfcnDLEs9f5ZQyxLnXjJEGvFEOuK//X6sNGWfW1oiHU52MKXDbGsbE70zGPtQfh6PrTDsmxDljbask8bVr9wWPu0YR1bWcresg1ZysvSRl/pO177fUcUjhtiWdrCc4ZYV+YULl0bspS9ZRk/a4g1rOMhS9mfNMQa1vlCSz/nip24dP7EFTtx6WQ/rHYii/+F5wTyubzaOr5gbUnBuo+wMP8WwtqagvUQYWn7GSTf1Ql08MwL3INxtUJbwxcMbR9H9G8+/l0cKMzUJ5Ry2OGXG7Iefg2UOxf/FdrXwnu7tftq5vNJhX6eeLXlp7OX4Frih+XDewm2KbwWKC4Kz4SddBw3orxb58A6Y4h1wRBrxRDroCHWs4ZYS4ZY5w2xLOVlWUYrvjQ7Oyy6es4Qy7JtW+rEaUOsK/briv3yWUZL2R8zxLLU++cNsSzb9rC2R0sbPax9rWU9LhtiXQ790OVQRku+LO3qiiGWpb/K4/Zh0a8VQ6wXDbFOGmJZ+ibD2qddaY+XrozD2m9fDuM0SxvNe8dej3p/1hBrWOc6XjDEWjHEkvbI3wVGYT7+WxwoVKoyF41rJ7mgmy76Iobz5s0c0RMZ4Tuknydejflpz+Nrazkon3UkHz/rHMVGjvCRn2sV+WjrCuxHXhf/xnUsTH8tlBHT47Pkx3dviTNa2snoe+tvjXH7aAPlxVapUmvO1IrT9WqtMV0pN8ozxUa11iqVZkvluepspdJarM42ZsuVVnmmvDgZ9NY7twFPdVzN2gZ4LctTm3SuZV2t1FG/a1mPhp10w9T/yv09Wc6P96MLlYXV6oLv8+M1XXCdH59VF46GnXSD1p+lT205ljxliLViiDWsc3SWvv6wztEN67rAc4ZYluMGy/WKy2HNbxjX4KNwZR340sn+yjrwpZP9cUMsS70f1nXNK3bi0snesoyfNcSy9CdWDLEsZf+SIdaVNtQfVmiIdaUNXTrZW47dLcfI8g0FzyFFYT7+WxwslCcUukbYVcG+zh67fQbt9YNjN/iFYN9gz3dLsLebY1dqMpeGd8LjHeF/EiuQ6GZ8PXLXvD7eDb0O4jH9m7Z1MP9JjDkJuAFgRGGC8HKB5ZxjuZgjekGgz4EK/TzxastPZw50HfHD8uE50BGF1wLFReFw2EnHcSPKOxfWSUOs84ZYxwyxzhhivWCItWKIdW5I+Vo2xDpoiLU0pHxdMMSy1HtLvixlf8oQy7IeLWV/3BDLsowvGWIdMsR62RDLUl6nDbGGtW2vGGKJPyHfXqP/KPfRTwW9vtNGojcKcYgvfuk4xc/Hv4uDhZLgb/CD375TYb0iYyyT0Bc/cwzS5xL+ChbHCa08YVnLzlU25J/1Zz3ww3cvaFjr+8SaUOJ81Om4o9xIf9LBq1aOUZLJqEInp8hE3m9w8IXppxTakldkOAFxhjIsu2SIbVHor+Y+CpHbzZROzrFYF/Tq4PoErIB+30zvRgAPA4+50UZOBr02U+hG9lHq50aI57ssbgRaI8o7bi+Y/8YELG2uIQrNsBOP6avxXEOE/c3t3Zg3Kfy5dPdmJf1NkEb40WQjeScV2v3YUOSroPAwskZ0RteIzoY1ojOxRnTG14gO2/ebDencDGnGiM4thnRugTSbiM6thnRuhTTs++2EOLQ3wsdtCh/SP+2C94b9U+b9u0I/T7wa89P2tXYRPywf7lveoPBaUOJw7yvGIZ03KHQ0rBFDLNGNqaBXV24jOjsVOjsddG5T6Ihe3U7lmY9/FwcK5VmplzuC3iBxd8K7z4UdPjiM0G/kO7LpL+3o4HI6polyvZPisI3dRXFYV3dT3Bsh7p74eSrolS/SxjgpI7/jesT8tzvo7BqQzi6FzqSSb1BbqcmG68mCDsptF9HZZUgH5fYGovMGQzqoi28kOjsgH663PbOtkwfzoQ+MeeWsuTFK/0vbO5jHYkyxJXcCX4a2pC5luyvoDRJ3N9Bmnb0H4ljP7oU41o03QRzKnINmn0QWkX36Sh/26Q6IkzJJHUj+52HN8+y27vxYh/xNCPafD1DcG5W4CP8dN3T4QTlEPrvozQTkZb2R9L9IuuKn35me0foW9qXu8kQ7S3vW+hbkR/jOK3GjA/DaWpwtVorT043mdHWhVm3lgt42NaK843Hr3Up67b5BkfU9fmRdlrYwEnbwsV+OwijE3UVxYxAnPEZt9cM7uvm/2xP/WeSP9AtK+oegDP3UpU8stAcWWOtXibUl6O2TxOZ49n3nNBskQWvzBYpDnbuK4rA98Z3T2JfhXB+HNH/6T/vor7BfvCsBU/oCHAtIHzNGab8KfdtvU9+GPuH3hN1x6HsJnQjjm+T3CB2ca5Z+Mgq7E/j60zXxdaoNzdfh/utuT7Sz9l88/kF+hO+8EjdI/7VQalWaxYWFanmhUZuennb1R/iO+697lPTaGbci63v9yHpB67/uAblGYRTiuG/D/kt41PovP/1vdSGL/JF+QUn/KShDP3Uptl3zmzRb8QNhdxyO+dDX/Sa1cT9+YnmB2w0Gzc5z/4A6yf0Djlm4f3gzxPXbP4gs+u0f0E5imRBzFN5pNn6M0v8b6CP+F+ojsE8X2lG6D1/Xne5uhW+/bSb7XKvQ12yoj7lWzSZq7U7TP27fGLcNnjEO6dyr0NGwxgyxRC+mgl4dvZvo3KnQudNB526FjugVtj+7eqwUpV6KQW+QuBK863euVfjud64V5VqiOGxjZYrDuqpQHNq3avw8FfTKF2ljnJSR33E9Yv43O+jcMyCdexQ6k0q+XMJfocPvmI4mG9dcyWrpaPae69yCDsrtXqJzryEd1MU3ER300XGudfN1nTyYD+datbH3GKX/EZhrvSrGnAh628GlsiWazpYhjvWsAnGsG1WIQ5lz0OyTyKLfuVa01Vgm5D2rbyLpb6Z68uRLFLdQuTSZuuZAh83H8TOedvs4Wj/er4+D54ux7enXL9lliCW6PRUEiX5JjuKQzt0OOpq/dLn6OJoNWSsfh33Vfn0PzP9683GS5qgs6GjzG5ebj/OAkY9zFnych6jv9DP/YuvjsJ758nFw/uUrRmOwtLmSHNFO8oXeE776l+dpPnFdB/Nj1yXzdTvQ/qdX5mk4XLbzNK49Ttz39bvHSdsvcrn6MCjXtfZhkDbGSRnTfAvM/3rzYdZq793l6sM8Z+TDHAUf5uxrcJ6G9ey1NE+D6/lZfBNJ/4UhmqfZqZTf7x6V7D6O0M8Tr758HK0f1/a2a/2T5NVsD8/TaL7UPQodDWuXIRbP0yD2TqKjfROxy0FH2/fsd19Ducn9Pwatv+zXx8G9Dv34OChXtoXYxooU1+/8zlTQK99B5/Uw/70OOrcPSOd2hY7vvnqt9uOvlS91qeadknycf0Q+juTL6uNI+sfAx/mjNZmn6c+WaDpbhLhdFId+BOuGNr+T1T6tdp4GbTXbJ5wrkXTaXMkuhYZnPyLzHTjsR+zyw4/Tj0D5SNvaFHS+dX24eeDdTyzsfmTxgeah/W95rPHu+r4Dj9R3v6XR2Nfcvx9Lw1rDpWVt4TTyXFDeI8ZdKaWQL/y1GZK7COvuFKz7CEvbhc5WJAnrIcLSLBf3SFprY28K0yM/96bw82CYzM+9hPWmFKzHCEsbeQrWm1Ow9hAW5n8z5Ssm0ME0aA2LCm0Nn/W2lMLz3rCbZ+SLR2flFKzHCQvzlwmrkoK1j7Awf4XyVRPoYBocBVeBTk55p/GzP0zmp0pYtRSsA4SF+WuENZ2C9QRhYf5pyjeTQAfTTMP7GaCTU95p/DwZJvMjebP0cMirYY+SeVe80F+rHi5NrjxSnlV4LShxPIqYVejMKnQ0rLsMse4xxLrbEOteQ6w3G2IVDbFKhlgVQ6yyIVbVEEtsorYSsZXo9LsSgfnXaiViK9HBGTkcbb7h+k4e1EEcbWJe6YvGKP1HYbR5R4ypzZC5Vnww3WrkrNGRvgZ12HBWf1rki324BInDfu56eOagjU6F735nz1Cu3CejnZmlOLQbcxSHbfdb4uepoFe+bBM1PxDfufS44qBTHJBOUaEzqeQbtF1qsvHd/nlWtGhIRxs/sP5Y0NHGFmn27H6yZ5IvyZ6JLztG6d8F9uzBGHMi6G0Hl9KWsM5qfonEzUEc68a3QBzKnINmn0QW/c6eoa1m+6S1iYmgV/cuxeqa0M8HvW3Ox5hBmxPQ+kDNfkterT3dAM/cbkeUd662ucsQS8aSLt8hR3FIZ5eDjuZrePYPqrwKj2GSyhyFflfXVusfoFxrFIdtbJrisK643aJdFFuk9dusL/3225j/9eYf8KrHLkM6KLfL1T9Y7tM/4NU1Sf9t4B+cIP8A58OG1T9gPfPlH4gs+vUPcGw/A/isX5gO61DT9UB5l1NwuM2VEuhH4YPhq3+1ufWriYbWl+M71u+rFX5d7dVvX/bq6eJIT8qB75B+XpGJDx+pklGumm5VSOaaHrCOIJ2qQkfDYjvomhcv+ZFXZh9X6K/VvLjmL16tyHUt9DupnosOfvzY+85J9GnrQ8JPdLLIeNCrQ9q6GPON60jyLqluXOvZrrXFtPXA+wgrqQxJdeRaz9ZkMEZx/zjuxyMZ/ur13WlkHfYbkObX42etX+Y27WmtK3Ob5rWuaT/8ONe6UD6os+sDt+5g3SXtA3iTUlbW5XtTeGJd7nfPAWKxLrv2HBRTsFiXMT/7BWireWebthOcx6CI/8putOuT8YsO/JIDv+LA13bAanPaVYrDsWcN8P/UgX+3A/9eB/6bFHzGFLtRgLidFCdpvxljRD7y2Rt1fgUjCn5PlctuU4T+Wu001/ZDuXaaa/uUXF+tueyEaxcuYt1liCXr5353gFcq2pyGBG3+aq12gGO9cHtHOfP8FbYLnr/CPQnST6zVzmyNzqD6cpdCZ1LJl0v4K3T4XZavPLmeLOho+yG5zi3oaHslWX8s6Lh2gKO/inNUf09zVNoOcM3X5R3g98Ac1T/QHJWfr6dsd4CznqFPyLoxyA5wPE36KwN+oRLtTpavsx9uHnigeegD9d2PNOoHHtnz2Hubjz/R3H9glGC5+bCa353ALuIEDnajsI7idlH8A2FvOgxZpi38dE/Z3RGhv1bTFmlbmNkdeZPCa0GJ2w7P3JRGlHfrHFh3GmLxRSmIzVNl/R7CuEvh+cohjFcOYUyic+UQxtXRGYaP+5OW5qbp4hI8jD7L0pyk3wFuz1yM6fdSttfmIYwii0E+fGP7hJfZyMH8Encb5OPLlvBCLvxgTi6z0baDyEdgU/Q7epZLCseIr4+TPuBlhob60L4UQLtEyu8HfpXMnz8kDeOQ77wSNzoAr+XmwuJ0vd6qLLaKi/VWk9u68Mrv1gF9tr2SfrOS3vPBZHVpL3gpALbfKIxCHH+COAZx+CEqXwrg57DNSj2L/JF+QUl/P5Shn7rUhvzsR2bFkgsG8HITvnQXbRO3RT92IPvYRejniVdjftpjF+0y4x2KXLWhruTVfHc+mKzfLXqafbfAkr5H6yt2EB3tYuibHHR2KDwP04VFUViryzpRrjxFg22Mp9ywrtjHwTbNU6koX9aXfu0Q5ncdZHfzgHRuVuj4nkq9iej4uniaba6vi6fXapsk+6lJY5dTCZcuZh27SPpNMHY5Q74qX2Q8H/8uDhT6v/yMdRanW1nPcLzJuoHjFZQ5B80+iSwGGbuwfdLaxLD6Bzf54cfpH2h9YL/+AR/qNUiffochlujFVNBb39yvaLK52UFHs4+Xq3+AcuX259qaYeEf+Oi3NTo7B6SzU6Hj2z9Yq357J9HZaUjHtXVorfyDpMu8fz+Df+C6zFvS//0NHcw/IP/AT59g6x+wnvV70XdW+ySy6Nc/wLHcXQmYY0raGylO0n4T6uvvaC4T898SdMfdCHG3Upw2dtX6LcRAGqhz2M6bYXcZJP0/i/mOZHlmh465LgFT9FibJ8OxchRGIc5OfxdLEd+fBB1Amb5S3rC7TGiTRpT0PBep+R1oi26Jn7P4MNrcwy3wTubaNHkKj5dCnrcAj1nkien7lafIyDXPkwt6603zY13yvCV+dynkiTxmkafmm+dIJpge5SkyKgS9MnwjYd2iYGF757lgwR5X0rNNwvT/GWzO17d386fNt0ncjQo22t4cYWA58ko5JikO80a4f3JtN662LuGqG+24wDsVWmLftcu7/a4RlOvaeEGC1sdz/591DoD7f9yz4NoKjjLhoPkGIqdIty7AdmtOh89IR3BZj1hndig8ar7gnSm4/eoMj2Vf6zrDc0qoM6xPrwWdQfvNOrNT4VGbX0w7ZpR1Rts6jz4764x2QPJr6ZKnQfdQSBx+toIy4aDpDK7n9qMzaQfqu3QGL2bi/TRvSsFlndH2ZGntS3RG25Pl91KNcmtS4VUC65NWv1kPlea5Ku2TNE2fUCYcNJ3BCzf60Zm0431ZZ7T5NG3rufaZpbYvT9Jrx6KiPNjOaJ9tTSj5DO1MbVLhVYLE4eeRvJcSP+XkPkY7zlHi8IgF3jeFRyzw8bYYNJ0ROfWrM9pRv1ntjOTVjtRI+zSXdUb7vDmrzkhezzozVEdzSdy3QtxrTWfupyMi0UbzMU+ljDQlfdpn5qx/mr6ifXfpHx9BKvlwjg355+PmJH0jHuNG9fHN+FmbkxA5+Z2TKDa1OQmU61jYXW6XDKPQb5sXmRWCXntcpjjtuEjXXlXt2FNr30j8hdeLb8T9XNbLyIbVN8LxE9usuxQetYtZtM/2tcs9XXYM5c86g3ohef0eg1gpTSq8StDqnvsyrHvWC63utXEW6yG2fb5GAYOmMyKnfnVGswdZdQaPB3gug85o30VdrjqTxV683nXmgSt2pi+d4bmey1FnNpPO3KHg3gbvsnxPgWuTvA6B60L8vSbmG9Z9CLzWoF0Wqc03834P1BOUCQdNZ0RO/erMGwkX6ycKrnUIyRvpzDPxZv080Yr+DvSNT6PRLFVLM3OzzWq1MVfjC1WjIPq30QP9aq0+s1ifKZXmqqVmtZRKP5L/tq3d8hyFPFh3k8o7wRX9H6O886ssB4s1R/SCQN8rKvTzxKsxP+29omPED8uH94qOK7wWlDipg6kguU5yFIc8jCo8FJT8oxmwtPJsiv9FYf+BPfuab63v3f/E7mZAgXWF2/S6BPo5JX/gwMI8PtrVYm16YfFi4yo2S6/o41q361pjYbY4U67PNRanG5Xa4lrTby5U52YW5hZrxUZxrjRX6ceuTAa9upVL+BuFEQd2QcF6NHz1r9ggbEeWNkjw1xN/Rvhtv3BMkZPQ3uClbK1WVvsq9POBV3vftq8biB+WD3/rOuFHPs3oqEbRPbRZ44psmI/1xGPeE4/anKnwJHGjECd8RGn+6MZuHtd54tFvG201NB8F9yL/p+0dulg3OGeNer8O4jH9f4Zvlf7f+Hkq6O6X0E5thPj1Srz8lvpap6TFZ/4tvLNcMb3o5HhCWceprJL+72F+/j1bdUyUH/K1LgHzH5Q5f8HEvWiuNi/pNyrpsY0JP1NBb9vcSPmQ94mgO+A7rX5ylJb7YOmnMF/S7wkFJ4mHDQoO95OMyTQ1X4/HUiMKHWxT2OdPKPQN+4ea1ldK0HztHMVh2T8UdtJx0MauUqaovP+C1qswHfOjtTVL30jej8F7psv++Dilxf6cZTZmwGNBoTNOuOsd/OcIZ1TJNxno7VH7m5XfnMKvazy8WjqI9eGwmw7Wc9c1hvRdAtrxESXvp8NOPKa/a0cH8474Oa1PY1uCZfhI2HnHNpv9WG6TvK7NfRenwX4c0785Lgf2XWwfECt6VyJ5aj6C5vexj/AekGeV5Kn5AFNBr2xYhyeIFvrH0r+wDL4N+JjbkUxL5DrpKGP07jt26OmQB0zHGFrfKRhau5Z8Uwpf3PbYdow7aGj9mUZjjOIGrR+t30ZfQ/NhtHjsz5EOv1unpE/zP/IJ2BruuIKj2fkNFJdT4tiGYXnRhrFvoo3J0DZq7S6p7ly+t8Z7Fr9q3MG7Jj+0Q9ZzOcXZYqm4OFNrtUqN6fpCNW0uR96vD7vL9cpfeDcG5YrCBkxPcRMQNxp208/Hv0eBDmIJH2OUvgF1HYVxyCP5Cwr9caLfxbfyDnWNsUaUd5I+qtOPxTz6mKMr1+Zm63MLxVK5VS5XZqfT6lWTE84dREFkjXUxrpRtjNLvhj7nMfoGdUyhF6U74kiXS/j7CobybjTsfqfVEequpBfa+bCXR4nbCHFjRGdT/BvlhVjCxxilf4p0F/VN8hcU+huIfhffyjvW3Y1K+o1K+qh+9pM9wrJbz/29QpPw8R3zdsRju5quTpdmZ+uzi9OLrbnq4sJaz70vzk235iqVhVJlrtGcK02v+dx/tbLQKrUuzv9XWsXKbGnN1z7qxfLFtcyFhVqpWZ+ba615+UulUmu6ujA7vVi+OMW45msv1dZMfbo1U6yVG9VmuVFfa/r1meZcdbpSXqy05uqzxdm1pr/QmF4szlVKjXp9pjgzPbuatSeeI4mCzFF5WiPOfL5R204Hvb6sjzWVEeKH5cNr1tras7YOJ+fo55S4LOvSvrGmgt765nkJTTYjDjpcV1HIsk/C17xoVp0T+mu1TyLrvgKea8S8PKaMAuuJth9DWzt4rWBJ/ihoc8WPhN1xWMcs06y6KnOLbEunguS6EdoylsX3Ywq/PPf4e3TmL88nzse/iwMG7juQluc9TNPafJmESaXcXO84R8J1y+veGIf9Me+vwTBCv1EWEe1/mWGfnqYjOYobV8qhzc9wX5NT+HKtybvm+bR+Qs5szxFmELjncbQ58jR/hNc8ouBZ9zP7I0I/H/TWl4++IW2+jHXdtd6pzc3mKA7pbFDoaFjrDLFGqTxYH6wLnnzBzH6C0M8HvTL1oQtam8spctV80yx7xFz+SFZ/ctixXGOeLPWu0WH9RzrYv+O65F/TOprkw3U0zMvn/kn6wzd2MP8Tzedr9T+l8Mx+iqZn6xzl1+hMKPnm47/F/kKVX/jdz1ass2+AQeI2KmXOKek1v0H47veMVPQbNlIc9kObKA77zEmKQ9sr92RoOsI+S786gvldujg+IB3Nf/Ld5seIju+9IC4/abV0tHU2bT/QoHRQFzcQHcyHtvLqGzt5MB/aSsz7YNiJx/S7wVZuoz2dfvYOF+d4DIJBG4OwzqKdYT3bBHGsG5MQx3uyMWj2SWTR7xmp2A/kAZ/by4iS1zUf5GnMmdnnfz18NxMF9qe0fQTa2ML1DY4Flqs/4P1t/fYH2nym57HkLPetGDR70O8Z68J3v/4DynWC4rS2u1q/Q5uvYB9ZG9fiO1d/u95BZ3RAOq49k776wbXyU3hs7eObI62fWit/KMl/eIj8B20PKOblsZak/yj4D+8h/8FTn9CXLdF0NqtvwbqBvgXKnINmn9r7goL+/AfUCSkT7qPV5pW0fjEX9NpYnodCetrcq+QdNv+Q61cbh2p1yPWL/iG3180QhzLhkOY79vPtuuY/YDreF5hTeNTauqYD2pyRpNe+r+E9jFHQ9rtK3mGdn3C1bU0v2L6iXrAeTkEcyoRD2nxIPzqj2YOsOoN7tmV86VqrkPfaHOSYQtPFo+YXZ7VZvN9a+yaLaWM/h/wnjZNXYnmknTkncvJ85lxNO3MO5TpGPLlkGIV+2zyvsWv2WPO3eH5DWxvGuWDrvUEz5cVavVKbKy42azP16Zl+9ga5vifI4ndL2TV/Ogq81i3pP0d+lScbqq51J+1Vl/2q3HbZT5T0vwp+4g+RbeH5TYzTxgSub1G0bza5Htr7UQO9LXAZJP0XM9oAKY9nG1DVbAC2W7YBru9eo8A2YJOSHvtQ/j4jyT/m/kCTOfcR6L+4bD6PR74EdcR3YaBe54l3bSytzZfwXJL2vWzEyx9Sm/W0Jj6jjcMlaOsZOYrDdsI+EZ87gHHaOCmn8KD5NiKLfveIWNgJ9Plf4S/s5etStFvsn7nduvriIOhtt2ntXOYBCkFvXbJ+a31BP20mCvcTPe1bPWwzG4HWeNhJa1gH7fOhRNYjwPNo2OFd6GvfKEm69rjYD69F4VW+y5B+C2liWdZRen7m76D+CsaHWEasR9f3TNo3IfitjPCofT+0MewPawNhrR8AS/jSvpNZv0q+NKxxwurn+6//CdqEti8saS/Fv84wv+faSyHp/xb8tv+V/DbLPXtptpptXluWgd5Xzce/i4OFzPuehH4+6O1XfayHaX2CNoYW+Wz0w0/V5StqfVR0LtLmoLfOkD/B0sblrnlJ1vU02RSU/LwXFOvYtYeU+8Yse0hR3zcG7vFljrC0dqz5SJostLkZHq/9V2j3V8eXSrm+idbaL7d7bc+xxCXtOU7SLdfcxaSSXhubCG3UvckMWOsdtDcr6ScdtJEvzMu0k9qI5seKbC7FHBT6nuzHusaTUcgiS60eC5QeZae1Y9f81EaKw/bHbVxbH8b2os1x4bhW+uj/BszZHbEVxgQA",
      "debug_symbols": "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zO//ivz+ryhv/4oXyz9Vv+L9f93l/X/d5f1/3eX9f93l/X/d5f1/3eX9f93l/X/d5e1/3W6a3v8VP/7rvp/mz50Wzp0m506L505L506bz52Wz51WTp3mpnOnnasSd65K3LkqceeqxJ2rEneuSty5KnHnqsSdqxJ/rkr8uSrx56rEn6sSf65K/Lkq8eeqxJ+rEn+uSvy5KgnnqiScq5JwrkrCuSoJ56oknKuScK5KwrkqCeeqJJyrEjlXJXKuSuRclci5KpFzVSLnqkTOVYmcqxI5VyVyrkriuSqJ56oknquSeK5K4rkqieeqJJ6rkniuSuK5KonnqiSdq5J0rkrSuSpJ56oknauSdK5K0rkqSeeqJJ2rknSuSuZzVTKfq5L5XJXM56pkPlcl87kqmc9VyXyuSuZzVTKfq5J8rkryuSrJ56okn6uSfK5K8rkqyeeqJJ+rknyuSvK5KinnqqScq5JyrkrKuSop56qknKuScq5KyrkqKeeqpJyqEj9N505z507z504L506Tc6fFc6elc6fN507L5047VyXnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JX/yJ7LevDe7e4zm2c9qJK5nk9rfhPp23tOFvpfRa34cy2hpNtDaeYGs6rbFtrOM7WcLyt4QRbwxFbw4m2hmPrqlxsXZWLratyMXVVDpOpq3KYTF2Vw2TqqhwmU1flMF19Vd59FdNtPNHYeJKx8czGxpONjafYGo/78bX5fpo7d5o/d9rmNem2irls4XFbK4wH0Fyaw/p23zSnx8Y6W9huVnnZROZ2vwgHn52mad0AawqPH5OX+DF+MT7+OC0CpBjC1/HHxsefGh//3Pj4c+PjL22Pf/sBjIbG7xofv298/Nbvv0fj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",
      "brillig_names": ["sync_notes"]
    },
    {
      "name": "_assert_order_status",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "status",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7354432299782447020": {
            "error_kind": "string",
            "string": "Function _assert_order_status can only be called internally"
          },
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bbuM4DIbfJde5kKgj51UGi6KHTBEgSIq0XWBR9N1XMeJDY8qKqezsFOZNUcf8I+qLDhQTSx+rp83D+/Pddv/r8Lr68fNjtTs83r9tD/t09fG5Xj0ct7vd9vlu+PJKnf5oMI3g9eV+f7p+fbs/vq1+aANOrVeb/dPpfxNdepNf290mXSnzuR7bK4DWXFkYWCvC2nqvz9bWB9VZ+0gYR6fc2Tg60EPjv9bJ/3gb/xFbc63xN/pvbsTfxY5/LPHXLoTW2hsz7T86bCuL3thL/62+tf8avvrflIK/oxRnyVI0YicDpX2hFBuNbVtHHPSFTOsI0LWOGC7pOrreMOhu8LW/mf+4vfprGFn7xaNGhzxdCDxdBFIXTN8Egol99ZwmG4w3/bDQdxTtgexW/mycPp/O1oAlbAPalnJA7N8ZTm1gZG1C28ztoAcC1bcBdPvGAIO+TRo7244DzsahaUMwCME6gqiFYCVBLwSrCKb5SghWEpQ2WElQSxusJeiEYCVBFIJ1BMEKwUqCUQjWEcxkS4Tg9QRlVXcFwdjmS9wgmXYmaCWaqSUoEXUlQaeEYJGg72z9V9MTwSC9uJagrEkqCUbpxbUEpQ1WEkRpg7UEpQ3WEpTcTB1Bo2RdXEtQcjOVBLV8415LUHIzlQRBVnW1BCU3U0nQSER9SbDBYgULhUViXwqLlYCWxCIRAoXFSehJYpG5nMLiZYImsUgei8QiEzSFJcgETWKRNBKFRZ7GoLHIBE1hkecmaCwS/BNYrDzhQGORsYXCsthvKYxuXYaU5B1hWerYMo0FpLWQWJY6tkxjWWzmv4DFChYKy1KXitNYrAy5JBYZciksbqnBfwGLtBYKy2Iz/wUsS838F7AsNfM/jWWxmf8CFllBU1iiTNAkFhlySSwy5FJY0AoWCou0FgKLW+zDIMG2thAc37hhuNTZfA5D7aPtaKjLh9TdYjctuiFDkL5cz3CpidYbMjRLzcrOYhiw21c56tG8vNitd27IcLGb79ySoczL9QyXuvS4IUMnsU09Q5lTqhl6iW3qGUo7rGa42C3JbslQYpsrGKLp6od2xDDKvFzP8CbjoY79ISfWFRg6h637PkLvfvokKIrdkTAh9JvE6qAb9xG+s/teqe/tfvzW7utrxg/0Jfe7Xq714MyiUyGEQ67LXgWv+sqSJxwldm3XDXZwDBRpnMau4DtHrMKheVNb/B9qG/ragipVALu3Bt03GmOh8f+qbd3/ZP+/Of9rfh1tVRz638iQJbtmA4mxLN0mZaqbMLWKeDEHhoyL06LMxh/a2f7zucxOh8yvQAsiZIhyx59Ni+jxXMduYAE1ApH5KYSFdujVw7HrLELDEYX5oph56q4gcgyRZtQpAse9zGMtznYfrgv6UpT5ZqQgQobIWoYos1N4QeQYIs8pKdOfHHbBtdeXz/DFABxRYIgyP9OaFmW21C2IOCAwzhehYtDDzBFOpl8EGQcjkWeIQHFEliOKDFGmuxdEHBCWg9xySnIc5I6D3HGQZ/Kzxnchy3Ax1IoiQ5TJHk2LMru4F0SeIcrsi1AQ4XyRVoox6SZV4Ki0ZqlYZdHhZVozdvG8HWnoOQq7/BYGP9bE+Rp6Wito/HxNpsFOxuXpJcdSIUeVmQxLKk5Z6TZLxSpLs8rSrLLAsVSssgyrXpkHYAuqzPOhJZXnqJxiqdzsMSZz0DdCmzpAO9YwxiVN9+LpciLDN3ohWtCE2ZrM8baTDDIHuk5rNKMc+vevKV5oNWhGGjr6LWg45WChPoTGzG9vYBVDE+ZrHDA08+do8IahYZTDiAWAEQtkjiAqaGa2g8909ff9cXv/sNu8JsXp5vv+8W172J8v3/55ae88HLe73fb57uV4eNw8vR83d7vD4+neSp3//ARv1xBdM+eny+TQOq0gmiHkdDdl1SDGVGoq+V8=",
      "brillig_names": ["_assert_order_status"]
    },
    {
      "name": "_emit_settled",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "receiver",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15254322136740517089": {
            "error_kind": "string",
            "string": "Function _emit_settled can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "zZzZTuNIFIbfJde5qO1s/SqjUYsltCIhQCwjjRDvPg5NKgbbqR7r1C9uUAz189XvnNqOy/W6ud5dvvz6ub+7uX/a/PjrdXN7f3XxvL+/G65e37aby8f97e3+18/xrzfh8EOI3gVPDxd3h+un54vH582PmBOF7WZ3d334nJWGf3Kzv90NVyG/baflQ0rH4qGkUekwU7owx4/ShSXU0qwzhZUCfRRWSnFc+O/tRjj41N/sWDxGQ9bf6f6T1vuvrfsfSeRYmnM+X38jO5o1zuVr/SV71z+mz/U/UDRCKDxLiWZVlkLkBqVoLsfo0FFbWIgOSTU6VL7eXZv3nUbNLX1ub7lzvNqf3KNSPtVo0GmIK3W2ThfLnE6tBoyayFSla1Qpr1LJGlWOq1S8RlXm+1Zlrt2HStSqozgTT5RqrA4fT50Npd+MAmBYfwYBfBDABwN8sPZnCMCHAL4Ppf4MA7TzhXHDk2EhABgEYPjEFefK4PKVEQuAof0Z82OvMwPgIwN8ZICPAvBRAD4oARjSn8ERwAD0VwKIKwHElQJ8KCCuDNA+fOYMOVRGDl8Zw9I/ICAEgESEk4hwkhBOEsJJRjjJBQExAMRn9tCAUERAENHFiOhiiBNEdAminfhMInKpC8Rc8gSiCQERAMQQTgzgZBhQEBCEk4hwEhkASREBIQDEJz/QgiCiqyCiqyCcECK6CNFOxMeJhAqRNIH4dPWlPl2lUnQKcbldFPgIoUl+9vAQGAFBOPFZMxY9QcIMhAEQn0RwC6IAiM9yrgUxAMSnF25AfHphojqrp9EWiQphAMRnOUf5BKEZCAMgPtnaFkQBEC0IiAEgPoug85DsNDI2IISA+HwnqhWiNoFEn3Zi1QnnNIUoAJISAsIASI4ICMKJz/6tFsSng9RY24lNGyMFBEQAEE4IiAIgTmP8eYhGBMRlPOFitZ3MjCc+YzxTXf2yTebC2QoCov0hxSeb2oIIABIRTnyW2A2Iz2NZPqWimOIUwgCITza1BVEAxGf4bUEMAPEZfhsQn+1QEo+vSJCQTCEMgEhAQAoCYgCIIpyoAiA+aXQ5PcWWmKYQ6Q8ZknkAiE+GuwUhAMTnYWYLwgBIRjjJiO9kMY1ecoUw83mI1gS3pU9v570jFkd4R0R/F9TfBWl3BOf+iP4upL8Lke6IxT1QjgjujrDYH9HdBS9uonZElP6I7t0gx9wf0b0D4eTS9OpuEUutMwhEj1Ni09EL+LU+8r3qk+M3qw9/r/qUb3Z/fF4oO7/9iX3eKCvhtP0phSlEABBGOPFJomSVCgmTdBBLQkAMAPHJbzQgPi+KtyDUHyIhICAFAVEAxOcZRqH6GK6wTCECgCSEE58kyvmdrpITAmIAiM8zjAbEZwtBC0IACCOcMOI78dmncBaSwsKqLqR6rtnh8+gMLf2tW1iqtXW6TpdW8hYWPyHHeqRdyKMJ1lG3sEhp63idbuE9wpBPk/7hc5noFpIwocTTkXcl0URncR3PluopfNLphBcXphRt3UreUnw2dbpOl3idbmE7e1tnS7ow0vFEV8pK3Uoe5T/Q2dQf6TrdwupraJen9ldCmOqW+gk6r5O0Ureu3caFLV9tHf1/3dtw9c/F4/7i8nb3cVbqzcvd1ejo1Od/H3ZfTlF9eLy/2l2/PO4O56mejlI9NP+ceZtJhvocgsJsG4MdRrr3v6Wyzen98uAw21DUdKjCUI3/AA==",
      "brillig_names": ["_emit_settled"]
    },
    {
      "name": "_trigger_settlement",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13594925270014003382": {
            "error_kind": "string",
            "string": "Function _trigger_settlement can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["_trigger_settlement"]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "AztecGateway7683"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claimable_orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "open_orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "order_status",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "used_nonces",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "filled_orders_block_numbers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_assert_order_commitment_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_assert_order_commitment_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "receiver",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_emit_settled_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_emit_settled_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "fill_deadline",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        },
                        {
                          "name": "order_data_type",
                          "type": {
                            "kind": "array",
                            "length": 32,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        },
                        {
                          "name": "order_data",
                          "type": {
                            "kind": "array",
                            "length": 301,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::open_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::open_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "status",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_assert_order_status_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_assert_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "order_data",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_assert_nonce_and_set_order_details_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_assert_nonce_and_set_order_details_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::get_order_status_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::fill_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::fill_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::settle_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::settle_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_check_order_commitment_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_check_order_commitment_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_trigger_settlement_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_trigger_settlement_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "status",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_update_order_status_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_update_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::get_filled_order_block_number_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_filled_order_block_number_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::settle_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::settle_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::claim_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::claim_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::fill_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::fill_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "fill_deadline",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        },
                        {
                          "name": "order_data_type",
                          "type": {
                            "kind": "array",
                            "length": 32,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        },
                        {
                          "name": "order_data",
                          "type": {
                            "kind": "array",
                            "length": 301,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::open_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::open_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "resolved_order_bytes",
                    "type": {
                      "kind": "array",
                      "length": 613,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_emit_open_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_emit_open_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "103": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "106": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "107": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "108": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "109": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "110": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "112": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "113": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "114": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "136": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "139": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "142": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "143": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "144": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "145": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "146": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "147": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "152": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "153": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "154": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "155": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "159": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "162": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "171": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "185": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "188": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "189": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "191": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "192": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "194": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "196": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "200": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "224": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "226": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "269": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "270": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "286": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "287": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "301": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "303": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "304": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "313": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "324": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "338": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "342": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "343": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "359": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "360": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "362": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "368": {
      "path": "/Users/eidoo/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "397": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "51": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/main.nr",
      "source": "mod config;\nmod types;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract AztecGateway7683 {\n    // context.chain_id() returns 1, which corresponds to the mainnet, making it unsuitable for our use case.\n    // Instead, we designate 999999 as the destination domain.\n    global LOCAL_DESTINATION_DOMAIN: u32 = 999999;\n\n    global UNKNOWN: u32 = 0;\n    global OPENED: u32 = 1;\n    global FILLED: u32 = 2;\n    global INITIATED_PRIVATELY: u32 = 3;\n    global SETTLED: u32 = 4;\n\n    global SETTLE_ORDER_TYPE: [u8; 32] = [\n        25, 30, 167, 118, 189, 110, 12, 213, 106, 109, 68, 186, 74, 234, 47, 236, 70, 139, 74, 11,\n        76, 29, 136, 13, 64, 37, 146, 158, 235, 97, 93, 13,\n    ]; // sha256(\"SETTLE_ORDER_TYPE\")\n    global SECRET: [u8; 6] = [83, 69, 67, 82, 69, 84]; // SECRET\n\n    use crate::{\n        config::Config,\n        types::{\n            events::{Filled, Open, Settled},\n            helpers::InternalRCOParams,\n            onchain_cross_chain_order::OnchainCrossChainOrder,\n            order_data::{\n                ORDER_DATA_LENGTH, ORDER_DATA_TYPE, OrderData, PRIVATE_ORDER,\n                PRIVATE_ORDER_WITH_HOOK, PUBLIC_ORDER, PUBLIC_ORDER_WITH_HOOK,\n            },\n            resolved_cross_chain_order::{\n                FILL_INSTRUCTIONS_MAX_INSTRUCTIONS, FillInstruction, MAX_SPENT_MAX_OUTPUTS,\n                MIN_RECEIVED_MAX_OUTPUTS, Output, RESOLVED_CROSS_CHAIN_LENGTH,\n                ResolvedCrossChainOrder,\n            },\n        },\n        utils::{get_settle_content_hash, u32_to_u8_4, u8_32_to_aztec_address, u8_32_to_u128},\n    };\n    use dep::aztec::{\n        macros::{functions::{initializer, internal, private, public, view}, storage::storage},\n        prelude::{AztecAddress, EthAddress, Map, PublicImmutable, PublicMutable},\n        protocol_types::{hash::sha256_to_field, traits::{Packable, Serialize}},\n    };\n    use token::Token;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n        claimable_orders: Map<Field, PublicMutable<Field, Context>, Context>,\n        open_orders: Map<Field, PublicMutable<[u8; 32], Context>, Context>,\n        order_status: Map<Field, PublicMutable<u32, Context>, Context>,\n        used_nonces: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n        filled_orders_block_numbers: Map<Field, PublicMutable<Field, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(portal: EthAddress) {\n        storage.config.initialize(Config { portal });\n    }\n\n    #[public]\n    fn open(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, \"Invalid order data type\");\n\n        let data = _resolve(order, context.msg_sender(), context.timestamp());\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(data.order_data.sender_nonce);\n        let order_type = data.order_data.order_type;\n\n        assert(\n            (order_type == PUBLIC_ORDER) | (order_type == PUBLIC_ORDER_WITH_HOOK),\n            \"Not a public order\",\n        );\n        assert(\n            data.order_data.origin_domain == LOCAL_DESTINATION_DOMAIN,\n            \"Invalid order origin domain\",\n        );\n        assert(!storage.used_nonces.at(context.msg_sender()).at(nonce).read(), \"Invalid nonce\");\n\n        // We cannot store the entire order_data + ORDER_DATA_TYPE as it raises the following error:\n        // Reached the limit (63) on number of 'public data (contract storage) write' per tx 'storage_write_opcode(storage_slot, value).\n        // For this reason we store a commitment of it.\n        storage.open_orders.at(order_id).write(_get_open_order_commitment(order.order_data));\n        storage.order_status.at(order_id).write(OPENED);\n        storage.used_nonces.at(context.msg_sender()).at(nonce).write(true);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n\n            Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_in_public(\n                    context.msg_sender(),\n                    context.this_address(),\n                    u8_32_to_u128(min_received.amount),\n                    nonce,\n                )\n                .call(&mut context);\n        }\n\n        let event = Open::new(data.order_id_bytes, resolved_order.serialize());\n        context.emit_public_log(event.open1.pack());\n        context.emit_public_log(event.open2.pack());\n    }\n\n    #[private]\n    fn open_private(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, \"Invalid order data type\");\n\n        // NOTE: Force the sender to be zero in order to avoid creating a connection between the sender and the recipient.\n        // TODO: timestamp = 0?\n        let data = _resolve(order, AztecAddress::zero(), 0 as u64);\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(data.order_data.sender_nonce);\n        let order_type = data.order_data.order_type;\n\n        assert(\n            (order_type == PRIVATE_ORDER) | (order_type == PRIVATE_ORDER_WITH_HOOK),\n            \"Not a private order\",\n        );\n        assert(\n            data.order_data.origin_domain == LOCAL_DESTINATION_DOMAIN,\n            \"Invalid order origin domain\",\n        );\n\n        AztecGateway7683::at(context.this_address())\n            ._assert_nonce_and_set_order_details(order_id, order.order_data, nonce)\n            .enqueue(&mut context);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n            let amount = u8_32_to_u128(min_received.amount);\n            Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_in_private(context.msg_sender(), context.this_address(), amount, nonce)\n                .call(&mut context);\n        }\n\n        AztecGateway7683::at(context.this_address())\n            ._emit_open(data.order_id_bytes, resolved_order.serialize())\n            .enqueue(&mut context);\n    }\n\n    #[private]\n    fn claim_private(\n        secret: [u8; 32],\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n\n        AztecGateway7683::at(context.this_address())\n            ._assert_order_status(order_id, INITIATED_PRIVATELY)\n            .enqueue(&mut context);\n\n        // verify that a commitment exists for the given order.\n        AztecGateway7683::at(context.this_address())\n            ._check_order_commitment(order_id, origin_data_bytes, filler_data_bytes)\n            .enqueue(&mut context);\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        // if a commitment exists, the order is valid, allowing us to compare the recipient with hash(secret).\n        assert(sha256::digest(secret) == order_data.recipient, \"Invalid secret\");\n\n        // transfer from gateway public balance to user private balance\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_to_private(context.msg_sender(), u8_32_to_u128(order_data.amount_out))\n            .call(&mut context);\n\n        AztecGateway7683::at(context.this_address())._update_order_status(order_id, FILLED).enqueue(\n            &mut context,\n        );\n\n        // TODO: store filled order\n\n        AztecGateway7683::at(context.this_address())\n            ._trigger_settlement(\n                order_id,\n                order_id_bytes,\n                filler_data_bytes, // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn fill(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        AztecGateway7683::at(context.this_address())._assert_order_status(order_id, UNKNOWN).call(\n            &mut context,\n        );\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        let order_type = order_data.order_type;\n\n        assert(\n            (order_type == PUBLIC_ORDER) | (order_type == PUBLIC_ORDER_WITH_HOOK),\n            \"Not a public order\",\n        );\n        assert(order_id_bytes == sha256::digest(origin_data_bytes), \"Invalid order id\");\n        assert(context.timestamp() as u32 <= order_data.fill_deadline, \"Order fill expired\");\n        assert(\n            order_data.destination_domain == LOCAL_DESTINATION_DOMAIN,\n            \"Invalid order destination domain\",\n        );\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_in_public(\n                context.msg_sender(),\n                u8_32_to_aztec_address(order_data.recipient),\n                u8_32_to_u128(order_data.amount_out),\n                Field::from_be_bytes(order_data.sender_nonce),\n            )\n            .call(&mut context);\n\n        storage.claimable_orders.at(order_id).write(sha256_to_field(_get_order_pre_image(\n            origin_data_bytes,\n            filler_data_bytes,\n        )));\n        storage.order_status.at(order_id).write(FILLED);\n\n        AztecGateway7683::at(context.this_address())\n            ._trigger_settlement(\n                order_id,\n                order_id_bytes,\n                filler_data_bytes, // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n            )\n            .call(&mut context);\n        // TODO: implements hook for when order_type = PUBLIC_ORDER_WITH_HOOK\n\n        context.emit_public_log(Filled {\n            order_id: order_id_bytes,\n            origin_data: origin_data_bytes,\n            filler_data: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[public]\n    fn fill_private(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        AztecGateway7683::at(context.this_address())._assert_order_status(order_id, UNKNOWN).call(\n            &mut context,\n        );\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        let order_type = order_data.order_type;\n\n        assert(\n            (order_type == PRIVATE_ORDER) | (order_type == PRIVATE_ORDER_WITH_HOOK),\n            \"Not a private order\",\n        );\n        assert(order_id_bytes == sha256::digest(origin_data_bytes), \"Invalid order id\");\n        assert(context.timestamp() as u32 <= order_data.fill_deadline, \"Order fill expired\");\n        assert(order_data.destination_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order domain\");\n\n        storage.claimable_orders.at(order_id).write(sha256_to_field(_get_order_pre_image(\n            origin_data_bytes,\n            filler_data_bytes,\n        )));\n        storage.order_status.at(order_id).write(INITIATED_PRIVATELY);\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_in_public(\n                context.msg_sender(),\n                context.this_address(),\n                u8_32_to_u128(order_data.amount_out),\n                0,\n            )\n            .call(&mut context);\n\n        // TODO: implements hook for when order_type = PRIVATE_ORDER_WITH_HOOK\n\n        context.emit_public_log(Filled {\n            order_id: order_id_bytes,\n            origin_data: origin_data_bytes,\n            filler_data: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[public]\n    #[view]\n    fn get_order_status(order_id_bytes: [u8; 32]) -> u32 {\n        storage.order_status.at(Field::from_be_bytes(order_id_bytes)).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_filled_order_block_number(order_id_bytes: [u8; 32]) -> Field {\n        storage.filled_orders_block_numbers.at(Field::from_be_bytes(order_id_bytes)).read()\n    }\n\n    #[public]\n    fn settle(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n        message_leaf_index: Field,\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        // If a user wanted to open an order on the same chain, this code wouldn't work because\n        // the order_status would be FILLED. However, considering that for PoC we don't handle that case,\n        // this check is sufficient.\n        assert(storage.order_status.at(order_id).read() == OPENED, \"Invalid order status\");\n\n        let order_commitment = _get_open_order_commitment(origin_data_bytes);\n        assert(storage.open_orders.at(order_id).read() == order_commitment, \"Invalid order\");\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        let order_type = order_data.order_type;\n        // This check is necessary because if a user opens a private order, it means they have transferred\n        // tokens privately. As a result, the public state (`token.public_balances`) is not updated,\n        // making it impossible to call `transfer_in_public`, as it would fail.\n        assert(\n            (order_type == PUBLIC_ORDER) | (order_type == PUBLIC_ORDER_WITH_HOOK),\n            \"Not a public order\",\n        );\n\n        let content_hash =\n            get_settle_content_hash(SETTLE_ORDER_TYPE, order_id_bytes, filler_data_bytes);\n        /*context.consume_l1_to_l2_message(\n            content_hash,\n            Field::from_be_bytes(SECRET),\n            storage.config.read().portal,\n            message_leaf_index,\n        );*/\n\n        Token::at(u8_32_to_aztec_address(order_data.input_token))\n            .transfer_in_public(\n                context.this_address(),\n                u8_32_to_aztec_address(filler_data_bytes),\n                u8_32_to_u128(order_data.amount_in),\n                0,\n            )\n            .call(&mut context);\n\n        storage.order_status.at(order_id).write(SETTLED);\n\n        context.emit_public_log(Settled { order_id: order_id_bytes, receiver: filler_data_bytes }\n            .pack());\n    }\n\n    #[private]\n    fn settle_private(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n        message_leaf_index: Field,\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        // same as above\n        AztecGateway7683::at(context.this_address())._assert_order_status(order_id, OPENED).enqueue(\n            &mut context,\n        );\n        AztecGateway7683::at(context.this_address())\n            ._assert_order_commitment(order_id, origin_data_bytes)\n            .enqueue(&mut context);\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        let order_type = order_data.order_type;\n\n        assert(\n            (order_type == PRIVATE_ORDER) | (order_type == PRIVATE_ORDER_WITH_HOOK),\n            \"Not a private order\",\n        );\n\n        let content_hash =\n            get_settle_content_hash(SETTLE_ORDER_TYPE, order_id_bytes, filler_data_bytes);\n        /*context.consume_l1_to_l2_message(\n            content_hash,\n            Field::from_be_bytes(SECRET),\n            storage.config.read().portal,\n            message_leaf_index,\n        );*/\n\n        Token::at(u8_32_to_aztec_address(order_data.input_token))\n            .transfer_in_private(\n                context.this_address(),\n                u8_32_to_aztec_address(filler_data_bytes),\n                u8_32_to_u128(order_data.amount_in),\n                0,\n            )\n            .call(&mut context);\n\n        AztecGateway7683::at(context.this_address())\n            ._update_order_status(order_id, SETTLED)\n            .enqueue(&mut context);\n\n        AztecGateway7683::at(context.this_address())\n            ._emit_settled(order_id_bytes, filler_data_bytes)\n            .enqueue(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn _assert_nonce_and_set_order_details(\n        order_id: Field,\n        order_data: [u8; ORDER_DATA_LENGTH],\n        nonce: Field,\n    ) {\n        assert(!storage.used_nonces.at(context.msg_sender()).at(nonce).read(), \"Invalid nonce\");\n        // We cannot store the entire order_data + ORDER_DATA_TYPE as it raises the following error:\n        // Reached the limit (63) on number of 'public data (contract storage) write' per tx 'storage_write_opcode(storage_slot, value).\n        // For this reason we store a commitment of it.\n        storage.open_orders.at(order_id).write(_get_open_order_commitment(order_data));\n        storage.order_status.at(order_id).write(OPENED);\n        storage.used_nonces.at(context.msg_sender()).at(nonce).write(true);\n    }\n\n    #[contract_library_method]\n    fn _get_open_order_commitment(order_data: [u8; ORDER_DATA_LENGTH]) -> [u8; 32] {\n        let mut data: [u8; ORDER_DATA_LENGTH + 32] = [0; ORDER_DATA_LENGTH + 32];\n        for i in 0..32 {\n            data[i] = ORDER_DATA_TYPE[i];\n        }\n        for i in 0..ORDER_DATA_LENGTH {\n            data[i + 32] = order_data[i];\n        }\n        sha256::digest(data)\n    }\n\n    #[public]\n    #[internal]\n    fn _assert_order_status(order_id: Field, status: u32) {\n        assert(storage.order_status.at(order_id).read() == status, \"Invalid order status\");\n    }\n\n    #[public]\n    #[internal]\n    fn _assert_order_commitment(order_id: Field, origin_data_bytes: [u8; ORDER_DATA_LENGTH]) {\n        let order_commitment = _get_open_order_commitment(origin_data_bytes);\n        assert(storage.open_orders.at(order_id).read() == order_commitment, \"Invalid order\");\n    }\n\n    #[public]\n    #[internal]\n    fn _check_order_commitment(\n        order_id: Field,\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_commitment = storage.claimable_orders.at(order_id).read();\n        assert(\n            order_commitment\n                == sha256_to_field(_get_order_pre_image(origin_data_bytes, filler_data_bytes)),\n            \"Invalid order\",\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _emit_open(\n        order_id_bytes: [u8; 32],\n        resolved_order_bytes: [Field; RESOLVED_CROSS_CHAIN_LENGTH],\n    ) {\n        let event = Open::new(order_id_bytes, resolved_order_bytes);\n        context.emit_public_log(event.open1.pack());\n        context.emit_public_log(event.open2.pack());\n    }\n\n    #[public]\n    #[internal]\n    fn _emit_settled(order_id_bytes: [u8; 32], receiver: [u8; 32]) {\n        context.emit_public_log(Settled { order_id: order_id_bytes, receiver }.pack());\n    }\n\n    #[public]\n    #[internal]\n    fn _trigger_settlement(order_id: Field, order_id_bytes: [u8; 32], filler_data: [u8; 32]) {\n        storage.filled_orders_block_numbers.at(order_id).write(context.block_number());\n\n        let mut settlement_message_bytes: [u8; 96] = [0; 96];\n\n        for i in 0..32 {\n            settlement_message_bytes[i] = SETTLE_ORDER_TYPE[i]; // order_type\n            settlement_message_bytes[i + 32] = order_id_bytes[i]; // order_id_bytes\n            settlement_message_bytes[i + 64] = filler_data[i]; // recipient\n        }\n\n        let config = storage.config.read();\n        context.message_portal(config.portal, sha256_to_field(settlement_message_bytes));\n    }\n\n    #[contract_library_method]\n    fn _resolve(\n        order: OnchainCrossChainOrder,\n        sender: AztecAddress,\n        timestamp: u64,\n    ) -> InternalRCOParams {\n        let mut order_data = OrderData::decode(order.order_data);\n\n        assert(order_data.fill_deadline == order.fill_deadline, \"Invalid fill deadline\");\n        assert(u8_32_to_aztec_address(order_data.sender) == sender, \"Invalid order sender\");\n\n        let order_id_bytes = sha256::digest(order.order_data);\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        let destination_domain_bytes = u32_to_u8_4(order_data.destination_domain);\n\n        let min_received_output = Output {\n            token: order_data.input_token,\n            recipient: [0; 32],\n            amount: order_data.amount_in,\n            chain_id: u32_to_u8_4(order_data.origin_domain),\n        };\n        let min_received: [Output; MIN_RECEIVED_MAX_OUTPUTS] =\n            [min_received_output; MIN_RECEIVED_MAX_OUTPUTS];\n\n        let max_spent_output = Output {\n            token: order_data.output_token,\n            recipient: order_data.recipient,\n            amount: order_data.amount_out,\n            chain_id: destination_domain_bytes,\n        };\n        let max_spent: [Output; MAX_SPENT_MAX_OUTPUTS] = [max_spent_output; MAX_SPENT_MAX_OUTPUTS];\n\n        let fill_instruction = FillInstruction {\n            destination_chain_id: destination_domain_bytes,\n            destination_settler: order_data.destination_settler,\n            origin_data: order.order_data,\n        };\n        let fill_instructions: [FillInstruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS] =\n            [fill_instruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS];\n\n        let resolved_order = ResolvedCrossChainOrder {\n            user: order_data.sender,\n            origin_chain_id: u32_to_u8_4(LOCAL_DESTINATION_DOMAIN),\n            open_deadline: u32_to_u8_4(timestamp as u32),\n            fill_deadline: u32_to_u8_4(order.fill_deadline),\n            order_id: order_id_bytes,\n            min_received,\n            max_spent,\n            fill_instructions,\n        };\n\n        InternalRCOParams {\n            order_id_bytes,\n            order_id,\n            resolved_cross_chain_order: resolved_order,\n            order_data,\n        }\n    }\n\n    #[contract_library_method]\n    fn _get_order_pre_image(\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) -> [u8; ORDER_DATA_LENGTH + 32] {\n        let mut pre_image: [u8; ORDER_DATA_LENGTH + 32] = [0; ORDER_DATA_LENGTH + 32];\n        for i in 0..ORDER_DATA_LENGTH {\n            pre_image[i] = origin_data_bytes[i];\n        }\n        for i in 0..32 {\n            pre_image[i + ORDER_DATA_LENGTH] = filler_data_bytes[i];\n        }\n        pre_image\n    }\n\n    #[public]\n    #[internal]\n    fn _update_order_status(order_id: Field, status: u32) {\n        storage.order_status.at(order_id).write(status);\n    }\n}\n"
    },
    "52": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/types/events.nr",
      "source": "use crate::types::{\n    order_data::ORDER_DATA_LENGTH, resolved_cross_chain_order::RESOLVED_CROSS_CHAIN_LENGTH,\n};\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n// #[event]\n#[derive(Serialize)]\npub struct Filled {\n    pub order_id: [u8; 32],\n    pub origin_data: [u8; ORDER_DATA_LENGTH],\n    pub filler_data: [u8; 32],\n}\n\n// 301 + 32 + 32 = 365      365 / 31 = 11.74 = 12 + 1 (residual bytes) = 13\nimpl Packable<13> for Filled {\n    fn pack(self) -> [Field; 13] {\n        let mut packed = [0; 13];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        let mut filler_data_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n            filler_data_31[i] = self.filler_data[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n        residual_bytes[10] = self.filler_data[31];\n\n        for i in 0..10 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < ORDER_DATA_LENGTH {\n                    partial[j] = self.origin_data[k];\n                }\n            }\n            packed[i + 1] = Field::from_be_bytes(partial);\n\n            if i < 9 {\n                // no residual bytes for the last one\n                residual_bytes[i + 1] = self.origin_data[offset + 31];\n            }\n        }\n\n        packed[0] = Field::from_be_bytes::<31>(order_id_31);\n        packed[11] = Field::from_be_bytes::<31>(filler_data_31);\n        packed[12] = Field::from_be_bytes::<31>(residual_bytes);\n        packed\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], origin_data: [0; ORDER_DATA_LENGTH], filler_data: [0; 32] }\n    }\n}\n\n// #[event]\n#[derive(Serialize)]\npub struct Open1 {\n    pub order_id: [u8; 32],\n    pub resolved_order: [u8; 340],\n}\n\nimpl Packable<13> for Open1 {\n    fn pack(self) -> [Field; 13] {\n        let mut packed = [0; 13];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n\n        for i in 0..12 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < 340 {\n                    partial[j] = self.resolved_order[k];\n                }\n            }\n            packed[i + 1] = Field::from_be_bytes(partial);\n\n            let residual_bytes_offset = offset + 31;\n            if residual_bytes_offset < 340 {\n                residual_bytes[i + 1] = self.resolved_order[residual_bytes_offset];\n            }\n        }\n\n        packed[0] = Field::from_be_bytes::<31>(order_id_31);\n        packed[12] = Field::from_be_bytes::<31>(residual_bytes);\n        packed\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], resolved_order: [0; 340] }\n    }\n}\n\n// #[event]\n#[derive(Serialize)]\npub struct Open2 {\n    pub order_id: [u8; 32],\n    pub resolved_order: [u8; 273],\n}\n\nimpl Packable<11> for Open2 {\n    fn pack(self) -> [Field; 11] {\n        let mut packed = [0; 11];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n\n        for i in 0..10 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < 273 {\n                    partial[j] = self.resolved_order[k];\n                }\n            }\n            packed[i + 1] = Field::from_be_bytes(partial);\n\n            let residual_bytes_offset = offset + 31;\n            if residual_bytes_offset < 273 {\n                residual_bytes[i + 1] = self.resolved_order[residual_bytes_offset];\n            }\n        }\n\n        packed[0] = Field::from_be_bytes::<31>(order_id_31);\n        packed[10] = Field::from_be_bytes::<31>(residual_bytes);\n        packed\n    }\n\n    fn unpack(fields: [Field; 11]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], resolved_order: [0; 273] }\n    }\n}\n\npub struct Open {\n    pub open1: Open1,\n    pub open2: Open2,\n}\n\nimpl Open {\n    pub fn new(order_id: [u8; 32], resolved_order: [Field; RESOLVED_CROSS_CHAIN_LENGTH]) -> Self {\n        let mut resolved_order1 = [0; 340];\n        for i in 0..340 {\n            resolved_order1[i] = resolved_order[i] as u8;\n        }\n        let mut resolved_order2 = [0; 273];\n        for i in 0..273 {\n            resolved_order2[i] = resolved_order[i + 340] as u8;\n        }\n\n        Self {\n            open1: Open1 { order_id, resolved_order: resolved_order1 },\n            open2: Open2 { order_id, resolved_order: resolved_order2 },\n        }\n    }\n}\n\n//#[event]\n#[derive(Serialize)]\npub struct Settled {\n    order_id: [u8; 32],\n    receiver: [u8; 32],\n}\n\nimpl Packable<3> for Settled {\n    fn pack(self) -> [Field; 3] {\n        let mut packed = [0; 3];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        let mut receiver_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n            receiver_31[i] = self.receiver[i]\n        }\n        residual_bytes[0] = self.order_id[31];\n        residual_bytes[1] = self.receiver[31];\n\n        packed[0] = Field::from_be_bytes::<31>(order_id_31);\n        packed[1] = Field::from_be_bytes::<31>(receiver_31);\n        packed[2] = Field::from_be_bytes::<31>(residual_bytes);\n        packed\n    }\n\n    fn unpack(fields: [Field; 3]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], receiver: [0; 32] }\n    }\n}\n"
    },
    "55": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/types/order_data.nr",
      "source": "use crate::utils::u8_4_to_u32;\nuse dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n\npub global ORDER_DATA_LENGTH: u32 = 301;\npub global ORDER_DATA_TYPE: [u8; 32] = [\n    240, 12, 59, 246, 12, 115, 235, 151, 9, 127, 28, 152, 53, 83, 125, 160, 20, 224, 183, 85, 254,\n    148, 178, 93, 122, 200, 64, 29, 246, 103, 22, 160,\n];\n\npub global PUBLIC_ORDER: u8 = 0;\npub global PRIVATE_ORDER: u8 = 1;\npub global PUBLIC_ORDER_WITH_HOOK: u8 = 2;\npub global PRIVATE_ORDER_WITH_HOOK: u8 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OrderData {\n    pub sender: [u8; 32],\n    pub recipient: [u8; 32],\n    pub input_token: [u8; 32],\n    pub output_token: [u8; 32],\n    pub amount_in: [u8; 32],\n    pub amount_out: [u8; 32],\n    pub sender_nonce: [u8; 32],\n    pub origin_domain: u32,\n    pub destination_domain: u32,\n    pub destination_settler: [u8; 32],\n    pub fill_deadline: u32,\n    pub order_type: u8,\n    pub data: [u8; 32],\n}\n\nimpl OrderData {\n    pub fn decode(bytes: [u8; ORDER_DATA_LENGTH]) -> OrderData {\n        let sender = u8_order_data_length_to_u8_32(bytes, 0);\n        let recipient = u8_order_data_length_to_u8_32(bytes, 32);\n        let input_token = u8_order_data_length_to_u8_32(bytes, 64);\n        let output_token = u8_order_data_length_to_u8_32(bytes, 96);\n        let amount_in = u8_order_data_length_to_u8_32(bytes, 128);\n        let amount_out = u8_order_data_length_to_u8_32(bytes, 160);\n        let sender_nonce = u8_order_data_length_to_u8_32(bytes, 192);\n        let origin_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 224));\n        let destination_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 228));\n        let destination_settler = u8_order_data_length_to_u8_32(bytes, 232);\n        let fill_deadline = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 264));\n        let order_type = u8_order_data_length_to_u8(bytes, 268);\n        let data = u8_order_data_length_to_u8_32(bytes, 269);\n\n        OrderData {\n            sender,\n            recipient,\n            input_token,\n            output_token,\n            amount_in,\n            amount_out,\n            sender_nonce,\n            origin_domain,\n            destination_domain,\n            destination_settler,\n            fill_deadline,\n            order_type,\n            data,\n        }\n    }\n}\n\nfn u8_order_data_length_to_u8_32(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 32] {\n    let mut result = [0; 32];\n    for i in 0..32 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8_4(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 4] {\n    let mut result = [0; 4];\n    for i in 0..4 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> u8 {\n    bytes[start]\n}\n"
    },
    "58": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/utils.nr",
      "source": "use dep::aztec::{prelude::AztecAddress, protocol_types::traits::FromField};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\npub(crate) fn u8_32_to_u128(input: [u8; 32]) -> u128 {\n    let mut result = 0;\n    for i in 0..16 {\n        result = result + (input[31 - i] as u128) * (1 << (i * 8));\n    }\n    result\n}\n\npub(crate) fn u8_4_to_u32(bytes: [u8; 4]) -> u32 {\n    let field = Field::from_be_bytes(bytes);\n    field.assert_max_bit_size::<32>();\n    field as u32\n}\n\npub(crate) fn u8_32_to_aztec_address(bytes: [u8; 32]) -> AztecAddress {\n    AztecAddress::from_field(Field::from_be_bytes(bytes))\n}\n\npub(crate) fn u32_to_u8_4(x: u32) -> [u8; 4] {\n    [((x >> 24) & 0xFF) as u8, ((x >> 16) & 0xFF) as u8, ((x >> 8) & 0xFF) as u8, (x & 0xFF) as u8]\n}\n\npub fn get_settle_content_hash(\n    settle_order_type: [u8; 32],\n    order_id_bytes: [u8; 32],\n    filler_data_bytes: [u8; 32],\n) -> Field {\n    let mut hash_bytes = [0; 96];\n\n    for i in 0..32 {\n        hash_bytes[i] = settle_order_type[i];\n        hash_bytes[i + 32] = order_id_bytes[i];\n        hash_bytes[i + 64] = filler_data_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n"
    },
    "59": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "67": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "68": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "69": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "70": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "74": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "91": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "95": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "96": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "99": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    }
  }
}
