{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "AztecGateway7683",
  "functions": [
    {
      "name": "_assert_order_commitment",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10391454703121400355": {
            "error_kind": "string",
            "string": "Function _assert_order_commitment can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_assert_order_commitment"
      ]
    },
    {
      "name": "_trigger_settlement",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13594925270014003382": {
            "error_kind": "string",
            "string": "Function _trigger_settlement can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_trigger_settlement"
      ]
    },
    {
      "name": "settle_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "open",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order",
            "type": {
              "kind": "struct",
              "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder",
              "fields": [
                {
                  "name": "fill_deadline",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                },
                {
                  "name": "order_data_type",
                  "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                },
                {
                  "name": "order_data",
                  "type": {
                    "kind": "array",
                    "length": 301,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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OAADAYcBiS4NAYkBiB0MAYgBhwAoAgGIBABlATgAAwGIAYouDQGKAYkdDAGJAYgAKAIBiQQAZgE4AAMBiQGLLg0BiwGKHQwBigGJACgCAYoEAGcBOAADAYoBjC4NAYwBix0MAYsBigAoAgGLBABoATgAAwGLAY0uDQGNAYwdDAGMAYsAKAIBjAQAaQE4AAMBjAGOLg0BjgGNHQwBjQGMACgCAY0EAGoBOAADAY0Bjy4NAY8Bjh0MAY4BjQAoAgGOBABrATgAAwGOAZAuDQGQAY8dDAGPAY4AKAIBjwQAbAE4AAMBjwGRLg0BkQGQHQwBkAGPACgCAZAEAG0BOAADAZABki4NAZIBkR0MAZEBkAAoAgGRBABuATgAAwGRAZMuDQGTAZIdDAGSAZEAKAIBkgQAbwE4AAMBkgGULg0BlAGTHQwBkwGSACgCAZMEAHABOAADAZMBlS4NAZUBlB0MAZQBkwAoAgGUBABxATgAAwGUAZYuDQGWAZUdDAGVAZQAKAIBlQQAcgE4AAMBlQGXLg0BlwGWHQwBlgGVACgCAZYEAHMBOAADAZYBmC4NAZgBlx0MAZcBlgAoAgGXBAB0ATgAAwGXAZkuDQGZAZgdDAGYAZcAKAIBmAQAdQE4AAMBmAGaLg0BmgGZHQwBmQGYACgCAZkEAHYBOAADAZkBmy4NAZsBmh0MAZoBmQAoAgGaBAB3ATgAAwGaAZwuDQGcAZsdDAGbAZoAKAIBmwQAeAE4AAMBmwGdLg0BnQGcHQwBnAGbACgCAZwEAHkBOAADAZwBni4NAZ4BnR0MAZ0BnAAoAgGdBAB6ATgAAwGdAZ8uDQGfAZ4dDAGeAZ0AKAIBngQAewE4AAMBngGgLg0BoAGfHQwBnwGeACgCAZ8EAHwBOAADAZ8BoS4NAaEBoB0MAaABnwAoAgGgBAB9ATgAAwGgAaIuDQGiAaEdDAGhAaAAKAIBoQQAfgE4AAMBoQGjLg0BowGiHQwBogGhACgCAaIEAH8BOAADAaIBpC4NAaQBox0MAaMBogABOAADAA4BpC4NAaQBox0MAaMADgAoAgGjBACBATgAAwGjAaUuDQGlAaQdDAGkAaMAKAIBpAQAggE4AAMBpAGmLg0BpgGlHQwBpQGkACgCAaUEAIMBOAADAaUBpy4NAacBph0MAaYBpQAoAgGmBACEATgAAwGmAaguDQGoAacdDAGnAaYAKAIBpwQAhQE4AAMBpwGpLg0BqQGoHQwBqAGnACgCAagEAIYBOAADAagBqi4NAaoBqR0MAakBqAAoAgGpBACHATgAAwGpAasuDQGrAaodDAGqAakAKAIBqgQAiAE4AAMBqgGsLg0BrAGrHQwBqwGqACgCAasEAIkBOAADAasBrS4NAa0BrB0MAawBqwAoAgGsBACKATgAAwGsAa4uDQGuAa0dDAGtAawAKAIBrQQAiwE4AAMBrQGvLg0BrwGuHQwBrgGtACgCAa4EAIwBOAADAa4BsC4NAbABrx0MAa8BrgAoAgGvBACNATgAAwGvAbEuDQGxAbAdDAGwAa8AKAIBsAQAjgE4AAMBsAGyLg0BsgGxHQwBsQGwACgCAbEEAI8BOAADAbEBsy4NAbMBsh0MAbIBsQAoAgGyBACQATgAAwGyAbQuDQG0AbMdDAGzAbIAKAIBswQAkQE4AAMBswG1Lg0BtQG0HQwBtAGzACgCAbQEAJIBOAADAbQBti4NAbYBtR0MAbUBtAAoAgG1BACTATgAAwG1AbcuDQG3AbYdDAG2AbUAKAIBtgQAlAE4AAMBtgG4Lg0BuAG3HQwBtwG2ACgCAbcEAJUBOAADAbcBuS4NAbkBuB0MAbgBtwAoAgG4BACWATgAAwG4AbouDQG6AbkdDAG5AbgAKAIBuQQAlwE4AAMBuQG7Lg0BuwG6HQwBugG5ACgCAboEAJgBOAADAboBvC4NAbwBux0MAbsBugAoAgG7BACZATgAAwG7Ab0uDQG9AbwdDAG8AbsAKAIBvAQAmgE4AAMBvAG+Lg0BvgG9HQwBvQG8ACgCAb0EAJsBOAADAb0Bvy4NAb8Bvh0MAb4BvQAoAgG+BACcATgAAwG+AcAuDQHAAb8dDAG/Ab4AKAIBvwQAnQE4AAMBvwHBLg0BwQHAHQwBwAG/ACgCAcAEAJ4BOAADAcABwi4NAcIBwR0MAcEBwAAoAgHBBACfATgAAwHBAcMuDQHDAcIdDAHCAcEAATgAAwAQAcMuDQHDAcIdDAHCABAAKAIBwgQAoQE4AAMBwgHELg0BxAHDHQwBwwHCACgCAcMEAKIBOAADAcMBxS4NAcUBxB0MAcQBwwAoAgHEBACjATgAAwHEAcYuDQHGAcUdDAHFAcQAKAIBxQQApAE4AAMBxQHHLg0BxwHGHQwBxgHFACgCAcYEAKUBOAADAcYByC4NAcgBxx0MAccBxgAoAgHHBACmATgAAwHHAckuDQHJAcgdDAHIAccAKAIByAQApwE4AAMByAHKLg0BygHJHQwByQHIACgCAckEAKgBOAADAckByy4NAcsByh0MAcoByQAoAgHKBACpATgAAwHKAcwuDQHMAcsdDAHLAcoAKAIBywQAqgE4AAMBywHNLg0BzQHMHQwBzAHLACgCAcwEAKsBOAADAcwBzi4NAc4BzR0MAc0BzAAoAgHNBACsATgAAwHNAc8uDQHPAc4dDAHOAc0AKAIBzgQArQE4AAMBzgHQLg0B0AHPHQwBzwHOACgCAc8EAK4BOAADAc8B0S4NAdEB0B0MAdABzwAoAgHQBACvATgAAwHQAdIuDQHSAdEdDAHRAdAAKAIB0QQAsAE4AAMB0QHTLg0B0wHSHQwB0gHRACgCAdIEALEBOAADAdIB1C4NAdQB0x0MAdMB0gAoAgHTBACyATgAAwHTAdUuDQHVAdQdDAHUAdMAKAIB1AQAswE4AAMB1AHWLg0B1gHVHQwB1QHUACgCAdUEALQBOAADAdUB1y4NAdcB1h0MAdYB1QAoAgHWBAC1ATgAAwHWAdguDQHYAdcdDAHXAdYAKAIB1wQAtgE4AAMB1wHZLg0B2QHYHQwB2AHXACgCAdgEALcBOAADAdgB2i4NAdoB2R0MAdkB2AAoAgHZBAC4ATgAAwHZAdsuDQHbAdodDAHaAdkAKAIB2gQAuQE4AAMB2gHcLg0B3AHbHQwB2wHaACgCAdsEALoBOAADAdsB3S4NAd0B3B0MAdwB2wAoAgHcBAC7ATgAAwHcAd4uDQHeAd0dDAHdAdwAKAIB3QQAvAE4AAMB3QHfLg0B3wHeHQwB3gHdACgCAd4EAL0BOAADAd4B4C4NAeAB3x0MAd8B3gAoAgHfBAC+ATgAAwHfAeEuDQHhAeAdDAHgAd8AKAIB4AQAvwE4AAMB4AHiLg0B4gHhHQwB4QHgAAE4AAMAEgHiLg0B4gHhHQwB4QASACgCAeEEAMEBOAADAeEB4y4NAeMB4h0MAeIB4QAoAgHiBADCATgAAwHiAeQuDQHkAeMdDAHjAeIAKAIB4wQAwwE4AAMB4wHlLg0B5QHkHQwB5AHjACgCAeQEAMQBOAADAeQB5i4NAeYB5R0MAeUB5AAoAgHlBADFATgAAwHl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HQwCJAIjACgCAiQEAQcBOAADAiQCJi4NAiYCJR0MAiUCJAABOAADABoCJi4NAiYCJR0MAiUAGgAoAgIlBAEJATgAAwIlAicuDQInAiYdDAImAiUAKAICJgQBCgE4AAMCJgIoLg0CKAInHQwCJwImACgCAicEAQsBOAADAicCKS4NAikCKB0MAigCJwAoAgIoBAEMATgAAwIoAiouDQIqAikdDAIpAigAKAICKQQBDgE4AAMCKQIrLg0CKwIqHQwCKgIpACgCAioEAQ8BOAADAioCLC4NAiwCKx0MAisCKgAoAgIrBAEQATgAAwIrAi0uDQItAiwdDAIsAisAKAICLAQBEQE4AAMCLAIuLg0CLgItHQwCLQIuACgCAi0EARIBOAADAi0CMC4NAjACLx0MAi8CLQAoAgIvBAETATgAAwIvAjEuDQIxAjAdDAIwAi8AKAICMAQBFAE4AAMCMAIyLg0CMgIxHQwCMQIwACgCAjEEARUBOAADAjECMy4NAjMCMh0MAjICMQAoAgIyBAEWATgAAwIyAjQuDQI0AjMdDAIzAjIAKAICMwQBFwE4AAMCMwI1Lg0CNQI0HQwCNAIzACgCAjQEARgBOAADAjQCNi4NAjYCNR0MAjUCNAAoAgI1BAEZATgAAwI1AjcuDQI3AjYdDAI2AjUAKAICNgQBGgE4AAMCNgI4Lg0COAI3HQwCNwI2ACgCAjcEARsBOAADAjcCOS4NAjkCOB0MAjgCNwAoAgI4BAEcATgAAwI4AjouDQI6AjkdDAI5AjgAKAICOQQBHQE4AAMCOQI7Lg0COwI6HQwCOgI5ACgCAjoEAR4BOAADAjoCPC4NAjwCOx0MAjsCOgAoAgI7BAEfATgAAwI7Aj0uDQI9AjwdDAI8AjsAKAICPAQBIAE4AAMCPAI+Lg0CPgI9HQwCPQI8ACgCAj0EASEBOAADAj0CPy4NAj8CPh0MAj4CPQAoAgI+BAEiATgAAwI+AkAuDQJAAj8dDAI/Aj4AKAICPwQBIwE4AAMCPwJBLg0CQQJAHQwCQAI/ACgCAkAEASQBOAADAkACQi4NAkICQR0MAkECQAAoAgJBBAElATgAAwJBAkMuDQJDAkIdDAJCAkEAKAICQgQBJgE4AAMCQgJELg0CRAJDHQwCQwJCACgCAkMEAScBOAADAkMCRS4NAkUCRB0MAkQCQwAoAgJEBAEoATgAAwJEAkYuDQJGAkUdDAJFAkQAKAICRQQBKQE4AAMCRQJHLg0CRwJGHQwCRgJFACgCAkYEASoBOAADAkYCSC4NAkgCRx0MAkcCRgAoAgJHBAErATgAAwJHAkkuDQJJAkgdDAJIAkcAKAICSAQBLAE4AAMCSAJKLg0CSgJJHQwCSQJIAAEoAAOAZQJKLg0CSgJJHQwCSQADAC4IAAECSSgCAkoEAmYBEAABAkoAASgDAkkEAAEBKAJJAAICSi4MAkoCSy4OAAQCSwEoAksAAgJLLg4ABQJLASgCSwACAksuDgAGAksBKAJLAAICSy4OAAcCSwEoAksAAgJLLg4AEwJLASgCSwACAksuDgAdAksBKAJLAAICSy4OACICSwEoAksAAgJLLg4AIwJLASgCSwACAksuDgAlAksBKAJLAAICSy4OACcCSwEoAksAAgJLLg4AKQJLASgCSwACAksuDgArAksBKAJLAAICSy4OAC0CSwEoAksAAgJLLg4ALgJLASgCSwACAksuDgAwAksBKAJLAAICSy4OADECSwEoAksAAgJLLg4AMwJLASgCSwACAksuDgA1AksBKAJLAAICSy4OADcCSwEoAksAAgJLLg4AOQJLASgCSwACAksuDgA7AksBKAJLAAICSy4OAD0CSwEoAksAAgJLLg4APwJLASgCSwACAksuDgBBAksBKAJLAAICSy4OAEMCSwEoAksAAgJLLg4ARQJLASgCSwACAksuDgBHAksBKAJLAAICSy4OAEkCSwEoAksAAgJLLg4ASwJLASgCSwACAksuDgBMAksBKAJLAAICSy4OAE0CSwEoAksAAgJLLg4ACQJLASgCSwACAksuDgBOAksBKAJLAAICSy4OAE8CSwEoAksAAgJLLg4AUAJLASgCSwACAksuDgAfAksBKAJLAAICSy4OAFECSwEoAksAAgJLLg4AUgJLASgCSwACAksuDgBTAksBKAJLAAICSy4OACACSwEoAksAAgJLLg4AVAJLASgCSwACAksuDgBVAksBKAJLAAICSy4OAFYCSwEoAksAAgJLLg4ACAJLASgCSwACAksuDgBXAksBKAJLAAICSy4OAFgCSwEoAksAAgJLLg4AWQJLASgCSwACAksuDgBaAksBKAJLAAICSy4OAFsCSwEoAksAAgJLLg4AXAJLASgCSwACAksuDgBdAksBKAJLAAICSy4OAF4CSwEoAksAAgJLLg4AXwJLASgCSwACAksuDgBgAksBKAJLAAICSy4OAGECSwEoAksAAgJLLg4AYgJLASgCSwACAksuDgBjAksBKAJLAAICSy4OAGQCSwEoAksAAgJLLg4AZQJLASgCSwACAksuDgBmAksBKAJLAAICSy4OAGcCSwEoAksAAgJLLg4AaAJLASgCSwACAksuDgBpAksBKAJLAAICSy4OAGoCSwEoAksAAgJLLg4AawJLASgCSwACAksuDgBsAksBKAJLAAICSy4OAG0CSwEoAksAAgJLLg4AbgJLASgCSwACAksuDgBvAksBKAJLAAICSy4OAHACSwEoAksAAgJLLg4AcQJLASgCSwACAksuDgByAksBKAJLAAICSy4OAHMCSwEoAksAAgJLLg4AdAJLASgCSwACAksuDgB1AksBKAJLAAICSy4OAHYCSwEoAksAAgJLLg4AeAJLASgCSwACAksuDgB5AksBKAJLAAICSy4OAHoCSwEoAksAAgJLLg4AewJLASgCSwACAksuDgB8AksBKAJLAAICSy4OAH0CSwEoAksAAgJLLg4AfgJLASgCSwACAksuDgB/AksBKAJLAAICSy4OAIACSwEoAksAAgJLLg4AgQJLASgCSwACAksuDgCCAksBKAJLAAICSy4OAIMCSwEoAksAAgJLLg4AhAJLASgCSwACAksuDgCFAksBKAJLAAICSy4OAIYCSwEoAksAAgJLLg4AhwJLASgCSwACAksuDgCIAksBKAJLAAICSy4OAIkCSwEoAksAAgJLLg4AigJLASgCSwACAksuDgCLAksBKAJLAAICSy4OAIwCSwEoAksAAgJLLg4AjQJLASgCSwACAksuDgCOAksBKAJLAAICSy4OAI8CSwEoAksAAgJLLg4AkAJLASgCSwACAksuDgCRAksBKAJLAAICSy4OAJICSwEoAksAAgJLLg4AkwJLASgCSwACAksuDgCUAksBKAJLAAICSy4OAJUCSwEoAksAAgJLLg4AlgJLASgCSwACAksuDgALAksBKAJLAAICSy4OAJcCSwEoAksAAgJLLg4AmAJLASgCSwACAksuDgCZAksBKAJLAAICSy4OAJoCSwEoAksAAgJLLg4AmwJLASgCSwACAksuDgCcAksBKAJLAAICSy4OAJ0CSwEoAksAAgJLLg4AngJLASgCSwACAksuDgCfAksBKAJLAAICSy4OAKACSwEoAksAAgJLLg4AoQJLASgCSwACAksuDgCiAksBKAJLAAICSy4OAKMCSwEoAksAAgJLLg4ApAJLASgCSwACAksuDgClAksBKAJLAAICSy4OAKYCSwEoAksAAgJLLg4ApwJLASgCSwACAksuDgCoAksBKAJLAAICSy4OAKkCSwEoAksAAgJLLg4AqgJLASgCSwACAksuDgCrAksBKAJLAAICSy4OAKwCSwEoAksAAgJLLg4ArQJLASgCSwACAksuDgCuAksBKAJLAAICSy4OAK8CSwEoAksAAgJLLg4AsAJLASgCSwACAksuDgCxAksBKAJLAAICSy4OALICSwEoAksAAgJLLg4AswJLASgCSwACAksuDgC0AksBKAJLAAICSy4OALUCSwEoAksAAgJLLg4ADwJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLgqAeQJLASgCSwACAksuCoB5AksBKAJLAAICSy4KgHkCSwEoAksAAgJLLg4AtgJLASgCSwACAksuDgC3AksBKAJLAAICSy4OALgCSwEoAksAAgJLLg4AGAJLASgCSwACAksuDgC5AksBKAJLAAICSy4OALoCSwEoAksAAgJLLg4AuwJLASgCSwACAksuDgC8AksBKAJLAAICSy4OAL0CSwEoAksAAgJLLg4AvgJLASgCSwACAksuDgC/AksBKAJLAAICSy4OAMACSwEoAksAAgJLLg4AwQJLASgCSwACAksuDgDCAksBKAJLAAICSy4OAMMCSwEoAksAAgJLLg4AxAJLASgCSwACAksuDgDFAksBKAJLAAICSy4OAMYCSwEoAksAAgJLLg4AxwJLASgCSwACAksuDgDIAksBKAJLAAICSy4OAMkCSwEoAksAAgJLLg4AygJLASgCSwACAksuDgDLAksBKAJLAAICSy4OAMwCSwEoAksAAgJLLg4AzQJLASgCSwACAksuDgDOAksBKAJLAAICSy4OAM8CSwEoAksAAgJLLg4A0AJLASgCSwACAksuDgDRAksBKAJLAAICSy4OANICSwEoAksAAgJLLg4A0wJLASgCSwACAksuDgDUAksBKAJLAAICSy4OANUCSwEoAksAAgJLLg4A1gJLASgCSwACAksuDgDXAksBKAJLAAICSy4OAA0CSwEoAksAAgJLLg4A2AJLASgCSwACAksuDgDZAksBKAJLAAICSy4OANoCSwEoAksAAgJLLg4A2wJLASgCSwACAksuDgDcAksBKAJLAAICSy4OAN0CSwEoAksAAgJLLg4A3gJLASgCSwACAksuDgDfAksBKAJLAAICSy4OAOACSwEoAksAAgJLLg4A4QJLASgCSwACAksuDgDiAksBKAJLAAICSy4OAOMCSwEoAksAAgJLLg4A5AJLASgCSwACAksuDgDlAksBKAJLAAICSy4OAOYCSwEoAksAAgJLLg4A5wJLASgCSwACAksuDgDoAksBKAJLAAICSy4OAOkCSwEoAksAAgJLLg4A6gJLASgCSwACAksuDgDrAksBKAJLAAICSy4OAOwCSwEoAksAAgJLLg4A7QJLASgCSwACAksuDgDuAksBKAJLAAICSy4OAO8CSwEoAksAAgJLLg4A8AJLASgCSwACAksuDgDxAksBKAJLAAICSy4OAPICSwEoAksAAgJLLg4A8wJLASgCSwACAksuDgD0AksBKAJLAAICSy4OAPUCSwEoAksAAgJLLg4A9gJLASgCSwACAksuDgARAksBKAJLAAICSy4OAPcCSwEoAksAAgJLLg4A+AJLASgCSwACAksuDgD5AksBKAJLAAICSy4OAPoCSwEoAksAAgJLLg4A+wJLASgCSwACAksuDgD8AksBKAJLAAICSy4OAP0CSwEoAksAAgJLLg4A/gJLASgCSwACAksuDgD/AksBKAJLAAICSy4OAQACSwEoAksAAgJLLg4BAQJLASgCSwACAksuDgECAksBKAJLAAICSy4OAQMCSwEoAksAAgJLLg4BBAJLASgCSwACAksuDgEFAksBKAJLAAICSy4OAQYCSwEoAksAAgJLLg4BBwJLASgCSwACAksuDgEIAksBKAJLAAICSy4OAQkCSwEoAksAAgJLLg4BCgJLASgCSwACAksuDgELAksBKAJLAAICSy4OAQwCSwEoAksAAgJLLg4BDQJLASgCSwACAksuDgEOAksBKAJLAAICSy4OAQ8CSwEoAksAAgJLLg4BEAJLASgCSwACAksuDgERAksBKAJLAAICSy4OARICSwEoAksAAgJLLg4BEwJLASgCSwACAksuDgEUAksBKAJLAAICSy4OARUCSwEoAksAAgJLLg4ACgJLASgCSwACAksuDgEWAksBKAJLAAICSy4OARcCSwEoAksAAgJLLg4BGAJLASgCSwACAksuDgAcAksBKAJLAAICSy4OARYCSwEoAksAAgJLLg4BFwJLASgCSwACAksuDgEYAksBKAJLAAICSy4OABwCSwEoAksAAgJLLg4BGQJLASgCSwACAksuDgEaAksBKAJLAAICSy4OARsCSwEoAksAAgJLLg4BHAJLASgCSwACAksuDgEdAksBKAJLAAICSy4OAR4CSwEoAksAAgJLLg4BHwJLASgCSwACAksuDgEgAksBKAJLAAICSy4OASECSwEoAksAAgJLLg4BIgJLASgCSwACAksuDgEjAksBKAJLAAICSy4OASQCSwEoAksAAgJLLg4BJQJLASgCSwACAksuDgEmAksBKAJLAAICSy4OAScCSwEoAksAAgJLLg4BKAJLASgCSwACAksuDgEpAksBKAJLAAICSy4OASoCSwEoAksAAgJLLg4BKwJLASgCSwACAksuDgEsAksBKAJLAAICSy4OAS0CSwEoAksAAgJLLg4BLgJLASgCSwACAksuDgEvAksBKAJLAAICSy4OATACSwEoAksAAgJLLg4BMQJLASgCSwACAksuDgEyAksBKAJLAAICSy4OATMCSwEoAksAAgJLLg4BNAJLASgCSwACAksuDgE1AksBKAJLAAICSy4OATYCSwEoAksAAgJLLg4BNwJLASgCSwACAksuDgAZAksBKAJLAAICSy4OATgCSwEoAksAAgJLLg4BOQJLASgCSwACAksuDgE6AksBKAJLAAICSy4OATsCSwEoAksAAgJLLg4AIQJLASgCSwACAksuDgACAksBKAJLAAICSy4OABYCSwEoAksAAgJLLg4BPAJLASgCSwACAksuDgAeAksBKAJLAAICSy4OAT0CSwEoAksAAgJLLg4BPgJLASgCSwACAksuDgE/AksBKAJLAAICSy4OAUACSwEoAksAAgJLLg4BQQJLASgCSwACAksuDgAsAksBKAJLAAICSy4OAUICSwEoAksAAgJLLg4ALwJLASgCSwACAksuDgAyAksBKAJLAAICSy4OADQCSwEoAksAAgJLLg4ANgJLASgCSwACAksuDgA4AksBKAJLAAICSy4OADoCSwEoAksAAgJLLg4APAJLASgCSwACAksuDgA+AksBKAJLAAICSy4OAEACSwEoAksAAgJLLg4AQgJLASgCSwACAksuDgBEAksBKAJLAAICSy4OAEYCSwEoAksAAgJLLg4ASAJLASgCSwACAksuDgFDAksBKAJLAAICSy4OAUQCSwEoAksAAgJLLg4BRQJLASgCSwACAksuDgB3AksBKAJLAAICSy4OAUYCSwEoAksAAgJLLg4BRwJLASgCSwACAksuDgFIAksBKAJLAAICSy4OAUkCSwEoAksAAgJLLg4BSgJLASgCSwACAksuDgFLAksBKAJLAAICSy4OAUwCSwEoAksAAgJLLg4BTQJLASgCSwACAksuDgFOAksBKAJLAAICSy4OAU8CSwEoAksAAgJLLg4BUQJLASgCSwACAksuDgFQAksBKAJLAAICSy4OAVICSwEoAksAAgJLLg4BUwJLASgCSwACAksuDgFUAksBKAJLAAICSy4OAVUCSwEoAksAAgJLLg4BVgJLASgCSwACAksuDgFXAksBKAJLAAICSy4OAVgCSwEoAksAAgJLLg4BWQJLASgCSwACAksuDgFaAksBKAJLAAICSy4OAVsCSwEoAksAAgJLLg4BXQJLASgCSwACAksuDgFcAksBKAJLAAICSy4OAV4CSwEoAksAAgJLLg4BXwJLASgCSwACAksuDgFgAksBKAJLAAICSy4OAWECSwEoAksAAgJLLg4BYgJLASgCSwACAksuDgFjAksBKAJLAAICSy4OAWUCSwEoAksAAgJLLg4BZAJLASgCSwACAksuDgFmAksBKAJLAAICSy4OAWcCSwEoAksAAgJLLg4BaAJLASgCSwACAksuDgFpAksBKAJLAAICSy4OAWoCSwEoAksAAgJLLg4BawJLASgCSwACAksuDgFsAksBKAJLAAICSy4OAW0CSwEoAksAAgJLLg4BbgJLASgCSwACAksuDgFvAksBKAJLAAICSy4OAXACSwEoAksAAgJLLg4BcQJLASgCSwACAksuDgFyAksBKAJLAAICSy4OAXMCSwEoAksAAgJLLg4BdAJLASgCSwACAksuDgF1AksBKAJLAAICSy4OAXYCSwEoAksAAgJLLg4BdwJLASgCSwACAksuDgF4AksBKAJLAAICSy4OAXkCSwEoAksAAgJLLg4BegJLASgCSwACAksuDgF7AksBKAJLAAICSy4OAXwCSwEoAksAAgJLLg4BfQJLASgCSwACAksuDgF+AksBKAJLAAICSy4OAX8CSwEoAksAAgJLLg4BgAJLASgCSwACAksuDgGBAksBKAJLAAICSy4OAYICSwEoAksAAgJLLg4BgwJLASgCSwACAksuDgAMAksBKAJLAAICSy4OAYQCSwEoAksAAgJLLg4BhQJLASgCSwACAksuDgGGAksBKAJLAAICSy4OAYcCSwEoAksAAgJLLg4BiAJLASgCSwACAksuDgGJAksBKAJLAAICSy4OAYoCSwEoAksAAgJLLg4BiwJLASgCSwACAksuDgGMAksBKAJLAAICSy4OAY0CSwEoAksAAgJLLg4BjgJLASgCSwACAksuDgGPAksBKAJLAAICSy4OAZACSwEoAksAAgJLLg4BkQJLASgCSwACAksuDgGSAksBKAJLAAICSy4OAZMCSwEoAksAAgJLLg4BlAJLASgCSwACAksuDgGVAksBKAJLAAICSy4OAZYCSwEoAksAAgJLLg4BlwJLASgCSwACAksuDgGYAksBKAJLAAICSy4OAZkCSwEoAksAAgJLLg4BmgJLASgCSwACAksuDgGbAksBKAJLAAICSy4OAZwCSwEoAksAAgJLLg4BnQJLASgCSwACAksuDgGeAksBKAJLAAICSy4OAZ8CSwEoAksAAgJLLg4BoAJLASgCSwACAksuDgGhAksBKAJLAAICSy4OAaICSwEoAksAAgJLLg4ADgJLASgCSwACAksuDgGjAksBKAJLAAICSy4OAaQCSwEoAksAAgJLLg4BpQJLASgCSwACAksuDgGmAksBKAJLAAICSy4OAacCSwEoAksAAgJLLg4BqAJLASgCSwACAksuDgGpAksBKAJLAAICSy4OAaoCSwEoAksAAgJLLg4BqwJLASgCSwACAksuDgGsAksBKAJLAAICSy4OAa0CSwEoAksAAgJLLg4BrgJLASgCSwACAksuDgGvAksBKAJLAAICSy4OAbACSwEoAksAAgJLLg4BsQJLASgCSwACAksuDgGyAksBKAJLAAICSy4OAbMCSwEoAksAAgJLLg4BtAJLASgCSwACAksuDgG1AksBKAJLAAICSy4OAbYCSwEoAksAAgJLLg4BtwJLASgCSwACAksuDgG4AksBKAJLAAICSy4OAbkCSwEoAksAAgJLLg4BugJLASgCSwACAksuDgG7AksBKAJLAAICSy4OAbwCSwEoAksAAgJLLg4BvQJLASgCSwACAksuDgG+AksBKAJLAAICSy4OAb8CSwEoAksAAgJLLg4BwAJLASgCSwACAksuDgHBAksBKAJLAAICSy4OABACSwEoAksAAgJLLg4BwgJLASgCSwACAksuDgHDAksBKAJLAAICSy4OAcQCSwEoAksAAgJLLg4BxQJLASgCSwACAksuDgHGAksBKAJLAAICSy4OAccCSwEoAksAAgJLLg4ByAJLASgCSwACAksuDgHJAksBKAJLAAICSy4OAcoCSwEoAksAAgJLLg4BywJLASgCSwACAksuDgHMAksBKAJLAAICSy4OAc0CSwEoAksAAgJLLg4BzgJLASgCSwACAksuDgHPAksBKAJLAAICSy4OAdACSwEoAksAAgJLLg4B0QJLASgCSwACAksuDgHSAksBKAJLAAICSy4OAdMCSwEoAksAAgJLLg4B1AJLASgCSwACAksuDgHVAksBKAJLAAICSy4OAdYCSwEoAksAAgJLLg4B1wJLASgCSwACAksuDgHYAksBKAJLAAICSy4OAdkCSwEoAksAAgJLLg4B2gJLASgCSwACAksuDgHbAksBKAJLAAICSy4OAdwCSwEoAksAAgJLLg4B3QJLASgCSwACAksuDgHeAksBKAJLAAICSy4OAd8CSwEoAksAAgJLLg4B4AJLASgCSwACAksuDgASAksBKAJLAAICSy4OAeECSwEoAksAAgJLLg4B4gJLASgCSwACAksuDgHjAksBKAJLAAICSy4OAeQCSwEoAksAAgJLLg4B5QJLASgCSwACAksuDgHmAksBKAJLAAICSy4OAecCSwEoAksAAgJLLg4B6AJLASgCSwACAksuDgHpAksBKAJLAAICSy4OAeoCSwEoAksAAgJLLg4B6wJLASgCSwACAksuDgHsAksBKAJLAAICSy4OAe0CSwEoAksAAgJLLg4B7gJLASgCSwACAksuDgHvAksBKAJLAAICSy4OAfACSwEoAksAAgJLLg4B8QJLASgCSwACAksuDgHyAksBKAJLAAICSy4OAfMCSwEoAksAAgJLLg4B9AJLASgCSwACAksuDgH1AksBKAJLAAICSy4OAfYCSwEoAksAAgJLLg4B9wJLASgCSwACAksuDgH4AksBKAJLAAICSy4OAfkCSwEoAksAAgJLLg4B+gJLASgCSwACAksuDgH7AksBKAJLAAICSy4OAfwCSwEoAksAAgJLLg4B/QJLASgCSwACAksuDgH+AksBKAJLAAICSy4OAf8CSwEoAksAAgJLLg4AFAJLASgCSwACAksuDgIAAksBKAJLAAICSy4OAgECSwEoAksAAgJLLg4CAgJLASgCSwACAksuDgAVAksBKAJLAAICSy4OAgMCSwEoAksAAgJLLg4CBAJLASgCSwACAksuDgIFAksBKAJLAAICSy4OABcCSwEoAksAAgJLLg4CBgJLASgCSwACAksuDgIHAksBKAJLAAICSy4OAggCSwEoAksAAgJLLg4CCQJLASgCSwACAksuDgIKAksBKAJLAAICSy4OAgsCSwEoAksAAgJLLg4CDAJLASgCSwACAksuDgINAksBKAJLAAICSy4OAg4CSwEoAksAAgJLLg4CDwJLASgCSwACAksuDgIQAksBKAJLAAICSy4OAhECSwEoAksAAgJLLg4CEgJLASgCSwACAksuDgITAksBKAJLAAICSy4OAhQCSwEoAksAAgJLLg4CFQJLASgCSwACAksuDgIWAksBKAJLAAICSy4OAhcCSwEoAksAAgJLLg4CGAJLASgCSwACAksuDgIZAksBKAJLAAICSy4OAhoCSwEoAksAAgJLLg4CGwJLASgCSwACAksuDgIcAksBKAJLAAICSy4OAh4CSwEoAksAAgJLLg4CHQJLASgCSwACAksuDgIfAksBKAJLAAICSy4OAiACSwEoAksAAgJLLg4CIQJLASgCSwACAksuDgIiAksBKAJLAAICSy4OAiMCSwEoAksAAgJLLg4CJAJLASgCSwACAksuDgAaAksBKAJLAAICSy4OAiUCSwEoAksAAgJLLg4CJgJLASgCSwACAksuDgInAksBKAJLAAICSy4OAigCSwEoAksAAgJLLgqAeQJLASgCSwACAksuDgIpAksBKAJLAAICSy4OAioCSwEoAksAAgJLLg4CKwJLASgCSwACAksuDgIuAksBKAJLAAICSy4OAi0CSwEoAksAAgJLLg4CLwJLASgCSwACAksuDgIwAksBKAJLAAICSy4OAjECSwEoAksAAgJLLg4CMgJLASgCSwACAksuDgIzAksBKAJLAAICSy4OAjQCSwEoAksAAgJLLg4CNQJLASgCSwACAksuDgI2AksBKAJLAAICSy4OAjcCSwEoAksAAgJLLg4COAJLASgCSwACAksuDgI5AksBKAJLAAICSy4OAjoCSwEoAksAAgJLLg4COwJLASgCSwACAksuDgI8AksBKAJLAAICSy4OAj0CSwEoAksAAgJLLg4CPgJLASgCSwACAksuDgI/AksBKAJLAAICSy4OAkACSwEoAksAAgJLLg4CQQJLASgCSwACAksuDgJCAksBKAJLAAICSy4OAkMCSwEoAksAAgJLLg4CRAJLASgCSwACAksuDgJFAksBKAJLAAICSy4OAkYCSwEoAksAAgJLLg4CRwJLASgCSwACAksuDgJIAksBKAJLAAICSy4OAAMCSy0IAQIoAgADBAFVABABAwEnAwIEAQAoAgIDKAIABAQBVAA4BAMELQwDBQw4BQQGFgwGBiQCAAYAAHp0LgqAYQAFACgFAgUjAAB6Uy0IAQMAAAECAS0OAgMoAgACBAFULgiAeAABIwAAepMMOAECBCQCAAQAAIefIwAAeqUtCAEEKAIABQQBEgAQAQUBJwMEBAEAKAQCBSgCAAYEAREAOAYFBi0MBQcMOAcGCBYMCAgkAgAIAAB68C4KgGEABwAoBwIHIwAAes8tCAEFAAABAgEtDgQFKAIABAQCZS4IgHgAASMA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",
      "debug_symbols": "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",
      "brillig_names": [
        "open"
      ]
    },
    {
      "name": "fill_private",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10852400770788842366": {
            "error_kind": "string",
            "string": "Invalid order domain"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "fill_private"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "5048864367174250545": {
            "error_kind": "string",
            "string": "Function get_filled_order_block_number can only be called statically"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6017907102598075401": {
            "error_kind": "string",
            "string": "Function get_order_status can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7354432299782447020": {
            "error_kind": "string",
            "string": "Function _assert_order_status can only be called internally"
          },
          "8412360910299423372": {
            "error_kind": "string",
            "string": "Invalid order destination domain"
          },
          "9169818942746597700": {
            "error_kind": "string",
            "string": "Function _update_order_status can only be called internally"
          },
          "10391454703121400355": {
            "error_kind": "string",
            "string": "Function _assert_order_commitment can only be called internally"
          },
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "10852400770788842366": {
            "error_kind": "string",
            "string": "Invalid order domain"
          },
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "11094545764365153162": {
            "error_kind": "string",
            "string": "Function _assert_nonce_and_set_order_details can only be called internally"
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13459246948365409099": {
            "error_kind": "string",
            "string": "Function _emit_open can only be called internally"
          },
          "13594925270014003382": {
            "error_kind": "string",
            "string": "Function _trigger_settlement can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14563046062317426044": {
            "error_kind": "string",
            "string": "Function _check_order_commitment can only be called internally"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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ATgACQEeASAuDQEgAR8dDAEfASACHQwBIAEeAB0MAR4BHwIoAgEgBACkATgACQEgASIuDQEiASEdDAEhASICHQwBIgEgAB0MASABIQIoAgEiBAClATgACQEiASQuDQEkASMdDAEjASQCHQwBJAEiAB0MASIBIwIoAgEkBACmATgACQEkASYuDQEmASUdDAElASYCHQwBJgEkAB0MASQBJQIoAgEmBACnATgACQEmASguDQEoAScdDAEnASgCHQwBKAEmAB0MASYBJwIoAgEoBACoATgACQEoASouDQEqASkdDAEpASoCHQwBKgEoAB0MASgBKQIoAgEqBACpATgACQEqASwuDQEsASsdDAErASwCHQwBLAEqAB0MASoBKwIoAgEsBACqATgACQEsAS4uDQEuAS0dDAEtAS4CHQwBLgEsAB0MASwBLQIoAgEuBACrATgACQEuATAuDQEwAS8dDAEvATACHQwBMAEuAB0MAS4BLwIoAgEwBACsATgACQEwATIuDQEyATEdDAExATICHQwBMgEwAB0MATABMQIoAgEyBACtATgACQEyATQuDQE0ATMdDAEzATQCHQwBNAEyAB0MATIBMwIoAgE0BACuATgACQE0ATYuDQE2ATUdDAE1ATYCHQwBNgE0AB0MATQBNQIoAgE2BACvATgACQE2ATguDQE4ATcdDAE3ATgCHQwBOAE2AB0MATYBNwIoAgE4BACwATgACQE4ATouDQE6ATkdDAE5AToCHQwBOgE4AB0MATgBOQIoAgE6BACxATgACQE6ATwuDQE8ATsdDAE7ATwCHQwBPAE6AB0MAToBOwIoAgE8BACyATgACQE8AT4uDQE+AT0dDAE9AT4CHQwBPgE8AB0MATwBPQIoAgE+BACzATgACQE+AUAuDQFAAT8dDAE/AUACHQwBQAE+AB0MAT4BPwIoAgFABAC0ATgACQFAAUIuDQFCAUEdDAFBAUICHQwBQgFAAB0MAUABQQIoAgFCBAC1ATgACQFCAUQuDQFEAUMdDAFDAUQCHQwBRAFCAB0MAUIBQwIoAgFEBAC2ATgACQFEAUYuDQFGAUUdDAFFAUYCHQwBRgFEAB0MAUQBRQIoAgFGBAC3ATgACQFGAUguDQFIAUcdDAFHAUgCHQwBSAFGAB0MAUYBRwIoAgFIBAC4ATgACQFIAUouDQFKAUkdDAFJ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KAICTgQBOwE4AAkCTgJQLg0CUAJPHQwCTwJQAh0MAlACTgAdDAJOAk8CKAICUAQBPAE4AAkCUAJSLg0CUgJRHQwCUQJSAh0MAlICUAAdDAJQAlECKAICUgQBPQE4AAkCUgJULg0CVAJTHQwCUwJUAh0MAlQCUgAdDAJSAlMCKAICVAQBPgE4AAkCVAJWLg0CVgJVHQwCVQJWAh0MAlYCVAAdDAJUAlUCKAICVgQBPwE4AAkCVgJYLg0CWAJXHQwCVwJYAh0MAlgCVgAdDAJWAlcCKAICWAQBQAE4AAkCWAJaLg0CWgJZHQwCWQJaAh0MAloCWAAdDAJYAlkCKAICWgQBQQE4AAkCWgJcLg0CXAJbHQwCWwJcAh0MAlwCWgAdDAJaAlsCKAICXAQBQgE4AAkCXAJeLg0CXgJdHQwCXQJeAh0MAl4CXAAdDAJcAl0CKAICXgQBQwE4AAkCXgJgLg0CYAJfHQwCXwJgAh0MAmACXgAdDAJeAl8CKAICYAQBRAE4AAkCYAJiLg0CYgJhHQwCYQJiAh0MAmICYAAdDAJgAmECKAICYgQBRQE4AAkCYgJkLg0CZAJjHQwCYwJkAh0MAmQCYgAdDAJiAmMCKAICZAQBRgE4AAkCZAJmLg0CZgJlHQwCZQJmAh0MAmYCZAAdDAJkAmUCKAICZgQBRwE4AAkCZgJoLg0CaAJnHQwCZwJoAh0MAmgCZgAdDAJmAmcCKAICaAQBSAE4AAkCaAJqLg0CagJpHQwCaQJqAh0MAmoCaAAdDAJoAmkCKAICagQBSQE4AAkCagJsLg0CbAJrHQwCawJsAh0MAmwCagAdDAJqAmsCKAICbAQBSgE4AAkCbAJuLg0CbgJtHQwCbQJuAh0MAm4CbAAdDAJsAm0CKAICbgQBSwE4AAkCbgJwLg0CcAJvHQwCbwJwAh0MAnACbgAdDAJuAm8CKAICcAQBTAE4AAkCcAJyLg0CcgJxHQwCcQJyAh0MAnICcAAdDAJwAnECASgACYDEAnMuDQJzAnIdDAJyAnQCHQwCdAJzAB0MAnMCcgIBOAAJAAMCdS4NAnUCdB0MAnQCdQIdDAJ1AAkAHQwACQJ0Ai4IAAECdSgCAnYEAS4BEAABAnYAASgDAnUEAAEBKAJ1AAICdi4MAnYCdy4OAAwCdwEoAncAAgJ3Lg4ADwJ3ASgCdwACAncuDgATAncBKAJ3AAICdy4OABUCdwEoAncAAgJ3Lg4AFwJ3ASgCdwACAncuDgAZAncBKAJ3AAICdy4OABsCdwEoAncAAgJ3Lg4AHgJ3ASgCdwACAncuDgAiAncBKAJ3AAICdy4OACYCdwEoAncAAgJ3Lg4AKAJ3ASgCdwACAncuDgAuAncBKAJ3AAICdy4OADICdwEoAncAAgJ3Lg4ANgJ3ASgCdwACAncuDgA4AncBKAJ3AAICdy4OADsCdwEoAncAAgJ3Lg4APQJ3ASgCdwACAncuDgA/AncBKAJ3AAICdy4OAEECdwEoAncAAgJ3Lg4AQwJ3ASgCdwACAncuDgBFAncBKAJ3AAICdy4OAEcCdwEoAncAAgJ3Lg4ASAJ3ASgCdwACAncuDgBLAncBKAJ3AAICdy4OAE0CdwEoAncAAgJ3Lg4ATwJ3ASgCdwACAncuDgBRAncBKAJ3AAICdy4OAFMCdwEoAncAAgJ3Lg4AVQJ3ASgCdwACAncuDgBXAncBKAJ3AAICdy4OAFgCdwEoAncAAgJ3Lg4AWgJ3ASgCdwACAncuDgBdAncBKAJ3AAICdy4OAF8CdwEoAncAAgJ3Lg4AYQJ3ASgCdwACAncuDgBjAncBKAJ3AAICdy4OAGUCdwEoAncAAgJ3Lg4AZwJ3ASgCdwACAncuDgBpAncBKAJ3AAICdy4OAGsCdwEoAncAAgJ3Lg4AbQJ3ASgCdwACAncuDgBvAncBKAJ3AAICdy4OAHECdwEoAncAAgJ3Lg4AcwJ3ASgCdwACAncuDgB1AncBKAJ3AAICdy4OAHcCdwEoAncAAgJ3Lg4AeQJ3ASgCdwACAncuDgB7AncBKAJ3AAICdy4OAH0CdwEoAncAAgJ3Lg4AfwJ3ASgCdwACAncuDgCBAncBKAJ3AAICdy4OAIMCdwEoAncAAgJ3Lg4AhQJ3ASgCdwACAncuDgCHAncBKAJ3AAICdy4OAIkCdwEoAncAAgJ3Lg4AiwJ3ASgCdwACAncuDgCNAncBKAJ3AAICdy4OAI8CdwEoAncAAgJ3Lg4AkQJ3ASgCdwACAncuDgCTAncBKAJ3AAICdy4OAJUCdwEoAncAAgJ3Lg4AlwJ3ASgCdwACAncuDgCYAncBKAJ3AAICdy4OAJsCdwEoAncAAgJ3Lg4AnQJ3ASgCdwACAncuDgCfAncBKAJ3AAICdy4OAKECdwEoAncAAgJ3Lg4AowJ3ASgCdwACAncuDgClAncBKAJ3AAICdy4OAKcCdwEoAncAAgJ3Lg4AqQJ3ASgCdwACAncuDgCrAncBKAJ3AAICdy4OAK0CdwEoAncAAgJ3Lg4ArwJ3ASgCdwACAncuDgCxAncBKAJ3AAICdy4OALMCdwEoAncAAgJ3Lg4AtQJ3ASgCdwACAncuDgC3AncBKAJ3AAICdy4OALkCdwEoAncAAgJ3Lg4AuwJ3ASgCdwACAncuDgC9AncBKAJ3AAICdy4OAL8CdwEoAncAAgJ3Lg4AwQJ3ASgCdwACAncuDgDDAncBKAJ3AAICdy4OAMUCdwEoAncAAgJ3Lg4AxwJ3ASgCdwACAncuDgDJAncBKAJ3AAICdy4OAMsCdwEoAncAAgJ3Lg4AzQJ3ASgCdwACAncuDgDPAncBKAJ3AAICdy4OANECdwEoAncAAgJ3Lg4A0wJ3ASgCdwACAncuDgDVAncBKAJ3AAICdy4OANcCdwEoAncAAgJ3Lg4A2AJ3ASgCdwACAncuDgDbAncBKAJ3AAICdy4OAN0CdwEoAncAAgJ3Lg4A3wJ3ASgCdwACAncuDgDhAncBKAJ3AAICdy4OAOMCdwEoAncAAgJ3Lg4A5QJ3ASgCdwACAncuDgDnAncBKAJ3AAICdy4OAOkCdwEoAncAAgJ3Lg4A6wJ3ASgCdwACAncuDgDtAncBKAJ3AAICdy4OAO8CdwEoAncAAgJ3Lg4A8QJ3ASgCdwACAncuDgDzAncBKAJ3AAICdy4OAPUCdwEoAncAAgJ3Lg4A9wJ3ASgCdwACAncuDgD5AncBKAJ3AAICdy4OAPsCdwEoAncAAgJ3Lg4A/QJ3ASgCdwACAncuDgD/AncBKAJ3AAICdy4OAQECdwEoAncAAgJ3Lg4BAwJ3ASgCdwACAncuDgEFAncBKAJ3AAICdy4OAQcCdwEoAncAAgJ3Lg4BCQJ3ASgCdwACAncuDgELAncBKAJ3AAICdy4OAQ0CdwEoAncAAgJ3Lg4BDwJ3ASgCdwACAncuDgERAncBKAJ3AAICdy4OARMCdwEoAncAAgJ3Lg4BFQJ3ASgCdwACAncuDgEXAncBKAJ3AAICdy4OARgCdwEoAncAAgJ3Lg4BGwJ3ASgCdwACAncuDgEdAncBKAJ3AAICdy4OAR8CdwEoAncAAgJ3Lg4BIQJ3ASgCdwACAncuDgEjAncBKAJ3AAICdy4OASUCdwEoAncAAgJ3Lg4BJwJ3ASgCdwACAncuDgEpAncBKAJ3AAICdy4OASsCdwEoAncAAgJ3Lg4BLQJ3ASgCdwACAncuDgEvAncBKAJ3AAICdy4OATECdwEoAncAAgJ3Lg4BMwJ3ASgCdwACAncuDgE1AncBKAJ3AAICdy4OATcCdwEoAncAAgJ3Lg4BOQJ3ASgCdwACAncuDgE7AncBKAJ3AAICdy4OAT0CdwEoAncAAgJ3Lg4BPwJ3ASgCdwACAncuDgFBAncBKAJ3AAICdy4OAUMCdwEoAncAAgJ3Lg4BRQJ3ASgCdwACAncuDgFHAncBKAJ3AAICdy4OAUkCdwEoAncAAgJ3Lg4BSwJ3ASgCdwACAncuDgFNAncBKAJ3AAICdy4OAU8CdwEoAncAAgJ3Lg4BUQJ3ASgCdwACAncuDgFTAncBKAJ3AAICdy4OAVUCdwEoAncAAgJ3Lg4BVwJ3ASgCdwACAncuDgFYAncBKAJ3AAICdy4OAVsCdwEoAncAAgJ3Lg4BXQJ3ASgCdwACAncuDgFfAncBKAJ3AAICdy4OAWECdwEoAncAAgJ3Lg4BYwJ3ASgCdwACAncuDgFlAncBKAJ3AAICdy4OAWcCdwEoAncAAgJ3Lg4BaQJ3ASgCdwACAncuDgFrAncBKAJ3AAICdy4OAW0CdwEoAncAAgJ3Lg4BbwJ3ASgCdwACAncuDgFxAncBKAJ3AAICdy4OAXMCdwEoAncAAgJ3Lg4BdQJ3ASgCdwACAncuDgF3AncBKAJ3AAICdy4OAXkCdwEoAncAAgJ3Lg4BewJ3ASgCdwACAncuDgF9AncBKAJ3AAICdy4OAX8CdwEoAncAAgJ3Lg4BgQJ3ASgCdwACAncuDgGDAncBKAJ3AAICdy4OAYUCdwEoAncAAgJ3Lg4BhwJ3ASgCdwACAncuDgGJAncBKAJ3AAICdy4OAYsCdwEoAncAAgJ3Lg4BjQJ3ASgCdwACAncuDgGPAncBKAJ3AAICdy4OAZECdwEoAncAAgJ3Lg4BkwJ3ASgCdwACAncuDgGVAncBKAJ3AAICdy4OAZcCdwEoAncAAgJ3Lg4BmAJ3ASgCdwACAncuDgGbAncBKAJ3AAICdy4OAZ0CdwEoAncAAgJ3Lg4BnwJ3ASgCdwACAncuDgGgAncBKAJ3AAICdy4OAaMCdwEoAncAAgJ3Lg4BpQJ3ASgCdwACAncuDgGnAncBKAJ3AAICdy4OAagCdwEoAncAAgJ3Lg4BqwJ3ASgCdwACAncuDgGtAncBKAJ3AAICdy4OAa8CdwEoAncAAgJ3Lg4BsQJ3ASgCdwACAncuDgGzAncBKAJ3AAICdy4OAbUCdwEoAncAAgJ3Lg4BtwJ3ASgCdwACAncuDgG5AncBKAJ3AAICdy4OAbsCdwEoAncAAgJ3Lg4BvQJ3ASgCdwACAncuDgG/AncBKAJ3AAICdy4OAcECdwEoAncAAgJ3Lg4BwwJ3ASgCdwACAncuDgHFAncBKAJ3AAICdy4OAccCdwEoAncAAgJ3Lg4ByQJ3ASgCdwACAncuDgHLAncBKAJ3AAICdy4OAc0CdwEoAncAAgJ3Lg4BzwJ3ASgCdwACAncuDgHRAncBKAJ3AAICdy4OAdMCdwEoAncAAgJ3Lg4B1QJ3ASgCdwACAncuDgHXAncBKAJ3AAICdy4OAdgCdwEoAncAAgJ3Lg4B2wJ3ASgCdwACAncuDgHdAncBKAJ3AAICdy4OAd8CdwEoAncAAgJ3Lg4B4QJ3ASgCdwACAncuDgHjAncBKAJ3AAICdy4OAeUCdwEoAncAAgJ3Lg4B5wJ3ASgCdwACAncuDgHoAncBKAJ3AAICdy4OAesCdwEoAncAAgJ3Lg4B7QJ3ASgCdwACAncuDgHvAncBKAJ3AAICdy4OAfECdwEoAncAAgJ3Lg4B8gJ3ASgCdwACAncuDgH1AncBKAJ3AAICdy4OAfcCdwEoAncAAgJ3Lg4B+QJ3ASgCdwACAncuDgH6AncBKAJ3AAICdy4OAf0CdwEoAncAAgJ3Lg4B/wJ3ASgCdwACAncuDgIBAncBKAJ3AAICdy4OAgMCdwEoAncAAgJ3Lg4CBQJ3ASgCdwACAncuDgIHAncBKAJ3AAICdy4OAgkCdwEoAncAAgJ3Lg4CCwJ3ASgCdwACAncuDgINAncBKAJ3AAICdy4OAg8CdwEoAncAAgJ3Lg4CEQJ3ASgCdwACAncuDgITAncBKAJ3AAICdy4OAhUCdwEoAncAAgJ3Lg4CFwJ3ASgCdwACAncuDgIZAncBKAJ3AAICdy4OAhsCdwEoAncAAgJ3Lg4CHQJ3ASgCdwACAncuDgIfAncBKAJ3AAICdy4OAiECdwEoAncAAgJ3Lg4CIwJ3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CgI0ASgCNAACAjQuDgA7AjQBKAI0AAICNC4OAD0CNAEoAjQAAgI0Lg4ARQI0ASgCNAACAjQuDgBHAjQBKAI0AAICNC4OAEgCNAEoAjQAAgI0Lg4ATQI0ASgCNAACAjQuDgBPAjQBKAI0AAICNC4OAFMCNAEoAjQAAgI0Lg4AVQI0ASgCNAACAjQuDgBXAjQBKAI0AAICNC4OAFgCNAEoAjQAAgI0Lg4AWgI0ASgCNAACAjQuDgBdAjQBKAI0AAICNC4OAF8CNAEoAjQAAgI0Lg4AYQI0ASgCNAACAjQuDgBjAjQBKAI0AAICNC4OAGUCNAEoAjQAAgI0Lg4AZwI0ASgCNAACAjQuDgBpAjQBKAI0AAICNC4OAGsCNAEoAjQAAgI0Lg4AbQI0ASgCNAACAjQuDgBvAjQBKAI0AAICNC4OAHECNAEoAjQAAgI0Lg4AcwI0ASgCNAACAjQuDgB1AjQBKAI0AAICNC4OAHcCNAEoAjQAAgI0Lg4AeQI0ASgCNAACAjQuDgB7AjQBKAI0AAICNC4OAH0CNAEoAjQAAgI0Lg4AfwI0ASgCNAACAjQuDgAZAjQBKAI0AAICNC4OAIECNAEoAjQAAgI0Lg4AgwI0ASgCNAACAjQuDgCFAjQBKAI0AAICNC4OAEECNAEoAjQAAgI0Lg4AhwI0ASgCNAACAjQuDgCJAjQBKAI0AAICNC4OAIsCNAEoAjQAAgI0Lg4AQwI0ASgCNAACAjQuDgCNAjQBKAI0AAICNC4OAI8CNAEoAjQAAgI0Lg4AkQI0ASgCNAACAjQuDgAXAjQBKAI0AAICNC4OAJMCNAEoAjQAAgI0Lg4AlQI0ASgCNAACAjQuDgCXAjQBKAI0AAICNC4OAJgCNAEoAjQAAgI0Lg4AmwI0ASgCNAACAjQuDgCdAjQBKAI0AAICNC4OAJ8CNAEoAjQAAgI0Lg4AoQI0ASgCNAACAjQuDgCjAjQBKAI0AAICNC4OAKUCNAEoAjQAAgI0Lg4ApwI0ASgCNAACAjQuDgCpAjQBKAI0AAICNC4OAKsCNAEoAjQAAgI0Lg4ArQI0ASgCNAACAjQuDgCvAjQBKAI0AAICNC4OALECNAEoAjQAAgI0Lg4AswI0ASgCNAACAjQuDgC1AjQBKAI0AAICNC4OALcCNAEoAjQAAgI0Lg4AuQI0ASgCNAACAjQuDgC7AjQBKAI0AAICNC4OAL0CNAEoAjQAAgI0Lg4AvwI0ASgCNAACAjQuDgDBAjQBKAI0AAICNC4OAMMCNAEoAjQAAgI0Lg4AxQI0ASgCNAACAjQuDgDHAjQBKAI0AAICNC4OAMkCNAEoAjQAAgI0Lg4AywI0ASgCNAACAjQuDgDNAjQBKAI0AAICNC4OAM8CNAEoAjQAAgI0Lg4A0QI0ASgCNAACAjQuDgDTAjQBKAI0AAICNC4OANUCNAEoAjQAAgI0Lg4A1wI0ASgCNAACAjQuDgDYAjQBKAI0AAICNC4OANsCNAEoAjQAAgI0Lg4A3QI0ASgCNAACAjQuDgDfAjQBKAI0AAICNC4OAOECNAEoAjQAAgI0Lg4A4wI0ASgCNAACAjQuDgDlAjQBKAI0AAICNC4OAOcCNAEoAjQAAgI0Lg4A6QI0ASgCNAACAjQuDgDrAjQBKAI0AAICNC4OAO0CNAEoAjQAAgI0Lg4A7wI0ASgCNAACAjQuDgDxAjQBKAI0AAICNC4OAPMCNAEoAjQAAgI0Lg4A9QI0ASgCNAACAjQuDgD3AjQBKAI0AAICNC4OAPkCNAEoAjQAAgI0Lg4A+wI0ASgCNAACAjQuDgD9AjQBKAI0AAICNC4OAP8CNAEoAjQAAgI0Lg4BAQI0ASgCNAACAjQuDgEDAjQBKAI0AAICNC4OAQUCNAEoAjQAAgI0Lg4BBwI0ASgCNAACAjQuDgEJAjQBKAI0AAICNC4OAQsCNAEoAjQAAgI0Lg4BDQI0ASgCNAACAjQuDgEPAjQBKAI0AAICNC4OAB4CNAEoAjQAAgI0Lg4BEQI0ASgCNAACAjQuDgETAjQBKAI0AAICNC4OARUCNAEoAjQAAgI0Lg4BFwI0ASgCNAACAjQuDgEYAjQBKAI0AAICNC4OARsCNAEoAjQAAgI0Lg4BHQI0ASgCNAACAjQuDgEfAjQBKAI0AAICNC4OASECNAEoAjQAAgI0Lg4BIwI0ASgCNAACAjQuDgElAjQBKAI0AAICNC4OAScCNAEoAjQAAgI0Lg4BKQI0ASgCNAACAjQuDgErAjQBKAI0AAICNC4OAS0CNAEoAjQAAgI0Lg4BLwI0ASgCNAACAjQuDgExAjQBKAI0AAICNC4OATMCNAEoAjQAAgI0Lg4BNQI0ASgCNAACAjQuDgE3AjQBKAI0AAICNC4OATkCNAEoAjQAAgI0Lg4BOwI0ASgCNAACAjQuDgE9AjQBKAI0AAICNC4OAT8CNAEoAjQAAgI0Lg4BQQI0ASgCNAACAjQuDgFDAjQBKAI0AAICNC4OAUUCNAEoAjQAAgI0Lg4BRwI0ASgCNAACAjQuDgFJAjQBKAI0AAICNC4OAUsCNAEoAjQAAgI0Lg4BTQI0ASgCNAACAjQuDgAmAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuCoCWAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuCoCWAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuCoCWAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuCoCWAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuCoCWAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuCoCWAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuCoCWAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuCoCWAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuCoCWAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuCoCWAjQBKAI0AAICNC4KgJYCNAEoAjQAAgI0LgqAlgI0ASgCNAACAjQuDgFPAjQBKAI0AAICNC4OAVECNAEoAjQAAgI0Lg4BUwI0ASgCNAACAjQuDgA2AjQBKAI0AAICNC4OAVUCNAEoAjQAAgI0Lg4BVwI0ASgCNAACAjQuDgFYAjQBKAI0AAICNC4OAVsCNAEoAjQAAgI0Lg4BXQI0ASgCNAACAjQuDgFfAjQBKAI0AAICNC4OAWECNAEoAjQAAgI0Lg4BYwI0ASgCNAACAjQuDgFlAjQBKAI0AAICNC4OAWcCNAEoAjQAAgI0Lg4BaQI0ASgCNAACAjQuDgFrAjQBKAI0AAICNC4OAW0CNAEoAjQAAgI0Lg4BbwI0ASgCNAACAjQuDgFxAjQBKAI0AAICNC4OAXMCNAEoAjQAAgI0Lg4BdQI0ASgCNAACAjQuDgF3AjQBKAI0AAICNC4OAXkCNAEoAjQAAgI0Lg4BewI0ASgCNAACAjQuDgF9AjQBKAI0AAICNC4OAX8CNAEoAjQAAgI0Lg4BgQI0ASgCNAACAjQuDgGDAjQBKAI0AAICNC4OAYUCNAEoAjQAAgI0Lg4BhwI0ASgCNAACAjQuDgGJAjQBKAI0AAICNC4OAYsCNAEoAjQAAgI0Lg4BjQI0ASgCNAACAjQuDgGPAjQBKAI0AAICNC4OAZECNAEoAjQAAgI0Lg4AIgI0ASgCNAACAjQuDgGTAjQBKAI0AAICNC4OAZUCNAEoAjQAAgI0Lg4BlwI0ASgCNAACAjQuDgGYAjQBKAI0AAICNC4OAZsCNAEoAjQAAgI0Lg4BnQI0ASgCNAACAjQuDgGfAjQBKAI0AAICNC4OAaACNAEoAjQAAgI0Lg4BowI0ASgCNAACAjQuDgGlAjQBKAI0AAICNC4OAacCNAEoAjQAAgI0Lg4BqAI0ASgCNAACAjQuDgGrAjQBKAI0AAICNC4OAa0CNAEoAjQAAgI0Lg4BrwI0ASgCNAACAjQuDgGxAjQBKAI0AAICNC4OAbMCNAEoAjQAAgI0Lg4BtQI0ASgCNAACAjQuDgG3AjQBKAI0AAICNC4OAbkCNAEoAjQAAgI0Lg4BuwI0ASgCNAACAjQuDgG9AjQBKAI0AAICNC4OAb8CNAEoAjQAAgI0Lg4BwQI0ASgCNAACAjQuDgHDAjQBKAI0AAICNC4OAcUCNAEoAjQAAgI0Lg4BxwI0ASgCNAACAjQuDgHJAjQBKAI0AAICNC4OAcsCNAEoAjQAAgI0Lg4BzQI0ASgCNAACAjQuDgHPAjQBKAI0AAICNC4OACgCNAEoAjQAAgI0Lg4B0QI0ASgCNAACAjQuDgHTAjQBKAI0AAICNC4OAdUCNAEoAjQAAgI0Lg4B1wI0ASgCNAACAjQuDgHYAjQBKAI0AAICNC4OAdsCNAEoAjQAAgI0Lg4B3QI0ASgCNAACAjQuDgHfAjQBKAI0AAICNC4OAeECNAEoAjQAAgI0Lg4B4wI0ASgCNAACAjQuDgHlAjQBKAI0AAICNC4OAecCNAEoAjQAAgI0Lg4B6AI0ASgCNAACAjQuDgHrAjQBKAI0AAICNC4OAe0CNAEoAjQAAgI0Lg4B7wI0ASgCNAACAjQuDgHxAjQBKAI0AAICNC4OAfICNAEoAjQAAgI0Lg4B9QI0ASgCNAACAjQuDgH3AjQBKAI0AAICNC4OAfkCNAEoAjQAAgI0Lg4B+gI0ASgCNAACAjQuDgH9AjQBKAI0AAICNC4OAf8CNAEoAjQAAgI0Lg4CAQI0ASgCNAACAjQuDgIDAjQBKAI0AAICNC4OAgUCNAEoAjQAAgI0Lg4CBwI0ASgCNAACAjQuDgIJAjQBKAI0AAICNC4OAgsCNAEoAjQAAgI0Lg4CDQI0ASgCNAACAjQuDgAbAjQBKAI0AAICNC4OAg8CNAEoAjQAAgI0Lg4CEQI0ASgCNAACAjQuDgITAjQBKAI0AAICNC4OAD8CNAEoAjQAAgI0Lg4CDwI0ASgCNAACAjQuDgIRAjQBKAI0AAICNC4OAhMCNAEoAjQAAgI0Lg4APwI0ASgCNAACAjQuDgIVAjQBKAI0AAICNC4OAhcCNAEoAjQAAgI0Lg4CGQI0ASgCNAACAjQuDgIbAjQBKAI0AAICNC4OAA4CNAEoAjQAAgI0Lg4AEAI0ASgCNAACAjQuDgASAjQBKAI0AAICNC4OAh0CNAEoAjQAAgI0Lg4CHwI0ASgCNAACAjQuDgIhAjQBKAI0AAICNC4OAiMCNAEoAjQAAgI0Lg4CJQI0ASgCNAACAjQuDgInAjQBKAI0AAICNC4OAikCNAEoAjQAAgI0Lg4CKwI0ASgCNAACAjQuDgItAjQBKAI0AAICNC4OAB0CNAEoAjQAAgI0Lg4AHwI0ASgCNAACAjQuDgAhAjQBKAI0AAICNC4OACMCNAEoAjQAAgI0Lg4AJQI0ASgCNAACAjQuDgAnAjQBKAI0AAICNC4OACkCNAEoAjQAAgI0Lg4AKwI0ASgCNAACAjQuDgAtAjQBKAI0AAICNC4OAC8CNAEoAjQAAgI0Lg4AMQI0ASgCNAACAjQuDgAzAjQBKAI0AAICNC4OADUCNAEoAjQAAgI0Lg4CLwI0ASgCNAACAjQuDgIxAjQBKAI0AAICNC4OADgCNAEoAjQAAgI0Lg4ACwI0ASgCNAACAjQuDgANAjQBKAI0AAICNC4OABECNAEoAjQAAgI0Lg4AFAI0ASgCNAACAjQuDgAWAjQBKAI0AAICNC4OABgCNAEoAjQAAgI0Lg4AGgI0ASgCNAACAjQuDgAcAjQBKAI0AAICNC4OACACNAEoAjQAAgI0Lg4AJAI0ASgCNAACAjQuDgAqAjQBKAI0AAICNC4OACwCNAEoAjQAAgI0Lg4AMAI0ASgCNAACAjQuDgA0AjQBKAI0AAICNC4OADcCNAEoAjQAAgI0Lg4AOQI0ASgCNAACAjQuDgA8AjQBKAI0AAICNC4OAD4CNAEoAjQAAgI0Lg4AQAI0ASgCNAACAjQuDgBCAjQBKAI0AAICNC4OAEQCNAEoAjQAAgI0Lg4ARgI0ASgCNAACAjQuDgBJAjQBKAI0AAICNC4OAEoCNAEoAjQAAgI0Lg4ATAI0ASgCNAACAjQuDgBOAjQBKAI0AAICNC4OAFACNAEoAjQAAgI0Lg4AUgI0ASgCNAACAjQuDgBUAjQBKAI0AAICNC4OAFYCNAEoAjQAAgI0Lg4AWQI0ASgCNAACAjQuDgBbAjQBKAI0AAICNC4OAFwCNAEoAjQAAgI0Lg4AXgI0ASgCNAACAjQuDgBgAjQBKAI0AAICNC4OAGICNAEoAjQAAgI0Lg4AZAI0ASgCNAACAjQuDgBmAjQBKAI0AAICNC4OAGgCNAEoAjQAAgI0Lg4AagI0ASgCNAACAjQuDgBsAjQBKAI0AAICNC4OAG4CNAEoAjQAAgI0Lg4AcAI0ASgCNAACAjQuDgByAjQBKAI0AAICNC4OAHQCNAEoAjQAAgI0Lg4AdgI0ASgCNAACAjQuDgB4AjQBKAI0AAICNC4OAHoCNAEoAjQAAgI0Lg4AfAI0ASgCNAACAjQuDgB+AjQBKAI0AAICNC4OAIACNAEoAjQAAgI0Lg4AggI0ASgCNAACAjQuDgCEAjQBKAI0AAICNC4OAIYCNAEoAjQAAgI0Lg4AiAI0ASgCNAACAjQuDgCKAjQBKAI0AAICNC4OAIwCNAEoAjQAAgI0Lg4AjgI0ASgCNAACAjQuDgCQAjQBKAI0AAICNC4OAJICNAEoAjQAAgI0Lg4AlAI0ASgCNAACAjQuDgCWAjQBKAI0AAICNC4OAJkCNAEoAjQAAgI0Lg4AmgI0ASgCNAACAjQuDgCcAjQBKAI0AAICNC4OAJ4CNAEoAjQAAgI0Lg4AoAI0ASgCNAACAjQuDgCiAjQBKAI0AAICNC4OAKQCNAEoAjQAAgI0Lg4ApgI0ASgCNAACAjQuDgCoAjQBKAI0AAICNC4OAKoCNAEoAjQAAgI0Lg4ArAI0ASgCNAACAjQuDgCuAjQBKAI0AAICNC4OALACNAEoAjQAAgI0Lg4AsgI0ASgCNAACAjQuDgC0AjQBKAI0AAICNC4OALYCNAEoAjQAAgI0Lg4AuAI0ASgCNAACAjQuDgC6AjQBKAI0AAICNC4OALwCNAEoAjQAAgI0Lg4AvgI0ASgCNAACAjQuDgDAAjQBKAI0AAICNC4OAMICNAEoAjQAAgI0Lg4AxAI0ASgCNAACAjQuDgDGAjQBKAI0AAICNC4OAMgCNAEoAjQAAgI0Lg4AygI0ASgCNAACAjQuDgDMAjQBKAI0AAICNC4OAM4CNAEoAjQAAgI0Lg4A0AI0ASgCNAACAjQuDgDSAjQBKAI0AAICNC4OANQCNAEoAjQAAgI0Lg4A1gI0ASgCNAACAjQuDgDZAjQBKAI0AAICNC4OANoCNAEoAjQAAgI0Lg4A3AI0ASgCNAACAjQuDgDeAjQBKAI0AAICNC4OAOACNAEoAjQAAgI0Lg4A4gI0ASgCNAACAjQuDgDkAjQBKAI0AAICNC4OAOYCNAEoAjQAAgI0Lg4A6AI0ASgCNAACAjQuDgDqAjQBKAI0AAICNC4OAOwCNAEoAjQAAgI0Lg4A7gI0ASgCNAACAjQuDgDwAjQBKAI0AAICNC4OAPICNAEoAjQAAgI0Lg4A9AI0ASgCNAACAjQuDgD2AjQBKAI0AAICNC4OAPgCNAEoAjQAAgI0Lg4A+gI0ASgCNAACAjQuDgD8AjQBKAI0AAICNC4OAP4CNAEoAjQAAgI0Lg4BAAI0ASgCNAACAjQuDgECAjQBKAI0AAICNC4OAQQCNAEoAjQAAgI0Lg4BBgI0ASgCNAACAjQuDgEIAjQBKAI0AAICNC4OAQoCNAEoAjQAAgI0Lg4BDAI0ASgCNAACAjQuDgEOAjQBKAI0AAICNC4OARACNAEoAjQAAgI0Lg4BEgI0ASgCNAACAjQuDgEUAjQBKAI0AAICNC4OARYCNAEoAjQAAgI0Lg4BGQI0ASgCNAACAjQuDgEaAjQBKAI0AAICNC4OARwCNAEoAjQAAgI0Lg4BHgI0ASgCNAACAjQuDgEgAjQBKAI0AAICNC4OASICNAEoAjQAAgI0Lg4BJAI0ASgCNAACAjQuDgEmAjQBKAI0AAICNC4OASgCNAEoAjQAAgI0Lg4BKgI0ASgCNAACAjQuDgEsAjQBKAI0AAICNC4OAS4CNAEoAjQAAgI0Lg4BMAI0ASgCNAACAjQuDgEyAjQBKAI0AAICNC4OATQCNAEoAjQAAgI0Lg4BNgI0ASgCNAACAjQuDgE4AjQBKAI0AAICNC4OAToCNAEoAjQAAgI0Lg4BPAI0ASgCNAACAjQuDgE+AjQBKAI0AAICNC4OAUACNAEoAjQAAgI0Lg4BQgI0ASgCNAACAjQuDgFEAjQBKAI0AAICNC4OAUYCNAEoAjQAAgI0Lg4BSAI0ASgCNAACAjQuDgFKAjQBKAI0AAICNC4OAUwCNAEoAjQAAgI0Lg4BTgI0ASgCNAACAjQuDgFQAjQBKAI0AAICNC4OAVICNAEoAjQAAgI0Lg4BVAI0ASgCNAACAjQuDgFWAjQBKAI0AAICNC4OAVkCNAEoAjQAAgI0Lg4BWgI0ASgCNAACAjQuDgFcAjQBKAI0AAICNC4OAV4CNAEoAjQAAgI0Lg4BYAI0ASgCNAACAjQuDgFiAjQBKAI0AAICNC4OAWQCNAEoAjQAAgI0Lg4BZgI0ASgCNAACAjQuDgFoAjQBKAI0AAICNC4OAWoCNAEoAjQAAgI0Lg4BbAI0ASgCNAACAjQuDgFuAjQBKAI0AAICNC4OAXACNAEoAjQAAgI0Lg4BcgI0ASgCNAACAjQuDgF0AjQBKAI0AAICNC4OAXYCNAEoAjQAAgI0Lg4BeAI0ASgCNAACAjQuDgF6AjQBKAI0AAICNC4OAXwCNAEoAjQAAgI0Lg4BfgI0ASgCNAACAjQuDgGAAjQBKAI0AAICNC4OAYICNAEoAjQAAgI0Lg4BhAI0ASgCNAACAjQuDgGGAjQBKAI0AAICNC4OAYgCNAEoAjQAAgI0Lg4BigI0ASgCNAACAjQuDgGMAjQBKAI0AAICNC4OAY4CNAEoAjQAAgI0Lg4BkAI0ASgCNAACAjQuDgGSAjQBKAI0AAICNC4OAZQCNAEoAjQAAgI0Lg4BlgI0ASgCNAACAjQuDgGZAjQBKAI0AAICNC4OAZoCNAEoAjQAAgI0Lg4BnAI0ASgCNAACAjQuDgGeAjQBKAI0AAICNC4OAaECNAEoAjQAAgI0Lg4BogI0ASgCNAACAjQuDgGkAjQBKAI0AAICNC4OAaYCNAEoAjQAAgI0Lg4BqQI0ASgCNAACAjQuDgGqAjQBKAI0AAICNC4OAawCNAEoAjQAAgI0Lg4BrgI0ASgCNAACAjQuDgGwAjQBKAI0AAICNC4OAbICNAEoAjQAAgI0Lg4BtAI0ASgCNAACAjQuDgG2AjQBKAI0AAICNC4OAbgCNAEoAjQAAgI0Lg4BugI0ASgCNAACAjQuDgG8AjQBKAI0AAICNC4OAb4CNAEoAjQAAgI0Lg4BwAI0ASgCNAACAjQuDgHCAjQBKAI0AAICNC4OAcQCNAEoAjQAAgI0Lg4BxgI0ASgCNAACAjQuDgHIAjQBKAI0AAICNC4OAcoCNAEoAjQAAgI0Lg4BzAI0ASgCNAACAjQuDgHOAjQBKAI0AAICNC4OAdACNAEoAjQAAgI0Lg4B0gI0ASgCNAACAjQuDgHUAjQBKAI0AAICNC4OAdYCNAEoAjQAAgI0Lg4B2QI0ASgCNAACAjQuDgHaAjQBKAI0AAICNC4OAdwCNAEoAjQAAgI0Lg4B3gI0ASgCNAACAjQuDgHgAjQBKAI0AAICNC4OAeICNAEoAjQAAgI0Lg4B5AI0ASgCNAACAjQuDgHmAjQBKAI0AAICNC4OAekCNAEoAjQAAgI0Lg4B6gI0ASgCNAACAjQuDgHsAjQBKAI0AAICNC4OAe4CNAEoAjQAAgI0Lg4B8AI0ASgCNAACAjQuDgHzAjQBKAI0AAICNC4OAfQCNAEoAjQAAgI0Lg4B9gI0ASgCNAACAjQuDgH4AjQBKAI0AAICNC4OAfsCNAEoAjQAAgI0Lg4B/AI0ASgCNAACAjQuDgH+AjQBKAI0AAICNC4OAgACNAEoAjQAAgI0Lg4CAgI0ASgCNAACAjQuDgIEAjQBKAI0AAICNC4OAgYCNAEoAjQAAgI0Lg4CCAI0ASgCNAACAjQuDgIKAjQBKAI0AAICNC4OAgwCNAEoAjQAAgI0Lg4CDgI0ASgCNAACAjQuDgIQAjQBKAI0AAICNC4OAhICNAEoAjQAAgI0Lg4CFAI0ASgCNAACAjQuDgIWAjQBKAI0AAICNC4OAhgCNAEoAjQAAgI0Lg4CGgI0ASgCNAACAjQuDgIcAjQBKAI0AAICNC4OAh4CNAEoAjQAAgI0Lg4CIAI0ASgCNAACAjQuDgIiAjQBKAI0AAICNC4OAiQCNAEoAjQAAgI0Lg4CJgI0ASgCNAACAjQuDgIoAjQBKAI0AAICNC4OAioCNAEoAjQAAgI0Lg4CLAI0ASgCNAACAjQuDgIuAjQBKAI0AAICNC4OAjACNAEoAjQAAgI0Lg4CMwI0ASgCNAACAjQuDgI1AjQBKAI0AAICNC4OAjcCNAEoAjQAAgI0Lg4COAI0ASgCNAACAjQuDgI6AjQBKAI0AAICNC4OAjwCNAEoAjQAAgI0Lg4CPgI0ASgCNAACAjQuDgJAAjQBKAI0AAICNC4OAkICNAEoAjQAAgI0Lg4CRAI0ASgCNAACAjQuDgJGAjQBKAI0AAICNC4OAkgCNAEoAjQAAgI0Lg4CSgI0ASgCNAACAjQuDgJMAjQBKAI0AAICNC4OAk4CNAEoAjQAAgI0Lg4CUAI0ASgCNAACAjQuDgJSAjQBKAI0AAICNC4OAlQCNAEoAjQAAgI0Lg4CVgI0ASgCNAACAjQuDgJYAjQBKAI0AAICNC4OAloCNAEoAjQAAgI0Lg4CXAI0ASgCNAACAjQuDgJeAjQBKAI0AAICNC4OAmACNAEoAjQAAgI0Lg4CYgI0ASgCNAACAjQuDgJkAjQBKAI0AAICNC4OAmYCNAEoAjQAAgI0Lg4CaAI0ASgCNAACAjQuDgJqAjQBKAI0AAICNC4OAmwCNAEoAjQAAgI0Lg4CbgI0ASgCNAACAjQuDgJwAjQBKAI0AAICNC4OAnMCNAEoAjQAAgI0Lg4ACQI0JwIOBFItCABSLQwVUy0MBFQAEAAOACUAAOqVLQQAAC0MUwktDFQKLQxVCy0MVg0tDQkEACgEAgQtDgQJLQ0KBAAoBAIELQ4ECi0NCwQAKAQCBC0OBAstDQ0EACgEAgQtDgQNJwIOBFItCABSLQwJUy0MClQAEAAOACUAAOzYLQQAAC0MUwQnAgkEUi0IAFItDAxTLQwPVC0ME1UtDARWABAACQAlAADxYS0EAAAnAgkEUi0IAFItDAtTLQwNVAAQAAkAJQAA8p8tBAAALQxTBCcCCQRSLQgAUi0MDFMtDA9ULQwTVS0MBFYAEAAJACUAAPcoLQQAAAAoAgIKLQ0KCScCCwQCADgKCwQ7DQAEAAkjAACTECkCAAQATvD2nAo4AQQJLQ0CBAAoBAIELQ4EAicCBAAPJwIKABEpAgALALNAaPYpAgAMAL7FuwQkAgAJAACTVCMAAJs2LQgBDSgCAA4EAW4AEAEOAScDDQQBACgNAg4fJIBjgMcADi0NDQ4AKA4CDi0ODg0tCAEOAAABAgEtDg0OLQgBDQAAAQIBLgqAZAANJwIQBBEtCAARLQwOEi0MDRMtDAQUABAAEAAlAAD4Zi0EAAAtDBIPLQ0PEAAoEAIQLQ4QDycCEQQSLQgAEi0MDhMtDA0ULQwKFQAQABEAJQAA+b8tBAAALQwTEC0NEBEAKBECES0OERAnAhIEEy0IABMtDA4ULQwNFS0MBBYAEAASACUAAPhmLQQAAC0MFBEtDRENACgNAg0tDg0RLQgBDQAAAQIBLgqAlQANLQgBDgAAAQIBLgqAlgAOLQgBEgAAAQIBKAIAEwABQS0OExInAhMEFC0IABQtDA0VLQwOFi0MEhcAEAATACUAANESLQQAACcCFAQVLQgAFS0MDxYAEAAUACUAANUYLQQAAC0MFhMeAgAUAC0NAhUAKBUCFS0OFQInAhYEAScCGAQDADgWGBctCAEVABABFwEnAxUEAQAoFQIXLQ4WFwAoFwIXLQ4WFycCFwQDADgVFxYtDBYXLQ4TFy0NFRYAKBYCFi0OFhUnAhcEAicCGQQDADgXGRgtCAEWABABGAEnAxYEAQAoFgIYLQ4XGAAoGAIYLQ4XGCcCGAQDADgWGBctDBcYLQ4TGAAoGAIYLgqAlgAYLQ0WFwAoFwIXLQ4XFicCGAQZLQgAGS0MCxoAEAAYACUAAM54LQQAAC0MGhctDRYYACgYAhgtDhgWJwIaBBstCAAbLQwNHC0MDh0tDBIeLQwUHy0MFyAuCIBlACEtDBYiLgiAlQAjLgiAlgAkLgiAlQAlLgiAlgAmABAAGgAlAADpMy0EAAAtDBwYLQwdGS0NGRQAKBQCFC0OFBkLKAAYgGQAFCQCABQAAJYPJwIWBAA8CQEWJwIiBCMtCAAjLQwQJAAQACIAJQAA0cEtBAAALQwkFC0MJRYtDCYXLQwnGC0MKBktDCkaLQwqGy0MKxwtDCwdLQwtHi0MLh8tDC8gLQwwIS0NFCIAKCICIi0OIhQtDRYUACgUAhQtDhQWLQ0XFAAoFAIULQ4UFy0NGBQAKBQCFC0OFBgtDRkUACgUAhQtDhQZLQ0aFAAoFAIULQ4UGi0NGxQAKBQCFC0OFBstDR4UACgUAhQtDhQeLQ0hFAAoFAIULQ4UIQsoACCAYQAUJAIAFAAAluglAADaICcCFwQgLQgAIC0MECEtDAUiABAAFwAlAADV6i0EAAAtDCEUJwIZBCAtCAAgLQwPIS0MFCIAEAAZACUAANE3LQQAAC0MIRckAgAXAACXOyUAAPscHgIAFAYcDBQZBBwMGRcFHAwXFAQMOB8UFwsoABeAlQAUJAIAFAAAl2klAAD7LgsoAB2AYgAUJAIAFAAAl34lAAD7QCcCFwQdLQgAHS0MGB4AEAAXACUAANUYLQQAAC0MHhQeAgAXAScCGQQdLQgAHS0MFh4AEAAZACUAANUYLQQAAC0MHhgnAhkEHS0IAB0tDBoeABAAGQAlAADlNC0EAAAtDB4WJwIaBB0tCAAdLQwbHgAQABoAJQAA1RgtBAAALQweGScCJQQmLQgAJi0MFCctDBcoLQwYKS0MFiotDBkrABAAJQAlAADmLC0EAAAtDCcaLQwoGy0MKR0tDCoeLQwrHy0MLCAtDC0hLQwuIi0MLyMtDDAkJwIXBCUtCAAlLQwNJi0MDictDBIoLQwaKS0MGyotDB4rLQwfLC0MIS0tDCIuLQwjLy0MJDAAEAAXACUAAOkzLQQAAC0MJhQtDCcWLQ0WFwAoFwIXLQ4XFgsoABSAZAAWJAIAFgAAmMMnAhcEADwJARcnAhkEIS0IACEtDA0iLQwOIy0MEiQtDAYlLgiAqwAmLQwTJwAQABkAJQAA4nstBAAALQwiFC0MIxYtDCQXLQwlGCcCEwQhLQgAIS0MFCItDBYjLQwXJC0MGCUuCIBlACYAEAATACUAAOUjLQQAAB4CABMALQgBFAAAAQIBLQgBFgAAAQIBLQ0VFwAoFwIXLQ4XFS4KgGMAFC0OFRYnAhcEIS0IACEtDA8iLgiAwQAjABAAFwAlAAD7Ui0EAAAtDCIVLgiAZAAJIwAAmY8NKAAJgKYAFyQCABcAAMuNIwAAmaQnAhcEGC0IABgtDBEZLgiAwgAaABAAFwAlAAD7Ui0EAAAtDBkVLgiAZAAJIwAAmdQNKAAJgKYAFyQCABcAAMq5IwAAmeknAhUEFy0IABctDAwYABAAFQAlAADOeC0EAAAtDBgJLQ0UFS0NFhQtDRQWACgWAhYtDhYUJwIYBBktCAAZLQwNGi0MDhstDBIcLQwTHS0MCR4tDBUfLQwUIC4IgJUAIS4IgJYAIi4IgJUAIy4IgJYAJAAQABgAJQAA6TMtBAAALQwaFi0MGxctDRcJACgJAgktDgkXCygAFoBkAAkkAgAJAACalicCEwQAPAkBEy0NDwkAKAkCCS0OCQ8tDRAJACgJAgktDgkQLQ0RCQAoCQIJLQ4JEScCEwQULQgAFC0MDxUtDBAWLQwRFwAQABMAJQAA/cEtBAAALQwVCScCDwQTLQgAEy0MDRQtDA4VLQwSFi0MCRcAEAAPACUAAPFhLQQAAC0NAgkAKAkCCS0OCQIAKAICDi0NDg0nAg8EAgA4Dg8JOw0ACQANIwAAmzYpAgAJAHqHGNgKOAEJDScCCQADJAIADQAAm1YjAAChvS0IAQ0oAgAOBAFuABABDgEnAw0EAQAoDQIOHySAY4DHAA4tDQ0OACgOAg4tDg4NLQgBDgAAAQIBLQ4NDi0IAQ0AAAECAS4KgGQADScCEAQRLQgAES0MDhItDA0TLQwEFAAQABAAJQAA+GYtBAAALQwSDy0NDxAAKBACEC0OEA8nAhEEEi0IABItDA4TLQwNFC0MChUAEAARACUAAPm/LQQAAC0MExAtDRAKACgKAgotDgoQJwIRBBItCAASLQwOEy0MDRQtDAQVABAAEQAlAAD4Zi0EAAAtDBMKLQ0KDQAoDQINLQ4NCi0IAQ0AAAECAS4KgJUADS0IAQ4AAAECAS4KgJYADi0IAREAAAECASgCABIAAS8tDhIRJwISBBMtCAATLQwNFC0MDhUtDBEWABAAEgAlAADREi0EAAAnAhMEFC0IABQtDA8VABAAEwAlAADVGC0EAAAtDBUSHgIAEwAnAhUEAicCFwQDADgVFxYtCAEUABABFgEnAxQEAQAoFAIWLQ4VFgAoFgIWLQ4VFicCFgQDADgUFhUtDBUWLQ4SFgAoFgIWLgqAlgAWLQ0UFQAoFQIVLQ4VFCcCFgQXLQgAFy0MCxgAEAAWACUAAM54LQQAAC0MGBUtDRQWACgWAhYtDhYUJwIYBBktCAAZLQwNGi0MDhstDBEcLQwTHS0MFR4uCIBlAB8tDBQgLgiAlQAhLgiAlgAiLgiAlQAjLgiAlgAkABAAGAAlAADpMy0EAAAtDBoWLQwbFy0NFxMAKBMCEy0OExcLKAAWgGQAEyQCABMAAJ22JwIUBAA8CQEUJwIgBCEtCAAhLQwQIgAQACAAJQAA0cEtBAAALQwiEy0MIxQtDCQVLQwlFi0MJhctDCcYLQwoGS0MKRotDCobLQwrHC0MLB0tDC0eLQwuHy0NEyAAKCACIC0OIBMtDRQTACgTAhMtDhMULQ0VEwAoEwITLQ4TFS0NFhMAKBMCEy0OExYtDRcTACgTAhMtDhMXLQ0YEwAoEwITLQ4TGC0NGRMAKBMCEy0OExktDRwTACgTAhMtDhMcLQ0fEwAoEwITLQ4THwsoAB6AZgATJAIAEwAAno8lAAEDZycCFAQeLQgAHi0MEB8tDAUgABAAFAAlAADV6i0EAAAtDB8TJwIUBB4tCAAeLQwPHy0MEyAAEAAUACUAANE3LQQAAC0MHwUkAgAFAACe4iUAAPscHgIABQYcDAUUBBwMFBMFHAwTBQQMOB0FEwsoABOAlQAFJAIABQAAnxAlAAD7LgsoABuAYgAFJAIABQAAnyUlAAEDeScCEwQbLQgAGy0MFhwAEAATACUAANUYLQQAAC0MHAUeAgATAR4CABQAJwIWBBstCAAbLQwYHAAQABYAJQAA5TQtBAAALQwcFScCIQQiLQgAIi0MBSMtDBMkLQwUJS0MFSYuCICWACcAEAAhACUAAOYsLQQAAC0MIxYtDCQXLQwlGC0MJhktDCcbLQwoHC0MKR0tDCoeLQwrHy0MLCAnAhQEIS0IACEtDA0iLQwOIy0MESQtDBYlLQwXJi0MGSctDBsoLQwdKS0MHiotDB8rLQwgLAAQABQAJQAA6TMtBAAALQwiBS0MIxMtDRMUACgUAhQtDhQTCygABYBkABMkAgATAACgMycCFAQAPAkBFCcCFgQdLQgAHS0MDR4tDA4fLQwRIC0MCSEuCICpACItDBIjABAAFgAlAAEDiy0EAAAtDB4FLQwfEy0MIBQtDCEVJwIXBB0tCAAdLQwQHi0MCh8AEAAXACUAAQYzLQQAAC0MHhYnAhkEHS0IAB0tDBYeABAAGQAlAAEHjC0EAAAtDB4XMAwAFwAVJwIbBB0tCAAdLQwNHi0MDh8tDBEgLQwGIS4IgKsAIi0MEiMAEAAbACUAAOJ7LQQAAC0MHhUtDB8WLQwgFy0MIRknAhIEHS0IAB0tDBUeLQwWHy0MFyAtDBkhLgiAZwAiABAAEgAlAADlIy0EAAAtDQ8SACgSAhItDhIPLQ0QEgAoEgISLQ4SEC0NChIAKBICEi0OEgonAhUEHS0IAB0tDA8eLQwQHy0MCiAAEAAVACUAAP3BLQQAAC0MHhInAgoEHS0IAB0tDA0eLQwOHy0MESAtDBIhABAACgAlAADxYS0EAAAAKAICDi0NDg0nAg8EAgA4Dg8KOw0ACgANIwAAob0pAgAFALaPNzgKOAEFCiQCAAoAAKHYIwAAo7MtCAEFJwIKBCEAEAEKAScDBQQBACgFAgofJIBjgKYACi0NBQoAKAoCCi0OCgUtCAEKAAABAgEtDgUKLQgBBQAAAQIBLgqAZAAFJwIOBA8tCAAPLQwKEC0MBREtDAQSABAADgAlAAEH4y0EAAAtDBANLQ0NBQAoBQIFLQ4FDS0IAQUAAAECAS4KgJUABS0IAQoAAAECAS4KgJYACi0IAQ4AAAECASgCAA8AAS0tDg8OJwIPBBAtCAAQLQwFES0MChItDA4TABAADwAlAADREi0EAAAeAgAPCQsoAA+AmAAQJAIAEAAAosQlAAEJPCcCEAQRLQgAES0MDRIAEAAQACUAANUYLQQAAC0MEg8nAhMEFC0IABQtDAUVLQwKFi0MDhctDAYYLgiAqwAZLQwPGgAQABMAJQAA4nstBAAALQwVDS0MFhAtDBcRLQwYEicCCgQTLQgAEy0MDRQtDBAVLQwRFi0MEhcAEAAKACUAAQlOLQQAAC0MFAUcDAUKACcCDQQBJwIPBAMAOA0PDi0IAQUAEAEOAScDBQQBACgFAg4tDg0OACgOAg4tDg0OJwIOBAMAOAUODS0MDQ4tDgoOACgFAg4tDQ4NJwIPBAIAOA4PCjsNAAoADSMAAKOzKQIABQBj8aPrCjgBBQonAgUAByQCAAoAAKPTIwAApYQtCAEKJwINBCEAEAENAScDCgQBACgKAg0fJIBjgKYADS0NCg0AKA0CDS0ODQotCAENAAABAgEtDgoNLQgBCgAAAQIBLgqAZAAKJwIPBBAtCAAQLQwNES0MChItDAQTABAADwAlAAEH4y0EAAAtDBEOLQ0OCgAoCgIKLQ4KDi0IAQoAAAECAS4KgJUACi0IAQ0AAAECAS4KgJYADS0IAQ8AAAECASgCABAAASQtDhAPJwIQBBEtCAARLQwKEi0MDRMtDA8UABAAEAAlAADREi0EAAAeAgAQCQsoABCAmAARJAIAEQAApL8lAAEJbScCEQQSLQgAEi0MDhMAEAARACUAANUYLQQAAC0MExAnAhQEFS0IABUtDAoWLQwNFy0MDxgtDAUZLgiArQAaLQwQGwAQABQAJQABA4stBAAALQwWDi0MFxEtDBgSLQwZEy8MABMACicCDwQBJwITBAMAOA8TEC0IAQ0AEAEQAScDDQQBACgNAhAtDg8QACgQAhAtDg8QJwIQBAMAOA0QDy0MDxAtDgoQACgNAhAtDRAPJwITBAIAOBATCjsNAAoADyMAAKWEKQIACgBBTcD9CjgBCg0kAgANAAClnyMAAKxELQgBDSgCAA4EAW8AEAEOAScDDQQBACgNAg4fJIBjgMgADi0NDQ4AKA4CDi0ODg0tCAEOAAABAgEtDg0OLQgBDQAAAQIBLgqAZAANJwIQBBEtCAARLQwOEi0MDRMtDAQUABAAEAAlAAEJfy0EAAAtDBIPLQ0PEAAoEAIQLQ4QDy0IARAoAgARBAEuABABEQEnAxAEAQAoEAIRKAIAEgQBLQA4EhESLQwREww4ExIUFgwUFCQCABQAAKZpLgqAlgATACgTAhMjAACmSC0IAREAAAECAS0OEBEuCIBkAAojAACmgQ0oAAqAhAAQJAIAEAAAyjgjAACmli0NDhAtDQ0SASgAEoCEABMOOBITFCQCABQAAKa4JQAA0QAtDhAOLQ4TDS0NERAnAhIEEy0IABMtDBAUABAAEgAlAAEK2C0EAAAtDBQRLQ0REAAoEAIQLQ4QEScCEgQTLQgAEy0MDhQtDA0VLQwEFgAQABIAJQABCX8tBAAALQwUEC0NEBIAKBICEi0OEhAtDQ4SLQ0NEw0oABOAyAAUJAIAFAAAp0ElAAEMOAEoABOAYwAUDjgTFBUkAgAVAACnWyUAANEALQ4SDi0OFA0tCAENAAABAgEuCoCVAA0tCAEOAAABAgEuCoCWAA4tCAESAAABAgEnAhMA/S0OExInAhMEFC0IABQtDA0VLQwOFi0MEhcAEAATACUAANESLQQAACcCFAQVLQgAFS0MDxYAEAAUACUAANUYLQQAAC0MFhMnAhgEGS0IABktDA0aLQwOGy0MEhwtDAYdLgiAqwAeLQwTHwAQABgAJQAA4nstBAAALQwaFC0MGxUtDBwWLQwdFycCGQQaLQgAGi0MFBstDBUcLQwWHS0MFx4AEAAZACUAAQlOLQQAAC0MGxgLKAAYgGMAFCQCABQAAKhWJQABDEonAhUEFi0IABYtDBEXABAAFQAlAADf1y0EAAAtDBcULQ0UFQAoFQIVLQ4VFCcCGQQaLQgAGi0MDRstDA4cLQwSHS4IgJoAHi4IgKoAHy0MEyAAEAAZACUAAN0vLQQAAC0MGxUtDBwWLQwdFy0MHhgnAhoEGy0IABstDBUcLQwWHS0MFx4tDBgfABAAGgAlAAEMXC0EAAAtDBwZJwIWBBotCAAaLQwZGy0MFBwAEAAWACUAANE3LQQAAC0MGxUkAgAVAACpICUAAQ3KJwIhBCItCAAiLQwRIwAQACEAJQAA0cEtBAAALQwjFC0MJBUtDCUWLQwmFy0MJxgtDCgZLQwpGi0MKhstDCscLQwsHS0MLR4tDC4fLQwvIC0NFBEAKBECES0OERQtDRURACgRAhEtDhEVLQ0WEQAoEQIRLQ4RFi0NFxEAKBECES0OERctDRgRACgRAhEtDhEYLQ0ZEQAoEQIRLQ4RGS0NGhEAKBECES0OERotDR0RACgRAhEtDhEdLQ0gEQAoEQIRLQ4RIAsoAB+AYQARJAIAEQAAqfklAADaIC0IAREnAhQEYQAQARQBJwMRBAEAKBECFCcCFQRgADgVFBUtDBQXDDgXFRkWDBkZJAIAGQAAqkAuCoBhABcAKBcCFyMAAKofLQgBFAAAAQIBLQ4RFC4IgGQACiMAAKpYDSgACoCmABEkAgARAADJRiMAAKptLQ0UCicCEQQZLQgAGS0MChoAEAARACUAAQ3cLQQAAC0MGg8nAhEEGS0IABktDBYaABAAEQAlAADVGC0EAAAtDBoKHgIAEQAnAhUEGS0IABktDBAaABAAFQAlAADVGC0EAAAtDBoUJwIVBBktCAAZLQwYGgAQABUAJQAA5TQtBAAALQwaECcCHwQgLQgAIC0MCiEtDBEiLQwUIy0MECQuCICWACUAEAAfACUAAOYsLQQAAC0MIRUtDCIWLQwjFy0MJBgtDCUZLQwmGi0MJxstDCgcLQwpHS0MKh4nAhEEHy0IAB8tDA0gLQwOIS0MEiItDBUjLQwWJC0MGCUtDBkmLQwbJy0MHCgtDB0pLQweKgAQABEAJQAA6TMtBAAALQwgCi0MIRAtDRARACgRAhEtDhEQCygACoBkABAkAgAQAACruCcCEQQAPAkBEScCFQQbLQgAGy0MDRwtDA4dLQwSHi0MBh8uCICrACAtDBMhABAAFQAlAADiey0EAAAtDBwKLQwdEC0MHhEtDB8UJwINBBstCAAbLQwKHC0MEB0tDBEeLQwUHy4IgIIAIAAQAA0AJQAA5SMtBAAAACgCAg4tDQ4NJwIQBAIAOA4QCjsNAAoADSMAAKxEKQIACgD1peh5CjgBCg0kAgANAACsXyMAALJALQgBDSgCAA4EATAAEAEOAScDDQQBACgNAg4fJIBjgMAADi0NDQ4AKA4CDi0ODg0tCAEOAAABAgEtDg0OLQgBDQAAAQIBLgqAZAANJwIQBBEtCAARLQwOEi0MDRMuCICnABQAEAAQACUAARAmLQQAAC0MEg8tCAEQKAIAEQQBLgAQAREBJwMQBAEAKBACESgCABIEAS0AOBIREi0MERMMOBMSFBYMFBQkAgAUAACtHi4KgJYAEwAoEwITIwAArP0tCAERAAABAgEtDhARLgiAZAAKIwAArTYNKAAKgIQAECQCABAAAMjFIwAArUstDQ4QLQ0NEgEoABKAhAATDjgSExQkAgAUAACtbSUAANEALQ4QDi0OEw0tDREQJwISBBMtCAATLQwQFAAQABIAJQABCtgtBAAALQwUES0NERAAKBACEC0OEBEnAhIEEy0IABMtDA4ULQwNFS4IgKcAFgAQABIAJQABECYtBAAALQwUEC0IAQ0AAAECAS4KgJUADS0IAQ4AAAECAS4KgJYADi0IARIAAAECAScCEwDmLQ4TEicCEwQULQgAFC0MDRUtDA4WLQwSFwAQABMAJQAA0RItBAAAHgIAEwEeAgAUAAo4ExQVJAIAFQAArj0lAAEQ/B4CABMBLQgBFCcCFQQDABABFQEnAxQEAQAoFAIVLQwVFi0OCBYAKBYCFi0OExYnAhgEGS0IABkuCIDKABoAEAAYACUAAM6NLQQAAC0MGhMtDBsVLQwcFi0MHRctDRMYACgYAhgtDhgTLQ0VGAAoGAIYLQ4YFS0IARgAAAECAS0OExgtCAETAAABAgEtDhUTLQgBFQAAAQIBLQ4WFS0IARYAAAECAS0OFxYuCIBkAAojAACu8Q0oAAqAZQAXJAIAFwAAyGkjAACvBicCFwQZLQgAGS0MGBotDBMbLQwVHC0MFh0AEAAXACUAANBWLQQAAC0MGhQLKAAUgJYAEwsoABOAlQAVJAIAFQAAr04lAADaRCcCGAQZLQgAGS0MDRotDA4bLQwSHC0MFB0uCICwAB4tDBAfABAAGAAlAADaVi0EAAAtDBoTLQwbFS0MHBYtDB0XJwIYBBktCAAZLQwTGi0MFRstDBYcLQwXHQAQABgAJQAA3P4tBAAALQwaFAsoABSAlQATJAIAEwAAr88lAADdHScCFwQYLQgAGC0MDRktDA4aLQwSGy4IgJoAHC4IgKoAHS0MDx4AEAAXACUAAN0vLQQAAC0MGRMtDBoULQwbFS0MHBYnAhgEGS0IABktDBEaABAAGAAlAADf1y0EAAAtDBoXJwIRBBgtCAAYLQwTGS0MFBotDBUbLQwWHC0MFx0AEAARACUAAOFcLQQAACcCFgQXLQgAFy0MDRgtDA4ZLQwSGi0MBhsuCICrABwtDA8dABAAFgAlAADiey0EAAAtDBgRLQwZEy0MGhQtDBsVJwIPBBYtCAAWLQwRFy0MExgtDBQZLQwVGi4IgGMAGwAQAA8AJQAA5SMtBAAAHgIADwEtCAERJwITBAMAEAETAScDEQQBACgRAhMtDBMULQ4IFAAoFAIULQ4PFCcCFQQWLQgAFi4IgMoAFwAQABUAJQAAzo0tBAAALQwXCC0MGA8tDBkTLQwaFC0NCBUAKBUCFS0OFQgtDQ8VACgVAhUtDhUPLQgBFQAAAQIBLQ4IFS0IAQgAAAECAS0ODwgtCAEPAAABAgEtDhMPLQgBEwAAAQIBLQ4UEy4IgGQACiMAALF+DSgACoBlABQkAgAUAADIDSMAALGTJwIRBBYtCAAWLQwVFy0MCBgtDA8ZLQwTGgAQABEAJQAA0FYtBAAALQwXCgsoAAqAlgAICygACICVAA8kAgAPAACx2yUAANpEJwIUBBUtCAAVLQwNFi0MDhctDBIYLQwKGS4IgLAAGi0MEBsAEAAUACUAANpWLQQAAC0MFggtDBcPLQwYES0MGRMwCICYABMAKAICDi0NDg0nAhAEAgA4DhAKOw0ACgANIwAAskAKOAELCCQCAAgAALJSIwAAtA0tCAEIJwIKBAMAEAEKAScDCAQBACgIAgofJIBjgGUACi0NCAoAKAoCCi0OCggtCAEKAAABAgEtDggKLQgBCAAAAQIBLgqAZAAIJwINBA4tCAAOLQwKDy0MCBAuCICnABEAEAANACUAAREOLQQAAC0MDwsnAg4EDy0IAA8tDAoQLQwIEQAQAA4AJQABEaYtBAAALQwQDQEoAA2AYwAKLQ0KCBwMCA0EHAwNCgAcDAoIBC0IAQoAAAECAS4KgJUACi0IAQ0AAAECAS4KgJYADS0IAQ4AAAECAScCDwDhLQ4PDicCDwQQLQgAEC0MChEtDA0SLQwOEwAQAA8AJQAA0RItBAAAHgIADwEeAgAQAAo4DxARJAIAEQAAs3ElAAESHScCEwQULQgAFC0MChUtDA0WLQwOFy0MBhguCICrABktDAsaABAAEwAlAADiey0EAAAtDBUPLQwWEC0MFxEtDBgSJwILBBMtCAATLQwPFC0MEBUtDBEWLQwSFwAQAAsAJQABCU4tBAAALQwUCgo4CggLJAIACwAAs+8lAAEMSgAoAgILLQ0LCicCDQQCADgLDQg7DQAIAAojAAC0DSkCAAgAwF4ltQo4AQgKJAIACgAAtCgjAAC2qC0IAQooAgALBAEvABABCwEnAwoEAQAoCgILHzSAYwAHAAstDQoLACgLAgstDgsKLQgBCwAAAQIBLQgBDQAAAQIBASgACoBjAA8tDQ8OLQ4KCy4KgGMADS0IAQooAgAPBAEuABABDwEnAwoEAQAoCgIPKAIAEAQBLQA4EA8QLQwPEQw4ERASFgwSEiQCABIAALTKLgqAlgARACgRAhEjAAC0qS0IAQ8AAAECAS0OCg8uCIBkAAgjAAC04g0oAAiAhAAKJAIACgAAx48jAAC09y0NCwctDQ0IASgACICEAAoOOAgKECQCABAAALUZJQAA0QAtDgcLLQ4KDS0NDwcnAgoEDy0IAA8tDAcQABAACgAlAAEK2C0EAAAtDBAILQ0IBwAoBwIHLQ4HCC0IAQcAAAECAS4KgJUABy0IAQoAAAECAS4KgJYACi0IAQsAAAECAScCDQDLLQ4NCycCDQQPLQgADy0MBxAtDAoRLQwLEgAQAA0AJQAA0RItBAAAHgIADQEeAgAPAAo4DQ8QJAIAEAAAtcAlAAESLycCDwQQLQgAEC0MCBEAEAAPACUAAN/XLQQAAC0MEQ0tDQ0IACgIAggtDggNJwISBBMtCAATLQwHFC0MChUtDAsWLgiAmgAXLgiAqgAYLQwOGQAQABIAJQAA3S8tBAAALQwUCC0MFQ8tDBYQLQwXEScCCgQSLQgAEi0MCBMtDA8ULQwQFS0MERYAEAAKACUAAQxcLQQAAC0MEwcnAgoEDi0IAA4tDAcPLQwNEAAQAAoAJQAA0TctBAAALQwPCCQCAAgAALaKJQABDcoAKAICCi0NCggnAgsEAgA4CgsHOw0ABwAIIwAAtqgpAgAHAJ06HqUKOAEHCCQCAAgAALbDIwAAueItCAEIKAIACgQBTwAQAQoBJwMIBAEAKAgCCh80gGMAAwAKLQ0ICgAoCgIKLQ4KCC0IAQoAAAECAS0IAQsAAAECAQEoAAiAYwAOLQ0ODS0OCAouCoBjAAstCAEIKAIADgQBLgAQAQ4BJwMIBAEAKAgCDigCAA8EAS0AOA8ODy0MDhAMOBAPERYMEREkAgARAAC3ZS4KgJYAEAAoEAIQIwAAt0QtCAEOAAABAgEtDggOLgiAZAAHIwAAt30NKAAHgIQACCQCAAgAAMcRIwAAt5ItDQoILQ0LDwEoAA+AhAAQDjgPEBEkAgARAAC3tCUAANEALQ4ICi0OEAstDQ4IJwIPBBAtCAAQLQwIEQAQAA8AJQABCtgtBAAALQwRDi0NDggAKAgCCC0OCA4tCAEIJwIPBCEAEAEPAScDCAQBACgIAg8nAhAEIAA4EA8QLQwPEQw4ERASFgwSEiQCABIAALgzLgqAlgARACgRAhEjAAC4Ei0IAQ8AAAECAS0OCA8uCIBkAAcjAAC4Sw0oAAeApgAIJAIACAAAxpMjAAC4YC0NCgMtDQsHASgAB4CmAAgOOAcIECQCABAAALiCJQAA0QAtDgMKLQ4ICy0NDwMnAggEDy0IAA8tDAMQABAACAAlAAESQS0EAAAtDBAHLQ0HAwAoAwIDLQ4DBy0IAQMAAAECAS4KgJUAAy0IAQgAAAECAS4KgJYACC0IAQoAAAECAScCCwC4LQ4LCicCCwQPLQgADy0MAxAtDAgRLQwKEgAQAAsAJQAA0RItBAAAHgIACwEeAgAPAAo4Cw8QJAIAEAAAuSklAAES6CcCEgQTLQgAEy0MAxQtDAgVLQwKFi0MCRcuCICpABgtDA0ZABAAEgAlAAEDiy0EAAAtDBQLLQwVDy0MFhAtDBcRLwwAEQADJwIJBBEtCAARLQwOEi0MBxMAEAAJACUAAQYzLQQAAC0MEggnAgkEES0IABEtDAgSABAACQAlAAEHjC0EAAAtDBIHCjgDBwgkAgAIAAC5xCUAAQ3KACgCAggtDQgHJwIJBAIAOAgJAzsNAAMAByMAALniKQIAAwCY1W0oCjgBAwckAgAHAAC5/SMAAL4TKAIABwQChS0IAQgoAgAJBAKGABABCQEnAwgEAQAoCAIJHzSAYwAHAAktDQgJACgJAgktDgkILQgBCQAAAQIBLQ4ICS0IAQgAAAECAS4KgGQACC0IAQonAgsEIQAQAQsBJwMKBAEAKAoCCycCDQQgADgNCw0tDAsODDgODQ8WDA8PJAIADwAAupYuCoCWAA4AKA4CDiMAALp1LQgBCwAAAQIBLQ4KCy4IgGQAAyMAALquDSgAA4CmAAokAgAKAADGFSMAALrDLQ0JCi0NCA0BKAANgKYADg44DQ4PJAIADwAAuuUlAADRAC0OCgktDg4ILQ0LCicCDQQOLQgADi0MCg8AEAANACUAARJBLQQAAC0MDwstDQsKACgKAgotDgoLLQgBCigCAA0EAmYAEAENAScDCgQBACgKAg0oAgAOBAJlADgODQ4tDA0PDDgPDhAWDBAQJAIAEAAAu2guCoCWAA8AKA8CDyMAALtHLQgBDQAAAQIBLQ4KDS4IgGQAAyMAALuADSgAA4DJAAokAgAKAADFlyMAALuVLQ0JBy0NCAoBKAAKgMkADg44Cg4PJAIADwAAu7clAADRAC0OBwktDg4ILQ0NBy0NBwgAKAgCCC0OCActCAEIAAABAgEtDgcILQgBBwAAAQIBLgqAZAAHLQgBCSgCAAoEAmYAEAEKAScDCQQBACgJAgooAgANBAJlADgNCg0tDAoODDgODQ8WDA8PJAIADwAAvDcuCoCWAA4AKA4CDiMAALwWLQgBCgAAAQIBLQ4JCi0NCQ0AKA0CDS0ODQkuCIBkAAMjAAC8XA0oAAOAyQANJAIADQAAxQsjAAC8cS0NCgMtDQkHAigHAgctDgcJLQ0DBwAoBwIHLQ4HAy0IAQcAAAECAS4KgJUABy0IAQgAAAECAS4KgJYACC0IAQkAAAECAScCCgChLQ4KCScCCgQNLQgADS0MBw4tDAgPLQwJEAAQAAoAJQAA0RItBAAAHgIACgEeAgANAAo4Cg0OJAIADgAAvP4lAAES+icCEAQRLQgAES0MCxItDAMTABAAEAAlAADqlS0EAAAtDBIKLQwTDS0MFA4tDBUPLQ0KAwAoAwIDLQ4DCi0NDQMAKAMCAy0OAw0tDQ4DACgDAgMtDgMOLQ0PAwAoAwIDLQ4DDycCCwQQLQgAEC0MChEtDA0SABAACwAlAADs2C0EAAAtDBEDJwIKBBAtCAAQLQwHES0MCBItDAkTLQwDFAAQAAoAJQAA8WEtBAAAJwIKBBAtCAAQLQwOES0MDxIAEAAKACUAAPKfLQQAAC0MEQMnAgoEDS0IAA0tDAcOLQwIDy0MCRAtDAMRABAACgAlAAD3KC0EAAAAKAICCC0NCAcnAgkEAgA4CAkDOw0AAwAHIwAAvhMKOAEMAyQCAAMAAL4lIwAAwJAtCAEHJwIIBEIAEAEIAScDBwQBACgHAggfJIBjgKgACC0NBwgAKAgCCC0OCActCAEIAAABAgEtCAEJAAABAgEBKAAHgGMACy0NCwotDgcILgqAYwAJJwILBAwtCAAMLQwIDS0MCQ4tDAQPABAACwAlAAETDC0EAAAtDA0HJwIMBA0tCAANLQwIDi0MCQ8tDAQQABAADAAlAAETDC0EAAAtDA4LLQgBBAAAAQIBLgqAlQAELQgBCAAAAQIBLgqAlgAILQgBCQAAAQIBJwIMAHctDgwJJwIMBA0tCAANLQwEDi0MCA8tDAkQABAADAAlAADREi0EAAAeAgAMAR4CAA0ACjgMDQ4kAgAOAAC/NyUAARRlJwIQBBEtCAARLQwEEi0MCBMtDAkULQwFFS4IgK0AFi0MChcAEAAQACUAAQOLLQQAAC0MEgwtDBMNLQwUDi0MFQ8eAgAEBTAMAAQADy0IAQQnAgUEYQAQAQUBJwMEBAEAKAQCBScCCARgADgIBQgtDAUJDDgJCAoWDAoKJAIACgAAv8ouCoBhAAkAKAkCCSMAAL+pLQgBBQAAAQIBLQ4EBS4IgGQAAyMAAL/iDSgAA4CmAAQkAgAEAADEGSMAAL/3LwiAmAADLQgBBCcCBwQCABABBwEnAwQEAQAoBAIHLQwHCC0OAwgtDQQDACgDAgMtDgMEJwIHBAgtCAAILQwECQAQAAcAJQAAziYtBAAALQwJAy0NBQQnAgcECC0IAAgtDAQJABAABwAlAAEN3C0EAAAtDAkFOAwAAwAFACgCAgUtDQUEJwIHBAIAOAUHAzsNAAMABCMAAMCQKQIAAwCRG0bnCjgBAwQkAgAEAADAqyMAAMJULQgBAycCBAQDABABBAEnAwMEAQAoAwIEHySAY4BlAAQtDQMEACgEAgQtDgQDLQgBBAAAAQIBLQ4DBC0IAQMAAAECAS4KgGQAAycCBwQILQgACC0MBAktDAMKLgiApwALABAABwAlAAERDi0EAAAtDAkFJwIIBAktCAAJLQwECi0MAwsAEAAIACUAARGmLQQAAC0MCgcBKAAHgGMABC0NBAMcDAMHBBwMBwQAHAwEAwQtCAEEAAABAgEuCoCVAAQtCAEHAAABAgEuCoCWAActCAEIAAABAgEnAgkARC0OCQgnAgkECi0IAAotDAQLLQwHDC0MCA0AEAAJACUAANESLQQAAB4CAAkBHgIACgAKOAkKCyQCAAsAAMHKJQABFHcnAg0EDi0IAA4tDAQPLQwHEC0MCBEtDAYSLgiAqwATLQwFFAAQAA0AJQAA4nstBAAALQwPCS0MEAotDBELLQwSDCcCBAQNLQgADS0MCQ4tDAoPLQwLEC0MDBEtDAMSABAABAAlAADlIy0EAAAAKAICBS0NBQQnAgYEAgA4BQYDOw0AAwAEIwAAwlQnAgICbycCAwJrJwIEAncnAgUCey0IAQYnAgcEHAAQAQcBJwMGBAEAKAYCBy0MBwguCoBVAAgAKAgCCC4KgG0ACAAoCAIILQ4DCAAoCAIILgqAbQAIACgIAggtDgIIACgIAggtDgQIACgIAgguCoBtAAgAKAgCCC4KgKUACAAoCAIILgqARwAIACgIAgguCoCvAAgAKAgCCC4KgLEACAAoCAIILgqArwAIACgIAgguCoCuAAgAKAgCCC4KgLMACAAoCAIILQ4CCAAoCAIILgqAsgAIACgIAgguCoClAAgAKAgCCC0OBQgAKAgCCC4KgEcACAAoCAIILgqArwAIACgIAgguCoCxAAgAKAgCCC4KgK8ACAAoCAIILgqArgAIACgIAgguCoCzAAgAKAgCCC0OAggAKAgCCC4KgLIACAAoCAIILgqAUAAICyCAlYCXAAIkAgACAADEGCcCAwQeLQgBBCcCBQQeABABBQEtDAQFKgMABQUnRkiy9UEXvQAoBQIFACgGAgcnAggEGy4EAAeAAy4EAAWABC4EAAiABSUAARSJJwIHBBsAOAUHBS4KgGMABQAoBQIFLQ4BBQAoBQIFPA0EAyYtDQUEASCAgQACAAkAOAkDCi0NCgguBAAEgAMoAIAEBABhJQABFM8uCIAFAAkAKAkCCgA4CgMMLQ4IDAEoAAOAYwAEASgAA4CmAAgAKAcCDAA4DAMNLQ0NCg0oAAiArAAMJAIADAAAxIclAAEMOC4EAAmAAygAgAQEAGElAAEUzy4IgAUADAAoDAINADgNCA4tDgoOASgAA4CPAAgAKAsCCgA4CgMNLQ0NCQ0oAAiArAAKJAIACgAAxNglAAEMOC4EAAyAAygAgAQEAGElAAEUzy4IgAUACgAoCgINADgNCA4tDgkOLQ4KBS0MBAMjAAC/4i0NCg0tDQgOLQ0HDw0oAA+AyQAQJAIAEAAAxSwlAAEMOAAoDgIRADgRDxItDRIQASgAD4BjABEOOA8REiQCABIAAMVUJQAA0QAtDg4ILQ4RBy4EAA2AAygAgAQEAmYlAAEUzy4IgAUADgAoDgIPADgPAxEtDhARLQ4OCgEoAAOAYwANLQwNAyMAALxcLQ0NCi0NCQ4tDQgPADgPAxAOOA8QESQCABEAAMW6JQAA0QAMOBAHDyQCAA8AAMXMJQABDDgAKA4CEQA4ERASLQ0SDy4EAAqAAygAgAQEAmYlAAEUzy4IgAUADgAoDgIQADgQAxEtDg8RLQ4ODQEoAAOAYwAKLQwKAyMAALuALQ0LCi0NCQ0tDQgOADgOAw8OOA4PECQCABAAAMY4JQAA0QAMOA8HDiQCAA4AAMZKJQABDDgAKA0CEAA4EA8RLQ0RDi4EAAqAAygAgAQEACElAAEUzy4IgAUADQAoDQIPADgPAxAtDg4QLQ4NCwEoAAOAYwAKLQwKAyMAALquLQ0PCC0NChAtDQsRADgRBxIOOBESEyQCABMAAMa2JQAA0QAMOBIDESQCABEAAMbIJQABDDgAKBACEwA4ExIULQ0UES4EAAiAAygAgAQEACElAAEUzy4IgAUAEAAoEAISADgSBxMtDhETLQ4QDwEoAAeAYwAILQwIByMAALhLLQ0OCC0NCg8tDQsQADgQBxEOOBAREiQCABIAAMc0JQAA0QAMOBEDECQCABAAAMdGJQABDDgAKA8CEgA4EhETLQ0TEC4EAAiAAygAgAQEAS4lAAEUzy4IgAUADwAoDwIRADgRBxItDhASLQ4PDgEoAAeAYwAILQwIByMAALd9LQ0PCi0NCxAtDQ0RADgRCBIOOBESEyQCABMAAMeyJQAA0QAMOBIHESQCABEAAMfEJQABDDgAKBACEwA4ExIULQ0UES4EAAqAAygAgAQEAS4lAAEUzy4IgAUAEAAoEAISADgSCBMtDhETLQ4QDwEoAAiAYwAKLQwKCCMAALTiJAIAFAAAyBojAADIWAAoEQIWADgWChctDRcUJwIWBBctCAAXLQwVGC0MCBktDA8aLQwTGy0MFBwAEAAWACUAAM8tLQQAACMAAMhYASgACoBjABQtDBQKIwAAsX4kAgAXAADIdiMAAMi0ACgUAhkAOBkKGi0NGhcnAhkEGi0IABotDBgbLQwTHC0MFR0tDBYeLQwXHwAQABkAJQAAzy0tBAAAIwAAyLQBKAAKgGMAFy0MFwojAACu8S0NERAtDQ4SLQ0NEwA4EwoUDjgTFBUkAgAVAADI6CUAANEADSgAFIDAABMkAgATAADI/SUAAQw4ACgSAhUAOBUUFi0NFhMuBAAQgAMoAIAEBAEuJQABFM8uCIAFABIAKBICFAA4FAoVLQ4TFS0OEhEBKAAKgGMAEC0MEAojAACtNi0NFBEBIICBAAIAFwA4FwoZLQ0ZFS4EABGAAygAgAQEAGElAAEUzy4IgAUAFwAoFwIZADgZChotDhUaASgACoBjABEBKAAKgKYAFQAoDwIaADgaChstDRsZDSgAFYCsABokAgAaAADJtCUAAQw4LgQAF4ADKACABAQAYSUAARTPLgiABQAaACgaAhsAOBsVHC0OGRwBKAAKgI8AFQAoEAIZADgZChstDRsXDSgAFYCsABkkAgAZAADKBSUAAQw4LgQAGoADKACABAQAYSUAARTPLgiABQAZACgZAhsAOBsVHC0OFxwtDhkULQwRCiMAAKpYLQ0REC0NDhItDQ0TADgTChQOOBMUFSQCABUAAMpbJQAA0QANKAAUgMgAEyQCABMAAMpwJQABDDgAKBICFQA4FRQWLQ0WEy4EABCAAygAgAQEAS4lAAEUzy4IgAUAEgAoEgIUADgUChUtDhMVLQ4SEQEoAAqAYwAQLQwQCiMAAKaBLQ0UFy0NFhgAKBUCGgA4GgkbLQ0bGS0NGRoAKBoCGi0OGhknAhwEAQYoHAIaJwIeBAMAOBweHS0IARsAEAEdAScDGwQBACgbAh0tDhwdACgdAh0tDhwdJwIeBAMAOBseHQAoGQIeLgQAHoADLgQAHYAELgQAHIAFJQABFIknAh0EHi0IAB4tDBcfLQwYIC4IgGMAIS0MGyIAEAAdACUAARVdLQQAAC0MHxktDCAcLQ0cFwAoFwIXLQ4XHC0OGRQtDhwWASgACYBjABctDBcJIwAAmdQtDRQXLQ0WGAAoFQIaADgaCRstDRsZLQ0ZGgAoGgIaLQ4aGScCHAQBBigcAhonAh4EAwA4HB4dLQgBGwAQAR0BJwMbBAEAKBsCHS0OHB0AKB0CHS0OHB0nAh4EAwA4Gx4dACgZAh4uBAAegAMuBAAdgAQuBAAcgAUlAAEUiScCHQQeLQgAHi0MFx8tDBggLgiAYwAhLQwbIgAQAB0AJQABFV0tBAAALQwfGS0MIBwtDRwXACgXAhctDhccLQ4ZFC0OHBYBKAAJgGMAFy0MFwkjAACZjyQCAD0AAMxuIwAAzLoAKDICRwA4RwRILQ1IPSgCAEcEAnQuCAAAAnQuDABFAnUuDAAuAnYuDAA6AncuDAA7AnguDAA9AnkAEABHACUAAM8tLQQAACMAAMy6ASgABIBjAD0tDD0EIwAAWZUkAgBFAADM2CMAAM0kACgyAkgAOEgESy0NS0UoAgBIBAJ2LggAAAJ2LgwARwJ3LgwALgJ4LgwAOwJ5LgwAPQJ6LgwARQJ7ABAASAAlAADPLS0EAAAjAADNJAEoAASAYwBFLQxFBCMAAFZ+LQ0MCy0NCg0tDQkOADgOBA8OOA4PECQCABAAAM1YJQAA0QAMOA8DDiQCAA4AAM1qJQABDDgAKA0CEAA4EA8RLQ0RDi4EAAuAAygAgAQEAU8lAAEUzy4IgAUADQAoDQIPADgPBBAtDg4QLQ4NDAEoAASAYwALLQwLBCMAAA66ACgKAg0AOA0DDi0NDgwnAg0EDi0IAA4tDAQPLQwGEC0MBxEtDAsSLQwMEwAQAA0AJQAAzy0tBAAAASgAA4BjAAwtDAwDIwAADAIoAIAEBHgADQAAAIAEgAMkAIADAADOJSoBAAEF96Hzr6Wt1Mo8AQECJiUAAM39ASgAAYBjAAMtDQMCHAwCAQAsAgADAAAAAAAAAAAAAAAAAP//////////////////////////DjgBAwQkAgAEAADOcyUAARYsLQwCASYlAADN/RwMAQMEHAwDAgAcDAIBBCYlAADN/S0IAQInAgMEBAAQAQMBJwMCBAEAKAICAy0MAwQuCoCWAAQAKAQCBC4KgJYABAAoBAIELgqAlgAELQ0CAwAoAwIDLQ4DAi0IAQMnAgQEBQAQAQQBJwMDBAEAKAMCBC0MBAUuCoCWAAUAKAUCBS4KgJYABQAoBQIFLgqAlgAFACgFAgUtDgEFLgiAlQAELQwCAS0MAwIuCIBkAAMmJQAAzf0tDQMGLQ0EBwsoAAeAlQAIJAIACAAAz1MnAgkEADwJAQkLKAAGgGcAByQCAAcAAM/iIwAAz2gtDQEGLQ0CBy0NAwgtDQQJDSgACIBnAAokAgAKAADPjSUAAQw4LgQABoADKACABAQABCUAARTPLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgGMABQ44CAUGJAIABgAAz80lAADRAC0OCgEtDgcCLQ4FAy0OCQQjAADQVScCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAARY+LQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAEUzy4IgAUACQAoCQIKASgACoBkAAstDgULLQ4JAS0OBwIuCoBjAAMtDggEIwAA0FUmJQAAzf0tDQQFCygABYCVAAYkAgAGAADQeCcCBwQAPAkBBycCBQQGLQgABi0MAQctDAIILQwDCS0MBAoAEAAFACUAARY+LQQAAC0NAQUtDQIGLQ0DBy0OBQEtDgYCLQ4HAy4KgJcABAEoAAaAYwACLQ0CASYqAQABBfSAAaZZ0ydCPAEBAiYqAQABBR8AUBJAJCLuPAEBAiYqAQABBR8KLSfcgoeiPAEBAiYqAQABBUWnynEZQeQVPAEBAiYlAADN/R4CAAQAHgIABQAzOAAEAAUABiQCAAYAANE2JQABF0wmJQAAzf0tCAEEAAABAgEuCoCXAAQuCIBkAAMjAADRVg0oAAOApgAFJAIABQAA0XAjAADRay0NBAEmLQ0EBQAoAQIHADgHAwgtDQgGACgCAggAOAgDCS0NCQcKOAYHCAQ4BQgGLQ4GBAEoAAOAYwAFLQwFAyMAANFWKgEAAQW35IldMXaK3zwBAQImJQAAzf0nAgMEBC0IAAQtDAEFLgiAZAAGABAAAwAlAAEXXi0EAAAtDAUCLQ0CAwAoAwIDLQ4DAicCBAQFLQgABS0MAQYuCICmAAcAEAAEACUAARdeLQQAAC0MBgMtDQMEACgEAgQtDgQDJwIFBAYtCAAGLQwBBy4IgI8ACAAQAAUAJQABF14tBAAALQwHBC0NBAUAKAUCBS0OBQQnAgYEBy0IAActDAEILgiArAAJABAABgAlAAEXXi0EAAAtDAgFLQ0FBgAoBgIGLQ4GBScCBwQILQgACC0MAQkuCIC1AAoAEAAHACUAARdeLQQAAC0MCQYtDQYHACgHAgctDgcGJwIIBAktCAAJLQwBCi4IgLYACwAQAAgAJQABF14tBAAALQwKBy0NBwgAKAgCCC0OCAcnAgkECi0IAAotDAELLgiAtwAMABAACQAlAAEXXi0EAAAtDAsILQ0ICQAoCQIJLQ4JCCcCCgQLLQgACy0MAQwuCIC5AA0AEAAKACUAARhVLQQAAC0MDAknAgsEDC0IAAwtDAkNABAACwAlAAEZSC0EAAAtDA0KJwILBAwtCAAMLQwBDS4IgLoADgAQAAsAJQABGFUtBAAALQwNCScCDAQNLQgADS0MCQ4AEAAMACUAARlILQQAAC0MDgsnAgwEDS0IAA0tDAEOLgiAuwAPABAADAAlAAEXXi0EAAAtDA4JLQ0JDAAoDAIMLQ4MCScCDQQOLQgADi0MAQ8uCIC9ABAAEAANACUAARhVLQQAAC0MDwwnAg4EDy0IAA8tDAwQABAADgAlAAEZSC0EAAAtDBANASgAAYC+AA4tDQ4MJwIPBBAtCAAQLQwBES4IgL4AEgAQAA8AJQABF14tBAAALQwRDi0NDgEAKAECAS0OAQ4tDQIBACgBAgEtDgECLQ0DAQAoAQIBLQ4BAy0NBAEAKAECAS0OAQQtDQUBACgBAgEtDgEFLQ0GAQAoAQIBLQ4BBi0NBwEAKAECAS0OAQctDQgBACgBAgEtDgEILQ0JAQAoAQIBLQ4BCS0NDgEAKAECAS0OAQ4tDAIBLQwDAi0MBAMtDAUELQwGBS0MBwYtDAgHLQwKCC0MCQotDAsJLQwNCy0MDg0mKgEAAQUq4YsU1OpBWjwBAQImJQAAzf0tCAEDAAABAgEuCoCYAAMtCAEEAAABAgEuCoCWAAQuCIBkAAIjAADVRg0oAAKApgAFJAIABQAA1WAjAADVWy0NBAEmLQ0EBQMwgKQAAgAGDygAAoCkAAckAgAHAADVgSUAARoxDSgABoCmAAckAgAHAADVliUAAQw4ACgBAggAOAgGCS0NCQccDAcGAC0NAwcEOAYHCAA4BQgGLQ4GBAUoAAeAvAAFLQ4FAwEoAAKAYwAFLQwFAiMAANVGKgEAAQWQfkcGuXRGPzwBAQImJQAAzf0cDAIFBBwMBQQFHAwEAgQNMICEAAIABAsoAASAlQAFJAIABQAA1h8nAgYEADwJAQYHKAACgI8ABC4JgI4ABQAoBQIFLgYABYCOLQgBBQAAAQIBLgqAjgAFLgiAZAADIwAA1lIMOAMEBiQCAAYAANjJIwAA1mQnAggEQAY4AggJBDgJCAoCOAIKBwsoAAeAZAAIJAIACAAA1wYjAADWjQUwgI8ABAAHJwIJBAAKOAkECCQCAAgAANbBBjgHBAsLKAALgI8ACiQCAAoAANbBJQABGkMnAgkECi0IAAotDAELLQwCDC0MBw0AEAAJACUAARpVLQQAAC0MCwQtDAwILQ0EAQAoAQIBLQ4BBC0MBAMtDAgGIwAA11wtCAEBJwIEBBEAEAEEAScDAQQBACgBAgQnAgcEEAA4BwQHLQwECAw4CAcJFgwJCSQCAAkAANdNLgqAZAAIACgIAggjAADXLC0MAQMuCIBkAAYjAADXXC0NAwcAKAcCBy0OBwMHKAAGgIIABw0oAAeAkgAIJAIACAAA14YlAAEMOAAoAwIJADgJBwotDQoIJwIKBAstCAALLQwIDC0MBg0uCIC0AA4AEAAKACUAAR0oLQQAAC0MDAkuBAADgAMoAIAEBAARJQABFM8uCIAFAAgAKAgCCgA4CgcLLQ4JCw0oAAaAkAADJAIAAwAA2DUjAADX+C0NBQMtCAEFJwIGBAkAEAEGAScDBQQBACgIAgYAKAMCBwAoBQIJQD8ACQAHAAYtDAUBLgiAZAAEIwAA2GAtDQUDASgABoBjAAUOOAYFByQCAAcAANhTJQAA0QAtDAMBLQwFBCMAANhgLQ0BAwAoAwIDLQ4DAScCBQQJLQgACS0MCAotDAQLLQwCDAAQAAUAJQABHq0tBAAALQwKAy0NAwIAKAICAi0OAgMnAgQEBS0IAAUtDAMGLQwBBwAQAAQAJQABIuwtBAAALQwGAi0MAgEmBTCAjwADAAYnAggEAAo4CAMHJAIABwAA2P0GOAYDCgsoAAqAjwAJJAIACQAA2P0lAAEaQycCCQQKLQgACi0MAQstDAIMLQwGDQAQAAkAJQABGlUtBAAALQwLBy0MDAgtDQcGACgGAgYtDgYHLQ0FBi0IAQknAgoECQAQAQoBJwMJBAEAKAcCCgAoBgILACgJAgxAPwAMAAsACi0NCQYAKAYCBi0OBgktDgkFASgAA4BjAAYtDAYDIwAA1lIlAADN/ScCAgIYGjgBAgMcDAMEAhwMBAIEHAwCAwIbKAABgKIAAhwMAgUCHAwFBAQcDAQCAhsoAAGAmwAEHAwEBgIcDAYFBBwMBQQCHAwBBgIcDAYFBBwMBQECLQgBBScCBgQFABABBgEnAwUEAQAoBQIGLQwGBy0OAwcAKAcCBy0OAgcAKAcCBy0OBAcAKAcCBy0OAQctDAUBJioBAAEFUCX8dzBk45U8AQECJioBAAEFW021Co+HABM8AQECJioBAAEFAtxuJ4B2Ep08AQECJiUAAM39LQgBCCcCCQQDABABCQEnAwgEAQAoCAIJLQwJCi0OBAoAKAoCCi0OBgonAgsEDC0IAAwuCIDKAA0AEAALACUAAM6NLQQAAC0MDQQtDA4GLQwPCS0MEAotDQQLACgLAgstDgsELQ0GCwAoCwILLQ4LBi0IAQsAAAECAS0OBAstCAEEAAABAgEtDgYELQgBBgAAAQIBLQ4JBi0IAQkAAAECAS0OCgkuCIBkAAcjAADbCg0oAAeAZQAKJAIACgAA3KIjAADbHycCDgQPLQgADy0MCxAtDAQRLQwGEi0MCRMAEAAOACUAANBWLQQAAC0MEA0LKAAFgKkABAsoAA2AlgAGJAIABAAA3GcjAADbZwsoAAWAqgAEJAIABAAA3D0jAADbfAsoAAWAqwAEJAIABAAA3BMjAADbkQsoAAWArQAEJAIABAAA2+kjAADbpgsoAAWAsAAEJAIABAAA278nAgkEADwJAQkLKAAGgJUABCQCAAQAANvUJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA3JELKAAGgJUABCQCAAQAANv+JQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA3JELKAAGgJUABCQCAAQAANwoJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA3JELKAAGgJUABCQCAAQAANxSJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA3JELKAAGgJUABCQCAAQAANx8JQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA3JEtDAoDLQwHAS0MCAItDAwEJiQCAAoAANyvIwAA3O0AKAgCDAA4DAcNLQ0NCicCDAQNLQgADS0MCw4tDAQPLQwGEC0MCREtDAoSABAADAAlAADPLS0EAAAjAADc7QEoAAeAYwAKLQwKByMAANsKJQAAzf0vDAAEAAUcDAUGARwMBgQAHAwEBQEtDAUBJioBAAEFD/SS/LbkggA8AQECJiUAAM39LQgBCCcCCQQDABABCQEnAwgEAQAoCAIJLQwJCi0OBAoAKAoCCi0OBgonAgsEDC0IAAwuCIDKAA0AEAALACUAAM6NLQQAAC0MDQQtDA4GLQwPCS0MEAotDQQLACgLAgstDgsELQ0GCwAoCwILLQ4LBi0IAQsAAAECAS0OBAstCAEEAAABAgEtDgYELQgBBgAAAQIBLQ4JBi0IAQkAAAECAS0OCgkuCIBkAAcjAADd4w0oAAeAZQAKJAIACgAA33sjAADd+CcCDgQPLQgADy0MCxAtDAQRLQwGEi0MCRMAEAAOACUAANBWLQQAAC0MEA0LKAAFgKkABAsoAA2AlgAGJAIABAAA30AjAADeQAsoAAWAqgAEJAIABAAA3xYjAADeVQsoAAWAqwAEJAIABAAA3uwjAADeagsoAAWArQAEJAIABAAA3sIjAADefwsoAAWAsAAEJAIABAAA3pgnAgkEADwJAQkLKAAGgJUABCQCAAQAAN6tJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA32oLKAAGgJUABCQCAAQAAN7XJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA32oLKAAGgJUABCQCAAQAAN8BJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA32oLKAAGgJUABCQCAAQAAN8rJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA32oLKAAGgJUABCQCAAQAAN9VJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA32otDAoDLQwHAS0MCAItDAwEJiQCAAoAAN+IIwAA38YAKAgCDAA4DAcNLQ0NCicCDAQNLQgADS0MCw4tDAQPLQwGEC0MCREtDAoSABAADAAlAADPLS0EAAAjAADfxgEoAAeAYwAKLQwKByMAAN3jJQAAzf0tCAEDKAIABAQBTgAQAQQBJwMDBAEAKAMCBCgCAAUEAU0AOAUEBS0MBAYMOAYFBxYMBwckAgAHAADgJy4KgGEABgAoBgIGIwAA4AYtCAEEAAABAgEtDgMELgiAZAACIwAA4D8NKAACgKYAAyQCAAMAAOEMIwAA4FQuCIBkAAIjAADgXw0oAAKAhAADJAIAAwAA4KIjAADgdC0NBAEnAgMEBC0IAAQtDAEFLgiAxQAGABAAAwAlAAEkpi0EAAAtDAUCLQwCASYtDQQDASgAAoCmAAUAKAECBwA4BwIILQ0IBg0oAAWAxAAHJAIABwAA4NElAAEMOC4EAAOAAygAgAQEAU4lAAEUzy4IgAUABwAoBwIIADgIBQktDgYJLQ4HBAEoAAKAYwADLQwDAiMAAOBfLQ0EAwEggGAAAgAGADgGAgctDQcFLgQAA4ADKACABAQBTiUAARTPLgiABQAGACgGAgcAOAcCCC0OBQgBKAACgGMAAy0OBgQtDAMCIwAA4D8lAADN/S0IAQcnAggEIQAQAQgBJwMHBAEAKAcCCCcCCQQgADgJCAktDAgKDDgKCQsWDAsLJAIACwAA4aguCoCWAAoAKAoCCiMAAOGHLQgBCAAAAQIBLQ4HCC4IgGQABiMAAOHADSgABoCmAAEkAgABAADiKSMAAOHVLQ0IAi4IgGQAASMAAOHkDSgAAYCmAAMkAgADAADh+iMAAOH5JhwMAQMAADgEAwUAKAICBgA4BgEHLQ0HAzAMAAMABQEoAAGAYwADLQwDASMAAOHkACgFAgIAOAIGAy0NAwEcDAECAC0NCAEuBAABgAMoAIAEBAAhJQABFM8uCIAFAAMAKAMCBwA4BwYJLQ4CCS0OAwgBKAAGgGMAAS0MAQYjAADhwCUAAM39LQgBCCcCCQQDABABCQEnAwgEAQAoCAIJLQwJCi0OBAoAKAoCCi0OBgonAgsEDC0IAAwuCIDKAA0AEAALACUAAM6NLQQAAC0MDQQtDA4GLQwPCS0MEAotDQQLACgLAgstDgsELQ0GCwAoCwILLQ4LBi0IAQsAAAECAS0OBAstCAEEAAABAgEtDgYELQgBBgAAAQIBLQ4JBi0IAQkAAAECAS0OCgkuCIBkAAcjAADjLw0oAAeAZQAKJAIACgAA5McjAADjRCcCDgQPLQgADy0MCxAtDAQRLQwGEi0MCRMAEAAOACUAANBWLQQAAC0MEA0LKAAFgKkABAsoAA2AlgAGJAIABAAA5IwjAADjjAsoAAWAqgAEJAIABAAA5GIjAADjoQsoAAWAqwAEJAIABAAA5DgjAADjtgsoAAWArQAEJAIABAAA5A4jAADjywsoAAWAsAAEJAIABAAA4+QnAgkEADwJAQkLKAAGgJUABCQCAAQAAOP5JQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA5LYLKAAGgJUABCQCAAQAAOQjJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA5LYLKAAGgJUABCQCAAQAAORNJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA5LYLKAAGgJUABCQCAAQAAOR3JQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA5LYLKAAGgJUABCQCAAQAAOShJQAA2kQtDAEHLQwCCC0MAwotDA0MIwAA5LYtDAoDLQwHAS0MCAItDAwEJiQCAAoAAOTUIwAA5RIAKAgCDAA4DAcNLQ0NCicCDAQNLQgADS0MCw4tDAQPLQwGEC0MCREtDAoSABAADAAlAADPLS0EAAAjAADlEgEoAAeAYwAKLQwKByMAAOMvJQAAzf0cDAUGADAMAAYABCYlAADN/S0IAQMAAAECAScCBAYALQ4EAycCBAIfJwIFBgEuCIBhAAIjAADlYA0oAAKAogAGJAIABgAA5XojAADldS0NAwEmLQ0DBgI4BAIHHAwHCAQNKAAIgKYAByQCAAcAAOWdJQABDDgAKAECCQA4CQgKLQ0KBxwMBwgGBSgAAoCbAAcYOAUHCQ0oAAeAtAAKJAIACgAA5dIlAAEoQQQ4CAkHJwILBgAKOAsJCiQCAAoAAOYABjgHCQ0KOA0IDCQCAAwAAOYAJQABGkMAOAYHCA44BggJJAIACQAA5hclAADRAC0OCAMBKAACgGYABi0MBgIjAADlYCUAAM39JwIHBAAnAgkEAwA4BwkILQgBBgAQAQgBJwMGBAEAKAYCCC0OBwgAKAgCCC0OBwgnAggEAwA4BggHJwIIBAEnAgoEAwA4CAoJLQgBBwAQAQkBJwMHBAEAKAcCCS0OCAkAKAkCCS0OCAknAgkEAwA4BwkILQwICS0OAgknAgkECi0IAAouCIBkAAstDAYMLgiAYwANLQwHDgAQAAkAJQABFV0tBAAALQwLAi0MDAgtDQgGACgGAgYtDgYIJwIHBAEnAgoEAwA4BwoJLQgBBgAQAQkBJwMGBAEAKAYCCS0OBwkAKAkCCS0OBwknAgkEAwA4BgkHLQwHCS0OAwknAgkECi0IAAotDAILLQwIDC4IgGMADS0MBg4AEAAJACUAARVdLQQAAC0MCwMtDAwHLQ0HAgAoAgICLQ4CBxwMBAIAACgDAgQuBAAHgAMoAIAEBAABJQABKFMuCIAFAAYuCIAGAAgtDgIILQ0GAgAoAgICLQ4CBgAoBAICLgQABoADKACABAQAASUAAShTLgiABQADLgiABgAHLQ4FBy0NAwQAKAQCBC0OBAMpAgAEAIyeVHInAgYEBy0IAActDAQIABAABgAlAADOeC0EAAAtDAgFJwIEAmYnAgYCXycCBwJpJwIIAnAnAgkCdScCCgJiLQgBCycCDAQTABABDAEnAwsEAQAoCwIMLQwMDS4KgLMADQAoDQINLgqAsgANACgNAg0uCoCAAA0AKA0CDS4KgG0ADQAoDQINLgqARwANACgNAg0tDgQNACgNAg0uCoCvAA0AKA0CDS4KgLIADQAoDQINLQ4GDQAoDQINLQ4HDQAoDQINLgqAbQANACgNAg0tDgYNACgNAg0tDggNACgNAg0tDgkNACgNAg0tDgoNACgNAg0uCoCxAA0AKA0CDS0OBw0AKA0CDS4KgK4ADS0NCwQAKAQCBC0OBAstDQMEACgEAgQtDgQDLgiAlQAGLgiAlQAHLgiAlQAJLQwCBC0MBQItDAMFLQwLAy4IgJYACi4IgJYACCYlAADN/RwMBQwAACgGAgUuBAAHgAMoAIAEBAABJQABKdMuCIAFAA0uCIAGAA4tDgwOLQ0NBgAoBgIGLQ4GDRYMCAYcDAgHABwMBggABDgHCQYFKAAIgJEABwA4BgcIFgwKBhwMCgcAHAwGCQAEOAcLBgUoAAmAkQAHADgGBwktCAEGJwIHBAMAEAEHAScDBgQBACgGAgctDAcKLQ4ICgAoCgIKLQ4JCgAoBgIHACgNAgotDQoJJwILBAIAOAoLCDn1AAcABAAIAAkgAgAEIQIABS0IAQcAKAcCCi0NCgknAgsEAgA4CgsIIjSAZAAFAAgtDAUJJwILBAMAOAkLCgAQAQoBJwMHBAEAKAcCCy0OCQsAKAsCCy0OCQstDAkGBigGAgYtDQcFACgFAgUtDgUHJAIABAAA6owjAADqcAAoBwIDLQ0DAicCBAQCADgDBAE8DQECIwAA6owtDAYBLQwHAiYlAADN/S0IAQQoAgAFBAFVABABBQEnAwQEAQAoBAIFKAIABgQBVAA4BgUGLQwFBww4BwYIFgwICCQCAAgAAOrlLgqAYQAHACgHAgcjAADqxC0IAQUAAAECAS0OBAUuCIBkAAMjAADq/Q0oAAOAxgAEJAIABAAA7HwjAADrEi0IAQQoAgAGBAESABABBgEnAwQEAQAoBAIGKAIABwQBEQA4BwYHLQwGCAw4CAcJFgwJCSQCAAkAAOtdLgqAYQAIACgIAggjAADrPC0IAQYAAAECAS0OBAYuCIBkAAMjAADrdQ0oAAOAvwAEJAIABAAA7AMjAADrii0NAQIAKAICAi0OAgEtDQUCLQ0CAwAoAwIDLQ4DAi0NAQMAKAMCAy0OAwEtDQIDACgDAgMtDgMCLQ0BAwAoAwIDLQ4DAS0NBgMtDQMEACgEAgQtDgQDLQ0BBAAoBAIELQ4EAS0NAwQAKAQCBC0OBAMtDAMELQwBAyYtDQYEASgAA4DGAAcNKAAHgMkACCQCAAgAAOwkJQABDDgAKAICCQA4CQcKLQ0KCBwMCAkCHAwJBwAcDAcIAi4EAASAAygAgAQEARIlAAEUzy4IgAUABwAoBwIJADgJAwotDggKASgAA4BjAAQtDgcGLQwEAyMAAOt1LQ0FBAAoAgIHADgHAwgtDQgGHAwGCAIcDAgHABwMBwYCLgQABIADKACABAQBVSUAARTPLgiABQAHACgHAggAOAgDCS0OBgkBKAADgGMABC0OBwUtDAQDIwAA6v0lAADN/S0IAQQnAgUEDgAQAQUBJwMEBAEAKAQCBScCBgQNADgGBQYtDAUHDDgHBggWDAgIJAIACAAA7SQuCoCWAAcAKAcCByMAAO0DLQgBBQAAAQIBLQ4EBS0IAQQnAgYEIAAQAQYBJwMEBAEAKAQCBicCBwQfADgHBgctDAYIDDgIBwkWDAkJJAIACQAA7XguCoBhAAgAKAgCCCMAAO1XLQgBBgAAAQIBLQ4EBi0IAQQnAgcEIAAQAQcBJwMEBAEAKAQCBycCCAQfADgIBwgtDAcJDDgJCAoWDAoKJAIACgAA7cwuCoBhAAkAKAkCCSMAAO2rLQgBBwAAAQIBLQ4EBy4IgGQAAyMAAO3kDSgAA4CkAAQkAgAEAADxFCMAAO35LQ0GBAEoAAGApgAJLQ0JCC4EAASAAygAgAQEACAlAAEUzy4IgAUAAQAoAQIJASgACYBkAAotDggKLQ4BBi0IAQEnAgQEIAAQAQQBJwMBBAEAKAECBCcCCAQfADgIBAgtDAQJDDgJCAoWDAoKJAIACgAA7n0uCoBhAAkAKAkCCSMAAO5cLgiAZAADIwAA7ogNKAADgKAABCQCAAQAAO8+IwAA7p0tDQUBLQ0HAicCBAQHLQgABy0MAggAEAAEACUAAStNLQQAAC0MCAMuBAABgAMoAIAEBAAOJQABFM8uCIAFAAIAKAICBAEoAASAZAAHLQ4DBy0NBgEnAgQEBi0IAAYtDAEHABAABAAlAAErTS0EAAAtDAcDLgQAAoADKACABAQADiUAARTPLgiABQABACgBAgQBKAAEgKAABi0OAwYtDgEFJi0NAQgAKAgCCC0OCAEtCAEIAAABAgEtDgEIBTCApgADAAkuCIBkAAQjAADvaw0oAASApAAKJAIACgAA8IkjAADvgC0NBQQBKAADgGMACi0NCAsnAgwEDS0IAA0tDAsOABAADAAlAAEsDS0EAAAtDA4IDSgACoCFAAskAgALAADvxCUAAQw4LgQABIADKACABAQADiUAARTPLgiABQALACgLAgwAOAwKDS0OCA0tDgsFASgACYCkAAQOOAkECCQCAAgAAPAIJQAA0QANKAAEgMYACCQCAAgAAPAdIwAA8IAtDQYJJAIACAAA8C4lAAEMOAAoAgILADgLBAwtDQwIDSgACoCkAAQkAgAEAADwUSUAAQw4LgQACYADKACABAQAICUAARTPLgiABQAEACgEAgsAOAsKDC0OCAwtDgQGIwAA8IAtDAoDIwAA7ogAOAkECg44CQoLJAIACwAA8KAlAADRAA0oAAqAxgALASgABIBjAAwkAgALAADwvSMAAPELLQ0IDSQCAAsAAPDOJQABDDgAKAICDgA4DgoPLQ0PCy4EAA2AAygAgAQEACAlAAEUzy4IgAUACgAoCgIOADgOBA8tDgsPLQ4KCCMAAPELLQwMBCMAAO9rLQ0HBAAoAQIJADgJAwotDQoILgQABIADKACABAQAICUAARTPLgiABQAJACgJAgoAOAoDCy0OCAsBKAADgGMABC0OCQctDAQDIwAA7eQlAADN/S0IAQYnAgcEDgAQAQcBJwMGBAEAKAYCBycCCAQNADgIBwgtDAcJDDgJCAoWDAoKJAIACgAA8a0uCoCWAAkAKAkCCSMAAPGMLQgBBwAAAQIBLQ4GBy4IgGQABSMAAPHFDSgABYCFAAEkAgABAADyUiMAAPHaLQ0HAScCBAQNBigEAgInAgYEAwA4BAYFLQgBAwAQAQUBJwMDBAEAKAMCBS0OBAUAKAUCBS0OBAUnAgYEAwA4AwYFACgBAgYuBAAGgAMuBAAFgAQuBAAEgAUlAAEUiQAoAwIFLQ0FBCcCBgQCADgFBgE3DQABAAQmACgEAgIAOAIFAy0NAwEtDQcCLgQAAoADKACABAQADiUAARTPLgiABQADACgDAgYAOAYFCC0OAQgtDgMHASgABYBjAAEtDAEFIwAA8cUlAADN/S0IAQQnAgUEDAAQAQUBJwMEBAEAKAQCBScCBgQLADgGBQYtDAUHDDgHBggWDAgIJAIACAAA8usuCoCWAAcAKAcCByMAAPLKLQgBBQAAAQIBLQ4EBS0IAQQnAgYEIAAQAQYBJwMEBAEAKAQCBicCBwQfADgHBgctDAYIDDgIBwkWDAkJJAIACQAA8z8uCoBhAAgAKAgCCCMAAPMeLQgBBgAAAQIBLQ4EBi0IAQQnAgcEIAAQAQcBJwMEBAEAKAQCBycCCAQfADgIBwgtDAcJDDgJCAoWDAoKJAIACgAA85MuCoBhAAkAKAkCCSMAAPNyLQgBBwAAAQIBLQ4EBy4IgGQAAyMAAPOrDSgAA4CkAAQkAgAEAAD22yMAAPPALQ0GBAEoAAGApgAJLQ0JCC4EAASAAygAgAQEACAlAAEUzy4IgAUAAQAoAQIJASgACYBkAAotDggKLQ4BBi0IAQEnAgQEIAAQAQQBJwMBBAEAKAECBCcCCAQfADgIBAgtDAQJDDgJCAoWDAoKJAIACgAA9EQuCoBhAAkAKAkCCSMAAPQjLgiAZAADIwAA9E8NKAADgJ4ABCQCAAQAAPUFIwAA9GQtDQUBLQ0HAicCBAQHLQgABy0MAggAEAAEACUAAStNLQQAAC0MCAMuBAABgAMoAIAEBAAMJQABFM8uCIAFAAIAKAICBAEoAASAZAAHLQ4DBy0NBgEnAgQEBi0IAAYtDAEHABAABAAlAAErTS0EAAAtDAcDLgQAAoADKACABAQADCUAARTPLgiABQABACgBAgQBKAAEgJ4ABi0OAwYtDgEFJi0NAQgAKAgCCC0OCAEtCAEIAAABAgEtDgEIBTCApgADAAkuCIBkAAQjAAD1Mg0oAASApAAKJAIACgAA9lAjAAD1Ry0NBQQBKAADgGMACi0NCAsnAgwEDS0IAA0tDAsOABAADAAlAAEsDS0EAAAtDA4IDSgACoCfAAskAgALAAD1iyUAAQw4LgQABIADKACABAQADCUAARTPLgiABQALACgLAgwAOAwKDS0OCA0tDgsFASgACYCkAAQOOAkECCQCAAgAAPXPJQAA0QANKAAEgL8ACCQCAAgAAPXkIwAA9kctDQYJJAIACAAA9fUlAAEMOAAoAgILADgLBAwtDQwIDSgACoCkAAQkAgAEAAD2GCUAAQw4LgQACYADKACABAQAICUAARTPLgiABQAEACgEAgsAOAsKDC0OCAwtDgQGIwAA9kctDAoDIwAA9E8AOAkECg44CQoLJAIACwAA9mclAADRAA0oAAqAvwALASgABIBjAAwkAgALAAD2hCMAAPbSLQ0IDSQCAAsAAPaVJQABDDgAKAICDgA4DgoPLQ0PCy4EAA2AAygAgAQEACAlAAEUzy4IgAUACgAoCgIOADgOBA8tDgsPLQ4KCCMAAPbSLQwMBCMAAPUyLQ0HBAAoAQIJADgJAwotDQoILgQABIADKACABAQAICUAARTPLgiABQAJACgJAgoAOAoDCy0OCAsBKAADgGMABC0OCQctDAQDIwAA86slAADN/S0IAQYnAgcEDAAQAQcBJwMGBAEAKAYCBycCCAQLADgIBwgtDAcJDDgJCAoWDAoKJAIACgAA93QuCoCWAAkAKAkCCSMAAPdTLQgBBwAAAQIBLQ4GBy4IgGQABSMAAPeMDSgABYCfAAEkAgABAAD4GSMAAPehLQ0HAScCBAQLBigEAgInAgYEAwA4BAYFLQgBAwAQAQUBJwMDBAEAKAMCBS0OBAUAKAUCBS0OBAUnAgYEAwA4AwYFACgBAgYuBAAGgAMuBAAFgAQuBAAEgAUlAAEUiQAoAwIFLQ0FBCcCBgQCADgFBgE3DQABAAQmACgEAgIAOAIFAy0NAwEtDQcCLgQAAoADKACABAQADCUAARTPLgiABQADACgDAgYAOAYFCC0OAQgtDgMHASgABYBjAAEtDAEFIwAA94wlAADN/S0IAQUnAgYEIQAQAQYBJwMFBAEAKAUCBicCBwQgADgHBgctDAYIDDgIBwkWDAkJJAIACQAA+LIuCoCWAAgAKAgCCCMAAPiRLQgBBgAAAQIBLQ4FBi4IgGQABCMAAPjKDSgABICmAAMkAgADAAD5PiMAAPjfLQ0BAy0NAgQBKAAEgKYABQ44BAUHJAIABwAA+QElAADRAC0OAwEtDgUCLQ0GAScCAwQELQgABC0MAQUAEAADACUAARJBLQQAAC0MBQItDQIBACgBAgEtDgECLQwCASYtDQYDLQ0BBS0NAgcAOAcECA44BwgJJAIACQAA+WElAADRAA0oAAiAxwAHJAIABwAA+XYlAAEMOAAoBQIJADgJCAotDQoHLgQAA4ADKACABAQAISUAARTPLgiABQAFACgFAggAOAgECS0OBwktDgUGASgABIBjAAMtDAMEIwAA+MolAADN/S0IAQUoAgAGBAEuABABBgEnAwUEAQAoBQIGKAIABwQBLQA4BwYHLQwGCAw4CAcJFgwJCSQCAAkAAPoPLgqAlgAIACgIAggjAAD57i0IAQYAAAECAS0OBQYuCIBkAAQjAAD6Jw0oAASAhAADJAIAAwAA+psjAAD6PC0NAQMtDQIEASgABICEAAUOOAQFByQCAAcAAPpeJQAA0QAtDgMBLQ4FAi0NBgEnAgMEBC0IAAQtDAEFABAAAwAlAAEK2C0EAAAtDAUCLQ0CAQAoAQIBLQ4BAi0MAgEmLQ0GAy0NAQUtDQIHADgHBAgOOAcICSQCAAkAAPq+JQAA0QANKAAIgMcAByQCAAcAAPrTJQABDDgAKAUCCQA4CQgKLQ0KBy4EAAOAAygAgAQEAS4lAAEUzy4IgAUABQAoBQIIADgIBAktDgcJLQ4FBgEoAASAYwADLQwDBCMAAPonKgEAAQUJnd1Th4MHTjwBAQImKgEAAQW5ZHVeVNfiIzwBAQImKgEAAQV0vrWtZMdijDwBAQImJQAAzf0tCAEEJwIFBAIAEAEFAScDBAQBACgEAgUtDAUGLgqAlgAGLQ0EBQAoBQIFLQ4FBC0IAQUnAgYEIQAQAQYBJwMFBAEAKAUCBi0MBgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHACgHAgctDgQHLQgBBAAAAQIBLQ4FBAsoAAKAwQAFLgiAZAADIwAA/N0NKAADgKYABiQCAAYAAPz3IwAA/PItDQQBJi0NBAcAKAECCQA4CQMKLQ0KCBwMCAkALQgBCCcCCgQCABABCgEnAwgEAQAoCAIKLQwKCy0OCQskAgAFAAD9XSMAAP07CygAAoDCAAkkAgAJAAD9VCcCCgQAPAkBCi0MCAYjAAD9hi0IAQgnAgoEAgAQAQoBJwMIBAEAKAgCCi0MCgstDgkLLQwIBiMAAP2GLgQAB4ADKACABAQAISUAARTPLgiABQAIACgIAgkAOAkDCi0OBgoBKAADgGMABi0OCAQtDAYDIwAA/N0lAADN/S0IAQUnAgYEDgAQAQYBJwMFBAEAKAUCBicCBwQNADgHBgctDAYIDDgIBwkWDAkJJAIACQAA/g0uCoCWAAgAKAgCCCMAAP3sLQgBBgAAAQIBLQ4FBi0IAQUnAgcEIAAQAQcBJwMFBAEAKAUCBycCCAQfADgIBwgtDAcJDDgJCAoWDAoKJAIACgAA/mEuCoBhAAkAKAkCCSMAAP5ALQgBBwAAAQIBLQ4FBy0IAQUnAggEIAAQAQgBJwMFBAEAKAUCCCcCCQQfADgJCAktDAgKDDgKCQsWDAsLJAIACwAA/rUuCoBhAAoAKAoCCiMAAP6ULQgBCAAAAQIBLQ4FCC0IAQUnAgkEIAAQAQkBJwMFBAEAKAUCCScCCgQfADgKCQotDAkLDDgLCgwWDAwMJAIADAAA/wkuCoBhAAsAKAsCCyMAAP7oLQgBCQAAAQIBLQ4FCS4IgGQABCMAAP8hDSgABICkAAUkAgAFAAEC3iMAAP82LQ0HBQEoAAGApgALLQ0LCi4EAAWAAygAgAQEACAlAAEUzy4IgAUAAQAoAQILASgAC4BkAAwtDgoMASgAA4CmAAotDQoFLgQAAYADKACABAQAICUAARTPLgiABQADACgDAgoBKAAKgJ4ACy0OBQstDgMHLQgBAScCAwQgABABAwEnAwEEAQAoAQIDJwIFBB8AOAUDBS0MAwoMOAoFCxYMCwskAgALAAD/7y4KgGEACgAoCgIKIwAA/84uCIBkAAQjAAD/+g0oAASAngADJAIAAwABAQAjAAEADy0NBgEtDQgCJwIEBAotCAAKLQwCCwAQAAQAJQABK00tBAAALQwLAy4EAAGAAygAgAQEAA4lAAEUzy4IgAUAAgAoAgIEASgABIBkAAUtDgMFLQ0JAScCBAQILQgACC0MAQkAEAAEACUAAStNLQQAAC0MCQMuBAACgAMoAIAEBAAOJQABFM8uCIAFAAEAKAECBAEoAASAnwAFLQ4DBS0NBwInAgQEBy0IAActDAIIABAABAAlAAErTS0EAAAtDAgDLgQAAYADKACABAQADiUAARTPLgiABQACACgCAgQBKAAEgKAABS0OAwUtDgIGLQwCASYtDQEFACgFAgUtDgUBLQgBBQAAAQIBLQ4BBQUwgKYABAAKLgiAZAADIwABAS0NKAADgKQACyQCAAsAAQJTIwABAUItDQYDASgABIBjAAstDQUMJwINBA4tCAAOLQwMDwAQAA0AJQABLA0tBAAALQwPBQ0oAAuAhQAMJAIADAABAYYlAAEMOC4EAAOAAygAgAQEAA4lAAEUzy4IgAUADAAoDAINADgNCw4tDgUOLQ4MBg0oAASAnQADJAIAAwABAcUjAAECSi0NBwMBKAAKgKQABQ44CgUMJAIADAABAeMlAADRAA0oAAWAhAAKJAIACgABAfglAAEMOAAoAgIMADgMBQ0tDQ0KDSgAC4CkAAUkAgAFAAECGyUAAQw4LgQAA4ADKACABAQAICUAARTPLgiABQAFACgFAgwAOAwLDS0OCg0tDgUHIwABAkotDAsEIwAA//oAOAoDCw44CgsMJAIADAABAmolAADRAA0oAAuAhAAMASgAA4BjAA0kAgAMAAEChyMAAQLVLQ0FDiQCAAwAAQKYJQABDDgAKAICDwA4DwsQLQ0QDC4EAA6AAygAgAQEACAlAAEUzy4IgAUACwAoCwIPADgPAxAtDgwQLQ4LBSMAAQLVLQwNAyMAAQEtLQ0IBQAoAQILADgLBAwtDQwKLgQABYADKACABAQAICUAARTPLgiABQALACgLAgwAOAwEDS0OCg0BKAAEgGMABS0OCwgtDQkKACgDAgwAOAwEDS0NDQsuBAAKgAMoAIAEBAAgJQABFM8uCIAFAAwAKAwCDQA4DQQOLQ4LDi0ODAktDAUEIwAA/yEqAQABBUW8OStteQvcPAEBAiYqAQABBZabeQCnC1t+PAEBAiYlAADN/S0IAQgnAgkEAwAQAQkBJwMIBAEAKAgCCS0MCQotDgQKACgKAgotDgYKJwILBAwtCAAMLgiAygANABAACwAlAADOjS0EAAAtDA0ELQwOBi0MDwktDBAKLQ0ECwAoCwILLQ4LBC0NBgsAKAsCCy0OCwYtCAELAAABAgEtDgQLLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS0OCQYtCAEJAAABAgEtDgoJLgiAZAAHIwABBD8NKAAHgGUACiQCAAoAAQXXIwABBFQnAg4EDy0IAA8tDAsQLQwEES0MBhItDAkTABAADgAlAADQVi0EAAAtDBANCygABYCpAAQLKAANgJYABiQCAAQAAQWcIwABBJwLKAAFgKoABCQCAAQAAQVyIwABBLELKAAFgKsABCQCAAQAAQVIIwABBMYLKAAFgK0ABCQCAAQAAQUeIwABBNsLKAAFgLAABCQCAAQAAQT0JwIJBAA8CQEJCygABoCVAAQkAgAEAAEFCSUAANpELQwBBy0MAggtDAMKLQwNDCMAAQXGCygABoCVAAQkAgAEAAEFMyUAANpELQwBBy0MAggtDAMKLQwNDCMAAQXGCygABoCVAAQkAgAEAAEFXSUAANpELQwBBy0MAggtDAMKLQwNDCMAAQXGCygABoCVAAQkAgAEAAEFhyUAANpELQwBBy0MAggtDAMKLQwNDCMAAQXGCygABoCVAAQkAgAEAAEFsSUAANpELQwBBy0MAggtDAMKLQwNDCMAAQXGLQwKAy0MBwEtDAgCLQwMBCYkAgAKAAEF5CMAAQYiACgIAgwAOAwHDS0NDQonAgwEDS0IAA0tDAsOLQwEDy0MBhAtDAkRLQwKEgAQAAwAJQAAzy0tBAAAIwABBiIBKAAHgGMACi0MCgcjAAEEPyUAAM39LQgBBCgCAAUEAU4AEAEFAScDBAQBACgEAgUoAgAGBAFNADgGBQYtDAUHDDgHBggWDAgIJAIACAABBoMuCoBhAAcAKAcCByMAAQZiLQgBBQAAAQIBLQ4EBS4IgGQAAyMAAQabDSgAA4CEAAQkAgAEAAEHPyMAAQawLgiAZAABIwABBrsNKAABgKYAAyQCAAMAAQbVIwABBtAtDQUBJi0NBQMBKAABgIQABAAoAgIHADgHAQgtDQgGDSgABIDEAAckAgAHAAEHBCUAAQw4LgQAA4ADKACABAQBTiUAARTPLgiABQAHACgHAggAOAgECS0OBgktDgcFASgAAYBjAAMtDAMBIwABBrstDQUEACgBAgcAOAcDCC0NCAYuBAAEgAMoAIAEBAFOJQABFM8uCIAFAAcAKAcCCAA4CAMJLQ4GCQEoAAOAYwAELQ4HBS0MBAMjAAEGmyUAAM39JwIDBAQtCAAELQwBBS4IgMUABgAQAAMAJQABJKYtBAAALQwFAi0NAgEAKAECAS0OAQInAgMEBC0IAAQtDAIFABAAAwAlAAEszS0EAAAtDAUBJiUAAM39LQgBBScCBgQhABABBgEnAwUEAQAoBQIGJwIHBCAAOAcGBy0MBggMOAgHCRYMCQkkAgAJAAEILy4KgJYACAAoCAIIIwABCA4tCAEGAAABAgEtDgUGLgiAZAAEIwABCEcNKAAEgKYAAyQCAAMAAQi7IwABCFwtDQEDLQ0CBAEoAASApgAFDjgEBQckAgAHAAEIfiUAANEALQ4DAS0OBQItDQYBJwIDBAQtCAAELQwBBQAQAAMAJQABEkEtBAAALQwFAi0NAgEAKAECAS0OAQItDAIBJi0NBgMtDQEFLQ0CBwA4BwQIDjgHCAkkAgAJAAEI3iUAANEADSgACICmAAckAgAHAAEI8yUAAQw4ACgFAgkAOAkICi0NCgcuBAADgAMoAIAEBAAhJQABFM8uCIAFAAUAKAUCCAA4CAQJLQ4HCS0OBQYBKAAEgGMAAy0MAwQjAAEIRyoBAAEFU4PmoCWolAk8AQECJiUAAM39LwwABAAFHAwFBgQcDAYEABwMBAUELQwFASYqAQABBUYRK2RUjHAxPAEBAiYlAADN/S0IAQUnAgYEIQAQAQYBJwMFBAEAKAUCBicCBwQgADgHBgctDAYIDDgIBwkWDAkJJAIACQABCcsuCoCWAAgAKAgCCCMAAQmqLQgBBgAAAQIBLQ4FBi4IgGQABCMAAQnjDSgABICmAAMkAgADAAEKVyMAAQn4LQ0BAy0NAgQBKAAEgKYABQ44BAUHJAIABwABCholAADRAC0OAwEtDgUCLQ0GAScCAwQELQgABC0MAQUAEAADACUAARJBLQQAAC0MBQItDQIBACgBAgEtDgECLQwCASYtDQYDLQ0BBS0NAgcAOAcECA44BwgJJAIACQABCnolAADRAA0oAAiAyAAHJAIABwABCo8lAAEMOAAoBQIJADgJCAotDQoHLgQAA4ADKACABAQAISUAARTPLgiABQAFACgFAggAOAgECS0OBwktDgUGASgABIBjAAMtDAMEIwABCeMlAADN/S0NAQMAKAMCAy0OAwEtCAEDAAABAgEtDgEDLQgBAQAAAQIBLgqAZAABLQgBBCgCAAUEAS4AEAEFAScDBAQBACgEAgUoAgAGBAEtADgGBQYtDAUHDDgHBggWDAgIJAIACAABC1EuCoBhAAcAKAcCByMAAQswLQgBBQAAAQIBLQ4EBS0NBAYAKAYCBi0OBgQuCIBkAAIjAAELdg0oAAKAhAAGJAIABgABC50jAAELiy0NBQEtDQQCAigCAgItDgIEJi0NBQYtDQMHLQ0BCA0oAAiAhAAJJAIACQABC74lAAEMOAAoBwIKADgKCAstDQsJASgACIBjAAoOOAgKCyQCAAsAAQvmJQAA0QAtDgcDLQ4KARwMCQgCHAwIBwAcDAcIAi4EAAaAAygAgAQEAS4lAAEUzy4IgAUABwAoBwIJADgJAgotDggKLQ4HBQEoAAKAYwAGLQwGAiMAAQt2KgEAAQXFa8RaDhAAAjwBAQImKgEAAQWXCoUE7Jw/dTwBAQImJQAAzf0tCAEGJwIHBCEAEAEHAScDBgQBACgGAgcnAggEIAA4CAcILQwHCQw4CQgKFgwKCiQCAAoAAQyoLgqAlgAJACgJAgkjAAEMhy0IAQcAAAECAS0OBgcuCIBkAAUjAAEMwA0oAAWApgABJAIAAQABDXsjAAEM1S0NBwEtDQECACgCAgItDgIBLQgBAgAAAQIBLQ4BAi0IAQEAAAECAS4KgGQAAS0IAQMnAgQEIQAQAQQBJwMDBAEAKAMCBCcCBQQgADgFBAUtDAQGDDgGBQcWDAcHJAIABwABDUkuCoBhAAYAKAYCBiMAAQ0oJwIFBAYtCAAGLQwCBy0MAQguCIC4AAktDAMKABAABQAlAAEuEy0EAAAtDAcELQwEASYtDQcBHAwFAgAAOAQCAy8MAAMAAi4EAAGAAygAgAQEACElAAEUzy4IgAUAAwAoAwIGADgGBQgtDgIILQ4DBwEoAAWAYwABLQwBBSMAAQzAKgEAAQUDi6MQrnM7SjwBAQImJQAAzf0uCYCOAAQAKAQCBC4GAASAjicCBgQHLQgABy0MAQguCICsAAkuCIBkAAoAEAAGACUAAS9ELQQAAC0MCAQtDAkFLQ0EBgAoBgIGLQ4GBC0IAQYnAgcECQAQAQcBJwMGBAEAKAQCBwEggI4AAgAIACgGAglAPwAJAAgABy0NBgQAKAQCBC0OBAYnAggECS0IAAktDAEKLgiArAALLgiAjwAMABAACAAlAAEvRC0EAAAtDAoELQwLBy0NBAEAKAECAS0OAQQHKAAHgIIAAQ0oAAGAkgAIJAIACAABDsElAAEMOAAoBAIJADgJAQotDQoIJwIKBAstCAALLQwIDC0MBw0uCIC0AA4AEAAKACUAAR0oLQQAAC0MDAkuBAAEgAMoAIAEBAARJQABFM8uCIAFAAgAKAgCCgA4CgELLQ4JCw0oAAeAkAABJAIAAQABD2wjAAEPMy0IAQEnAgQECQAQAQQBJwMBBAEAKAgCBAAoBgIFACgBAgdAPwAHAAUABC0MAQIuCIBkAAMjAAEPkwEoAAeAYwABDjgHAQQkAgAEAAEPhiUAANEALQwGAi0MAQMjAAEPky0NAgEAKAECAS0OAQInAgQECS0IAAktDAgKLQwDCy4IgKwADAAQAAQAJQABHq0tBAAALQwKAS0NAQMAKAMCAy0OAwEnAgQEBS0IAAUtDAEGLQwCBwAQAAQAJQABIuwtBAAALQwGAy0NAwEAKAECAS0OAQMnAgIEBC0IAAQtDAMFABAAAgAlAAEszS0EAAAtDAUBJiUAAM39LQ0BBS0NAgYNKAAGgMAAByQCAAcAARBIJQABDDgAKAUCCAA4CAYJLQ0JBy0IAQgnAgkEAgAQAQkBJwMIBAEAKAgCCS0MCQotDgcKASgABoBjAAkOOAYJCiQCAAoAARCQJQAA0QAtDgUBLQ4JAgsoAAOAmgABJAIAAQABEM8jAAEQrQsoAAOApwABJAIAAQABEMYnAgIEADwJAQItDAcEIwABEPcnAgIECS0IAAktDAgKABAAAgAlAADOJi0EAAAtDAoBLQwBBCMAARD3LQwEASYqAQABBZn3vpddTLOKPAEBAiYlAADN/ScCBgQHLQgABy0MAQgtDAIJABAABgAlAAERpi0EAAAtDAgFCygAA4CaAAEkAgABAAEReSMAARFLCygAA4CnAAEkAgABAAERZCcCAgQAPAkBAgEoAAWAYwACLQ0CAS0MAQQjAAERoScCAgQGLQgABi0MBQcAEAACACUAAM4mLQQAAC0MBwEtDAEEIwABEaEtDAQBJiUAAM39LQ0BAy0NAgQNKAAEgGUABSQCAAUAARHIJQABDDgAKAMCBgA4BgQHLQ0HBS0IAQYnAgcEAgAQAQcBJwMGBAEAKAYCBy0MBwgtDgUIASgABIBjAAUOOAQFByQCAAcAARIQJQAA0QAtDgMBLQ4FAi0MBgEmKgEAAQVmEDE2ETEfrDwBAQImKgEAAQWQNdz/Bx0CIzwBAQImJQAAzf0tDQECACgCAgItDgIBLQgBAgAAAQIBLQ4BAi0IAQEAAAECAS4KgGQAAS0IAQMnAgQEIQAQAQQBJwMDBAEAKAMCBCcCBQQgADgFBAUtDAQGDDgGBQcWDAcHJAIABwABErYuCoBhAAYAKAYCBiMAARKVJwIFBAYtCAAGLQwCBy0MAQguCIDDAAktDAMKABAABQAlAAEuEy0EAAAtDAcELQwEASYqAQABBcoaVTxAFNV8PAEBAiYqAQABBbrI2coVlJtLPAEBAiYlAADN/S0IAQUnAgYEIQAQAQYBJwMFBAEAKAUCBicCBwQgADgHBgctDAYIDDgIBwkWDAkJJAIACQABE1guCoCWAAgAKAgCCCMAARM3LQgBBgAAAQIBLQ4FBi4IgGQABCMAARNwDSgABICmAAMkAgADAAET5CMAAROFLQ0BAy0NAgQBKAAEgKYABQ44BAUHJAIABwABE6clAADRAC0OAwEtDgUCLQ0GAScCAwQELQgABC0MAQUAEAADACUAARJBLQQAAC0MBQItDQIBACgBAgEtDgECLQwCASYtDQYDLQ0BBS0NAgcAOAcECA44BwgJJAIACQABFAclAADRAA0oAAiAqAAHJAIABwABFBwlAAEMOAAoBQIJADgJCAotDQoHLgQAA4ADKACABAQAISUAARTPLgiABQAFACgFAggAOAgECS0OBwktDgUGASgABIBjAAMtDAMEIwABE3AqAQABBbyq4IELKoi2PAEBAiYqAQABBX9Bvb6hDxlEPAEBAiYBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgABFM4uAYAIgAYuAoAGgAkBAIAIAAKACAEAgAkAAoAJIwABFJ0mLgGAA4AGCwCABgACgAckAIAHAAEU6iMAART1LgCAA4AFIwABFVwuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAEVSC4BgAqACC4CgAiACwEAgAoAAoAKAQCACwACgAsjAAEVFygBgAUEAAEDAIAGAAKABiMAARVcJiUAAM39LQgBBgAAAQIBLQ4BBi0IAQEAAAECAS0OAgEtDQQCACgCAgItDgIELgiAZAAFIwABFZQMOAUDAiQCAAIAARW3IwABFaYtDQYCLQ0BAy0MAgEtDAMCJiQCAAIAARXEJQABDDgnAggEAwA4BAgHADgHBQgtDQgCLQ0GBy0NAQgAKAcCCS4EAAiAAygAgAQEAAElAAEoUy4IgAUACi4IgAYACy0OAgstDQoCACgCAgItDgIKLQ4JBi0OCgEBKAAFgGMAAi0MAgUjAAEVlCoBAAEFWgLkG7UeqZ88AQECJiUAAM39LgiAZAAFIwABFk4NKAAFgGcABiQCAAYAARa5IwABFmMtDQEFLQ0CBi0NAwctDQQILQgBCScCCgQFABABCgEnAwkEAQAoBgIKJwILBAQAKAkCDD8PAAoADC0NCQYAKAYCBi0OBgktDgUBLQ4JAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWAYwAGJAIABwABFtcjAAEXQy0NAQctDQIILQ0DCS0NBAoAKAgCDAA4DAUNLQ0NCwAoBwINADgNBQ4tDQ4MADgLDA0uBAAIgAMoAIAEBAAFJQABFM8uCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAEXQy0MBgUjAAEWTioBAAEFvh4//z6k9vo8AQECJiUAAM39LQgBBCcCBQQhABABBQEnAwQEAQAoBAIFJwIGBCAAOAYFBi0MBQcMOAcGCBYMCAgkAgAIAAEXqi4KgGEABwAoBwIHIwABF4ktCAEFAAABAgEtDgQFLgiAZAADIwABF8INKAADgKYABCQCAAQAARfcIwABF9ctDQUBJi0NBQQAOAIDBg44AgYHJAIABwABF/clAADRAA0oAAaAhAAHJAIABwABGAwlAAEMOAAoAQIIADgIBgktDQkHLgQABIADKACABAQAISUAARTPLgiABQAGACgGAggAOAgDCS0OBwkBKAADgGMABC0OBgUtDAQDIwABF8IlAADN/S0IAQQnAgUEBQAQAQUBJwMEBAEAKAQCBS0MBQYuCoBhAAYAKAYCBi4KgGEABgAoBgIGLgqAYQAGACgGAgYuCoBhAAYtCAEFAAABAgEtDgQFLgiAZAADIwABGLUNKAADgIIABCQCAAQAARjPIwABGMotDQUBJi0NBQQAOAIDBg44AgYHJAIABwABGOolAADRAA0oAAaAhAAHJAIABwABGP8lAAEMOAAoAQIIADgIBgktDQkHLgQABIADKACABAQABSUAARTPLgiABQAGACgGAggAOAgDCS0OBwkBKAADgGMABC0OBgUtDAQDIwABGLUlAADN/S0IAQMAAAECAS4KgJgAAy0IAQQAAAECAS4KgJYABC4IgGQAAiMAARl2DSgAAoCCAAUkAgAFAAEZuSMAARmLLQ0EARwMAQIAKQIAAwD/////DjgCAwQkAgAEAAEZryUAARYsHAwBAgQtDAIBJi0NBAUDMIBnAAIABg8oAAKAZwAHJAIABwABGdolAAEaMQ0oAAaAggAHJAIABwABGe8lAAEMOAAoAQIIADgIBgktDQkHHAwHBgAtDQMHBDgGBwgAOAUIBi0OBgQFKAAHgLwABS0OBQMBKAACgGMABS0MBQIjAAEZdioBAAEFKIaSsEfc/UM8AQECJioBAAEFZGGIqMbPlMs8AQECJiUAAM39LQgBBScCBgQRABABBgEnAwUEAQAoBQIGJwIHBBAAOAcGBy0MBggMOAgHCRYMCQkkAgAJAAEaoS4KgGQACAAoCAIIIwABGoAtCAEGAAABAgEtDgUGDDgCAwUkAgAFAAEbICMAARrAASgAA4CPAAcOOAMHCCQCAAgAARraJQAA0QAMOAIHCCQCAAgAARr3IwABGuwuCICPAAUjAAEbFwI4AgMHDjgDAggkAgAIAAEbDiUAARoxLQwHBSMAARsXLQwFBCMAARsrLgiAZAAEIwABGysHKAAEgIIAAi0IAQUAAAECAS0OAgUnAggEBAY4BAgJBDgJCAoCOAQKBwsoAAeAZAAIJAIACAABG4wjAAEbaQEoAAKAYwAHDjgCBwgkAgAIAAEbgyUAANEALQ4HBSMAARuMLQ0FBy4IgGQAAiMAARubDDgCBwUkAgAFAAEbtiMAARutLQ0GAS0MBAImLQgBCAAAAQIBLgqAZAAIBSgAAoCCAAknAgsEAAsoAAuAggAKJAIACgABG/wHKAAJgIIADQo4DQIMJAIADAABG/wlAAEaQy4IgGQABSMAARwHDSgABYCCAAokAgAKAAEcdCMAARwcLQ0GBS0NCAkNKAACgJIACCQCAAgAARw5JQABDDguBAAFgAMoAIAEBAARJQABFM8uCIAFAAgAKAgCCgA4CgILLQ4JCwEoAAKAYwAFLQ4IBi0MBQIjAAEbmwA4CQULDjgJCwwkAgAMAAEciyUAANEADDgLBAwkAgAMAAEcqCMAARydLgiAYQAKIwABHOsAOAMLDA44AwwNJAIADQABHL8lAADRAA0oAAyAhAALJAIACwABHNQlAAEMOAAoAQINADgNDA4tDQ4LLQwLCiMAARzrLQ0ICxkoAAuAmwAMHAwKCwQAOAwLCg44DAoNJAIADQABHRMlAADRAC0OCggBKAAFgGMACi0MCgUjAAEcByUAAM39JwIGBAQGOAIGBwQ4BwYIAjgCCAUDMICCAAUAAg8oAAWAggAGJAIABgABHV4lAAEaMRwMAgcCHAwHBgQcDAYCAgUwgJsAAgAGJwIIAgAKOAgCByQCAAcAAR2hBjgGAgoLKAAKgJsACSQCAAkAAR2hJQABGkMaOAEGBw0oAAKAmQABJAIAAQABHcYjAAEduy4IgGQABCMAAR3pGDgHBgENKAAGgKUAAiQCAAIAAR3gJQABKEEtDAEEIwABHekcDAMCBAMwgGcABQADDygABYBnAAYkAgAGAAEeCyUAARoxHAwDBgIcDAYFBBwMBQMCDSgAA4CZAAUkAgAFAAEeOiMAAR4vLgiAZAABIwABHpEFMICbAAMABScCBwIACjgHAwYkAgAGAAEebgY4BQMJCygACYCbAAgkAgAIAAEebiUAARpDGDgCBQMNKAAFgKUAAiQCAAIAAR6IJQABKEEtDAMBIwABHpEAOAQBAg44BAIDJAIAAwABHqglAADRAC0MAgEmJQAAzf0tCAEEAAABAgEtDgEELQgBBQAAAQIBLQ4CBS0NAQYAKAYCBi0OBgEnAgcEBAY4AgcIBDgIBwkCOAIJBgsoAAaAZAAHJAIABwABIB8jAAEfAgcoAAKAggAIAzCAggAGAAkPKAAGgIIACiQCAAoAAR8nJQABGjENKAAIgJIABiQCAAYAAR88JQABDDgAKAECCgA4CggLLQ0LBhwMCQsCHAwLCgQcDAoLAgUwgJsACwAKJwINAgAKOA0LDCQCAAwAAR+NBjgKCw8LKAAPgJsADiQCAA4AAR+NJQABGkMaOAYKDA0oAAuAmQAGJAIABgABH7IjAAEfpy4IgGQAByMAAR/VGDgMCgYNKAAKgKUACyQCAAsAAR/MJQABKEEtDAYHIwABH9UuBAABgAMoAIAEBAARJQABFM8uCIAFAAYAKAYCCgA4CggLLQ4HCy0OBgQAOAIJBg44AgYHJAIABwABIBYlAADRAC0OBgUjAAEgHy0NBQYHKAAGgIIABS0MBQIjAAEgNA0oAAKAkwAFJAIABQABIpYjAAEgSQUwgJwAAwAFJwIHBAAKOAcDBiQCAAYAASB9BjgFAwkLKAAJgJwACCQCAAgAASB9JQABGkMcDAUDACcCBgEALQgBBScCBwQJABABBwEnAwUEAQAoBQIHJwIIBAhDA7AAA4CUAAgABgAHLgiAZAACIwABILwNKAACgGUAAyQCAAMAASDnIwABINEtDQQCLQ0BAwIoAwIDLQ4DAS0MAgEmBSgAAoCCAAMtDQQGATCAkwACAAcNKAADgJwACCQCAAgAASEQJQABDDgAKAUCCQA4CQMKLQ0KCAEoAAOAYwAJDjgDCQokAgAKAAEhOCUAANEADSgACYCcAAokAgAKAAEhTSUAAQw4ACgFAgsAOAsJDC0NDAoBKAADgGUACQ44AwkLJAIACwABIXUlAADRAA0oAAmAnAALJAIACwABIYolAAEMOAAoBQIMADgMCQ0tDQ0LASgAA4BnAAkOOAMJDCQCAAwAASGyJQAA0QANKAAJgJwAAyQCAAMAASHHJQABDDgAKAUCDAA4DAkNLQ0NAxwMCAkEGSgACYCbAAgcDAoJBAA4CAkKDjgICgwkAgAMAAEh/iUAANEAGSgACoCbAAgcDAsJBAA4CAkKDjgICgskAgALAAEiIiUAANEAGSgACoCbAAgcDAMJBAA4CAkDDjgIAwokAgAKAAEiRiUAANEADSgAB4CSAAgkAgAIAAEiWyUAAQw4LgQABoADKACABAQAESUAARTPLgiABQAIACgIAgkAOAkHCi0OAwotDggEASgAAoBjAAMtDAMCIwABILwtDQQFDSgAAoCSAAYkAgAGAAEiryUAAQw4LgQABYADKACABAQAESUAARTPLgiABQAGACgGAgcAOAcCCC4KgGQACAEoAAKAYwAFLQ4GBC0MBQIjAAEgNCUAAM39LQgBBAAAAQIBLQgBBScCBgQhABABBgEnAwUEAQAoBQIGJwIHBCAAOAcGBy0MBggMOAgHCRYMCQkkAgAJAAEjQS4KgGEACAAoCAIIIwABIyAtCAEGAAABAgEtDgUGLQgBBScCBwQJABABBwEnAwUEAQAoAQIHACgCAggAKAUCCUA/AAkACAAHLQ0FAQAoAQIBLQ4BBS0OBQQuCIBkAAMjAAEjlA0oAAOAnAABJAIAAQABI64jAAEjqS0NBgEmLQ0EAgAoAgIHADgHAwgtDQgFHAwFAgAnAgcBAC0IAQUnAggEBQAQAQgBJwMFBAEAKAUCCCcCCQQEQwOwAAKAlAAJAAcACAUwgIIAAwACLgiAZAABIwABJAcNKAABgIIAByQCAAcAASQtIwABJBwBKAADgGMAAS0MAQMjAAEjlC0NBgcAOAIBCA44AggJJAIACQABJEglAADRAAAoBQIKADgKAQstDQsJDSgACICmAAokAgAKAAEkayUAAQw4LgQAB4ADKACABAQAISUAARTPLgiABQAKACgKAgsAOAsIDC0OCQwtDgoGASgAAYBjAActDAcBIwABJAclAADN/RwMAgUEHAwFBAUcDAQCBA0wgMQAAgAECygABICVAAUkAgAFAAEk2ycCBgQAPAkBBgcoAAKAjwAELgmAjgAFACgFAgUuBgAFgI4tCAEFAAABAgEuCoCOAAUuCIBkAAMjAAElDgw4AwQGJAIABgABJ4UjAAElICcCCARABjgCCAkEOAkICgI4AgoHCygAB4BkAAgkAgAIAAElwiMAASVJBTCAjwAEAAcnAgkEAAo4CQQIJAIACAABJX0GOAcECwsoAAuAjwAKJAIACgABJX0lAAEaQycCCQQKLQgACi0MAQstDAIMLQwHDQAQAAkAJQABMhctBAAALQwLBC0MDAgtDQQBACgBAgEtDgEELQwEAy0MCAYjAAEmGC0IAQEnAgQEEQAQAQQBJwMBBAEAKAECBCcCBwQQADgHBActDAQIDDgIBwkWDAkJJAIACQABJgkuCoBkAAgAKAgCCCMAASXoLQwBAy4IgGQABiMAASYYLQ0DBwAoBwIHLQ4HAwcoAAaAggAHDSgAB4CSAAgkAgAIAAEmQiUAAQw4ACgDAgkAOAkHCi0NCggnAgoECy0IAAstDAgMLQwGDS4IgLQADgAQAAoAJQABHSgtBAAALQwMCS4EAAOAAygAgAQEABElAAEUzy4IgAUACAAoCAIKADgKBwstDgkLDSgABoCQAAMkAgADAAEm8SMAASa0LQ0FAy0IAQUnAgYECQAQAQYBJwMFBAEAKAgCBgAoAwIHACgFAglAPwAJAAcABi0MBQEuCIBkAAQjAAEnHC0NBQMBKAAGgGMABQ44BgUHJAIABwABJw8lAADRAC0MAwEtDAUEIwABJxwtDQEDACgDAgMtDgMBJwIFBAktCAAJLQwICi0MBAstDAIMABAABQAlAAEerS0EAAAtDAoDLQ0DAgAoAgICLQ4CAycCBAQFLQgABS0MAwYtDAEHABAABAAlAAEi7C0EAAAtDAYCLQwCASYFMICPAAMABicCCAQACjgIAwckAgAHAAEnuQY4BgMKCygACoCPAAkkAgAJAAEnuSUAARpDJwIJBAotCAAKLQwBCy0MAgwtDAYNABAACQAlAAEyFy0EAAAtDAsHLQwMCC0NBwYAKAYCBi0OBgctDQUGLQgBCScCCgQJABABCgEnAwkEAQAoBwIKACgGAgsAKAkCDEA/AAwACwAKLQ0JBgAoBgIGLQ4GCS0OCQUBKAADgGMABi0MBgMjAAElDioBAAEFyW+TOxOd6RY8AQECJi4BgAOABwEAgAMAAoALLgGAC4AIAQCACwACgAsuAYALgAkBAIALAAKACgEAgAiABIALDwCAC4AJgAwLAIAHAAKADSQAgAwAASiiIwABKRIkAIANAAEoryMAASjILgCAA4AFAQCABQACgA4uAoALgA4jAAEpDSgAgA8EAAMBAIAJgA+ADi4AAAGABQEAAAGADgABKAGABQQAAQEAgAUAAoAOLgKAC4AOAQCADgACgA4uAoAJgA4jAAEpDSMAASlmKACADwQAAgUAgAuAD4AOKACAEAQAAwEAgA6AEIAPLgAAAYAFAQAAAYAPAAEoAYAFBAABAQCABQACgA8uAoALgA8BAIAPAAKADy4CgA6ADyMAASlmKACADQQAAwEAgAWADYAMCwCAA4AFgA0kAIANAAEpygEAgAqACIAPLgCACoAQLgCADIARCwCAEIAPgBIkAIASAAEpyi4BgBCADi4CgA6AEQEAgBAAAoAQAQCAEQACgBEjAAEpmQEAgAyACIAGJi4BgAOABwEAgAMAAoALLgGAC4AIAQCACwACgAsuAYALgAkBAIALAAKACgEAgAiABIALDwCAC4AJgAwLAIAHAAKADSQAgAwAASoiIwABKpIkAIANAAEqLyMAASpILgCAA4AFAQCABQACgA4uAoALgA4jAAEqjSgAgA8EAAMBAIAJgA+ADi4AAAGABQEAAAGADgABKAGABQQAAQEAgAUAAoAOLgKAC4AOAQCADgACgA4uAoAJgA4jAAEqjSMAASrmKACADwQAAgUAgAuAD4AOKACAEAQAAwEAgA6AEIAPLgAAAYAFAQAAAYAPAAEoAYAFBAABAQCABQACgA8uAoALgA8BAIAPAAKADy4CgA6ADyMAASrmKACADQQAAwEAgAWADYAMAQCADIAEgA0DAIAIAAKADgEAgA2ADoAPAQCACoAOgBANAIAQgAqADiQAgA4AAStGLgGAEIARLgKAEYAPAwCAEAACgBADAIAPAAKADyMAASsVLgCADIAGJiUAAM39LQgBAwAAAQIBLgqAmAADLQgBBAAAAQIBLgqAlgAELgiAZAACIwABK3sNKAACgKQABSQCAAUAASuVIwABK5AtDQQBJi0NBAUDMICjAAIABg8oAAKAowAHJAIABwABK7YlAAEaMQ0oAAaApAAHJAIABwABK8slAAEMOAAoAQIIADgIBgktDQkHHAwHBgAtDQMHBDgGBwgAOAUIBi0OBgQFKAAHgLwABS0OBQMBKAACgGMABS0MBQIjAAEreyUAAM39LQgBAwAAAQIBLgqAmAADLQgBBAAAAQIBLgqAlgAELgiAZAACIwABLDsNKAACgKQABSQCAAUAASxVIwABLFAtDQQBJi0NBAUDMICjAAIABg8oAAKAowAHJAIABwABLHYlAAEaMQ0oAAaApAAHJAIABwABLIslAAEMOAAoAQIIADgIBgktDQkHHAwHBgAtDQMHBDgGBwgAOAUIBi0OBgQFKAAHgLwABS0OBQMBKAACgGMABS0MBQIjAAEsOyUAAM39LQgBAwAAAQIBLgqAmAADLQgBBAAAAQIBLgqAlgAELQgBBQAAAQIBLgqAlgAFLgiAZAACIwABLQoNKAACgKEABiQCAAYAAS1ZIwABLR8tDQUCASgAAYCSAActDQcGHAwGAQAtDQMGBDgBBgMAOAIDAS0OAQUtDQQCBDgCBgMAOAEDAi0MAgEmLQ0FBgMwgKMAAgAHDSgAB4CmAAgkAgAIAAEteiUAAQw4ACgBAgkAOAkHCi0NCggcDAgHAC0NAwgEOAcICQA4BgkHLQ4HBQUoAAiAvAAGLQ4GAy0NBAcDMICTAAIACA8oAAKAkwAJJAIACQABLcwlAAEaMQ0oAAiApgAJJAIACQABLeElAAEMOAAoAQIKADgKCAstDQsJHAwJCAAEOAgGCQA4BwkGLQ4GBAEoAAKAYwAGLQwGAiMAAS0KJQAAzf0tCAEGAAABAgEtDgQGLQ0EBwAoBwIHLQ4HBAsoAAOAuAAHLgiAZAAFIwABLkUNKAAFgKYACCQCAAgAAS5sIwABLlotDQYBLQ0EAgIoAgICLQ4CBCYtDQYJLQ0BCi0NAgsNKAALgKYADCQCAAwAAS6NJQABDDgAKAoCDQA4DQsOLQ0ODAEoAAuAYwANDjgLDQ4kAgAOAAEutSUAANEALQ4KAS0ODQIcDAwLAhwMCwoAHAwKCwIkAgAHAAEu+yMAAS7ZCygAA4DDAAokAgAKAAEu8icCDAQAPAkBDC0MCwgjAAEvCRwMCgsCLQwLCCMAAS8JLgQACYADKACABAQAISUAARTPLgiABQAKACgKAgsAOAsFDC0OCAwBKAAFgGMACC0OCgYtDAgFIwABLkUlAADN/S0IAQUnAgYEEQAQAQYBJwMFBAEAKAUCBicCBwQQADgHBgctDAYIDDgIBwkWDAkJJAIACQABL5AuCoBkAAgAKAgCCCMAAS9vLQgBBgAAAQIBLQ4FBgw4AgMFJAIABQABMA8jAAEvrwEoAAOAjwAHDjgDBwgkAgAIAAEvySUAANEADDgCBwgkAgAIAAEv5iMAAS/bLgiAjwAFIwABMAYCOAIDBw44AwIIJAIACAABL/0lAAEaMS0MBwUjAAEwBi0MBQQjAAEwGi4IgGQABCMAATAaBygABICCAAItCAEFAAABAgEtDgIFJwIIBAQGOAQICQQ4CQgKAjgECgcLKAAHgGQACCQCAAgAATB7IwABMFgBKAACgGMABw44AgcIJAIACAABMHIlAADRAC0OBwUjAAEwey0NBQcuCIBkAAIjAAEwigw4AgcFJAIABQABMKUjAAEwnC0NBgEtDAQCJi0IAQgAAAECAS4KgGQACAUoAAKAggAJJwILBAALKAALgIIACiQCAAoAATDrBygACYCCAA0KOA0CDCQCAAwAATDrJQABGkMuCIBkAAUjAAEw9g0oAAWAggAKJAIACgABMWMjAAExCy0NBgUtDQgJDSgAAoCSAAgkAgAIAAExKCUAAQw4LgQABYADKACABAQAESUAARTPLgiABQAIACgIAgoAOAoCCy0OCQsBKAACgGMABS0OCAYtDAUCIwABMIoAOAkFCw44CQsMJAIADAABMXolAADRAAw4CwQMJAIADAABMZcjAAExjC4IgGEACiMAATHaADgDCwwOOAMMDSQCAA0AATGuJQAA0QANKAAMgKwACyQCAAsAATHDJQABDDgAKAECDQA4DQwOLQ0OCy0MCwojAAEx2i0NCAsZKAALgJsADBwMCgsEADgMCwoOOAwKDSQCAA0AATICJQAA0QAtDgoIASgABYBjAAotDAoFIwABMPYlAADN/S0IAQUnAgYEEQAQAQYBJwMFBAEAKAUCBicCBwQQADgHBgctDAYIDDgIBwkWDAkJJAIACQABMmMuCoBkAAgAKAgCCCMAATJCLQgBBgAAAQIBLQ4FBgw4AgMFJAIABQABMuIjAAEyggEoAAOAjwAHDjgDBwgkAgAIAAEynCUAANEADDgCBwgkAgAIAAEyuSMAATKuLgiAjwAFIwABMtkCOAIDBw44AwIIJAIACAABMtAlAAEaMS0MBwUjAAEy2S0MBQQjAAEy7S4IgGQABCMAATLtBygABICCAAItCAEFAAABAgEtDgIFJwIIBAQGOAQICQQ4CQgKAjgECgcLKAAHgGQACCQCAAgAATNOIwABMysBKAACgGMABw44AgcIJAIACAABM0UlAADRAC0OBwUjAAEzTi0NBQcuCIBkAAIjAAEzXQw4AgcFJAIABQABM3gjAAEzby0NBgEtDAQCJi0IAQgAAAECAS4KgGQACAUoAAKAggAJJwILBAALKAALgIIACiQCAAoAATO+BygACYCCAA0KOA0CDCQCAAwAATO+JQABGkMuCIBkAAUjAAEzyQ0oAAWAggAKJAIACgABNDYjAAEz3i0NBgUtDQgJDSgAAoCSAAgkAgAIAAEz+yUAAQw4LgQABYADKACABAQAESUAARTPLgiABQAIACgIAgoAOAoCCy0OCQsBKAACgGMABS0OCAYtDAUCIwABM10AOAkFCw44CQsMJAIADAABNE0lAADRAAw4CwQMJAIADAABNGojAAE0Xy4IgGEACiMAATStADgDCwwOOAMMDSQCAA0AATSBJQAA0QANKAAMgMQACyQCAAsAATSWJQABDDgAKAECDQA4DQwOLQ0OCy0MCwojAAE0rS0NCAsZKAALgJsADBwMCgsEADgMCwoOOAwKDSQCAA0AATTVJQAA0QAtDgoIASgABYBjAAotDAoFIwABM8k=",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "claim_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15663063161611103517": {
            "error_kind": "string",
            "string": "Invalid secret"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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ovt29X22M/mQ+mxpqdnOpOfrs51Jc9dnO5Murs92Ju1an+1M+rI626nOga/PdiadVp/tUlpqqjPP67OlpWa7lJaa6nzv+myX0lJTnZNdn+1SWmqq86brs11KS011bnN9tktpqanOP67PdiktNdU5wvXZLqWlpjqPtz7bpbTUVOfa1me7lJaa6nzY+myX0lJTnbNan+1SWmqq80rrs11KS0117md9tktpqanOz6zPdiktNdU5lPXZLqWlpjrPsT7bpbTUVOci1me7lJaa6nzB+myX0lJTndNXn+1SWmqq8+7qs11KS011blx9tktpqanOX6vPdiktNdU5ZvXZLqWlpjoPrD7bpbTUVOdq1Wc7lZYiZfbZerUlZktLzXYqLVWd7VRaqjrbqbRUdbZTaanqbKfSUrXZTnXuUH22U2mp6myn0lLV2S6lpaY6B6c+26W01FTnydRnu5SWmupclvpsV9JSYarzTeqzXUlLhanOCanPdiUtFTZaarYraakw1bkV9dmupKXCVOc/1Ge7lJaa6hyF+myX0lJTnUdQn+1SWmqqff3rs11KS021P359tktpqan2ma/PdiktNdV+7fXZLqWl5tr3vDrbpbTUXPueV2e7lJaaa9/z6myX0lJz7Xtene1SWmqufc+rs11KS82173l1tktpqbn2Pa/MNl7wrMD5/Wrrgnme7e+Irujnbw/+m3uNKF3/2uyJMMaHSkTGxW2/Omyvx1LFTDuU+UNsjw9xPT7E9/iQ0ONDYocPyTR2mD9E9fgQ3eNDenzjdY9vvO7xjdc9vvG6xzde9/jG6x7feNPjG296fONNj2+86fGNNz2+8abHN970+MabHt940+Mbb3p846nHN556fOOpxzeeenzjqcc3nnp846nHN556fOOpxzeeenzjbY9vvO3xjbc9vvG2xzfe9vjG2x7feNvjG297fONtj2+87fGNdz2+8a7HN971+Ma7Ht941+Mb73p84x3HNz744+q4qcSH+B4fEnp8SOzwIX7r8SGqx4foHh9ienwIMX/Ir8cSLx/C8Y0Px+Mfc+sBf/uQ16vD8YglmMcTFh1c4toY9jBi/H7tPXgnOXgvOfggOfgoOPiwSQ5eSQ5eSw7eSA6eJAcveYUNklfYIHmFDZJX2DD2Cuv2a9W26dfo49hLbC36sdfYWvRjL7K16MdeZWvRj73M1qLnWGej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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAADcxXp7u8\nqLunBDtPVrpHhmxDAUUZZ/S/8LRHsLpl+ywa8Ym/80zlOYBOcY0mTx5wSaAjIwB6mP+HTRf7apAj\negQzsCjQEpzzbqDYldarqy4btEBSEQ9jOqLpCg7lWnvlCUVyfOEQ1cB2tONl9VDkO6iCIHmB4BK0\nUhYRpMhnf3sZhLlsaA58USshObJS4Q4wAOlpi4VIWzNe2Y1F1+GRKRyoOOK49xcULRHUJgs4eHNB\n/QP/3w1A6L7RlRj4QAZRJSGUDeWsfGwy5fkzINf1WiJglaPad8XAhVbZ57pK/qsi8+klG3+rIqUX\nmgCzVr7IGifK3noXW0alJPuy0cS5Gi95ze8OdDrTlJSbYltDWRWC63mkXu5gtTWYWp31tO7CEYam\nKhomthgBuJIKS17FJxkEoB+l1KR2HzrG2mEDyOMPfrHCoPnRIs6C44kp7hbrb7tXfO39axyF5fEC\ntDBPXRmcTpg4I6rAZaHjjEiQfnbGV0qZmg4T+Ww0tGYc45QVIuSmLVifXcWOAD4X0sKeZqqcjXq3\nWBuYEO2nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icBeLX7pkty84W07XnANO\nffS98tL2pzWC4p73hAiC46JREAhmzOvN0rd8TPt/+R2+rZKv2lChktlaXccxjKozEasj2/vxoAUf\nD6XbA3+NQzthfSwP3kdqKEsvEUHPoj0/dy9WqoR2odY8P6XWos0aYYvRdugLGSuHbZfb4Keb8Bqw\nCGgqsrfZGNq8zWBcHLM/zTwcTq+zxiXuhz7nzcSDQjADUBzj0Bl5Dn8DNE0cTEN4c6VvEO6RNxgE\nOk/P0MwEhyHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk\n6o4uDu5wKlMm81nJR8AUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxu\na015bsn0E4YWuRKVxKct3D6sKlhhIGqouj8Jxtki8brbOO2SMJD0RWklAHP22ccwTaWLQikW24Ti\n6tvXLePTAAhzf4dbDP5pRTFyqXoatNS7wgInuB0aR7lCAsIgds1l3WUSycOiIB3X3iva39HM3fgT\ns2tWAfWJlH2qEKartHJkomp7nolAR5y+5xITzRUAAyta8+sj56GT1KZHsjUnMO4rtRHifVR5xoTI\nVzDsdY/JDvS30BegFZH/Vo+Ppwlzc6WhGr1QvvpVMMkLIvQ9cX9ogApWJTKljIRm3uu8Hv6CYiLA\nHkxTW5kciSmpzSrtDUAUY68JIUmm1K0mcmQYN+KntAouYNuMejqvnJtDN+H0JuevSx7tWWkHCzqB\nbT+br7FLRfzln/NHyBsWEyd87YPeChhEIjmZsP14I5oi84XY2zPc+J4cEpHCnr3mBmbzrubXt0wD\n+g4pVwGwu14paA6eetZunwzGA91oou2mcmGxhwrEfx58XC5XjOiQrMy2jgLge/aPVTVwmxXdV0U+\nJiR2eQpsFfDJ/TBG+hhAJNARtwybkMwKZzJwwabd/aHV65Tj4sMFzqY1/YKyh8QIvvth3ZMDb1Rx\nVhtF7OdV51o8CAPu3A4iNLaV1TLAwbiBCjM6TN4ECX1Vz9eYeE9bGM8LmEcOAMSdevszTMeIigjl\nVpe9muc7HAK7rGqNq8V1Yz2am5sSc41XgvE+8AmTh1JC9/qfLmf16kGoqzjqkmpVgHndGgRkMHTZ\neB1j88OU5vryEacs0gw4v3w+t1GtO+KZiCEBHAlIyjrvn7w36UTQRsgyfmlVqv2E6PeLurti1zva\nd14l0OolqX3f1B8SQq8unf3DePHMjd0dr8vA797PorMtKBAoqtx1Nsj14OtC+xqxo1GsW0GdqFah\nvIm0lDIYUvfLAHYXaAmc4dFUb8HF2T8KO2o9Ml9fz2XeBm/nwG55ldcBazN1btkZIJ9Nb1xpPOIS\nQctqyc8U7pzyCvnJ83Em6gMIU1PxSp2rBzzBk7mLR7GQkPwwLqaUFvfU+HMKjogaLESUKWtigfab\nefMtYKTgpFbKL/hvYxhz/mw3BiBl7EAtm+c5KAbUenket2ewpJYNTV7J9tYNWNz+Y4AqqMsQoA6e\nfOievCZP3GlpR5CVadLo3HzKsWxO4cFJtAqHGXu8IO1CrgTw2toWiVQkdyQBK/11f+E0D/PzBUjh\nc8VPLg0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAACAm18dXbYS+/Y8e8++mxohSRLgCaqbCS148nwGGOcGMEZvfTeqyAJojzO39MG\n9ne/tTnD2nFnmTPFve/egukuCgDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04s\nAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJ\niS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "get_filled_order_block_number",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5048864367174250545": {
            "error_kind": "string",
            "string": "Function get_filled_order_block_number can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_filled_order_block_number"
      ]
    },
    {
      "name": "settle",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "settle"
      ]
    },
    {
      "name": "_check_order_commitment",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "255477095918156618": {
            "error_kind": "string",
            "string": "Invalid order"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14563046062317426044": {
            "error_kind": "string",
            "string": "Function _check_order_commitment can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_check_order_commitment"
      ]
    },
    {
      "name": "get_order_status",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6017907102598075401": {
            "error_kind": "string",
            "string": "Function get_order_status can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_order_status"
      ]
    },
    {
      "name": "_update_order_status",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "status",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9169818942746597700": {
            "error_kind": "string",
            "string": "Function _update_order_status can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgMEAicCBAQAHxgABAADgEgdAIBJgEkELgiASAABLgiASQACJQAAAFIlAAAAdigCAAEEgEonAgIEADsNAAEAAigAgEMEAAMoAIBEAQAAKACARQQAACgAgEYBAAEoAIBHBAABJiUAAAJxHgIAAwAeAgAEADM4AAMABAAFJAIABQAAAJolAAACmh4CAAMBHgIABAAKOAMEBSQCAAUAAAC2JQAAAqwnAgMAAC0IAQQnAgUEBAAQAQUBJwMEBAEAKAQCBS0MBQYtDgMGACgGAgYtDgMGACgGAgYtDgMGLQ0EBQAoBQIFLQ4FBCsCAAUAAAAAAAAAAAIAAAAAAAAAAC0IAQYnAgcEBQAQAQcBJwMGBAEAKAYCBy0MBwgtDgMIACgIAggtDgMIACgIAggtDgMIACgIAggtDgUILQ0EBQAoBQIFLQ4FBC0NBgUAKAUCBS0OBQYtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS4KgEUABi0IAQcAAAECAS4KgEQABycCCAAFJwIJBAotCAAKLQwFCy0MBAwtDAYNLQwHDi0MCA8AEAAJACUAAAK+LQQAACcCCAQJLQgACS0MBQotDAQLLQwGDC0MBw0tDAEOABAACAAlAAACvi0EAAAtDQcBCygAAYBEAAgkAgAIAAACFCcCCQQAPAkBCScCAQQILQgACC0MBQktDAQKLQwGCy0MBwwAEAABACUAAAPnLQQAAC0NBAEBKAABgEcABS0NBQQKOAQDAQsoAAGARAADJAIAAwAAAmUlAAAE+hwMAgEAMAwAAQAEJigAgAQEeAANAAAAgASAAyQAgAMAAAKZKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQV/Qb2+oQ8ZRDwBAQImJQAAAnEtDQMGLQ0EBwsoAAeARAAIJAIACAAAAuQnAgkEADwJAQkLKAAGgEMAByQCAAcAAANzIwAAAvktDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAADHiUAAAUMLgQABoADKACABAQABCUAAAUeLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAA14lAAAFrC0OCgEtDgcCLQ4FAy0OCQQjAAAD5icCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAPnLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAFHi4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA+YmJQAAAnEuCIBFAAUjAAAD9w0oAAWAQwAGJAIABgAABGcjAAAEDC0NAQUtDQIGLQ0DBy0NBAgnAgkEBC0IAQonAgsEBQAQAQsBJwMKBAEAKAYCCycCDAQEACgKAg0/DwALAA0tDQoGACgGAgYtDgYKLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAASFIwAABPEtDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAAUeLgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABPEtDAYFIwAAA/cqAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAU5IwAABUQuAIADgAUjAAAFqy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAWXLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAVmKAGABQQAAQMAgAYAAoAGIwAABasmKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z3dbupIDMffhWsuxp4Pe86rHK2qfnAqJAQVbVdaVX33DRwSAjFM42HPqopvUFPmj51fPDMeQzIfs6fFw/vz3XL9a/M6+/HzY7baPN6/LTfr5ujjcz572C5Xq+XzXf/fM7d7AfR7wevL/Xp3/Pp2v32b/QCP0c1ni/XT7m/PsfmQX8vVojly/nM+bO8Q2+YuYK+1E1qHlODQOiRyXevEQmOOLh4ac0ToN/5r3vjPt/E/57Y5QP6D/vsb8Y/c8ecSf4hEbevk/XX/c8ztyebkw7n/AW7tP+Cp/3sr+U9YiUG0Ajl3MnSQClYC+9BGB/f6woXoIOyig+mcbpTPG3vdDU/7m/+P4zV9hVEIJx7tdVmnI9LpGCUdOub27NBlx50ughgwyR+HhWNHgYRit0rdRx8viccgtKUcWj8o5+Mn4y4GBq09tWEeej0Qpb6NCN0JYq9vi41jaMeBGLjfdE+QjGAdwQxGsJJgMoJVBJv5yghWErQYrCQIFoO1BKMRrCSYjWAdQQxGsJIgG8E6gnK1xAiOIGirui8Q5LZeEnvFtAPBYNlMLUHLqCsJRmcEiwRT1zadNt0RJOvFtQRtTVJJkK0X1xK0GKwkmC0GawlaDNYStNpMHUHvbF1cS9BqM5UEwb5xryVotZlKgmirulqCVpupJOgtoz4nuMcSDIuExXJfCUuwhFbEYhmChCVa6ilisblcwpJsghaxWB1LxGITtISFbIIWsVgZScJid2PIWGyClrDYfRMyFkv+BSzB7nCQsdjYImGZ7LcUHlqXsSnyDrBMdWy5jgUtWkQsUx1brmOZbOW/gCUYFgnLVJeK17EEG3JFLDbkSljiVJP/AhaLFgnLZCv/BSxTrfwXsEy18n8dy2Qr/wUstoKWsLBN0CIWG3JFLDbkSlhyMCwSFosWAUuc7M0gFNq2SFHfeM9wqrP5GIaQuH3SJZA7v0k9TvahRTdkiNaX6xlOtdB6Q4Z+qlXZUQwpd89VZhjMy5N99M4NGU724Tu3ZGjzcj3DqS49bsgwWm5Tz9DmlGqGyXKbeoYWh9UMJ/tIslsytNzmCwyz784vhwFDtnm5nuFNxkPg4yYnIRYYxphb9xPj0f3mSkgUuy1hiI5uAMHe/Yzf2f3k3Pd2n7+1+/CV8aNnQ3Y/uNYGBKQTI8PW7Kjtjez4OCaIOxwBuN42UMcdjnzA3/7z/+C/T53/ka/7T+zbzcqIsyudbOjcBoi9b4t+b+hE8jcd4LqxsKGVz4Y3knd0KImivJVT7AqPQOeFR7qwP911kQeNKClEwckiTl3fcwMQSXYvYC9iBpbkH2mVRFkhkn/gUxKRQsSac8oa97K8TWAM3cWNBGcidkEhutA1CqKkEMk3p5REpBB5jaUL/SnmLm9KcH57FoegEWWFKJJClFAj0oAgpxFp6PGFHSiP+a2POBCxQiRnlSVRGi/KcgJYEgWNSAEig9eINJYQNSINcq9B7i8gT12C5vl8YMkX5tyCiBSiiBoRK0TJK0QEGpFizs2kyCMye41IYQmcnFpSatNRSmGgkeen3JUtMqWBRg69giYoNDxecyFYr+bkjYo0qgQqVdKoSGWLVLZYZYtVtrLKVtZcL3CgUmnOq5GpVEGlYo0KUaWi0WMMyAvRjO2KPAdBM35cArkXX7eTFL7Ji9CCJo/XyEvQ6wxo/JgJrLAjl3Yzt3FwUpM+aOTMt6AZb+fCbq+985E04+MN5adoFDR5vAbHz53onUITx2sUuQAqcgFU5AIYFdcnjoyDz+bo7/vt8v5htXhtFLs339ePb8vN+nD49s9L+87DdrlaLZ/vXrabx8XT+3Zxt9o87t6bucPLz8aBORLtZ7nmsLkoc0Ded4Xdu8RzZNdYbSz/Cw==",
      "brillig_names": [
        "_update_order_status"
      ]
    },
    {
      "name": "open_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "order",
            "type": {
              "kind": "struct",
              "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder",
              "fields": [
                {
                  "name": "fill_deadline",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                },
                {
                  "name": "order_data_type",
                  "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                },
                {
                  "name": "order_data",
                  "type": {
                    "kind": "array",
                    "length": 301,
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "filler_data",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089903740940599642": {
            "error_kind": "string",
            "string": "Invalid fill deadline"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5024954142921657308": {
            "error_kind": "string",
            "string": "Not a private order"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6579113687620452371": {
            "error_kind": "string",
            "string": "Invalid order origin domain"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10411837482733946431": {
            "error_kind": "string",
            "string": "Invalid order sender"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13250867036985658079": {
            "error_kind": "string",
            "string": "Invalid order data type"
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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skYHrazQYW6fSgetrNFBK2t00MoaHYGOQgetrNFBK2t00MoaHbSyRgetrNBhbp9KB62s0UEra3TQyhodgY5CB62s0UEra3TQyhodtLJGB62s0GFun0oHrazRQStrdNDKGh2BjkIHrazRQStrdNDKGh20skYHrazQYW6fSgetrNFBK2t00MoaHYGOQgetrNFBK2t00MoaHbSyRgetrNBhbp9KB62s0UEra3TQyhodgY5CB62s0UEra3TQyhodtLJGB62s0GFun0oHrazRQStrdNDKGh2BjkIHrazRQStrdNDKGh20skYHrazQYW6fSgetrNFBK2t00MoaHYGOQgetrNFBK2t00MoaHbSyRgetrNBhbp9KB62s0UEra3TQyhodgY5CB62s0UEra3TQyhodtLJGB62s0GFun0oHrazRQStrdNDKGh2BjkIHrazRQStrdNDKGh20skYHrZynk5jbp9JBK2t00MoaHbSyRkego9BBK2t00MoaHbSyRgetrNFBKyt0mNun0kEra3TQyhodtLJGR6Cj0EEra3TQyhodtLJGB62s0UErK3SY26fSQStrdNDKGh20skZHoKPQQStrdNDKGh20skYHrazRQSsrdJjbp9JBK2t00MoaHbSyRkego9BBK2t00MoaHbSyRgetrNFBKyt0mNun0kEra3TQyhodtLJGR6Cj0EEra3TQyhodtLJGB62s0UErK3SY26fSQStrdNDKGh20skZHoKPQQStrdNDKGh20skYHrazRQSsrdJjbp9JBK2t00MoaHbSyRkego9BBK2t00MoaHbSyRgetrNFBKyt0mNun0kEra3TQyhodtLJGR6Cj0EEra3TQyhodtLJGB62s0UErK3SY26fSQStrdNDKGh20skZHoKPQQStrdNDKGh20skYHrazRQSsrdJjbp9JBK2t00MoaHbSyRkego9BBK2t00MoaHbSyRgetrNFBK2fpTANz+1Q6aGWNDlpZo4NW1ugIdBQ6aGWNDlpZo4NW1uiglTU6aGWFDnP7VDpoZY0OWlmjg1bW6Ah0FDpoZY0OWlmjg1bW6KCVNTpoZYUOc/tUOmhljQ5aWaODVtboCHQUOmhljQ5aWaODVtbooJU1OmhlhQ5z+1Q6aGWNDlpZo4NW1ugIdBQ6aGWNDlpZo4NW1uiglTU6aGWFDnP7VDpoZY0OWlmjg1bW6Ah0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F/4H8161+J3MexXvdzLvVe3fybxXe3An8179xH3M49CrAbmTea+O5U7mvVqcO5n3+sTmTuYC88uZ40OvZ44PvZ45PvR65vjQ65njQy9nPuJDr2eOD72eOT70eub40OuZC8wvZ44PvZ45PvR65vjQ65njQ69njg+9nHnAh17PHB96PXN86PXM8aHXMxeYX84cH3o9c3zo9czxodczx4dezxwfejnzCR96PXN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjlzAUfej1zfOj1zPGh1zPHh17PXGB+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cxrHwnYJHN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjlzGsfktskc3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMV3zo9czxodczx4dezxwfej1zgfnlzPGh1zPHh17PHB96PXN86PXM8aGXM4/40OuZ40OvZ44PvZ45PvR65gLzy5njQ69njg+9njk+9Hrm+NDrmeNDL2ee8KHXM8eHXs8cH3o9c3zo9cwF5pczx4dezxwfej1zfOj1zPGh1zPHh17NPA340OuZ40OvZ44PvZ45PvR65gLzy5njQ69njg+9njk+9Hrm+NDrmeNDL2c+4kOvZ44PvZ45PvR65vjQ65kLzC9njg+9njk+9Hrm+NDrmeNDr2eOD72cecCHXs8cH3o9c3zo9czxodczF5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfMJH3o9c3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMBR96PXN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjlzGd86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhlzNf8KHXM8eHXs8cH3o9c3zo9cwF5pczx4dezxwfej1zfOj1zPGh1zPHh17OfMWHXs8cH3o9c3zo9czxodczF5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOID72eOT70eub40OuZ40OvZy4wv5w5PvR65vjQ65njQ69njg+9njk+9HLmCR96PXN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjF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",
      "brillig_names": [
        "discover_new_messages",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "fill",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "origin_data_bytes",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "filler_data_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "692953268510459726": {
            "error_kind": "string",
            "string": "Invalid order id"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5775299686015755157": {
            "error_kind": "string",
            "string": "Not a public order"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8412360910299423372": {
            "error_kind": "string",
            "string": "Invalid order destination domain"
          },
          "13358931442698543651": {
            "error_kind": "string",
            "string": "Order fill expired"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "fill"
      ]
    },
    {
      "name": "_assert_order_status",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "status",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7354432299782447020": {
            "error_kind": "string",
            "string": "Function _assert_order_status can only be called internally"
          },
          "10883657705690251125": {
            "error_kind": "string",
            "string": "Invalid order status"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bbuM4DIbfJde5kChRh3mVwaLoIVMECJIibRdYFH33VYz40JiyYio7O4V5U9Qxf4v6oiNjSR+rp83D+/Pddv/r8Lr68fNjtTs83r9tD/t09fG5Xj0ct7vd9vlu+PFKnf5oMI3g9eV+f7p+fbs/vq1+aAOo1qvN/un0vwmYHvJru9ukK2U+12N7BdCaKwsDa0VYW+f02do6rzprFwjjgArPxgFBD43/Wif/w238j7E11zr+Rv/Njfhj6PiHEn+N3rfWzphp/yPGNrPRGXvpv9W39l/DV/+bVOLvSAUtmYqOsZOB0q6Qig3GtqUjDOpCpnR46EpH8Jd0kc43DKobfK1v5j8ur+4aRtZ+8ajRRZ7Oe54uAKlzGvqir7FngZosMM70zUJfUbQDslq5s3H6fjpbA5aw9dG2lH2M/ZPhVAZG1sa3xdwOaiBQdRtAtw8GGNRt0hhtCwNtGJo2BL0QrCMYtRCsJOiEYBXB1F8JwUqCUgYrCWopg7UEUQhWEoxCsI4gWCFYSTAIwTqCmWiJELyeoMzqriAY2ngJDoJpZ4JWRjO1BGVEXUkQlRAsEnSdrftqeiLopRbXEpQ5SSXBILW4lqCUwUqCUcpgLUEpg7UEJTZTR9AomRfXEpTYTCVBLb+41xKU2EwlQZBZXS1Bic1UEjQyor4k2GCxgoXCImNfCouVAS2JRUYIFBaUoSeJRfpyCouTDprEInEsEot00BQWLx00iUXCSBQWWY1BY5EOmsIi6yZoLDL4J7BYWeFAY5G2hcKy2F8pjG5dhhTkHWFZatsyjQWktJBYltq2TGNZbOS/gMUKFgrLUqeK01isNLkkFmlyKSy41MF/AYuUFgrLYiP/BSxLjfwXsCw18j+NZbGR/wIWmUFTWIJ00CQWaXJJLNLkUliiFSwUFiktBBZc7GIQb1tb8Mg3bhgutTefw1C70O50qb26XKSOi9206IYMQepyPcOlBlpvyNAsNSo7i6GPHY2gR/3yYrfeuSHDxW6+c0uG0i/XM1zq1OOGDFHGNvUMpU+pZuhkbFPPUMphNcPFbkl2S4YytrmCYTRd/qIdMQzSL9czvEl7qEN/yInFAkPE2LrvAvTup2+CotgdCeN9v0ms9rpxP8J3dt8p9b3dD9/afX1N++Gw5H5Xy7UenFl0SoRwCLvolXeqfzR5wpE3oa263g6OgSKNU9vlXeeIVXFo3uQ2/g+59X1uQZUyELtHg+7PczIWGv+v2tb9T/b/m/O/6u1o74f+N7LIkl21gcRI5g09rFJdh6lViBd9oM+4OC3KbPyh0fbfz2V02mfeAi2IIkOUO/5sWkS35zp0DQuoEYjMqxAW2qZXD9uusygajsjPF4XMqruCCBkizchTAI57mWUtaLsvF72+FGV+GSmIIkNkLUOU2Sm8IEKGyHFSytQnjKZvji7X8AUPHJFniDKvaU2LMlvqFkQcEDHMF0XFoBczRziZfhJkEEYixxCB4ogsRxQYokx1L4g4ICwHueWkhBzkyEGOHOSZ+Kxx3fzGBD0SBYYoEz2aFmV2cS+IHEOU2RehIIrzRVopRqebVJ6j0pqlYqVFDy/TnLEbz9uRhu6jYhffit6NNWG+hu7WCho3X5MpsJPj8vQRslSRo8p0hiUVJ610m6VipaVZaWlWWoAsFSstw8pXZgFsQZVZH1pSOY4KFUuFs9uYzEHfEdrQQbRjDaNd0nQtnk4nMHyjJ6IFjZ+tyRxvO8kgc6DrtEYz0qHff03jhVYTzUhDj34LGk46sZAfQmPmlzewiqHx8zUIDM38PhqcYWgY6TDGAsAYC2SOICpoZpaDz3T19/1xe/+w27wmxenm+/7xbXvYny/f/nlp7zwct7vd9vnu5Xh43Dy9Hzd3u8Pj6d5Knf/8BGfXELDp89NlcmidZhBNE3K6m6JqEEJKNaX8Lw==",
      "brillig_names": [
        "_assert_order_status"
      ]
    },
    {
      "name": "_emit_open",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id_bytes",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "resolved_order_bytes",
            "type": {
              "kind": "array",
              "length": 613,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13459246948365409099": {
            "error_kind": "string",
            "string": "Function _emit_open can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_emit_open"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZRcx3Ul+BO1AJVAoZIASZAEuIGQuEu51uK1ZImSRYq0NkvW7qzKTIoWSIAASAEkAP5CFUAIxEpSpGTLm7wvsuVVXmTN6Fjj02O3Pe7RsdvubndPd8+Z6Z6Z9nSPZ3rsPu7jxif/y7x58/34PytfFJIE4hygfv6IuO/FixcvXiw/Ihd0Qi7+OxoMEATk2pte/TsR/14H8SMX/83Hv4uDhdIE0bXEny3OzU0o5TPkvzIRY+b84BcF35P8i+tjnM+HHXwsi9DdcPHfRnh+Mujoh6/yS/35LP9WR5lFd94aBu3QoVuqzE5XyrPT5XKjWaw3pmdac5WZYmWhVplbXCgVK7XybGOmXikWm5XmYrXYmJ6rNZr1uVqltVCfmxbst6nYlebCRahafXp2odSqT7eKC9WZ2Uq9NTPTqDfmqs2ZWrFRWpwuLZZLrdnZeq1WX6zNlUqt5lytNdvGvi/0IrOy4L/dC36lJvjvAPzRwLZNReG7/eC3bdo7/eC35X+/F/l3+H8gxg8Ce9m/ywvvpTb+g35kUxX8h/zgVwT/ewA/5wH/3X7w27rzHj/4bd1/rx/5twT/fTF+ANil2Uq5PFOZmynOzTaKpWpjsTx70fovVIuLxfpiuTlXLc21quVqZbGxuDBbna2XWsVWfXGuNfsquGC/X8Eu9hdK/EKwv9eLXCptvf9A6KNeK+0+64P9y6aUhi7Y39c/dlpo91UfSsZetdoI9ocV7HK9slicaxXrtdn6THO2dtHNKF58WJhttqbL9YWLDke5USqVmtWL/5WbjercQmO6tDDdnCnXFi6Sa8vkI6EPfSktCv5HjfGn68W55vT0jOB/zBh/YWF6pn5RnoL/cWP8yuJ0s1WZaduxTxjj12vVVqtWqQv+9xvj10rFZq0809bNujH+3EKxNj0729afBWP8i/5ypTFXXxD8RWv5LDSLi43S3GSM04jxhUYUhHbTmHYc5nJEL4jx+Z3QzxOv1v5kjughPw14J+MukV0r7OW1oMShjeG4EeWd0NGwPmaI9XFDrE8YYn2/IVbdEGvBEEvatd+2Vm33oy0v+JVZwX/YC36xKfif9IFf6vhejwB+YMd/G/8HAD/nAf9TfuTfxt/tRz7t8dijMb4P7Mf8yKbtg+3xg98ec+z1g9/2UR/3g9+2Dfv84Lfnzvf7wW/7qAf84Ld9vCf84Ld91Cf94DcE/9Ne8Ett+RwEfDvbWW7btkNe8Ctt/Kf84Lft29Ne8Ktt/MN+8NtzNkf84Lft81E/+G37/Iwf/LbvE3rBr7XHyEte8Kfb+nPMD357rnjZD35bP1f84Lf187gf/LZ+nvCD3/YfnvWD3/YfTvrBb/sPn/GD3+6/TvnBb/fvz/nBb/fvp/3gt+3bGT/4bft21gv+TLt/P+cHvz0He94Pftt+XvCD37afz/vBb9vPF/zgt+3ni37w2/bts37w2/btJT/4bfv2sh/8tv35XIwfrB67wi+ivULRPqFtW1/F23Tx3+YY++Hmge/avWfxUw898ehCcx/OSEsJg6B7plpGPhwi1C0d1LfueezAvvrigbc0Gvua+/czwjoFOUhAzQPqJ+uPPPbORhI/faJ9oLlv/yN7HmO00Yxosh9qDNIb+qzFyRhvnPhD2utJCja0Sw2t5lnKSD9PvBqPv0s5oif8sHxw3SKK26DwWlDiuA43KHQ2KHQKStxKaId1zhDruCHWGUMsyzI+Z4h10hDrtCHWCUOsg4ZYlrJfMcQ6P6RYS4ZYljqxYohlqV/LhliWbdtSJ44ZYlna6BcMsVYMsSz7Dhmb+PWtirOTCm0JEoffYqBPxYE9ceQ7wr9xaweX00nYBPT2H3ps8aE9B5r7A0eGKMhGfH4/bMJjhzCfoQxBkC7YUgbBsgOPvE0SJubNKVjaEIeVGWU+nsADYkhdoSNsOIioZCkH0l+rQYRmJLRBhMhnwo98yjnCR34mFPmwDnPdRf/kw6AxwML0+BEZpsdnyY/v/jL+Wwh625F8nJBT4kaUdyLfSObfpLJh3bCe+qmHaimrngr9fOCz3XT0VNMLrTObCHrr2XJjVZZ61WzbRiVOsDbFv1FPMX0eyojp8Vny47v/Pf5bCHp1mvV0o1IefId6+q/j54mE8szHv4sDhZkZrZ/idoBystwonrUdCP184FPvOu1AqyfNnojsNim8FpQ4nvTZpNDZpNApKHHsiA6CdcYQ65gh1ooh1vkhxTppiHXaEOuEIdZBQ6xThliWej+M8nL1g/1iRcFSVy8YYj1riGWpq5ZlXDLEGta2/ZIh1iFDLFmEZT9T8KMwEfS2PeuxG9KTcuA7pJ8nXm356fhKmlw1n1bkM+lHPm1+JhV+JhX5SF1uVuIEayr+jWMGTD8JZcT0+Cz58Z0MAAuEGQUeM2xWyoPvcMxwd667bFg3rKc+6wHpCd/4DunnA5/tpujUC639TwS99Wwon2KWekV+pS6nlDjBko+gUE8x/WYoI6bHZ8mP776T9BR1mvV0SikPvkM9nSM9xbphPfVSD6VWZj0V+vnAZ7vp6KmmF5OKHCeC3no2lE8xS70iv1KXBSVOsK6Kf6OeYvopKCOmx2fJj+8eJD1FneaPwwpKefAd6uk7YtyJhPLMx7+LA4VaVatLO/yZ0qRSTm5nKGs7va5kbmdCPx/06oWPdnYV8ZOkByK7LQqvBSWOdWSLQmeLQqegxPG4ZhCsFUOsg4ZYxwyxThliLRlinTTEes4Qa8UQa9kQKzTEOm+EpdnnQfg6Z8RXFC4YYlm27ZcMsSxtoWV7PG2IZVmPLxtiWeqEpeyt2nZgXEZLnThjiDWsdsKSr8vBZ7rSp1062Vu2x+OGWJZlfHFI+bL0JyzLyOsDOLbMxX8ngt62ZzjObuaInpQD3yH9PPFqy09nnK3J9SpFriK7rQqvBSWOx9lbFTpbFToFJY77jEGwVgyxDhpiWZbxpCHWaUOsC4ZYlrJ/yRDrSj32h/WyIZalTiwbYp0xxFoxxDpviGUpe0tdtZT9sNovS11dMcR6zhDLsh4t9cuyDVnq1zlDrCVDLMsyrhhiWbZHyzJa+hPDWo/D6su9aIg1rH6OpY95xZ94fbQhSzthyZeVfkXPPK86CF/PG/EVBUvZW/oAKzEW73cT/Cj4nUMrZ95jy3NoXvZgpcyhaXvrJoJePTSUTylLPSO/UpdXK3GCdU38G/eEYfqtUEZMj8+SH9+9JRZKgTCjwHvCrlbKg+9EvtGesG+Nf0wklGc+/l0cLMzyfKjQQNooJ0O9y3SJBNLPBz71rtMOtHrS7IvI7hqF10LQqzusD9codK5R6FzBGi6sdxthuWyYxEdhQslnbW+RnpQD3yH9fODVLpRcctXspcjnWj/yae9Rvlbh51pFPlKX25Q4wbou/o39Eaa/FsqI6fFZ8uO7JvVH2yAtt4FtSnnwHfZHn1jXXTasG9ZTP/WQ/ZsPoZ8PfLabjp5qeqG1/4mgt54N5VPMUq/Ir9TldUqcYF0f/0Y9xfTboIyYHp8lP77bT3qKOs16ep1SHnyHevpo/GMqSG6fWdoz4mp2m2WI+bg9eKnvUrOYtT0I/Xzgs3122sO2jHIV+VznRT6NVhb9QX6lLq9X4gTrhvg3tgdMfx2UEdPjs+THdyvUHrDtcHu4XikPvsP2cJTsNtYN66mXeigWW1n1VOjnA592sqOnml5o/d9E0FvPhvw0s9Qr8it1eYMSJ1jb49+op5j+eigjpsdnyY/vnic9RZ3mb/VuUMqD71BPT9N4l8szH/8uDhSaJa0u7fDrxQlF1nb45fZl9du94C/MCv4OP/jTgn+jF/zZdv3e5AW/1pbPzX7wG4J/ix/9afN/qxf8SkXwd3rBb7b5v80LfrWNv8sL/kK7/b7BC/5cW//f6Ec+7fq93Qt+qyb4d/iRT5v/O/3w37b/dwO+5VyE4N/rBb9YEXncE3TCiFImoS++yF2QPpfwV7A4TmjlCcuX36eVDfnncd89wA/KIAnrnj6xJpQ4H3V6t6PcSH/SwSuXIwp8Bs5qZRKFZUOsZwyxzhlhab7tIHw9ZcjX9UZ8af7vIFjbDbHGjLCiwJceDsLXDiO+oucbhxTrJkOsmw2xbjHEutUQa6ch1m1GWFHgy64G4WuXIV9nDfl6gxFf0fMbDbGs+o7o+XZDrDsMse40wooCz50OC5asIfud76rO+Z3vqtT9zndVG37nu2oVv/Nd1Rm/813VRfHVpT8UGqhbt8B7u3FFNfO3oEI/T7za8tMZ391C/LB8eP/OrQqvBSWO2+itCp1bFToFJY738g6C9YIh1pIh1ilDrJOGWMuGWAcNsZ4zxFoxxDo/pFiWunrCEGvFCCt65n57WHTVsj1eMMQa1vb4vCGWZRsaVtk/a4hlaScs+9oVQyxL2VvKa1j1y9I3WTHEspT95WAnXjLCip55DDsIX0cM+dpuxJclVhSeDu342mHIl5XsoxAaYlnqBM+lD4I1ZoQVBSudiMIzhliHDbEs9cuSLytdHWZbuNmQL0tdtaxHS7s6rPKy1FWeWx0GXY2Cpf162RDL0v86bohlOaewYohlOVawnHsU/17msW+CuFz81+8aQHHVawA3+eHHuQZwkyJXbT+sIT+NLPWM/Epd7lTiBOu2+Dfu7cf0t0IZMT0+S3589xNxxRUIMwq8t3+nUh58J/KN9vb/8Eh32W6BdKynfuoh+x2wQj8feG03JZde3KLIUdMLyVtQ4tinz1pfWt3z3rdBsM4YYh0zxFoxxDo/pFgnDbFOG2KdMMQ6aIh11hDLsg1Z1uMLhlhLhlgXDLFWDLEs9cuyDVna1ctB9s8ZYlnaaLGF2ndUhv5HUfvOyRC//c3BbQ5ZIH3eiyPx2l/B4jihlScs47KVXGVD/rme0Q9HGSRh3dYnlvZtnI863ekoN9L3+y1grez3W8DatN9vAast0fk3gDxzJLvbvdTlbOazVIR+nnj11aZuJ35YPtIORHZ3KLwWlDjeu3eHQucOhU5BieN+exCsFwyxlgyxThlinTTEWjbEOmiIddYQ65whlqXsh1VXLxhirRhiWeqXpc05Y4h1Ocj+OUOsFUOs80OKZdm2TxhirRhhRc+8L3dYdHVYfQBLrCv99pV++7XSd1zpt6/021f67den7IdVV583xLKUl6XNsZT9s4ZYlm3Ist9eMcQaVn91WPXL0vddMcSylP3lYCdeMsKKnnl/ziBYOw2xrObJo+fbjLCiwHuPB+FrsyFfR4z4ikJoiPWMEVb0zOtfV2TvLiN/OzEI1nZDrB1GWFGwlNcbjfiy1NUoWLahYdX7YS3j690WWvIVhSt9x2u/74jCUSOs6Nlyz4OVvKLnGw35OmzIl1VfGwXL/tFSXsPYd0ThZUMsyzHfcUMsyzWdFUMsy/kJy/05/H0b7g3LxX+18+IjOvPx7+JgoZEjelIOfIf088SrMT8ll1xvV+SqnXdvyM9ijvCRnzsV+Uhd3q3ECZack4nft2H6O6GMmB6fJX/Xu3jSpUCYUeDv27Sz0vGdyDf6vu2/jHaXDeuG9dRPPZQzf98m9POB13ZTcumF1v41vZC8Wn1xv5+1vjSsk4ZY5w2xjhlinTHEesEQa8UQ69yQ8rVsiHXQEOslQ6xDhlgvG2JZyuu0IZZle7xgiLViiGVpCy3r8bghlqXNsdSJ5wyxLGW/NKR8nTXEstQJS9/Est+2rMdhtV+W+mXZHlcMsSxttCWWpX6dMMRaibFkvILjm1z81/MdcNUc0ZNy4DuknydebfnpjPU0ud6pyLWf+8WiZ8s7m9g2D4J1xhDrmCHWiiHW+SHFOmmIddoQ64Qh1kFDLKu7kaKwZIhl2R4vGGJZ6pelvE4ZYlnql2UbsrSrljqxYog1rG3bsj1atqEXDLEs2+PloF/PGWJZ+gDS107Fcehv3xp00+nX58f8km5SyZeL//q9w3cu83kdQj+vyMSHz39PRrmK7O5VeC0ocbx35V6Fzr0KnYISx33TIFgvGGItGWKdMsQ6aYi1bIh10BDrrCHWOUMsS9kPq65eMMRaMcSy1C9Lm3PGEOtykP1zhlgrhljnhxTLsm2fMMRaMcKKnvm8jmHR1WH1ASyxhrXftpS9pQ9gaaMt/Ylh1dUr/fal69Ou+OT9YV3xyS+dfl3xCy+dfg2jXxgFS3kNq64+b4hlKS9Lm2Mp+2cNsSzbkGXfsWKINazjoWHVL0vfd8UQy1L2l4OdeMkIK3rmPU6D8PW0IV87jfiKnjcbYlmuD1nK60ZDvkIjvqLwjBFW9Mzf9A+DTkSBv20eBtlbtm3r9mjVhqLn24ywomDZHi8H/eLzhgbB2m6ItcMIKwqW8nqjEV+WtjAKljZ6WPV+WMv4eu9rLfmKwhXf5LXfd0ThqBGWpT8RBSt5Rc+WPvlhQ76s+tooWPaPlvIaxr4jCi8bYlnOKRw3xLJct1oxxLKc/7LcX8jnDW2GuFz8V/b5oq2L6MzHv4sDhVLm84aEfj7o7avs+Ons870u6JXrZkWuIrvrFV4LShyPja9X6Fyv0CkocbzmOwjWGUOsY4ZYK4ZY54cU66Qh1mlDrBOGWAcNsc4aYlm2Ict6fMEQa8kQ64Ih1oohlqV+WfJlWY+WfFnaCUudsKzH5wyxLO292FXxrdgnmI9/FwcKtZr4JujLiE81EfT6JoZ+3WyO6Imc8B3SzxOvtvx0/Dqt3lA+7NfdoPBaUOK4Dm9Q6Nyg0Ckocdw2B8H6jCGWJV9njLCi54nABsu6jAcNsZ4zxDpviHXCEMtSXhcMsT5riHXWEGvFEMtS9icNsZYNsSzL+JIh1iFDLJnnY98iCvPx34vdYWV2ulKenS6XG81ivTE905qrzBQrC7XK3OJCqViplWcbM/VKsdisNBerxcb0XK3RrM/VKq2F+tyMX9+hNjcR9Np4Q9+kJPjb/eCXBX+HH/yK4N/oB78q+Dv94NcE/zY/+NOCv8sP/ozfsw9Ks4J/rx/8dvt6kx/8uuC/2Q9+Q/CLfvCbgl/yg98S/LIX/HJR8Ct+8Nv2s+oHv20/a37w2/Zz2g9+237O+MFv289ZP/ht+znnB79tP7/FD37bfn6rH/y2/fw2P/ht+/ntfvAXBP87/OAvCv53+sFv2/95P/ht+/8WP/ht+/9dXvArbfv/Vj/4bfv/Nj/4bft/nx/8tv1/ux/8tv18hx/8tv38bj/4bfv2Tj/4bft2vx/8tn17wA9+2769yw9+27496Ae/bd8e8oPftm/f4wW/2rY/7/aD37Y/7/GD37Y/7/WD3/Y/3+cHv+1/vt8Pftt+fq8f/Lb9/IAf/Lb/+UE/+G37/H1+8Nv2+UN+8Nv2+cN+8Nv2+SN+8Nv2+aN+8Nv2+WN+8Nv2+eNe8Gtt//MTfvDb9v/7/eC37X/dD37b/i/4wW/b/0U/+G373/CD37b/TT/4bfvf8oPftv8PB53Qwa40Fy4utdTq07MLpVZ9ulVcqM7MVuqtmZlGvTFXbc7Uio3S4nRpsVxqzc7Wa7X6Ym2uVGo152qt2Tbvn1SxBwmddZFHfMil1GrbhR8A/JwZ/7Nt/E95wS+229VuL3rT4f9RL/JvtO3+Y4Gx7pSKxehe0NPrX8WaAtlLOdZTncheoDF4/lTYnUbiMf2f5F/9G9E7H4NOUp4Anicov22dleZyRC8gWgHRzyuy8bHPaYT4YfnwPqdRhdcCxUWB171HFTqjCh0N62VDrIOGWGcNsVYMsU4bYi0bYp00xLIs4wlDrGHVryVDrHOGWBcMsSz1y1JepwyxLPXLsg2dMcSy1IkVQyzZDzkR6H3hfPy7OFCYnpW+Fn13CRKHvjf30T8A6d8WdtJxGKHfWKYNF/+9ZWsHl9MxP+jLPAL4mpwkaPvaLX0cwV/vB78iOjUedMuUy7Q+QVYSr/0NAt0/FFr5oFfuPvxDrWzIP7eXceCH97prWON9Yk0ocT7qdMxRbqQ/6eBVK8coyUSzRzlFJvJ+vYMvTD+l0Ja8IsMNEGcow7JLhtgWhf4meG40F554+F17cEqknR/lIHK7jtLdH3bkwDo4noAV0G/+DmYE8DD4HTNe2n5A3vXbD6CteoTiVmv3osC2QavDqH7/2jG3kKRDWecWJP3frO/Q+3/i541Ac6OD5iaKw/RRuJ/oT0LZRpQ0G4lHSf+3MV9R/b0nrj9NdsLPBOV/PemylKlfXcZ6RN4QU3SH6zapXkY3dHh5/9YOz0xvU5BcDvn9sEJPeJ+itFGQOi7Ae8M5rsx3sQn9PPFq3A+1fZgC8cPyEV3bBHLcvafeeGt97/4ndjfXkSj5+COBLxCcpMG0GArAEqbn/Kyq7wp783EQUU4Fvc16inhC/BHlHZveKYU3UXORzV2xmkdm66r4eTLQ1TgKE0GvbA1VYTGragr9fODTHHZUczPxkyR7kY+nprKQC3qbxYhCU/iVuiwocYJ1VfwbTSSmn4IyYnp8lvz47uZYnwpBb/N+IOzmQWv6+E7kG+np9THulFKeSSqbVm/asS8FJT/LEHXykbA7blQpm8SNOeLGHXHrlXJJ3AbI9ynKl1cwIzpPbujgJckG9UrcF802JdnWJKz7CAvzFwjrqhSshwgL819FWFtSsB4kLMy/hbC2pmA9RliYfythXZ2CtYewMP/VhHVNCtZewsL81xDWtSlYjxMW5r+WsLalYO0jLMy/jbCuS8HaT1iYn4/1uz4F6wBhYX6+hu2GFKwnCAvz87G321OwniQszM9H8e1IwXqYsDC/5J1UsNgP8PPJYnY/QOjniVdffsCNQa9cUT48HLpJ4bWgxLHdukmhc5NCR8PaYoi11RDrakOsawyxrjXE2maIdZ0h1vWGWDcYYrHdSuuv3xu++tfVX0s+1F1MNwJptD4aMZL8ARyz4fsdGcqD71g2OxLoJfGHspHxpsv/mKJ8Gs9TKXRcPEs6zWfeHXbH4RQ7+7c4Hcx+OE6VFyhuvVIu9pmxXtlnRrmhzzxG5TkUv/c7HVcsYh0myQplnEv4GwTZpmsx37o1oBOF7wv909HKM2lIB7HeFnbTWfspvmIzSzmQvu8pPpHFFocstnqhXc083bmVZLHFkyxEL9PGbbykqI3NtL4Ep0cfbh64uEj3XYfeX38YVyTRrDI73CwK9PuqBLbmKd1W+i3uH/OBWBiYD55+5fTzKenxeVR5HwVtWMvTsFq14TvXNOw1DjpbBqSzRaEjTQtdXB87Nzyd8tde5demErBMQn9SkVM/ph1p5YPeOvJhBrSyueoZhxhZply29Yk1ocT5qNNrHeVG+pMOXrVy4Gox2rkd8bGCkVv307TUwfYB5eBn91hlOqs+Cv212mmedaeL5qpL3gLFRYFv6tB2nYwpdDSsM4ZYzxtinTbEWjbEOmiIZVlGy3q0LOMxQyzLMj5niHXWEOuUIdaKIdYFQ6yThliWOmHZHi3bkKVOWMrrhCHWeUMsS9kfN8SylP05QyxLeVnawiVDLEt5DasttJSXpc25HHwmS51YMcSykn30PBHYYEXBUu8tZf+sIZal3luW0dJOWPoAlvJ6yRAry9fYOQVL3mtfsGjzUpfLFyw1SmfxBUuN3o0E+hcs+MUEz4cFkN7vfGylnCN6XMaA6OeJV+P6d97up8179nu7H9+0PSw38lnehGR5+9opQ6wVQyzLG60sb4Wz1AnLG8Asb+2y1AlLeZ0wxLKU13FDLEt5PW+IZamry4ZYl0M9Wt6QOay3gC4ZYlnKa1j7IUt5Wdp7S/2ytDmW7fH1fgNr9MxzMMOi95ayf9YQy1LvLctoaSeG1f96yRBL5mC0T4n4EwZtDHudgw7mvy4DljYelvTap0euuR7t0yO/t6R15nq0+tA+X1rNXI/IrUTpeK4HbdsNCVgB/S7Ru6S5nrH4nexbOhcbT5Gvp/1o6lZz3q+Ie0Z5X2S/n9pqnytrdLYMSGeLQsevLPs/RYM/m8ATdfkTh08BFp6CwmGEfmN5o3bxwT5O2MD6eCQBc0xJu47iJO2PT3T4WIz58LvvcO3q5L6wk46DVidS3kgWrQHrhPe/It/a59JZPuPGd9y2tM+4NTq3D0jndoXOpJIvl/BX6PA7pqPx7JpvXy0dxJI27Hfuvn/9Zzmj/vPeXDyhm0/Rw9O1cR2Ig9Y2RBZRvp/P0Db8rjetnQz5kzeUIbZtDpoMRRZZZTgV9MqQ2/ZmpRxau0eM1bR7jYdh6ye2UBzW8VaKwzq+muJ2Ax3+JO5RyMdrWY9B3BjF7YE4PglxL8RtoLjHIQ7rmkNaf/YXffRnqDdZ+jPtCBXB9ftJWaWSxe4j/TzxastPZx1U+0RYO7lTZHe1wmuB4qJwOOyk47gR5d06B9ZJQ6zzhljHDLHOGGK9YIi1Yoh1bkj5WjbEOmiI9ZIh1iFDrJcNsSzlddoQy7I9XjDEWjHEsrSFlvV43BDLsh4t7ZelvM4aYi0ZYlnKy7INWfoTlvI6ZYh1xa5eOrtqJfvomddBh0XvLWX/rCGWpd5bltHSTpwwxBpWf/UpQyzxVyUfjvFxzdLzOQbtW0Wv94PfPifBtZaL9HlML/HaX8HiON63fbWfsjn3bbv0AOfGsxwRel2fWJfyPBOUNZ9novGqlWOroUyy3ICizS31W7euI1s9t7H2noKtDjkh/UG+HylTuvvCjhy47rYlYAX0u0zvkvYUTAW9dbo+gU+hy+9YVzD/qIPOhgHpbMhIZ2pAOlMZ6WwZkM6WjHSu1E83nUtZP2KH8cwiWbeNbODBvE5zDGjiWU28Z0LS/zLchvt0PrmMOSo/9uGy1uL3Bq7+18lYlnxrdAB/MWhrTFKmfm+KwW/0+KYYwcQ6w5tixiAe05/Md3j52nYdMweY+K0i3yIkbTbpFiHmQdKfBh7kFiHGHE0o13gC5hdBF8/ldcxAwdTKtYHKxTysJx4k/QtQrq/DJkVMg3QkPBp285ZXaAUJ79im5RPiXHTT8kbPGwmD9yywvm6i9JI/SaasK5L+Cw5dGVN4wPJyvTIPnGZDAg8/pvCAx1Yu7tl7KL7VJ6CApjun/Oaq5CoYU3CSgoghKt4X8zqO/HapH3bF4wqNDQk8Yt5IPGLiGs3dzQPNBAGtI7DRBGLrAj34ve3TT7+h7a9A28tB61OkvJF8vrG9g8vpJGi32F3xq5LpaH4VY2n+UhSaYSce0/8u2JFvbtcx1yVgyjUyrj5N25sk6bUxo8vnRn3kcbpGG2XJdvfqPnlNm29YT7xqY9GsvN4Xri2vo33yukGhjX3PReP6yJPNfQ/tOdA+RTtQ2AjoeYLesRnm/mI8gdVNlG4z/eZjldm8X0W/8wp/WhA+MDAvI0F6kCYqsvojaKJ/ntBEg0BvoqL2PPzCvDj8EpV4EtLxMPrTVB5MjzQl/UGgo7k4T1K5Jf03FRdHG5oLPxOU37bbnZkTGR4KeoPEPQW0eavY05D+rWEnHQeta5UyRbIo9TFcw3pE3hATuwys26R6+VdQL3yxJ9L7dJBcDvk9ptBjWUp8FKSOn4b3dnVcq+eInpQN3yH9fNArWx/T/E8TPywfzQw7LvY8BM8I/yGCkzSYFsOHgCVMz/m52q9X8nEQUY4Rz1K+yJz8ezJb2PS5e0AeRpR37G2NK/xrdDYMSGdDRjqv5fJkuQByRCmrdjkkX9a4B+L4Asi9QW+5eIe2hrnPgbnfEXfAEfeEEheV88imDo/cvWhNnS+VxLpLatdJWPcRFuZ/mrAOp2DxpZKY/zBhHUnB4kslMf8RwjqagsWXSmL+o4T1TAoWXyqJ+Z8hrDAFay9hYf6QsJZSsPhSScy/RFjHUrD4UknMf4ywllOw+FJJzL9MWCspWAcIC/OvENbxFCy+VBLzHyesEylYfKkk5j9BWM+mYD1MWJj/WcI6mYLFF71h/pOE9ZkULL4YDfN/hrBOObCiZ/nae0rJf4qwnkvB2k5YmF/yTipY0g+JO3ka3tu5b6XMX7kI/TzxastPx508HfTKFeXDQ5czCq8FJQ77IoxDOmcUOhrWIUOspw2xDhtiHTHEOmqI9YwhVmiItWSIdcwQa9kQa8UQ67gh1glDrGcNsU4aYn3GEIv7MpdfHz3LqSsuv17yoT3j6a4RyoPpESNp3DAS6OOB5zKUB9+xbJ5LoJfEH8pGLn4edJwSPe8krNWOU6Ln2whrteOU6HkXYa12nBI930NYqx2nRM/3EtZqxynR85sIC/OzbU8bp3w67MbC/P2OUz5CWKsdp0TPbw66sVY7Tomei4S12nFK9FwirNWOU6LnMmGtdpwSPVcIa7XjlOi5SliDjFNqhOUap5xOwZomLMx/mrDOpGDNEBbmP0NYZ1OwZgkL858lrHMpWHOEhfnPEdb5FKxvISzMf56wLqRgfSthYf4LhPV8Cta3ERbmf56wXkjB+nbCwvwvENaLKVjfQViY/0XC+mwK1ncSFub/LGG9lII1T1iY/yXCejkF6y2EhflfJqzPpWB9F2Fh/s8R1udTsN5KWJj/84T1gylYbyMszP+DhPVDKVj3ERbm/yHC+oIDKwrfG3ZjYf4vENYPp2C9nbAw/w8T1o8E7jK+PejGwvw/Qlg/moL1DsLC/D9KWD/mwIpCK+zGwvw/Rlg/nsLXdxNfmP/HCeuLKVjvJCzM/0XC+okUrPsJC/P/BGH9ZArWA4SF+X+SsH4qBetdhIX5f4qwfjoF60HCwvw/TVg/k4L1EGFh/p8hrJ91YEWhGXZjYf6fJayfS+Hre4gvzP9zhPXzKVjvJizM//OE9QspWO8hLMz/C4T1iylY7yUszP+LhPWlFKz3ERbm/xJh/VIK1vsJC/P/EmH9cgrW9xIW5v9lwvpyCtYHCAvzf5mwfiUF64OEhfl/hbB+NQXr+wgL8/8qYf1aCtaHCAvz/xph/XoK1ocJC/P/OmH9RgrWRwgL8/8GYf1mCtZHCQvz/yZhfSUF62OEhfm/Qli/lYL1ccLC/L9FWL+dgvUJwsL8v01Yv5OC9f2Ehfl/h7B+NwWrTliY/3cJ66spWAuEhfkl76SClYv/yjrX78F7u3WlailH9KQc+A7p54lXW34661y/F/TKFeXD61xfU3gtKHE85/g1hc7XFDoa1mFDrCOGWEcNsZ4xxAoNsZYMsY4ZYi0bYq0YYh03xDphiPWsIdZJQ6zPGGKdMsQ6bYh1xhDrrCHWOUOs84ZYFwyxnjfEesEQ60VDrM8aYr1kiPWyIdbnDLE+b4j1g4ZYP2SI9QVDrB82xPoRQ6wfNcT6MUOsHzfE+qIh1k8YYv2kIdZPGWL9tCHWzxhi/awh1s8ZYv28IdYvGGL9oiHWlwyxfskQ65cNsb5siPUrhli/aoj1a4ZYv26I9RuGWL9piPUVQ6zfMsT6bUOs3zHE4jnHtH1yi/Gza5+c5MN5J/40c4TyYHrESNqHNxLo++u+mqE8+I5l89UEekn8oWwa8bPFvr8mYQ2y769FWJi/331/1xOWtu9vSsnH+0SfctCJgmuf6FMOOl8dkM5XFTrad4q7w+64EaWs/J1i9MzfPu6BuEMUt1cpF3+niG2Ev1NEHeTvFFGn+DtF1BH+ThHrHL9TlO9xRUZh/H6Cyiaymo9/FwcM2u2KLEest1zC3yDorkMJrB+Yb90a0IkC31q0VuU5ZEgHseSYA6394oliq2m/mP+pBCw52iAK8o0vttMxSv98rMvRt8J/SUdtaHvUR+Dd/Y6ySl5pI9y/zce/i4OFkuAf9YNfcfWPWCa2KSi7fvQLaeUJy1p2rrIh/6yH2F9n8SOO9Ik1ocT5qNPDjnJrfYjGq1aOpLaJdPKKTCT9UQdfmN7lP4kM0YcxlGHZJUPNB1vNKcgit+2Ujm9W1nxRxgro93Z6NwJ4GDTbtjGBT6GbZscxP/thTxFf2l+hw++Yjsaz0MHzLKSfiHyeL9PZDKJ3eGQOfkd1A8R3pd/awfy1GFP7ziupreSAnutUM6GXdNTSaAJ/vwX9Hp9oqZ0sd4ODZ8FEXxh5lnM/mIffIz/SUx+p+pFCSzsRjb9p7vfUvoOKHJJkGwX0U9CPwfS/36efgvrNfgryJHm1MT+fnqrRcfWTmxQ6g/oHGh2NZx67RQHb+R9TOxd9QJ3HvHIewhil/5stHcw/dbRz3j/EPg3bPm7nQi+pnbPeSPo/c7RzzWd+V5jMs2Ci/iDP3M4l/T+jdu7Jr1HbudDS+jFu5/32Y5od1+hMDkhnUqHju7+cJDqHDekglrTJtPb676i9Sr1q7ZX7bUz/NWiv/ye1V9R3V31y33FYocttJgiyzVG6vk1mGxUFV9/RtlGOvsM1BoiCa4zrmhPGdJjGNW864qCB+oTvxWdN8j2QjuYvjybg5hQe5fRlv2PumZa0BZz7lSBxocKzxC1B+veFnXQcRug3linSlX+R4URnbWwYJmCyTKPAp79LmdcpuEcJF20Ay+uBsDtO0m6NCxO1/w2TOh7rSRRkns7vuHK2yPWLgeuX5cNBq1/hO6rfjTs6uJyOaWIdLlEc0uEz/rCPFIxI9jfGRIe1La2mvfQjT629aPLktQiUp2CgPMcIYx70/WbSd0nD/UUUpP1ImxX5jSr5o8C+n6S/LaYZyeeDO3T6rvYWBLpdQDnwWaNhoPOilVnSfjvp4xLlmY9/FwcK1ZLU4zHiGWkve6KdxV9D+pMKP8J3XokbHYDXWmlmpjxdbdRaC9OztVozR/jCK7/juUPtrI6rlPQi6+NeZF1pSFMbCTv4KyDXKIxC3DLFjUGc8Bi1oQ/v6OZ/xRP/WeSP9AtK+vvCTrp+6rKg0OGx2iBYh1eJtSXobgNaX4i+DfeF6L+IfY3s8kcT7HIWWye2je0+lpPt4IfI1oVEez7+XRwoVKqaP8q27pgn2lltndCfDJLrNq/EDWLrGrVqqdqaqy00WpVmY6aVC3r7hBHlHds6TW8LSnrPtqKo2Tq2Z6MQd4zi0NYJj5qt89MvVopZ5I/0C0p6tnVZ67Kg0GFbNwjW4VViia1bgvxh/KzZOvZTjyrlQVvH47JPkE3yc6WDPkfINhX5jQKOoY+CnFi+jIPv0G/GPDxnI+kfBr+9ManzJ2V4QOFP27uE5XpkMjndUSVdNIU0Jbw1D7zvk/V9zcb7mov7mgdGAp09LiIXn4dTAaWLAk/P7KffHM+Y0gVnvblM/iKWVnWIzV3vozDkaZIJGyVa8/Hf4oBBGzpyV+tnea2ceVgh9PNBr8r52NahTW2ifLh79LMsUS5Gww9eMojCJ8Ne2TAfrsvFeIm/32XKEYXOZKC3K+1vEGSb7k+aMkgztUmm8QyYxqOTnfRsa7Q6d12l4Nq2klPS86V6uESXc+DzdMsK2Iuv05QrulRSDrmVapTi5uP3xYFCuRTx8UmYymK9RXctqZ1p14VIetdWsijIkoZra5GmW6hLoiNaPbvalI+lf43O1IB0phQ6vtvuFNFJWqr7fEKbTFqqK0M8pv9lWKr7AtVnku16pVxhJ26N2ky53zaj2SlXm0n7dENkqC2xfiDsjtP0neUahUbYzcOIwoPWnxaU/JIui5/C/cV8/Ls4UChl9lOE/lr5KaMZ5SryecqPfIou3XxKkQ9vDeC6Q9uNbV8b/mjLfdhP8HDxN+PG7tpS4Go72hL8K9v/aFjk2w/itjUCPFYAS65H8r3tA+0l14eh7lel3Ecd5Wb60T9cBhohDC09j3kYnz+Rkvx48bumW6yPfwg+6TcmdcwgcPukLJPxQO8vedlb0v8jxY/U6hiXDf+Q+lWUJW81OqLI4ZWtdBn6e20Zn/v7/biVjvjS7I/mV7EP369fpdFhrKxbBCX9P4V64QuX065Fy7I1nttoFDTZJG3DwHxiZ7jtJOklto0HqfyS/l9C+d9Dt4di+0vaDpT0SeNI4NavHP3jqbvo3xaFvrYsEv2bj38XBwxsy0aBRqjww8s3/57am0zfjihl1eS6pNDFKeMtRHeJ6Eb1eHRHN6bwtjHobWdanfC2dObzUxQv6f9vsLP/gfrqpC39/9+kTjsf6HqY1E6QV2yHB8PueEn/NyCvpYSxAfKj8aq1UbyEvd82+hDxKun/ztFGXbqk+XS8lUdro8x3jt5n1Ys2zuZOuf/B4cOhXkxt7uaBtxSm2Qf2Hebj38UBA9cltlPNXnJdTlC5luL3I0pZtToNFbpLkIbtQ0h0NfuAn/QJH7sBM0mPxxSeo8Btrr3sATxwmxtVyqzpgdbHuj7pwE+mtfRcFkm/FXh1zfuJP+B3DqOkzvth2xkLu8utXROs+VYspyBBTmLfCkG6TZa06IvheKkVduIx/R1gJ27c3F1W15yEp+XIuRzRCwJ9TkLor9WcRL91+5TCfyNMTq+1MW3OI1o74TncAmAJXbyC+ii90+YpeD4qaWxzD9kGbQ4M9U7GckwzCo1Qp4m4SFOb62Q72c+cXJoMNP3Pop8aHdfa0kFDOtp2WNeYMUlf+Z1r7gbtMdsmH3MkzwCfWcY7IZQhi3+rfXKqbU/mtjuaIDueI5H0e8D2fie1K1cZo4DjUuZJG7vyPMBS0KGt8cxjV0n/Nuij0z6fw3JEgecDJP07AJPnA5Ygfxa7q23nWYI0wo/WJnjciGPAkOho2Lx1T8NZIhwuZ5KvLRja1rXo33z8uzhgELzlGA993hWFnzFK/72kxyeCbpm6ZBb9O67QxWOy2dc+TnQ1X1t4w7E41jvXCa9LM5885pL0H4H2/CHypbB/x/60vlmnjeOCZQevxxRel4AWjwsk/Scc4wJtzhN51XxyaZOXwidHuzUWdstHsx+u+cSs9kPbWniU4rC/znIESJY+ZjwhPeuspH9UGVO5PteN8PeQv4V0eD/AQSiDq5/iusK8Ec39m3Vc7EtQZg+H3eWV9A2YM3+S2mDSfNjBhDaoHXERhfuItqTfAbSfJhlqa0qutfucEpfFnx3NSOepBDpBRjpaeSz9Zm2+/mriud+1DMy/VntEriY6RxQ6nv3mzGNqoZ8Petu9jzG161hIlKuk1+ZLDjvSh0p67egpHFOjDQ+ILo6pQ3qntXOeR+x3jOXa56Wtf6bZuc/1aeceDzvxmP4/XtXB/CGyc8O2r+yaAelco9DxbTOuofI85ShPvzqF+dfq6IxriA72D6ifX0pYf+j3CJp/Avr55VXqp+u4i7U6JsXHHM3lUJ7Xcxv5A6M28t9BG/kfqY1o+9Fcx52sVs5Z6bwe6vOIIR1tbj5Nb/4iYU0vq95I+p8BvfnnGfRGk03SUZlId630zYXl8i21fUqueUnXGiqm147nEF3w+3ly9v3AQj9PvNry0xknLAW9sntGkd2moDM3VW/uL5Vn39Zc3Hdo7wGuDAEskJBDApT0Af3mfBFTSZ0bpo0CnieHilSg/DwQYfwsPKWlTYvXGuEzCeUMgmyNEPMnNcKk87xCiMf0/xEmubKc54XK0895XkkGZEQpQz4hH07qYxyW+X5HmSX9/+8o85GUMt8Xdpc56bxc/M3pRpQybAj0CXbXQuS1QTfv/eoT5l+rzv1aopPU6Y5MdfKgHJI+/HkU4jH9i9DpjseY/Z7Rx+fw9StnjY5vOfNZrEcc5en3nHHtXG9XPT0KaZI2Z2kbqqLAH0ZL+mviuvR8Nrf6jb/Q0r53xw83txnp8AnQ4RtIh7WJrrWaUOunreSC1beVtSqPC0trDzniGdO/ph3aUrOYxQYh/de8Q/uvct1CDglQ0gf0m/O5HFpOy8ZQFGlQh1bjKSltvw4t0maHtt8ZYsyPq+DYIGwVqdzzZSKuvoZAk2f2noYyaI5a0qx8LgGfDSUe7qLJjndCSfqZuEOIHMiVeHVfq6ttCfwFQba6wvxrNZu/jej42O0XBf7KM003ysRXkhP7VnIAtAsgtJVlvtxgGhyAt5MDoM0Su1aNspxWoe3Y1ToozfFM2uWQptcsI433KLBDKOkXyCH0c0JNrXjpVqNrmTtlPrhJ++omr8SNDsBrbaZVKk5Pz1Ra5fpsszbNfZfwyu+yrFTfrKT3O6NXVQ/dRMc/CqMQd5TixiBOeNQOovPjMFUbWeSP9AtK+qSviTWsKKzzgCWHx7m++OIdT1FwXdgm6ZvQd2a5COUppTyuCzpG6DfbMrZVUZiP/6bVcCslBCS39Qov/IWcpN0Ncnl2R3dZtEPqRMYjDhqB8i4XJMuOaYwoeO8Pu+OOZOBNm7BDjIMJfEYY2qD7JipLv5MpNyn8+Fz5Qppp/svT5L+krXw9GXbiMf0u8F+Okv+i7cZhPywX6L4D2xT8Ek+bEGY7IOmXQd/TLrDCcjKPiIn+C/LM/oukP0n+i6cdbeqEltBaq5PhGGs06OxaR/v4jrBbVpL+PfGgNKrns1P9YX53AubvTnUwL/SJ+c4EzF8EzBcden9d0E0P25TWzljGmF/S+T0BqXNZ6F4/+O2LJfcossAyCf1Bd9AirbX6MlIrm6ue9wA/3JY0rD19Yk0ocT7qdNRRbqQ/6eBVKwf7FRqd6xSZSPrHHXxhemnDqPuSV2SIl2sbyrDsqm+87Fvor+ayUJHbNkrHl4Wi7PcmYAX0exu9Gwn0y0Ijm/k/xHZe65c2J/AsPKT1S5if9d+PzZxZ1L7klaB9yYs8chih38h3VN83bu3gcjrEYD3mywRdNjcJQ5v7TGv3UcDJe9n9v//Ann3Nd+975Mn6geZ9TzYfO6Do74agu3zr6Def9Iy8Il+TlI4XZ/fQ7wP0+wmFHw4sEwyTSrqkkNY+7oTn1bQPzO+aV7x1QDq3KnRcWHcqWC77fauS/nKx37dROhnbDWK/b6N3SfabecHx031hJw3PeUv6v6LxkB+fZK4yGfTaNCmL0H7cE+0c0QsC3S8V+pMKP8J3XokbZD63PFsplWYvLgU3i9VivVF0tTF8x21yn5L+biW9yPpA4EXW6sUi+0CuURiFuMcpbgzihEdtPteP3ZjLJH+kX1DS83xJ1rrUsO5bJZbM56Ltlbbtt63373+NUJzrREtct8C5Zw6a3yblfeViuwx+m+sUKr/j8rWTIeoqB02GUt5+ZYi6xjL005bXTobYRjloMpTyRjJs9SFD1DWew0bb1D5VLhgu+fKGK1yHelvYScchTYZv6UOG2jz4SKDLibF4HPKwwo/Y6SeCbv6x/qLA61qY/wnCOpiCdR9hYf4sX84h1kOE5dq/cDgF60HCcn0pcyQF6zHCcp2GeDQFaw9huU5meiYFay9hJZ18G/0LU7AeJyzMHxLWUgrWPsLC/EuEdSwFaz9hYf5jhLWcgnWAsDD/ckI+tG9RmFTeSVv3e/Fcqe8LWbXxgo85bk3uml8osltReC0ocdhvYxzSWVHoaFijhlhPG2LtM8R6whDroCHWU4ZYhw2xjhhiHTXEesYQKzTEWjLEOmaItdcQS+aRtXnQx4lOv/OgPG+ThqXZ0E3xvyi8Mm/+1vre/U/sbgYUeI2U58sPJNAvKPkDypujd4UELMHJER7PUYidT7rBgvd0SPrvjgnj6V0TSn7DcUdd+6hLgsRh/8B9H/qtbwu747Sb/HIKHW18IO8iWXyDTocOFCxtbQF14hZ4xjihz+9Y1zG/pNPo3DognVsVOi6sWxQsSa+NKW5V0mvjE8nr+Sac9tqCNsbTxiWrWVsQuW2ndLy2oI31GCug39vpXdragvCS9AEwry1I+v2xbk8ovNrVx2zF9d2C333qs5nXFoT+pMIPnxTO+yHnV8lra7ZcXKy0msVaZWFhsdhwtbF+T5J4g5Le7566WXVtAefBojAKcYcpbgzi8MRxXlvwYzdmi1nkj/QLSnrut7PWpSWWrC2g7ZW27betD+/aAu5J6GdeHPtLPoQAZXg7PGOc8MPvuN5vV3idVPLlEv4KHX7HdDSete/XcP/zSqGTB/UK9z9j3ifCTjym3wL7n5917NngMTrrKupGFLid4KmwWfpDSX8afGXe/6x9W/FEmMyz0MByub7fkvQXqE/20y/q+5+FluukO5ZHEHTqxPVtnCYHv2WcaWjfD0jQ7A3vocU5Bt57EELcPopbAjrfF3bH4Ziexz3LEHeA4rS5NYk7DnGjFIcnn6OOctBsJh7K8hd92Eztph4eE6J8tX1Id8Azxgmv/I71DfPvTcjHdsTznqeS5zbd3lesfbOFZWJfV5unz9K/IK21mkfXyubaq4HzDDyPrGE93SfWhBLno073Ocqt2QSNV60cPC+otbM7FJlI+sMOvjC9dtjQWs8HaDK0mg8Qud1N6XivOOrg0wlYAf2+m94lzQdodnQ0gU+hm2ZHs35jgv7i1ws6zazf+0v6v4Pvm74Bzzwnp8lvin5Hfw/Fz573V81q8x0Bye4Q0cY4XgsKgiBzn417qEqr3EN1iOgLJtbfpyFN0tzz/wz+9Ne265i5QB9DsE8vOpH1m0ZJ/+cOn17SjCaUa08C5v8FuviXCboeKJhauR6ncjEPe4kHSf9Xyrx+EPTaX7Ypj4bdvO1TaAUJ77jP2ZcQ56Kbljd6fpIw2Kdgff00pZf1qSSZsq5I+v/NoSvatxyuPaXMA6d5PIGH/0PhIeqPNsbxi3v2HkpYzsLmkwt6l7e4KrkKRhWcpCD4UfGkOTCO/Hapn7b9FfM+nsAj5sUzrhrN3c0DSet965QCaMTWBXrw/F1UUduDL0HbR8j9Bvu3GLcf4tD2ctD6FPyeKuu62en1rz6vlU+SxdeIQjPsxGP6f4B2xzfI7QU+NEy8PZoblmtuRNKnjdeEvshS8/tdtLV9jZL+cJ+8amsN6EPvI15dh2Sm8XpfuLa87u2TV20fA9rqi8bokSeb+x7ac6CJzYPZCOh5gt4lbUuQ348nsLqJ0vE0Mh8xwv0Df+a3X+FPC8IHBuZlJEgPfF7xVDx9HDXRP09ookHg3k6hbTNG1/LrNLTQllBc6uhyYbVzTxGDjw2R9Nug3Gyasl76K+m17bI4BcpTwNgM+NgnXObDKd0ojEKc4VC+oV3ehzIYC7OXV5NPqKTXjmcsUHqUlbbUwtOg2IXhWbkrpH/akWWusrm2EMU/Ey9XfTjsxGP6Ox36t6TwoJ03K+mPKemXIA1PCYcQJ3k1/cNPKqIwCnGG+tfU9A9lwPrnKq8mn2UlPS4ZSP0WKD3KSuJQX4SmZv9E5njUkbaMm0v4GxAel01b2n4g7Kbj63ITWWZje6m5ctFzOX4WV59lPx//Lg4YuP3gFMQxhZ+eS5Sv6i7XCshHs+vloDv9skJ3hcqKdJeJLl6Sy1POUcDpwLcTr0uAzdPurjIvwPLxO+Nnl5vJR2O+C3g/tSM5P/eBvN0H41wXm2rHhKFusr2V9O8FPs+AjKOANg+nz6MwCnGGutrqt89dgrgsfW5an8D9KrYPHv5oQymUedLwJ+lSXDyqFtN/DOqIL8XFvp0v9D3YJ+9ZfdinoRx83K6rPjQ+jgGWlh7bL6ZvKTJhTGwLWMdhAuYjgPmXfWI+moC52+HPaP2vdq46211Mj32y8KN9TrVCccg797vLQJ/TPkb0MQ7bFtMNHPxyn53GL9tciVsGm/3p+Fm7gN7HkqlWl3cp5clal087ys9Y2L+yvmptaFmR19GrdMyxPjGXlH5P85V2hx3aywl9dhS4z44C26anFb7QF9DGN7wMKLx9Rmmvl2wMUGoWtf4Q5cj9oTZOc92jESrp+XjkKBSU9D8Qdse57grRpsey9jd4xOi2DHexCE3XfEX0fAOll3KjjUedeQTiMf3nHTY+VHjQtn24dD+ENHxsKNaV5HVtjb4U+ury30KlvEcHkA/rK9pNPnYb9YU/F7TS1xHSV80GaXXJ7SdU+NHaKctpPCG94HEf+qUMfhXy4PpUIOv8gtbHLQc6bWybIeDzBaCS/teGyZ4XSyWtfaBcuX24ZBiFfn3EMH52fU6qtY9jFKfN1Waxu1FwtR3Ji5fAamPjpCOg02gyj9p4WbP1kv4bDluv9b0uWx8q6TUboNkOyXvpxuq6LqMMsth613hnSUkfBt1liYJm63ksrG0FTrPdf+DQP15Wznq/mEtX+FMppJ11beRS1v1aro0k+aUsK5QJYmm2wTWnMqi/GQW+SzfN3+S5SUn/b/v0N116uKSkDyHNUPubq9DDUCnvpfQ3NRuE84Rfctgg9vk0/XP5Z2k2iK+v0mzQiMIX9sXaZ6BRmI//FgcMrjUdz/eU1nJET+SB75B+XpGjIT8lV71qcwB+r3MqViMzpa3HfTLslU2S3WEbLmtpUXgQcERXteMgcH1ILrTmNoM2GPMKDfYDx7d0MEcIUztWDW0w+7/asWoR7ueo7fO1YUhTq3OXvxwCHS099k2YfmNcVm18uKTw4Jp7SluL4fFxCHHHAp22tt9A60sl/VVQnks/PiyXLvWaP/dZrrEj6uAS0dH6Iu0zWu0zBBwDBgltC9fUsW3xMYPa599JPEZB1km5XXKb0MokR/axv7ZT0TFuhwFgboV3/fojrjklrqNQwXJ96iz5x5X0iMdt7M4MNiNpXodlKunvcchUaxMumaa1iTB+zjJPFSpYKNP7Qp3XrDKV9BWHTNPmylimkn7aIVNNRi6ZZp2Hcq1VZpUpb4kWOlllKum/3SFTXC/KIlNJP38JZYplXqF8IcSxf8z2Lp+Qb4sDcykBU95jPtfRplpdajaN6/J+R11q5VrKWK5jRuU61me5JP27PZXrqYRyPdVnuZZSysXrrpL+AxnKpc2TRIHn/iX9hzL6dpdyrmIt50t5ThR14ymKQ1+J5/etxjcHaXzD188jTW0/O/LBOiDpP5lRB9ZmT7muA671fM2Pdo2p0uZ0uJ61Y440HeA5Ve1Ilqz+PR6Zs39zdzrkJ5fwV2jyu3UZysZtC8cRKFcZRwzD3lzkh+3mURofaXtzQwWH+9ekvbm812qZ6Gp7c5PmXkLiFfu4LHMvkv4FmHtZjp81n0fGp9r8Ads0rY9BfUjqY05mtC/C17D1MUsQl6WPGWT/bEhYWj+i7Z/V5ht4DU9bl4n0448n0/kPlbzcPsYDtz/I7eNlhz+zDHm08WYlAfMLoPc/uKW7/FiPsi8rSveTW2xo/6hjHKONS1xrTseV9GhzhJ8p4gHzcrm5rn6S7II2x8UyQb8Z07PfrO2DzAXp44FlpYwsw/GE9GgrMf0vKHpWUMq5RPQ0/rL230vAa5jB/gpN19XvUWA9cfk+Im+kjfPXuL72Sv6wE7c2trhcvtS+nshH0wc+tl+zxSPwzmWL+foh9M3QFn8+rgz20f970GHed6/5/chXkt//+w57pcnNpYehkl7bi6DNOYeOfNo6KdKaj/8Wi62BgtBbivHWK7wIXfa1/gjk+OwOnddcD7+DBddYYCLQ7a4N7XIxR/SCoHesgfTzga4P8yb8dNZ0l4gflg+v6foZr5RauKaL+otrulg3mv+n7dPAccKfkc+i2QC0cyWIx/T/HPylv0jADAK3vUvbI/bvNnXjhgquxZyNZluWKA7z8ToQ1gnb/rRvm3gvpKT/t2AbXN8OCl9+9563LvneWpGZtrc2y/cQqAtJ39OPB+5xF6/X/7XDP3Tt7z3cJ+9HFd65nXPb+TPyHZHm0xloau01RzST9vfeAPGY/m/X0G+4sr+3N30YdJclCln296K+ZN3f+8ex7da+y85yvaE25+3qs1C/t0M8ps/HC4DDfP6KyMmz/pUv9R5jqd8s56+49nZq19JE+vflWP98ynFmttj2aaUO8Vh5DKMQj+l3xDqZh3LI39EB+GzN1EutSr1Vr9UbjepinY+Jj4LUWXTMVaQP27Z2ZMZt23JeXvDH/OC3vxsehbKOKGUS+qJL6yB9LuFvEOhjFqGVJyzjspVcZUP+eb1mlPiR5ySs0T6x/B6p2KnTEUe5mX5Seq0NyPtxBz6mF7uOOjxOsljvRxZlV72NA02hv5pjsOX3DkrH12KhvMcSsAL6vYPejQT6Mdhsl7TrTSSPZ5tSzmoHhH4+8Noe2nZgjPhJart4nOHuPfVGfLIqmzyuOhQnwnGxuera3SK9Y3VYR/nE1dO6UOYzp2BoIuAbwHMKfc2UjCTQDYKOurL5SMOS5xEHL0kYOcKYdGBcaTpXmo4SrjSdbE3H2hsvz85Oz5UXitWZxmKrUa2keePW9BcXpheqzYXF6VJ1ulItNvoZDbC3kXT5wzqIx/QfgVE3r0Ctc2BGgU9SlfQfd4zkNa9IK2cWM4D8TAW9esUjiLXSp5n67MLc4ly1Xp0uLhZnpldTn1q5UfYHwu704lkmXVwseGOU/lNQV7xbYxzyCNaTYS8m84z1gx47X8Ym6fcAD+dp1gPlwF0ietOGXdBijugFgd4lCv184LWLLnF9CD8sH14J8zTCWcgRPvKzXpGP1OUGJU6wZCYIbQ2mXw9lxPT4LPnx3ZFYtwqEGQU5HTWnxI0o70S+r5yyRq4b1k0u4a/g8jsewaNs2Iah/cSVw2MJ9gPliXnFfnBbfHFrB/N4/Kz5F1x/bJNdfgLSS7JX3F9J+lNgK/jyEO6vsJzMI9IbVehGge2VpD9HM3Ge2r16eaTQ0vq7XKDLIwiyzUJp/eOkQkfktTFwz7S47IRrxkva3HhCesEbo/Sfd/RlGyDPiMIX+zKS/gsOX2ZCKZfWruV9Xkk/oZRrKui1f5JXW5UQ2Xs+oXZRW5VAGY6F6fJZP4B8RAcKlB5lpdnQ9UQnbWjJq7jaLBraXPTfphT6XE6tPYwr5XS1B618rLtf7tO3w4t21yfwkNW3k/S/Djy84PDtsC/7za1uXtne4NgH0/8e9GW/TfWjzYJqdpBXYrEuRUZoB8cVXK09s05obQXTs68tuj+ekB79KUz/+w6dyEMezb9kn0HS/4HDRm4MesuF4xiWwyYl/cagVw5TQa8N2BTotLE8KGe+QFvS/2OlPJrdxRWFKIxCnKHdVW/jQLmy3XXJMAos80klPcpSyleg9Ch/re1spDiku4F4SBvbsE3W/A20Hdr0KspA+JxQymtXd4ulHNGT8uE7pJ8PenXex1gyq46IfCb9yKfo0sFJRT7Cz2Yv/BQroisFhbbwGh9C1mVXMP0kyBDT47Pkx3f/gfR1CvIJfoHiosDjWIwbUd6tu0RYBQUL5SZ1GrXjf0Oy4JuttL+Cy++YR6xP0XmXjVgtHcQS/0ZrT9G/+fh3caBQKUs5NivlENqoV3ZtpzaT1dYJ/XzgtS2XXDqM8uGxbkHhtRD06vDTYSddmn4jHQ3rwpBirRhiPWeIddYQy1JeJw2xThtinTDEOmiIZVnGM4ZYlnwdM8RaMcSyrMdlQyzLNnTeEMuyHi119QVDrBVDrHOGWJ81xLLU+2G1OZZlfMkQ65Ah1suGWJbysvRNLPVrWP1CS70fVl9uyRDrlCHW5eDLDaveW/omV/q0/rCG1ZcbVlto6ctZ2kLLerSU17D6X08ZYg2r/3XcEMuybVu2IUt5WfZDlm1oWGVvab8s5+VWDLGGVb8sfd9h9TGHse+InnnNyqLv0NZ6cY/ihMKH5Xqv4G/xhC+yusohK6TPa78Sr/0VLI4TWnnCMi5byVU21xoxroejDJKwruoTa0KJ81GnBUe5kf6kg1etHJOGMhkzxOK9bdqeDW1dVdJvUdJrejKl0Ja8UrdbIc6wbsuuukUbIfRX8/W2yO0DlE5uc1gX9LaNqxKwAvr9AXo3AngYpoJeXduQwKfQ5XesK5h/kviQ37LnBffAyj4RbW9P9G8+/l0cKEyXXbbVbz8zXclqu4X+Wtlulw2LAu+NyGLDonAk7KQbxO5E4UVDrLOGWCuGWMcMsS4YYq0YYi0bYh00xLLUiSVDLEud+Iwh1ooh1rDqxGlDrDOGWMPati1lbymv44ZYlmU8ZYi1YohlqfcnDLEs9f5ZQyxLnXjJEGvFEOuK//X6sNGWfW1oiHU52MKXDbGsbE70zGPtQfh6PrTDsmxDljbask8bVr9wWPu0YR1bWcresg1ZysvSRl/pO177fUcUjhtiWdrCc4ZYV+YULl0bspS9ZRk/a4g1rOMhS9mfNMQa1vlCSz/nip24dP7EFTtx6WQ/rHYii/+F5wTyubzaOr5gbUnBuo+wMP8WwtqagvUQYWn7GSTf1Ql08MwL3INxtUJbwxcMbR9H9G8+/l0cKMzUJ5Ry2OGXG7Iefg2UOxf/FdrXwnu7tftq5vNJhX6eeLXlp7OX4Frih+XDewm2KbwWKC4Kz4SddBw3orxb58A6Y4h1wRBrxRDroCHWs4ZYS4ZY5w2xLOVlWUYrvjQ7Oyy6es4Qy7JtW+rEaUOsK/briv3yWUZL2R8zxLLU++cNsSzb9rC2R0sbPax9rWU9LhtiXQ790OVQRku+LO3qiiGWpb/K4/Zh0a8VQ6wXDbFOGmJZ+ibD2qddaY+XrozD2m9fDuM0SxvNe8dej3p/1hBrWOc6XjDEWjHEkvbI3wVGYT7+WxwoVKoyF41rJ7mgmy76Iobz5s0c0RMZ4Tuknydejflpz+Nrazkon3UkHz/rHMVGjvCRn2sV+WjrCuxHXhf/xnUsTH8tlBHT47Pkx3dviTNa2snoe+tvjXH7aAPlxVapUmvO1IrT9WqtMV0pN8ozxUa11iqVZkvluepspdJarM42ZsuVVnmmvDgZ9NY7twFPdVzN2gZ4LctTm3SuZV2t1FG/a1mPhp10w9T/yv09Wc6P96MLlYXV6oLv8+M1XXCdH59VF46GnXSD1p+lT205ljxliLViiDWsc3SWvv6wztEN67rAc4ZYluMGy/WKy2HNbxjX4KNwZR340sn+yjrwpZP9cUMsS70f1nXNK3bi0snesoyfNcSy9CdWDLEsZf+SIdaVNtQfVmiIdaUNXTrZW47dLcfI8g0FzyFFYT7+WxwslCcUukbYVcG+zh67fQbt9YNjN/iFYN9gz3dLsLebY1dqMpeGd8LjHeF/EiuQ6GZ8PXLXvD7eDb0O4jH9m7Z1MP9JjDkJuAFgRGGC8HKB5ZxjuZgjekGgz4EK/TzxastPZw50HfHD8uE50BGF1wLFReFw2EnHcSPKOxfWSUOs84ZYxwyxzhhivWCItWKIdW5I+Vo2xDpoiLU0pHxdMMSy1HtLvixlf8oQy7IeLWV/3BDLsowvGWIdMsR62RDLUl6nDbGGtW2vGGKJPyHfXqP/KPfRTwW9vtNGojcKcYgvfuk4xc/Hv4uDhZLgb/CD375TYb0iYyyT0Bc/cwzS5xL+ChbHCa08YVnLzlU25J/1Zz3ww3cvaFjr+8SaUOJ81Om4o9xIf9LBq1aOUZLJqEInp8hE3m9w8IXppxTakldkOAFxhjIsu2SIbVHor+Y+CpHbzZROzrFYF/Tq4PoErIB+30zvRgAPA4+50UZOBr02U+hG9lHq50aI57ssbgRaI8o7bi+Y/8YELG2uIQrNsBOP6avxXEOE/c3t3Zg3Kfy5dPdmJf1NkEb40WQjeScV2v3YUOSroPAwskZ0RteIzoY1ojOxRnTG14gO2/ebDencDGnGiM4thnRugTSbiM6thnRuhTTs++2EOLQ3wsdtCh/SP+2C94b9U+b9u0I/T7wa89P2tXYRPywf7lveoPBaUOJw7yvGIZ03KHQ0rBFDLNGNqaBXV24jOjsVOjsddG5T6Ihe3U7lmY9/FwcK5VmplzuC3iBxd8K7z4UdPjiM0G/kO7LpL+3o4HI6polyvZPisI3dRXFYV3dT3Bsh7p74eSrolS/SxjgpI7/jesT8tzvo7BqQzi6FzqSSb1BbqcmG68mCDsptF9HZZUgH5fYGovMGQzqoi28kOjsgH663PbOtkwfzoQ+MeeWsuTFK/0vbO5jHYkyxJXcCX4a2pC5luyvoDRJ3N9Bmnb0H4ljP7oU41o03QRzKnINmn0QWkX36Sh/26Q6IkzJJHUj+52HN8+y27vxYh/xNCPafD1DcG5W4CP8dN3T4QTlEPrvozQTkZb2R9L9IuuKn35me0foW9qXu8kQ7S3vW+hbkR/jOK3GjA/DaWpwtVorT043mdHWhVm3lgt42NaK843Hr3Up67b5BkfU9fmRdlrYwEnbwsV+OwijE3UVxYxAnPEZt9cM7uvm/2xP/WeSP9AtK+oegDP3UpU8stAcWWOtXibUl6O2TxOZ49n3nNBskQWvzBYpDnbuK4rA98Z3T2JfhXB+HNH/6T/vor7BfvCsBU/oCHAtIHzNGab8KfdtvU9+GPuH3hN1x6HsJnQjjm+T3CB2ca5Z+Mgq7E/j60zXxdaoNzdfh/utuT7Sz9l88/kF+hO+8EjdI/7VQalWaxYWFanmhUZuennb1R/iO+697lPTaGbci63v9yHpB67/uAblGYRTiuG/D/kt41PovP/1vdSGL/JF+QUn/KShDP3Uptl3zmzRb8QNhdxyO+dDX/Sa1cT9+YnmB2w0Gzc5z/4A6yf0Djlm4f3gzxPXbP4gs+u0f0E5imRBzFN5pNn6M0v8b6CP+F+ojsE8X2lG6D1/Xne5uhW+/bSb7XKvQ12yoj7lWzSZq7U7TP27fGLcNnjEO6dyr0NGwxgyxRC+mgl4dvZvo3KnQudNB526FjugVtj+7eqwUpV6KQW+QuBK863euVfjud64V5VqiOGxjZYrDuqpQHNq3avw8FfTKF2ljnJSR33E9Yv43O+jcMyCdexQ6k0q+XMJfocPvmI4mG9dcyWrpaPae69yCDsrtXqJzryEd1MU3ER300XGudfN1nTyYD+datbH3GKX/EZhrvSrGnAh628GlsiWazpYhjvWsAnGsG1WIQ5lz0OyTyKLfuVa01Vgm5D2rbyLpb6Z68uRLFLdQuTSZuuZAh83H8TOedvs4Wj/er4+D54ux7enXL9lliCW6PRUEiX5JjuKQzt0OOpq/dLn6OJoNWSsfh33Vfn0PzP9683GS5qgs6GjzG5ebj/OAkY9zFnych6jv9DP/YuvjsJ758nFw/uUrRmOwtLmSHNFO8oXeE776l+dpPnFdB/Nj1yXzdTvQ/qdX5mk4XLbzNK49Ttz39bvHSdsvcrn6MCjXtfZhkDbGSRnTfAvM/3rzYdZq793l6sM8Z+TDHAUf5uxrcJ6G9ey1NE+D6/lZfBNJ/4UhmqfZqZTf7x6V7D6O0M8Tr758HK0f1/a2a/2T5NVsD8/TaL7UPQodDWuXIRbP0yD2TqKjfROxy0FH2/fsd19Ducn9Pwatv+zXx8G9Dv34OChXtoXYxooU1+/8zlTQK99B5/Uw/70OOrcPSOd2hY7vvnqt9uOvlS91qeadknycf0Q+juTL6uNI+sfAx/mjNZmn6c+WaDpbhLhdFId+BOuGNr+T1T6tdp4GbTXbJ5wrkXTaXMkuhYZnPyLzHTjsR+zyw4/Tj0D5SNvaFHS+dX24eeDdTyzsfmTxgeah/W95rPHu+r4Dj9R3v6XR2Nfcvx9Lw1rDpWVt4TTyXFDeI8ZdKaWQL/y1GZK7COvuFKz7CEvbhc5WJAnrIcLSLBf3SFprY28K0yM/96bw82CYzM+9hPWmFKzHCEsbeQrWm1Ow9hAW5n8z5Ssm0ME0aA2LCm0Nn/W2lMLz3rCbZ+SLR2flFKzHCQvzlwmrkoK1j7Awf4XyVRPoYBocBVeBTk55p/GzP0zmp0pYtRSsA4SF+WuENZ2C9QRhYf5pyjeTQAfTTMP7GaCTU95p/DwZJvMjebP0cMirYY+SeVe80F+rHi5NrjxSnlV4LShxPIqYVejMKnQ0rLsMse4xxLrbEOteQ6w3G2IVDbFKhlgVQ6yyIVbVEEtsorYSsZXo9LsSgfnXaiViK9HBGTkcbb7h+k4e1EEcbWJe6YvGKP1HYbR5R4ypzZC5Vnww3WrkrNGRvgZ12HBWf1rki324BInDfu56eOagjU6F735nz1Cu3CejnZmlOLQbcxSHbfdb4uepoFe+bBM1PxDfufS44qBTHJBOUaEzqeQbtF1qsvHd/nlWtGhIRxs/sP5Y0NHGFmn27H6yZ5IvyZ6JLztG6d8F9uzBGHMi6G0Hl9KWsM5qfonEzUEc68a3QBzKnINmn0QW/c6eoa1m+6S1iYmgV/cuxeqa0M8HvW3Ox5hBmxPQ+kDNfkterT3dAM/cbkeUd662ucsQS8aSLt8hR3FIZ5eDjuZrePYPqrwKj2GSyhyFflfXVusfoFxrFIdtbJrisK643aJdFFuk9dusL/3225j/9eYf8KrHLkM6KLfL1T9Y7tM/4NU1Sf9t4B+cIP8A58OG1T9gPfPlH4gs+vUPcGw/A/isX5gO61DT9UB5l1NwuM2VEuhH4YPhq3+1ufWriYbWl+M71u+rFX5d7dVvX/bq6eJIT8qB75B+XpGJDx+pklGumm5VSOaaHrCOIJ2qQkfDYjvomhcv+ZFXZh9X6K/VvLjmL16tyHUt9DupnosOfvzY+85J9GnrQ8JPdLLIeNCrQ9q6GPON60jyLqluXOvZrrXFtPXA+wgrqQxJdeRaz9ZkMEZx/zjuxyMZ/ur13WlkHfYbkObX42etX+Y27WmtK3Ob5rWuaT/8ONe6UD6os+sDt+5g3SXtA3iTUlbW5XtTeGJd7nfPAWKxLrv2HBRTsFiXMT/7BWireWebthOcx6CI/8putOuT8YsO/JIDv+LA13bAanPaVYrDsWcN8P/UgX+3A/9eB/6bFHzGFLtRgLidFCdpvxljRD7y2Rt1fgUjCn5PlctuU4T+Wu001/ZDuXaaa/uUXF+tueyEaxcuYt1liCXr5353gFcq2pyGBG3+aq12gGO9cHtHOfP8FbYLnr/CPQnST6zVzmyNzqD6cpdCZ1LJl0v4K3T4XZavPLmeLOho+yG5zi3oaHslWX8s6Lh2gKO/inNUf09zVNoOcM3X5R3g98Ac1T/QHJWfr6dsd4CznqFPyLoxyA5wPE36KwN+oRLtTpavsx9uHnigeegD9d2PNOoHHtnz2Hubjz/R3H9glGC5+bCa353ALuIEDnajsI7idlH8A2FvOgxZpi38dE/Z3RGhv1bTFmlbmNkdeZPCa0GJ2w7P3JRGlHfrHFh3GmLxRSmIzVNl/R7CuEvh+cohjFcOYUyic+UQxtXRGYaP+5OW5qbp4hI8jD7L0pyk3wFuz1yM6fdSttfmIYwii0E+fGP7hJfZyMH8Encb5OPLlvBCLvxgTi6z0baDyEdgU/Q7epZLCseIr4+TPuBlhob60L4UQLtEyu8HfpXMnz8kDeOQ77wSNzoAr+XmwuJ0vd6qLLaKi/VWk9u68Mrv1gF9tr2SfrOS3vPBZHVpL3gpALbfKIxCHH+COAZx+CEqXwrg57DNSj2L/JF+QUl/P5Shn7rUhvzsR2bFkgsG8HITvnQXbRO3RT92IPvYRejniVdjftpjF+0y4x2KXLWhruTVfHc+mKzfLXqafbfAkr5H6yt2EB3tYuibHHR2KDwP04VFUViryzpRrjxFg22Mp9ywrtjHwTbNU6koX9aXfu0Q5ncdZHfzgHRuVuj4nkq9iej4uniaba6vi6fXapsk+6lJY5dTCZcuZh27SPpNMHY5Q74qX2Q8H/8uDhT6v/yMdRanW1nPcLzJuoHjFZQ5B80+iSwGGbuwfdLaxLD6Bzf54cfpH2h9YL/+AR/qNUiffochlujFVNBb39yvaLK52UFHs4+Xq3+AcuX259qaYeEf+Oi3NTo7B6SzU6Hj2z9Yq357J9HZaUjHtXVorfyDpMu8fz+Df+C6zFvS//0NHcw/IP/AT59g6x+wnvV70XdW+ySy6Nc/wLHcXQmYY0raGylO0n4T6uvvaC4T898SdMfdCHG3Upw2dtX6LcRAGqhz2M6bYXcZJP0/i/mOZHlmh465LgFT9FibJ8OxchRGIc5OfxdLEd+fBB1Amb5S3rC7TGiTRpT0PBep+R1oi26Jn7P4MNrcwy3wTubaNHkKj5dCnrcAj1nkien7lafIyDXPkwt6603zY13yvCV+dynkiTxmkafmm+dIJpge5SkyKgS9MnwjYd2iYGF757lgwR5X0rNNwvT/GWzO17d386fNt0ncjQo22t4cYWA58ko5JikO80a4f3JtN662LuGqG+24wDsVWmLftcu7/a4RlOvaeEGC1sdz/591DoD7f9yz4NoKjjLhoPkGIqdIty7AdmtOh89IR3BZj1hndig8ar7gnSm4/eoMj2Vf6zrDc0qoM6xPrwWdQfvNOrNT4VGbX0w7ZpR1Rts6jz4764x2QPJr6ZKnQfdQSBx+toIy4aDpDK7n9qMzaQfqu3QGL2bi/TRvSsFlndH2ZGntS3RG25Pl91KNcmtS4VUC65NWv1kPlea5Ku2TNE2fUCYcNJ3BCzf60Zm0431ZZ7T5NG3rufaZpbYvT9Jrx6KiPNjOaJ9tTSj5DO1MbVLhVYLE4eeRvJcSP+XkPkY7zlHi8IgF3jeFRyzw8bYYNJ0ROfWrM9pRv1ntjOTVjtRI+zSXdUb7vDmrzkhezzozVEdzSdy3QtxrTWfupyMi0UbzMU+ljDQlfdpn5qx/mr6ifXfpHx9BKvlwjg355+PmJH0jHuNG9fHN+FmbkxA5+Z2TKDa1OQmU61jYXW6XDKPQb5sXmRWCXntcpjjtuEjXXlXt2FNr30j8hdeLb8T9XNbLyIbVN8LxE9usuxQetYtZtM/2tcs9XXYM5c86g3ohef0eg1gpTSq8StDqnvsyrHvWC63utXEW6yG2fb5GAYOmMyKnfnVGswdZdQaPB3gug85o30VdrjqTxV683nXmgSt2pi+d4bmey1FnNpPO3KHg3gbvsnxPgWuTvA6B60L8vSbmG9Z9CLzWoF0Wqc03834P1BOUCQdNZ0RO/erMGwkX6ycKrnUIyRvpzDPxZv080Yr+DvSNT6PRLFVLM3OzzWq1MVfjC1WjIPq30QP9aq0+s1ifKZXmqqVmtZRKP5L/tq3d8hyFPFh3k8o7wRX9H6O886ssB4s1R/SCQN8rKvTzxKsxP+29omPED8uH94qOK7wWlDipg6kguU5yFIc8jCo8FJT8oxmwtPJsiv9FYf+BPfuab63v3f/E7mZAgXWF2/S6BPo5JX/gwMI8PtrVYm16YfFi4yo2S6/o41q361pjYbY4U67PNRanG5Xa4lrTby5U52YW5hZrxUZxrjRX6ceuTAa9upVL+BuFEQd2QcF6NHz1r9ggbEeWNkjw1xN/Rvhtv3BMkZPQ3uClbK1WVvsq9POBV3vftq8biB+WD3/rOuFHPs3oqEbRPbRZ44psmI/1xGPeE4/anKnwJHGjECd8RGn+6MZuHtd54tFvG201NB8F9yL/p+0dulg3OGeNer8O4jH9f4Zvlf7f+Hkq6O6X0E5thPj1Srz8lvpap6TFZ/4tvLNcMb3o5HhCWceprJL+72F+/j1bdUyUH/K1LgHzH5Q5f8HEvWiuNi/pNyrpsY0JP1NBb9vcSPmQ94mgO+A7rX5ylJb7YOmnMF/S7wkFJ4mHDQoO95OMyTQ1X4/HUiMKHWxT2OdPKPQN+4ea1ldK0HztHMVh2T8UdtJx0MauUqaovP+C1qswHfOjtTVL30jej8F7psv++Dilxf6cZTZmwGNBoTNOuOsd/OcIZ1TJNxno7VH7m5XfnMKvazy8WjqI9eGwmw7Wc9c1hvRdAtrxESXvp8NOPKa/a0cH8474Oa1PY1uCZfhI2HnHNpv9WG6TvK7NfRenwX4c0785Lgf2XWwfECt6VyJ5aj6C5vexj/AekGeV5Kn5AFNBr2xYhyeIFvrH0r+wDL4N+JjbkUxL5DrpKGP07jt26OmQB0zHGFrfKRhau5Z8Uwpf3PbYdow7aGj9mUZjjOIGrR+t30ZfQ/NhtHjsz5EOv1unpE/zP/IJ2BruuIKj2fkNFJdT4tiGYXnRhrFvoo3J0DZq7S6p7ly+t8Z7Fr9q3MG7Jj+0Q9ZzOcXZYqm4OFNrtUqN6fpCNW0uR96vD7vL9cpfeDcG5YrCBkxPcRMQNxp208/Hv0eBDmIJH2OUvgF1HYVxyCP5Cwr9caLfxbfyDnWNsUaUd5I+qtOPxTz6mKMr1+Zm63MLxVK5VS5XZqfT6lWTE84dREFkjXUxrpRtjNLvhj7nMfoGdUyhF6U74kiXS/j7CobybjTsfqfVEequpBfa+bCXR4nbCHFjRGdT/BvlhVjCxxilf4p0F/VN8hcU+huIfhffyjvW3Y1K+o1K+qh+9pM9wrJbz/29QpPw8R3zdsRju5quTpdmZ+uzi9OLrbnq4sJaz70vzk235iqVhVJlrtGcK02v+dx/tbLQKrUuzv9XWsXKbGnN1z7qxfLFtcyFhVqpWZ+ba615+UulUmu6ujA7vVi+OMW45msv1dZMfbo1U6yVG9VmuVFfa/r1meZcdbpSXqy05uqzxdm1pr/QmF4szlVKjXp9pjgzPbuatSeeI4mCzFF5WiPOfL5R204Hvb6sjzWVEeKH5cNr1tras7YOJ+fo55S4LOvSvrGmgt765nkJTTYjDjpcV1HIsk/C17xoVp0T+mu1TyLrvgKea8S8PKaMAuuJth9DWzt4rWBJ/ihoc8WPhN1xWMcs06y6KnOLbEunguS6EdoylsX3Ywq/PPf4e3TmL88nzse/iwMG7juQluc9TNPafJmESaXcXO84R8J1y+veGIf9Me+vwTBCv1EWEe1/mWGfnqYjOYobV8qhzc9wX5NT+HKtybvm+bR+Qs5szxFmELjncbQ58jR/hNc8ouBZ9zP7I0I/H/TWl4++IW2+jHXdtd6pzc3mKA7pbFDoaFjrDLFGqTxYH6wLnnzBzH6C0M8HvTL1oQtam8spctV80yx7xFz+SFZ/ctixXGOeLPWu0WH9RzrYv+O65F/TOprkw3U0zMvn/kn6wzd2MP8Tzedr9T+l8Mx+iqZn6xzl1+hMKPnm47/F/kKVX/jdz1ass2+AQeI2KmXOKek1v0H47veMVPQbNlIc9kObKA77zEmKQ9sr92RoOsI+S786gvldujg+IB3Nf/Ld5seIju+9IC4/abV0tHU2bT/QoHRQFzcQHcyHtvLqGzt5MB/aSsz7YNiJx/S7wVZuoz2dfvYOF+d4DIJBG4OwzqKdYT3bBHGsG5MQx3uyMWj2SWTR7xmp2A/kAZ/by4iS1zUf5GnMmdnnfz18NxMF9qe0fQTa2ML1DY4Flqs/4P1t/fYH2nym57HkLPetGDR70O8Z68J3v/4DynWC4rS2u1q/Q5uvYB9ZG9fiO1d/u95BZ3RAOq49k776wbXyU3hs7eObI62fWit/KMl/eIj8B20PKOblsZak/yj4D+8h/8FTn9CXLdF0NqtvwbqBvgXKnINmn9r7goL+/AfUCSkT7qPV5pW0fjEX9NpYnodCetrcq+QdNv+Q61cbh2p1yPWL/iG3180QhzLhkOY79vPtuuY/YDreF5hTeNTauqYD2pyRpNe+r+E9jFHQ9rtK3mGdn3C1bU0v2L6iXrAeTkEcyoRD2nxIPzqj2YOsOoN7tmV86VqrkPfaHOSYQtPFo+YXZ7VZvN9a+yaLaWM/h/wnjZNXYnmknTkncvJ85lxNO3MO5TpGPLlkGIV+2zyvsWv2WPO3eH5DWxvGuWDrvUEz5cVavVKbKy42azP16Zl+9ga5vifI4ndL2TV/Ogq81i3pP0d+lScbqq51J+1Vl/2q3HbZT5T0vwp+4g+RbeH5TYzTxgSub1G0bza5Htr7UQO9LXAZJP0XM9oAKY9nG1DVbAC2W7YBru9eo8A2YJOSHvtQ/j4jyT/m/kCTOfcR6L+4bD6PR74EdcR3YaBe54l3bSytzZfwXJL2vWzEyx9Sm/W0Jj6jjcMlaOsZOYrDdsI+EZ87gHHaOCmn8KD5NiKLfveIWNgJ9Plf4S/s5etStFvsn7nduvriIOhtt2ntXOYBCkFvXbJ+a31BP20mCvcTPe1bPWwzG4HWeNhJa1gH7fOhRNYjwPNo2OFd6GvfKEm69rjYD69F4VW+y5B+C2liWdZRen7m76D+CsaHWEasR9f3TNo3IfitjPCofT+0MewPawNhrR8AS/jSvpNZv0q+NKxxwurn+6//CdqEti8saS/Fv84wv+faSyHp/xb8tv+V/DbLPXtptpptXluWgd5Xzce/i4OFzPuehH4+6O1XfayHaX2CNoYW+Wz0w0/V5StqfVR0LtLmoLfOkD/B0sblrnlJ1vU02RSU/LwXFOvYtYeU+8Yse0hR3zcG7vFljrC0dqz5SJostLkZHq/9V2j3V8eXSrm+idbaL7d7bc+xxCXtOU7SLdfcxaSSXhubCG3UvckMWOsdtDcr6ScdtJEvzMu0k9qI5seKbC7FHBT6nuzHusaTUcgiS60eC5QeZae1Y9f81EaKw/bHbVxbH8b2os1x4bhW+uj/BszZHbEVxgQA",
      "debug_symbols": "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zO//ivz+ryhv/4oXyz9Vv+L9f93l/X/d5f1/3eX9f93l/X/d5f1/3eX9f93l/X/d5e1/3W6a3v8VP/7rvp/mz50Wzp0m506L505L506bz52Wz51WTp3mpnOnnasSd65K3LkqceeqxJ2rEneuSty5KnHnqsSdqxJ/rkr8uSrx56rEn6sSf65K/Lkq8eeqxJ+rEn+uSvy5KgnnqiScq5JwrkrCuSoJ56oknKuScK5KwrkqCeeqJJyrEjlXJXKuSuRclci5KpFzVSLnqkTOVYmcqxI5VyVyrkriuSqJ56oknquSeK5K4rkqieeqJJ6rkniuSuK5KonnqiSdq5J0rkrSuSpJ56oknauSdK5K0rkqSeeqJJ2rknSuSuZzVTKfq5L5XJXM56pkPlcl87kqmc9VyXyuSuZzVTKfq5J8rkryuSrJ56okn6uSfK5K8rkqyeeqJJ+rknyuSvK5KinnqqScq5JyrkrKuSop56qknKuScq5KyrkqKeeqpJyqEj9N505z507z504L506Tc6fFc6elc6fN507L5047VyXnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JX/yJ7LevDe7e4zm2c9qJK5nk9rfhPp23tOFvpfRa34cy2hpNtDaeYGs6rbFtrOM7WcLyt4QRbwxFbw4m2hmPrqlxsXZWLratyMXVVDpOpq3KYTF2Vw2TqqhwmU1flMF19Vd59FdNtPNHYeJKx8czGxpONjafYGo/78bX5fpo7d5o/d9rmNem2irls4XFbK4wH0Fyaw/p23zSnx8Y6W9huVnnZROZ2vwgHn52mad0AawqPH5OX+DF+MT7+OC0CpBjC1/HHxsefGh//3Pj4c+PjL22Pf/sBjIbG7xofv298/Nbvv0fj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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "portal",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgIEAScCAwQAHxgAAwACgEkuCIBJAAElAAAARSUAAABwKAIAAQSASicCAgQAOw0AAQACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABJiUAAAU1LQgBAwAAAQIBLgqARAADLQgBAwAAAQIBLgqARgADLQgBAwAAAQIBJwIEAAItDgQDHgIAAwA2OAADAAUABgAcDAYHAAQ4BwUIJAIABgAAAM4nAgUEADwJAQU2OAADAAUABgIcDAYDAAQ4AwUHJAIABgAAAPInAgMEADwJAQMtCAEDJwIFBAIAEAEFAScDAwQBACgDAgUfJIBFgEgABQEoAAOASAAGLQ0GBRwMBQYEHAwGAwAtCAEFJwIGBAIAEAEGAScDBQQBACgFAgYfJIBIgEgABgEoAAWASAAJLQ0JBisCAAUAAAAAAAAAAAIAAAAAAAAAACcCDQQOLQgADi0MBQ8AEAANACUAAAVeLQQAAC0MDwktDBAKLQwRCy0MEgwtDQkFACgFAgUtDgUJLQ0KBQAoBQIFLQ4FCi0IAQUAAAECAS0OCQUtCAEJAAABAgEtDgoJLQgBCgAAAQIBLQ4LCi0IAQsAAAECAS0ODAsnAgwALCcCDQQOLQgADi0MBQ8tDAkQLQwKES0MCxItDAwTABAADQAlAAAF/i0EAAAnAgwEDS0IAA0tDAUOLQwJDy0MChAtDAsRLQwGEgAQAAwAJQAABf4tBAAAJwIMBA0tCAANLQwFDi0MCQ8tDAoQLQwLEQAQAAwAJQAAByctBAAALQwOBicCBQANLQgBCScCCgQEABABCgEnAwkEAQAoCQIKLQwKCy0OBQsAKAsCCy0OAwsAKAsCCy0OBgstDQkDACgDAgMtDgMJKwIAAwAAAAAAAAAAAwAAAAAAAAAAJwIMBA0tCAANLQwDDgAQAAwAJQAABV4tBAAALQwOBS0MDwYtDBAKLQwRCy0NBQMAKAMCAy0OAwUtDQYDACgDAgMtDgMGLQgBAwAAAQIBLQ4FAy0IAQUAAAECAS0OBgUtCAEGAAABAgEtDgoGLQgBCgAAAQIBLQ4LCi4IgEUAAiMAAANFDSgAAoBDAAskAgALAAAE6yMAAANaJwIJBAstCAALLQwDDC0MBQ0tDAYOLQwKDwAQAAkAJQAAByctBAAALQwMAgo4BwIDJAIAAwAAA5clAAAHmwsoAAiARgACHgIAAwEKOAgDBRI4AgUDJAIAAwAAA7slAAAHrSkCAAIAO5rKAS8MAAIAAwsoAAOARgAFJAIABQAAA98lAAAHvygCAAMA3q0wDAADAAIrAgACAAAAAAAAAAABAAAAAAAAAAAnAggECS0IAAktDAIKABAACAAlAAAFXi0EAAAtDAoDLQwLBS0MDAYtDA0HLQ0DAgAoAgICLQ4CAy0NBQIAKAICAi0OAgUtCAECAAABAgEtDgMCLQgBAwAAAQIBLQ4FAy0IAQUAAAECAS0OBgUtCAEGAAABAgEtDgcGJwIHBAgtCAAILQwCCS0MAwotDAULLQwGDC0MAQ0AEAAHACUAAAX+LQQAACcCCAQJLQgACS0MAgotDAMLLQwFDC0MBg0AEAAIACUAAAcnLQQAAC0MCgcnAgIAATAMAAEAAjAMAAcABB4CAAEANAIAASYAKAkCDAA4DAINLQ0NCycCDAQNLQgADS0MAw4tDAUPLQwGEC0MChEtDAsSABAADAAlAAAF/i0EAAABKAACgEgACy0MCwIjAAADRSgAgAQEeAANAAAAgASAAyQAgAMAAAVdKgEAAQX3ofOvpa3UyjwBAQImJQAABTUtCAECJwIDBAQAEAEDAScDAgQBACgCAgMtDAMELgqARgAEACgEAgQuCoBGAAQAKAQCBC4KgEYABC0NAgMAKAMCAy0OAwItCAEDJwIEBAUAEAEEAScDAwQBACgDAgQtDAQFLgqARgAFACgFAgUuCoBGAAUAKAUCBS4KgEYABQAoBQIFLQ4BBS0MAgEtDAMCLgiARQADLgiARAAEJiUAAAU1LQ0DBi0NBAcLKAAHgEQACCQCAAgAAAYkJwIJBAA8CQEJCygABoBDAAckAgAHAAAGsyMAAAY5LQ0BBi0NAgctDQMILQ0ECQ0oAAiAQwAKJAIACgAABl4lAAAH0S4EAAaAAygAgAQEAAQlAAAH4y4IgAUACgAoCgILADgLCAwtDgUMASgACIBIAAUOOAgFBiQCAAYAAAaeJQAACHEtDgoBLQ4HAi0OBQMtDgkEIwAAByYnAgYEBy0IAActDAEILQwCCS0MAwotDAQLABAABgAlAAAIgy0EAAAtDQEGLQ0CBy0NBAguBAAGgAMoAIAEBAAEJQAAB+MuCIAFAAkAKAkCCgEoAAqARQALLQ4FCy0OCQEtDgcCLgqASAADLQ4IBCMAAAcmJiUAAAU1LQ0EBQsoAAWARAAGJAIABgAAB0knAgcEADwJAQcnAgUEBi0IAAYtDAEHLQwCCC0MAwktDAQKABAABQAlAAAIgy0EAAAtDQEFLQ0CBi0NAwctDgUBLQ4GAi0OBwMuCoBHAAQBKAAGgEgAAi0NAgEmKgEAAQX0gAGmWdMnQjwBAQImKgEAAQUfAFASQCQi7jwBAQImKgEAAQUfCi0n3IKHojwBAQImKgEAAQXFa8RaDhAAAjwBAQImLgGAA4AGCwCABgACgAckAIAHAAAH/iMAAAgJLgCAA4AFIwAACHAuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAIXC4BgAqACC4CgAiACwEAgAoAAoAKAQCACwACgAsjAAAIKygBgAUEAAEDAIAGAAKABiMAAAhwJioBAAEFRafKcRlB5BU8AQECJiUAAAU1LgiARQAFIwAACJMNKAAFgEMABiQCAAYAAAkDIwAACKgtDQEFLQ0CBi0NAwctDQQIJwIJBAQtCAEKJwILBAUAEAELAScDCgQBACgGAgsnAgwEBAAoCgINPw8ACwANLQ0KBgAoBgIGLQ4GCi0OBQEtDgoCLQ4HAy0OCAQmLQ0DBgw4BQYHASgABYBIAAYkAgAHAAAJISMAAAmNLQ0BBy0NAggtDQMJLQ0ECgAoCAIMADgMBQ0tDQ0LACgHAg0AOA0FDi0NDgwAOAsMDS4EAAiAAygAgAQEAAUlAAAH4y4IgAUACwAoCwIMADgMBQ4tDg0OLQ4HAS0OCwItDgkDLQ4KBCMAAAmNLQwGBSMAAAiT",
      "debug_symbols": "7V3dbtw6Dn6Xuc6FSFF/fZWDRZG2OUWAICnSdIFF0Xdfz+zI48b0qOZRG3rNmwLT6LPE76MkipLl74dPdx++fX5///j309fDu7++Hx6ePt6+3D89Dr++/7g5fHi+f3i4//x++t8Hd/wHIJ0AX7/cPh5/f325fX45vEspp5vD3eOnw7s8FBke8ff9w93hHTj/4183B0AQoaIE5VGEEtVFIrtIxGEQ1RVEdkVRXTFwKMAE4QwDzMn9hLuZlw8l1uIR4qS0Y0pTjHAuTXHy7JiZwjm42pIcEKaFj+1Prkv7oy9j+zM22o+Y3Lk0epyUpsQ+O1J9dgL6qfTJgrJ1CzJt3oLfoEFpWJCiPxdO6dJjCE8NKklXg9ChtgbFLg1K6EfHSKnRIO9cHea8i6XhdOigDr3oUn7tdAhh6xag27wF/TXI9E/c2nttDcrKGkR9RqJMdf6AHFoRSwBf3SjApDQbsYAjn+uzHaXyKmZBilu3gI9rN2XB5jWIm9cgbl6DRG9hQRktQMDXTcqor0lvonPMlyb56zrHgnW+cZe5CTGeml9g283vxH68ND9Dq/meRofwqdH8VHJtf3YUWw1p9MkhPtyZvWFf9sLO9IWd6Ys70xezcnuzC3FMIbuWvTgkbOuKu0wSzom4Rw/55/podBdqBoO5vHEeF5GU/SXM8KGcmPTaZ7rNMEna++DvZBLhwmTABpOpUC2dSvGN0n5MWpOfRGp8gntsBg5ZoWnho0K9Vn+m0G9TaM+j0SYUSjbKaVeITCHlChVTSLdC2fqQdoX2vALchEIFTSHlClm0rVshUp+XN4XIFFKukEUKyhUCbwopVyiZQroVQstta1fIom3lCnmLtrUrRKaQcoUst61cIbJoW7tCFm0rVyhYblu7QhZtK1coWrStXSHtp6hNIYu2lSuULNrWrpDtDylXKFu0/eYKeagvP6DHOFPIVqzKFbLTWOoVshWrboWCncZSrxCZQsoVsmhbuUJgkYJ2hSxSUK6QncZSr5D1IeUK2Wks9QrZ/pB2hWx/SLlCdhpLvUKW21auULBoW7tCFiloV8giBeUKRTKFlCtkfUi5QnYa6+0VSuOd3pgCzRSy/SHlCtlpLPUKWW5buULFctvaFSJTSLlCFinoVig6i7a1K2R9SLlCdhpLvUKdom3Ai0LUUMg7qN9H8UCt0mu/c+Gq+pTx0u7zdy5ir7NNm7E37MveXuduNmPvzvSlnelLe9O37Mve4Hdmb96XvRF3Zm/al71p0/HkyYJNzzBHC/KmY4KTBaTegi3ctZCcfl/eBI+gv0dtg0fr13141B81boJH1L/a2AaP5o9dePT6V0fb4FF/Fn8TPG4gu7gNHsl47MKjzTNdeAw2z/ThUX92bxM8Rv1Zw23waPmeLjwmi3v68EjGYxceLe7pwmO2fE8fHi3u6cJjsbinD4+W7+nBY3YW9/ThkYzHLjzqP/22CR7B4p4+PFrc04VHtPxjFx69+eOv8hguPMbXN4nkDZzC3cLbUznaPNOHR+vXXXjcwGnkbfBo+wp9eLT1TBceLY/biUeLe7rwWMwf+/BocU8PHovrFPeU+q4XlMni88jMqZb4J2rp9c5Ao5Y+M3Mp4zLTwS/czFE9L/g48Y54epeuYJfegM6PruIoN9pE2VN1wkwX/+ZvCwmpdrRhCZ2mhY/t73OaGS/9E11wjfaX8f6SUmDGaKd8SSl0aRHMfInwT9QS3B+phY38kWBEkb+8v3d8wLzw0N9q4RImDpg4AVPI9dEpunDdAZPP9dGJsOGtAD5V5wCgyWuHZ3/l72T+/7SVP+G00tZSq/A/DXbpf67DH1rpWgV/N2bXKvgt+lVVeEi1sEfnGk6RnR+vYHITF+KdIvtSnSIX13IKyuPYAGFyofLZKUreja3D+PbPe7vHsQ7vJ/2XN3YYgOujwYVpDtrp2VIAh8F44XjxznhhebF+xPOSjReOF/4bWcYLmb+wvPDvKhkvIRovHC/R5mmeF5uneV5s3GV5STbu8rwk44XjJYPxwvJi62mWl2LzNM+LzdM8LzZPc7yAs/U0z4vN0ywvYPM0z4utp1le0OZpnhebp3leivHC8eJtnuZ5sXma5YUs/8Lzstd5+urHsAHCXuO6Fi97zb+0eNnrPN3gJe51nm7xstd5usFLsnGX58XGXZaXvNf1dIsX8xeel73O01dfcQLY7T5Ji5e97pNc5wXdXtfTLV72up5u8AJ7nadbvNi4y/Ni8zTLy273SVq82DzN8uJ7zNPjm2JDRN3i5Q1fQsMumx9bMbbLmx+bMXbhQoFS6tvsMCz8pi9cc69nh1RLR9e6ToBihNoJY2oYkIOr7c8BYdb8QD2aH6F29eix1Xwa31im4OB680ssddFcEoZ58+2ipV/NPmAasw8+zEbjSEZkHyLNI/sQmeyupS6JRbSPinQiMtttxp2ItM849CGy2HccOhFJRmQfIm2y6UKkdzbZdCLS7prsQySYR3Yi0sKfPkTy12wHquvKMLkGs2L4K6UbmLweUwT1lPX1kPMCTFqPAUE9ILCH30ZqYNb7AXn2GFLINbUaMs4xZT2G/yR8A8PyFsc+GefH5Ym/PqeBSesxUVBPFNSTBPWkuB6TBfVkgT38eNDArPeD4EiAKesxfF8AN276gctlhuK3hpooPoQb/lBRkGa9KPAvBLRQC5+2aaGyBMX7OEAer3RFN2dj4RJ6wjqkwPTa2BGVBKi4cMF4CxVEqCJBgcguFLWQvxpyEHlUOSSYo6IEtdBTWqgsQS1sArZQRYKKoroW+lcYdwcHR5iNUTFFCYq/4KaJKhLUQt6phZKwkRYyCi2UhMNhJcOi/HhrNvgw61+JfwW9iSIRKktQC1fdt1BRgiIRGyRiPojqCiLmg4j5KGI+LjAfL6cb8my0SQvzcgtVJKhMEtRC4r+FCgJU5leYTZRkXs4AIpRkNh9yHBIU35cbh93yQl+O43cBjsPzHJUlKP7C0BYqggjFM58uH2HJMMvbZP6jBE0UiVBZglrY6m2hogRVRGwUCfPFORGKRCgJ8wVQhJIwX1DEBorYQBEb/KXrcPn6CBSaoxY+THMVhcB7VIp1YEvx9biGyPNe4uXQ3qwe5FlvYEiAyesxC/Hd1fwELpzubaEIRKgoQQVRXUFUVxTVFUV1JVFdSaRXFtWVRXYtzAktFIlQWYBa2p9uodLqMcbzMWHBmp0sxGDWj0ue78XX6yFB2/gVWgNT1mOCX89BWD9m+iioh98RKLn6wU/biGcMvyprYAT18P18Yg+HEfhbQQGmrMaQWz93EjgBJqzHCGIBEsQCJIgFyKMAs9IPfgy//n37fH/74eHu64A4/vHb48eX+6fH88+X/3ypf/nwfP/wcP/5/Zfnp493n749371/ePp4/NvBnf/5ixzcDKvWYxR4/Ikx3WA6/Tw6NaEf/hqGWoea/ws=",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "_assert_nonce_and_set_order_details",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "order_data",
            "type": {
              "kind": "array",
              "length": 301,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "11094545764365153162": {
            "error_kind": "string",
            "string": "Function _assert_nonce_and_set_order_details can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_assert_nonce_and_set_order_details"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "AztecGateway7683"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claimable_orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "open_orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "order_status",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "used_nonces",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "filled_orders_block_numbers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_check_order_commitment_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_check_order_commitment_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "fill_deadline",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        },
                        {
                          "name": "order_data_type",
                          "type": {
                            "kind": "array",
                            "length": 32,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        },
                        {
                          "name": "order_data",
                          "type": {
                            "kind": "array",
                            "length": 301,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::open_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::open_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::claim_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::claim_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "resolved_order_bytes",
                    "type": {
                      "kind": "array",
                      "length": 613,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_emit_open_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_emit_open_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "fill_deadline",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        },
                        {
                          "name": "order_data_type",
                          "type": {
                            "kind": "array",
                            "length": 32,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        },
                        {
                          "name": "order_data",
                          "type": {
                            "kind": "array",
                            "length": 301,
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 8
                            }
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  },
                  {
                    "name": "filler_data",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::open_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::open_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::fill_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::fill_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::settle_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::settle_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::settle_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::settle_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::fill_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::fill_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "status",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_assert_order_status_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_assert_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "filler_data",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_trigger_settlement_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_trigger_settlement_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "order_data",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_assert_nonce_and_set_order_details_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_assert_nonce_and_set_order_details_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::get_order_status_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "origin_data_bytes",
                    "type": {
                      "kind": "array",
                      "length": 301,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_assert_order_commitment_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_assert_order_commitment_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "status",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::_update_order_status_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::_update_order_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id_bytes",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecGateway7683::get_filled_order_block_number_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecGateway7683::get_filled_order_block_number_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "103": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "106": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "107": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "108": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "109": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "110": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "112": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "113": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "114": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "136": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "139": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "142": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "143": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "144": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "145": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "146": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "147": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "152": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "153": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "154": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "155": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "159": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "162": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "171": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "185": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "188": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "189": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "191": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "192": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "194": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "196": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "200": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "224": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "226": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "269": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "270": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "286": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "287": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "301": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "303": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "304": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "313": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "324": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "338": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "342": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "343": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "359": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "360": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "362": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "368": {
      "path": "/Users/eidoo/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "397": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "51": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/main.nr",
      "source": "mod config;\nmod types;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract AztecGateway7683 {\n    // context.chain_id() returns 1, which corresponds to the mainnet, making it unsuitable for our use case.\n    // Instead, we designate 999999 as the destination domain.\n    global LOCAL_DESTINATION_DOMAIN: u32 = 999999;\n\n    global UNKNOWN: u32 = 0;\n    global OPENED: u32 = 1;\n    global FILLED: u32 = 2;\n    global INITIATED_PRIVATELY: u32 = 3;\n    global SETTLED: u32 = 4;\n\n    global SETTLE_ORDER_TYPE: [u8; 32] = [\n        25, 30, 167, 118, 189, 110, 12, 213, 106, 109, 68, 186, 74, 234, 47, 236, 70, 139, 74, 11,\n        76, 29, 136, 13, 64, 37, 146, 158, 235, 97, 93, 13,\n    ]; // sha256(\"SETTLE_ORDER_TYPE\")\n    global SECRET: [u8; 6] = [83, 69, 67, 82, 69, 84]; // SECRET\n\n    use crate::{\n        config::Config,\n        types::{\n            events::{Filled, Open},\n            helpers::InternalRCOParams,\n            onchain_cross_chain_order::OnchainCrossChainOrder,\n            order_data::{\n                ORDER_DATA_LENGTH, ORDER_DATA_TYPE, OrderData, PRIVATE_ORDER, PUBLIC_ORDER,\n            },\n            resolved_cross_chain_order::{\n                FILL_INSTRUCTIONS_MAX_INSTRUCTIONS, FillInstruction, MAX_SPENT_MAX_OUTPUTS,\n                MIN_RECEIVED_MAX_OUTPUTS, Output, RESOLVED_CROSS_CHAIN_LENGTH,\n                ResolvedCrossChainOrder,\n            },\n        },\n        utils::{get_settle_content_hash, u32_to_u8_4, u8_32_to_aztec_address, u8_32_to_u128},\n    };\n    use dep::aztec::{\n        macros::{functions::{initializer, internal, private, public, view}, storage::storage},\n        prelude::{AztecAddress, EthAddress, Map, PublicImmutable, PublicMutable},\n        protocol_types::{hash::sha256_to_field, traits::{Packable, Serialize}},\n    };\n    use token::Token;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n        claimable_orders: Map<Field, PublicMutable<Field, Context>, Context>,\n        open_orders: Map<Field, PublicMutable<[u8; 32], Context>, Context>,\n        order_status: Map<Field, PublicMutable<u32, Context>, Context>,\n        used_nonces: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n        filled_orders_block_numbers: Map<Field, PublicMutable<Field, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(portal: EthAddress) {\n        storage.config.initialize(Config { portal });\n    }\n\n    #[public]\n    fn open(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, \"Invalid order data type\");\n\n        let data = _resolve(order, context.msg_sender(), context.timestamp());\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(data.order_data.sender_nonce);\n\n        assert(data.order_data.order_type == PUBLIC_ORDER, \"Not a public order\");\n        assert(\n            data.order_data.origin_domain == LOCAL_DESTINATION_DOMAIN,\n            \"Invalid order origin domain\",\n        );\n        assert(!storage.used_nonces.at(context.msg_sender()).at(nonce).read(), \"Invalid nonce\");\n\n        // We cannot store the entire order_data + ORDER_DATA_TYPE as it raises the following error:\n        // Reached the limit (63) on number of 'public data (contract storage) write' per tx 'storage_write_opcode(storage_slot, value).\n        // For this reason we store a commitment of it.\n        storage.open_orders.at(order_id).write(_get_open_order_commitment(order.order_data));\n        storage.order_status.at(order_id).write(OPENED);\n        storage.used_nonces.at(context.msg_sender()).at(nonce).write(true);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n\n            Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_in_public(\n                    context.msg_sender(),\n                    context.this_address(),\n                    u8_32_to_u128(min_received.amount),\n                    nonce,\n                )\n                .call(&mut context);\n        }\n\n        let event = Open::new(data.order_id_bytes, resolved_order.serialize());\n        context.emit_public_log(event.open1.pack());\n        context.emit_public_log(event.open2.pack());\n    }\n\n    #[private]\n    fn open_private(order: OnchainCrossChainOrder, filler_data: AztecAddress) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, \"Invalid order data type\");\n\n        // NOTE: Force the sender to be zero in order to avoid creating a connection between the sender and the recipient.\n        // TODO: timestamp = 0?\n        let data = _resolve(order, AztecAddress::zero(), 0 as u64);\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(data.order_data.sender_nonce);\n\n        assert(data.order_data.order_type == PRIVATE_ORDER, \"Not a private order\");\n        assert(\n            data.order_data.origin_domain == LOCAL_DESTINATION_DOMAIN,\n            \"Invalid order origin domain\",\n        );\n\n        AztecGateway7683::at(context.this_address())\n            ._assert_nonce_and_set_order_details(order_id, order.order_data, nonce)\n            .enqueue(&mut context);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n            let amount = u8_32_to_u128(min_received.amount);\n            Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_in_private(context.msg_sender(), context.this_address(), amount, nonce)\n                .call(&mut context);\n        }\n\n        AztecGateway7683::at(context.this_address())\n            ._emit_open(data.order_id_bytes, resolved_order.serialize())\n            .enqueue(&mut context);\n    }\n\n    #[private]\n    fn claim_private(\n        secret: [u8; 32],\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n\n        AztecGateway7683::at(context.this_address())\n            ._assert_order_status(order_id, INITIATED_PRIVATELY)\n            .enqueue(&mut context);\n\n        // verify that a commitment exists for the given order.\n        AztecGateway7683::at(context.this_address())\n            ._check_order_commitment(order_id, origin_data_bytes, filler_data_bytes)\n            .enqueue(&mut context);\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        // if a commitment exists, the order is valid, allowing us to compare the recipient with hash(secret).\n        assert(sha256::digest(secret) == order_data.recipient, \"Invalid secret\");\n\n        // transfer from gateway public balance to user private balance\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_to_private(context.msg_sender(), u8_32_to_u128(order_data.amount_out))\n            .call(&mut context);\n\n        AztecGateway7683::at(context.this_address())._update_order_status(order_id, FILLED).enqueue(\n            &mut context,\n        );\n\n        // TODO: store filled order\n\n        AztecGateway7683::at(context.this_address())\n            ._trigger_settlement(\n                order_id,\n                order_id_bytes,\n                filler_data_bytes, // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn fill(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        AztecGateway7683::at(context.this_address())._assert_order_status(order_id, UNKNOWN).call(\n            &mut context,\n        );\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_data.order_type == PUBLIC_ORDER, \"Not a public order\");\n        assert(order_id_bytes == sha256::digest(origin_data_bytes), \"Invalid order id\");\n        assert(context.timestamp() as u32 <= order_data.fill_deadline, \"Order fill expired\");\n        assert(\n            order_data.destination_domain == LOCAL_DESTINATION_DOMAIN,\n            \"Invalid order destination domain\",\n        );\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_in_public(\n                context.msg_sender(),\n                u8_32_to_aztec_address(order_data.recipient),\n                u8_32_to_u128(order_data.amount_out),\n                Field::from_be_bytes(order_data.sender_nonce),\n            )\n            .call(&mut context);\n\n        storage.order_status.at(order_id).write(FILLED);\n        // TODO: store filled order\n\n        AztecGateway7683::at(context.this_address())\n            ._trigger_settlement(\n                order_id,\n                order_id_bytes,\n                filler_data_bytes, // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n            )\n            .call(&mut context);\n\n        context.emit_public_log(Filled {\n            order_id: order_id_bytes,\n            origin_data: origin_data_bytes,\n            filler_data: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[public]\n    fn fill_private(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        AztecGateway7683::at(context.this_address())._assert_order_status(order_id, UNKNOWN).call(\n            &mut context,\n        );\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_data.order_type == PRIVATE_ORDER, \"Not a private order\");\n        assert(order_id_bytes == sha256::digest(origin_data_bytes), \"Invalid order id\");\n        assert(context.timestamp() as u32 <= order_data.fill_deadline, \"Order fill expired\");\n        assert(order_data.destination_domain == LOCAL_DESTINATION_DOMAIN, \"Invalid order domain\");\n\n        Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_in_public(\n                context.msg_sender(),\n                context.this_address(),\n                u8_32_to_u128(order_data.amount_out),\n                0,\n            )\n            .call(&mut context);\n\n        storage.claimable_orders.at(order_id).write(sha256_to_field(_get_order_pre_image(\n            origin_data_bytes,\n            filler_data_bytes,\n        )));\n        storage.order_status.at(order_id).write(INITIATED_PRIVATELY);\n\n        context.emit_public_log(Filled {\n            order_id: order_id_bytes,\n            origin_data: origin_data_bytes,\n            filler_data: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[public]\n    #[view]\n    fn get_order_status(order_id_bytes: [u8; 32]) -> u32 {\n        storage.order_status.at(Field::from_be_bytes(order_id_bytes)).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_filled_order_block_number(order_id_bytes: [u8; 32]) -> Field {\n        storage.filled_orders_block_numbers.at(Field::from_be_bytes(order_id_bytes)).read()\n    }\n\n    #[public]\n    fn settle(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n        message_leaf_index: Field,\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        // If a user wanted to open an order on the same chain, this code wouldn't work because\n        // the order_status would be FILLED. However, considering that for PoC we don't handle that case,\n        // this check is sufficient.\n        assert(storage.order_status.at(order_id).read() == OPENED, \"Invalid order status\");\n\n        let order_commitment = _get_open_order_commitment(origin_data_bytes);\n        assert(storage.open_orders.at(order_id).read() == order_commitment, \"Invalid order\");\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        // This check is necessary because if a user opens a private order, it means they have transferred\n        // tokens privately. As a result, the public state (`token.public_balances`) is not updated,\n        // making it impossible to call `transfer_in_public`, as it would fail.\n        assert(order_data.order_type == PUBLIC_ORDER, \"Not a public order\");\n\n        let content_hash =\n            get_settle_content_hash(SETTLE_ORDER_TYPE, order_id_bytes, filler_data_bytes);\n        /*context.consume_l1_to_l2_message(\n            content_hash,\n            Field::from_be_bytes(SECRET),\n            storage.config.read().portal,\n            message_leaf_index,\n        );*/\n\n        Token::at(u8_32_to_aztec_address(order_data.input_token))\n            .transfer_in_public(\n                context.this_address(),\n                u8_32_to_aztec_address(filler_data_bytes),\n                u8_32_to_u128(order_data.amount_in),\n                0,\n            )\n            .call(&mut context);\n\n        storage.order_status.at(order_id).write(SETTLED);\n\n        // TODO: emit Settle event\n    }\n\n    #[private]\n    fn settle_private(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n        message_leaf_index: Field,\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        // same as above\n        AztecGateway7683::at(context.this_address())._assert_order_status(order_id, OPENED).enqueue(\n            &mut context,\n        );\n        AztecGateway7683::at(context.this_address())\n            ._assert_order_commitment(order_id, origin_data_bytes)\n            .enqueue(&mut context);\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_data.order_type == PRIVATE_ORDER, \"Not a private order\");\n\n        let content_hash =\n            get_settle_content_hash(SETTLE_ORDER_TYPE, order_id_bytes, filler_data_bytes);\n        /*context.consume_l1_to_l2_message(\n            content_hash,\n            Field::from_be_bytes(SECRET),\n            storage.config.read().portal,\n            message_leaf_index,\n        );*/\n\n        Token::at(u8_32_to_aztec_address(order_data.input_token))\n            .transfer_in_private(\n                context.this_address(),\n                u8_32_to_aztec_address(filler_data_bytes),\n                u8_32_to_u128(order_data.amount_in),\n                0,\n            )\n            .call(&mut context);\n\n        AztecGateway7683::at(context.this_address())\n            ._update_order_status(order_id, SETTLED)\n            .enqueue(&mut context);\n\n        // TODO: emit Settle event\n    }\n\n    #[internal]\n    #[public]\n    fn _assert_nonce_and_set_order_details(\n        order_id: Field,\n        order_data: [u8; ORDER_DATA_LENGTH],\n        nonce: Field,\n    ) {\n        assert(!storage.used_nonces.at(context.msg_sender()).at(nonce).read(), \"Invalid nonce\");\n        // We cannot store the entire order_data + ORDER_DATA_TYPE as it raises the following error:\n        // Reached the limit (63) on number of 'public data (contract storage) write' per tx 'storage_write_opcode(storage_slot, value).\n        // For this reason we store a commitment of it.\n        storage.open_orders.at(order_id).write(_get_open_order_commitment(order_data));\n        storage.order_status.at(order_id).write(OPENED);\n        storage.used_nonces.at(context.msg_sender()).at(nonce).write(true);\n    }\n\n    #[contract_library_method]\n    fn _get_open_order_commitment(order_data: [u8; ORDER_DATA_LENGTH]) -> [u8; 32] {\n        let mut data: [u8; ORDER_DATA_LENGTH + 32] = [0; ORDER_DATA_LENGTH + 32];\n        for i in 0..32 {\n            data[i] = ORDER_DATA_TYPE[i];\n        }\n        for i in 0..ORDER_DATA_LENGTH {\n            data[i + 32] = order_data[i];\n        }\n        sha256::digest(data)\n    }\n\n    #[public]\n    #[internal]\n    fn _assert_order_status(order_id: Field, status: u32) {\n        assert(storage.order_status.at(order_id).read() == status, \"Invalid order status\");\n    }\n\n    #[public]\n    #[internal]\n    fn _assert_order_commitment(order_id: Field, origin_data_bytes: [u8; ORDER_DATA_LENGTH]) {\n        let order_commitment = _get_open_order_commitment(origin_data_bytes);\n        assert(storage.open_orders.at(order_id).read() == order_commitment, \"Invalid order\");\n    }\n\n    #[public]\n    #[internal]\n    fn _check_order_commitment(\n        order_id: Field,\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_commitment = storage.claimable_orders.at(order_id).read();\n        assert(\n            order_commitment\n                == sha256_to_field(_get_order_pre_image(origin_data_bytes, filler_data_bytes)),\n            \"Invalid order\",\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _emit_open(\n        order_id_bytes: [u8; 32],\n        resolved_order_bytes: [Field; RESOLVED_CROSS_CHAIN_LENGTH],\n    ) {\n        let event = Open::new(order_id_bytes, resolved_order_bytes);\n        context.emit_public_log(event.open1.pack());\n        context.emit_public_log(event.open2.pack());\n    }\n\n    #[public]\n    #[internal]\n    fn _trigger_settlement(order_id: Field, order_id_bytes: [u8; 32], filler_data: [u8; 32]) {\n        storage.filled_orders_block_numbers.at(order_id).write(context.block_number());\n\n        let mut settlement_message_bytes: [u8; 96] = [0; 96];\n\n        for i in 0..32 {\n            settlement_message_bytes[i] = SETTLE_ORDER_TYPE[i]; // order_type\n            settlement_message_bytes[i + 32] = order_id_bytes[i]; // order_id_bytes\n            settlement_message_bytes[i + 64] = filler_data[i]; // recipient\n        }\n\n        let config = storage.config.read();\n        context.message_portal(config.portal, sha256_to_field(settlement_message_bytes));\n    }\n\n    #[contract_library_method]\n    fn _resolve(\n        order: OnchainCrossChainOrder,\n        sender: AztecAddress,\n        timestamp: u64,\n    ) -> InternalRCOParams {\n        let mut order_data = OrderData::decode(order.order_data);\n\n        assert(order_data.fill_deadline == order.fill_deadline, \"Invalid fill deadline\");\n        assert(u8_32_to_aztec_address(order_data.sender) == sender, \"Invalid order sender\");\n\n        let order_id_bytes = sha256::digest(order.order_data);\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        let destination_domain_bytes = u32_to_u8_4(order_data.destination_domain);\n\n        let min_received_output = Output {\n            token: order_data.input_token,\n            recipient: [0; 32],\n            amount: order_data.amount_in,\n            chain_id: u32_to_u8_4(order_data.origin_domain),\n        };\n        let min_received: [Output; MIN_RECEIVED_MAX_OUTPUTS] =\n            [min_received_output; MIN_RECEIVED_MAX_OUTPUTS];\n\n        let max_spent_output = Output {\n            token: order_data.output_token,\n            recipient: order_data.recipient,\n            amount: order_data.amount_out,\n            chain_id: destination_domain_bytes,\n        };\n        let max_spent: [Output; MAX_SPENT_MAX_OUTPUTS] = [max_spent_output; MAX_SPENT_MAX_OUTPUTS];\n\n        let fill_instruction = FillInstruction {\n            destination_chain_id: destination_domain_bytes,\n            destination_settler: order_data.destination_settler,\n            origin_data: order.order_data,\n        };\n        let fill_instructions: [FillInstruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS] =\n            [fill_instruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS];\n\n        let resolved_order = ResolvedCrossChainOrder {\n            user: order_data.sender,\n            origin_chain_id: u32_to_u8_4(LOCAL_DESTINATION_DOMAIN),\n            open_deadline: u32_to_u8_4(timestamp as u32),\n            fill_deadline: u32_to_u8_4(order.fill_deadline),\n            order_id: order_id_bytes,\n            min_received,\n            max_spent,\n            fill_instructions,\n        };\n\n        InternalRCOParams {\n            order_id_bytes,\n            order_id,\n            resolved_cross_chain_order: resolved_order,\n            order_data,\n        }\n    }\n\n    #[contract_library_method]\n    fn _get_order_pre_image(\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) -> [u8; ORDER_DATA_LENGTH + 32] {\n        let mut pre_image: [u8; ORDER_DATA_LENGTH + 32] = [0; ORDER_DATA_LENGTH + 32];\n        for i in 0..ORDER_DATA_LENGTH {\n            pre_image[i] = origin_data_bytes[i];\n        }\n        for i in 0..32 {\n            pre_image[i + ORDER_DATA_LENGTH] = filler_data_bytes[i];\n        }\n        pre_image\n    }\n\n    #[public]\n    #[internal]\n    fn _update_order_status(order_id: Field, status: u32) {\n        storage.order_status.at(order_id).write(status);\n    }\n}\n"
    },
    "52": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/types/events.nr",
      "source": "use crate::types::{\n    order_data::ORDER_DATA_LENGTH, resolved_cross_chain_order::RESOLVED_CROSS_CHAIN_LENGTH,\n};\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n// #[event]\n#[derive(Serialize)]\npub struct Filled {\n    pub order_id: [u8; 32],\n    pub origin_data: [u8; ORDER_DATA_LENGTH],\n    pub filler_data: [u8; 32],\n}\n\n// 301 + 32 + 32 = 365      365 / 31 = 11.74 = 12 + 1 (residual bytes) = 13\nimpl Packable<13> for Filled {\n    fn pack(self) -> [Field; 13] {\n        let mut result = [0; 13];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        let mut filler_data_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n            filler_data_31[i] = self.filler_data[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n        residual_bytes[10] = self.filler_data[31];\n\n        for i in 0..10 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < ORDER_DATA_LENGTH {\n                    partial[j] = self.origin_data[k];\n                }\n            }\n            result[i + 1] = Field::from_be_bytes(partial);\n\n            if i < 9 {\n                // no residual bytes for the last one\n                residual_bytes[i + 1] = self.origin_data[offset + 31];\n            }\n        }\n\n        result[0] = Field::from_be_bytes::<31>(order_id_31);\n        result[11] = Field::from_be_bytes::<31>(filler_data_31);\n        result[12] = Field::from_be_bytes::<31>(residual_bytes);\n        result\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], origin_data: [0; ORDER_DATA_LENGTH], filler_data: [0; 32] }\n    }\n}\n\n// #[event]\n#[derive(Serialize)]\npub struct Open1 {\n    pub order_id: [u8; 32],\n    pub resolved_order: [u8; 340],\n}\n\nimpl Packable<13> for Open1 {\n    fn pack(self) -> [Field; 13] {\n        let mut result = [0; 13];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n\n        for i in 0..12 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < 340 {\n                    partial[j] = self.resolved_order[k];\n                }\n            }\n            result[i + 1] = Field::from_be_bytes(partial);\n\n            let residual_bytes_offset = offset + 31;\n            if residual_bytes_offset < 340 {\n                residual_bytes[i + 1] = self.resolved_order[residual_bytes_offset];\n            }\n        }\n\n        result[0] = Field::from_be_bytes::<31>(order_id_31);\n        result[12] = Field::from_be_bytes::<31>(residual_bytes);\n        result\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], resolved_order: [0; 340] }\n    }\n}\n\n// #[event]\n#[derive(Serialize)]\npub struct Open2 {\n    pub order_id: [u8; 32],\n    pub resolved_order: [u8; 273],\n}\n\nimpl Packable<11> for Open2 {\n    fn pack(self) -> [Field; 11] {\n        let mut result = [0; 11];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n\n        for i in 0..10 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < 273 {\n                    partial[j] = self.resolved_order[k];\n                }\n            }\n            result[i + 1] = Field::from_be_bytes(partial);\n\n            let residual_bytes_offset = offset + 31;\n            if residual_bytes_offset < 273 {\n                residual_bytes[i + 1] = self.resolved_order[residual_bytes_offset];\n            }\n        }\n\n        result[0] = Field::from_be_bytes::<31>(order_id_31);\n        result[10] = Field::from_be_bytes::<31>(residual_bytes);\n        result\n    }\n\n    fn unpack(fields: [Field; 11]) -> Self {\n        assert(true == false, \"not implemented\");\n        Self { order_id: [0; 32], resolved_order: [0; 273] }\n    }\n}\n\npub struct Open {\n    pub open1: Open1,\n    pub open2: Open2,\n}\n\nimpl Open {\n    pub fn new(order_id: [u8; 32], resolved_order: [Field; RESOLVED_CROSS_CHAIN_LENGTH]) -> Self {\n        let mut resolved_order1 = [0; 340];\n        for i in 0..340 {\n            resolved_order1[i] = resolved_order[i] as u8;\n        }\n        let mut resolved_order2 = [0; 273];\n        for i in 0..273 {\n            resolved_order2[i] = resolved_order[i + 340] as u8;\n        }\n\n        Self {\n            open1: Open1 { order_id, resolved_order: resolved_order1 },\n            open2: Open2 { order_id, resolved_order: resolved_order2 },\n        }\n    }\n}\n"
    },
    "55": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/types/order_data.nr",
      "source": "use crate::utils::u8_4_to_u32;\nuse dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n\npub global ORDER_DATA_LENGTH: u32 = 301;\npub global ORDER_DATA_TYPE: [u8; 32] = [\n    240, 12, 59, 246, 12, 115, 235, 151, 9, 127, 28, 152, 53, 83, 125, 160, 20, 224, 183, 85, 254,\n    148, 178, 93, 122, 200, 64, 29, 246, 103, 22, 160,\n];\n\npub global PUBLIC_ORDER: u8 = 0;\npub global PRIVATE_ORDER: u8 = 1;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OrderData {\n    pub sender: [u8; 32],\n    pub recipient: [u8; 32],\n    pub input_token: [u8; 32],\n    pub output_token: [u8; 32],\n    pub amount_in: [u8; 32],\n    pub amount_out: [u8; 32],\n    pub sender_nonce: [u8; 32],\n    pub origin_domain: u32,\n    pub destination_domain: u32,\n    pub destination_settler: [u8; 32],\n    pub fill_deadline: u32,\n    pub order_type: u8,\n    pub data: [u8; 32],\n}\n\nimpl OrderData {\n    pub fn decode(bytes: [u8; ORDER_DATA_LENGTH]) -> OrderData {\n        let sender = u8_order_data_length_to_u8_32(bytes, 0);\n        let recipient = u8_order_data_length_to_u8_32(bytes, 32);\n        let input_token = u8_order_data_length_to_u8_32(bytes, 64);\n        let output_token = u8_order_data_length_to_u8_32(bytes, 96);\n        let amount_in = u8_order_data_length_to_u8_32(bytes, 128);\n        let amount_out = u8_order_data_length_to_u8_32(bytes, 160);\n        let sender_nonce = u8_order_data_length_to_u8_32(bytes, 192);\n        let origin_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 224));\n        let destination_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 228));\n        let destination_settler = u8_order_data_length_to_u8_32(bytes, 232);\n        let fill_deadline = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 264));\n        let order_type = u8_order_data_length_to_u8(bytes, 268);\n        let data = u8_order_data_length_to_u8_32(bytes, 269);\n\n        OrderData {\n            sender,\n            recipient,\n            input_token,\n            output_token,\n            amount_in,\n            amount_out,\n            sender_nonce,\n            origin_domain,\n            destination_domain,\n            destination_settler,\n            fill_deadline,\n            order_type,\n            data,\n        }\n    }\n}\n\nfn u8_order_data_length_to_u8_32(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 32] {\n    let mut result = [0; 32];\n    for i in 0..32 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8_4(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 4] {\n    let mut result = [0; 4];\n    for i in 0..4 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> u8 {\n    bytes[start]\n}\n"
    },
    "58": {
      "path": "/Users/eidoo/Desktop/work/substancelabs/aztec-evm-bridge/aztec/aztec_gateway_7683/src/utils.nr",
      "source": "use dep::aztec::{prelude::AztecAddress, protocol_types::traits::FromField};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\npub(crate) fn u8_32_to_u128(input: [u8; 32]) -> u128 {\n    let mut result = 0;\n    for i in 0..16 {\n        result = result + (input[31 - i] as u128) * (1 << (i * 8));\n    }\n    result\n}\n\npub(crate) fn u8_4_to_u32(bytes: [u8; 4]) -> u32 {\n    let field = Field::from_be_bytes(bytes);\n    field.assert_max_bit_size::<32>();\n    field as u32\n}\n\npub(crate) fn u8_32_to_aztec_address(bytes: [u8; 32]) -> AztecAddress {\n    AztecAddress::from_field(Field::from_be_bytes(bytes))\n}\n\npub(crate) fn u32_to_u8_4(x: u32) -> [u8; 4] {\n    [((x >> 24) & 0xFF) as u8, ((x >> 16) & 0xFF) as u8, ((x >> 8) & 0xFF) as u8, (x & 0xFF) as u8]\n}\n\npub fn get_settle_content_hash(\n    settle_order_type: [u8; 32],\n    order_id_bytes: [u8; 32],\n    filler_data_bytes: [u8; 32],\n) -> Field {\n    let mut hash_bytes = [0; 96];\n\n    for i in 0..32 {\n        hash_bytes[i] = settle_order_type[i];\n        hash_bytes[i + 32] = order_id_bytes[i];\n        hash_bytes[i + 64] = filler_data_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n"
    },
    "59": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "67": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "68": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "69": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "70": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "74": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "91": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "95": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "96": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "99": {
      "path": "/Users/eidoo/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    }
  }
}
